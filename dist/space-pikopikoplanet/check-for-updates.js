var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __objSpread = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (cb, mod) => () => (mod || cb((mod = {exports: {}}).exports, mod), mod.exports);
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports2, module2) => {
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __createBinding;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports3) {
        factory(createExporter(root, createExporter(exports3)));
      });
    } else if (typeof module2 === "object" && typeof module2.exports === "object") {
      factory(createExporter(root, createExporter(module2.exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports3, previous) {
      if (exports3 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports3, "__esModule", {value: true});
        } else {
          exports3.__esModule = true;
        }
      }
      return function(id, v) {
        return exports3[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = {label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: []}, f, y, t, g;
      return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return {value: op[1], done: false};
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return {value: op[0] ? op[1] : void 0, done: true};
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, {enumerable: true, get: function() {
        return m[k];
      }});
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return {value: o && o[i++], done: !o};
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = {error};
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? {value: __await(o[n](v)), done: n === "return"} : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({value: v2, done: d});
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", {value: raw});
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {enumerable: true, value: v});
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : {default: mod};
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
  });
});

// node_modules/@firebase/util/dist/index.node.cjs.js
var require_index_node_cjs = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib = require_tslib();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var CONSTANTS = {
    NODE_CLIENT: false,
    NODE_ADMIN: false,
    SDK_VERSION: "${JSCORE_VERSION}"
  };
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var assert = function(assertion, message) {
    if (!assertion) {
      throw assertionError(message);
    }
  };
  var assertionError = function(message) {
    return new Error("Firebase Database (" + CONSTANTS.SDK_VERSION + ") INTERNAL ASSERT FAILED: " + message);
  };
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var stringToByteArray = function(str) {
    var out = [];
    var p = 0;
    for (var i = 0; i < str.length; i++) {
      var c = str.charCodeAt(i);
      if (c < 128) {
        out[p++] = c;
      } else if (c < 2048) {
        out[p++] = c >> 6 | 192;
        out[p++] = c & 63 | 128;
      } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
        c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
        out[p++] = c >> 18 | 240;
        out[p++] = c >> 12 & 63 | 128;
        out[p++] = c >> 6 & 63 | 128;
        out[p++] = c & 63 | 128;
      } else {
        out[p++] = c >> 12 | 224;
        out[p++] = c >> 6 & 63 | 128;
        out[p++] = c & 63 | 128;
      }
    }
    return out;
  };
  var byteArrayToString = function(bytes) {
    var out = [];
    var pos = 0, c = 0;
    while (pos < bytes.length) {
      var c1 = bytes[pos++];
      if (c1 < 128) {
        out[c++] = String.fromCharCode(c1);
      } else if (c1 > 191 && c1 < 224) {
        var c2 = bytes[pos++];
        out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
      } else if (c1 > 239 && c1 < 365) {
        var c2 = bytes[pos++];
        var c3 = bytes[pos++];
        var c4 = bytes[pos++];
        var u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
        out[c++] = String.fromCharCode(55296 + (u >> 10));
        out[c++] = String.fromCharCode(56320 + (u & 1023));
      } else {
        var c2 = bytes[pos++];
        var c3 = bytes[pos++];
        out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
      }
    }
    return out.join("");
  };
  var base64 = {
    byteToCharMap_: null,
    charToByteMap_: null,
    byteToCharMapWebSafe_: null,
    charToByteMapWebSafe_: null,
    ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
    get ENCODED_VALS() {
      return this.ENCODED_VALS_BASE + "+/=";
    },
    get ENCODED_VALS_WEBSAFE() {
      return this.ENCODED_VALS_BASE + "-_.";
    },
    HAS_NATIVE_SUPPORT: typeof atob === "function",
    encodeByteArray: function(input, webSafe) {
      if (!Array.isArray(input)) {
        throw Error("encodeByteArray takes an array as a parameter");
      }
      this.init_();
      var byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
      var output = [];
      for (var i = 0; i < input.length; i += 3) {
        var byte1 = input[i];
        var haveByte2 = i + 1 < input.length;
        var byte2 = haveByte2 ? input[i + 1] : 0;
        var haveByte3 = i + 2 < input.length;
        var byte3 = haveByte3 ? input[i + 2] : 0;
        var outByte1 = byte1 >> 2;
        var outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
        var outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
        var outByte4 = byte3 & 63;
        if (!haveByte3) {
          outByte4 = 64;
          if (!haveByte2) {
            outByte3 = 64;
          }
        }
        output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
      }
      return output.join("");
    },
    encodeString: function(input, webSafe) {
      if (this.HAS_NATIVE_SUPPORT && !webSafe) {
        return btoa(input);
      }
      return this.encodeByteArray(stringToByteArray(input), webSafe);
    },
    decodeString: function(input, webSafe) {
      if (this.HAS_NATIVE_SUPPORT && !webSafe) {
        return atob(input);
      }
      return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
    },
    decodeStringToByteArray: function(input, webSafe) {
      this.init_();
      var charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
      var output = [];
      for (var i = 0; i < input.length; ) {
        var byte1 = charToByteMap[input.charAt(i++)];
        var haveByte2 = i < input.length;
        var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
        ++i;
        var haveByte3 = i < input.length;
        var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
        ++i;
        var haveByte4 = i < input.length;
        var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
        ++i;
        if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
          throw Error();
        }
        var outByte1 = byte1 << 2 | byte2 >> 4;
        output.push(outByte1);
        if (byte3 !== 64) {
          var outByte2 = byte2 << 4 & 240 | byte3 >> 2;
          output.push(outByte2);
          if (byte4 !== 64) {
            var outByte3 = byte3 << 6 & 192 | byte4;
            output.push(outByte3);
          }
        }
      }
      return output;
    },
    init_: function() {
      if (!this.byteToCharMap_) {
        this.byteToCharMap_ = {};
        this.charToByteMap_ = {};
        this.byteToCharMapWebSafe_ = {};
        this.charToByteMapWebSafe_ = {};
        for (var i = 0; i < this.ENCODED_VALS.length; i++) {
          this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
          this.charToByteMap_[this.byteToCharMap_[i]] = i;
          this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
          this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
          if (i >= this.ENCODED_VALS_BASE.length) {
            this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
            this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
          }
        }
      }
    }
  };
  var base64Encode = function(str) {
    var utf8Bytes = stringToByteArray(str);
    return base64.encodeByteArray(utf8Bytes, true);
  };
  var base64Decode = function(str) {
    try {
      return base64.decodeString(str, true);
    } catch (e) {
      console.error("base64Decode failed: ", e);
    }
    return null;
  };
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function deepCopy(value) {
    return deepExtend(void 0, value);
  }
  function deepExtend(target, source) {
    if (!(source instanceof Object)) {
      return source;
    }
    switch (source.constructor) {
      case Date:
        var dateValue = source;
        return new Date(dateValue.getTime());
      case Object:
        if (target === void 0) {
          target = {};
        }
        break;
      case Array:
        target = [];
        break;
      default:
        return source;
    }
    for (var prop in source) {
      if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {
        continue;
      }
      target[prop] = deepExtend(target[prop], source[prop]);
    }
    return target;
  }
  function isValidKey(key) {
    return key !== "__proto__";
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var Deferred = function() {
    function Deferred2() {
      var _this = this;
      this.reject = function() {
      };
      this.resolve = function() {
      };
      this.promise = new Promise(function(resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      });
    }
    Deferred2.prototype.wrapCallback = function(callback) {
      var _this = this;
      return function(error, value) {
        if (error) {
          _this.reject(error);
        } else {
          _this.resolve(value);
        }
        if (typeof callback === "function") {
          _this.promise.catch(function() {
          });
          if (callback.length === 1) {
            callback(error);
          } else {
            callback(error, value);
          }
        }
      };
    };
    return Deferred2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function getUA() {
    if (typeof navigator !== "undefined" && typeof navigator["userAgent"] === "string") {
      return navigator["userAgent"];
    } else {
      return "";
    }
  }
  function isMobileCordova() {
    return typeof window !== "undefined" && !!(window["cordova"] || window["phonegap"] || window["PhoneGap"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
  }
  function isNode() {
    try {
      return Object.prototype.toString.call(global.process) === "[object process]";
    } catch (e) {
      return false;
    }
  }
  function isBrowser() {
    return typeof self === "object" && self.self === self;
  }
  function isBrowserExtension() {
    var runtime = typeof chrome === "object" ? chrome.runtime : typeof browser === "object" ? browser.runtime : void 0;
    return typeof runtime === "object" && runtime.id !== void 0;
  }
  function isReactNative() {
    return typeof navigator === "object" && navigator["product"] === "ReactNative";
  }
  function isElectron() {
    return getUA().indexOf("Electron/") >= 0;
  }
  function isIE() {
    var ua = getUA();
    return ua.indexOf("MSIE ") >= 0 || ua.indexOf("Trident/") >= 0;
  }
  function isUWP() {
    return getUA().indexOf("MSAppHost/") >= 0;
  }
  function isNodeSdk() {
    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;
  }
  function isSafari() {
    return !isNode() && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome");
  }
  function isIndexedDBAvailable() {
    return "indexedDB" in self && indexedDB != null;
  }
  function validateIndexedDBOpenable() {
    return new Promise(function(resolve, reject) {
      try {
        var preExist_1 = true;
        var DB_CHECK_NAME_1 = "validate-browser-context-for-indexeddb-analytics-module";
        var request_1 = window.indexedDB.open(DB_CHECK_NAME_1);
        request_1.onsuccess = function() {
          request_1.result.close();
          if (!preExist_1) {
            window.indexedDB.deleteDatabase(DB_CHECK_NAME_1);
          }
          resolve(true);
        };
        request_1.onupgradeneeded = function() {
          preExist_1 = false;
        };
        request_1.onerror = function() {
          var _a;
          reject(((_a = request_1.error) === null || _a === void 0 ? void 0 : _a.message) || "");
        };
      } catch (error) {
        reject(error);
      }
    });
  }
  function areCookiesEnabled() {
    if (!navigator || !navigator.cookieEnabled) {
      return false;
    }
    return true;
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var ERROR_NAME = "FirebaseError";
  var FirebaseError = function(_super) {
    tslib.__extends(FirebaseError2, _super);
    function FirebaseError2(code, message, customData) {
      var _this = _super.call(this, message) || this;
      _this.code = code;
      _this.customData = customData;
      _this.name = ERROR_NAME;
      Object.setPrototypeOf(_this, FirebaseError2.prototype);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(_this, ErrorFactory.prototype.create);
      }
      return _this;
    }
    return FirebaseError2;
  }(Error);
  var ErrorFactory = function() {
    function ErrorFactory2(service, serviceName, errors) {
      this.service = service;
      this.serviceName = serviceName;
      this.errors = errors;
    }
    ErrorFactory2.prototype.create = function(code) {
      var data = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        data[_i - 1] = arguments[_i];
      }
      var customData = data[0] || {};
      var fullCode = this.service + "/" + code;
      var template = this.errors[code];
      var message = template ? replaceTemplate(template, customData) : "Error";
      var fullMessage = this.serviceName + ": " + message + " (" + fullCode + ").";
      var error = new FirebaseError(fullCode, fullMessage, customData);
      return error;
    };
    return ErrorFactory2;
  }();
  function replaceTemplate(template, data) {
    return template.replace(PATTERN, function(_, key) {
      var value = data[key];
      return value != null ? String(value) : "<" + key + "?>";
    });
  }
  var PATTERN = /\{\$([^}]+)}/g;
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function jsonEval(str) {
    return JSON.parse(str);
  }
  function stringify(data) {
    return JSON.stringify(data);
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var decode = function(token) {
    var header = {}, claims = {}, data = {}, signature = "";
    try {
      var parts = token.split(".");
      header = jsonEval(base64Decode(parts[0]) || "");
      claims = jsonEval(base64Decode(parts[1]) || "");
      signature = parts[2];
      data = claims["d"] || {};
      delete claims["d"];
    } catch (e) {
    }
    return {
      header,
      claims,
      data,
      signature
    };
  };
  var isValidTimestamp = function(token) {
    var claims = decode(token).claims;
    var now = Math.floor(new Date().getTime() / 1e3);
    var validSince = 0, validUntil = 0;
    if (typeof claims === "object") {
      if (claims.hasOwnProperty("nbf")) {
        validSince = claims["nbf"];
      } else if (claims.hasOwnProperty("iat")) {
        validSince = claims["iat"];
      }
      if (claims.hasOwnProperty("exp")) {
        validUntil = claims["exp"];
      } else {
        validUntil = validSince + 86400;
      }
    }
    return !!now && !!validSince && !!validUntil && now >= validSince && now <= validUntil;
  };
  var issuedAtTime = function(token) {
    var claims = decode(token).claims;
    if (typeof claims === "object" && claims.hasOwnProperty("iat")) {
      return claims["iat"];
    }
    return null;
  };
  var isValidFormat = function(token) {
    var decoded = decode(token), claims = decoded.claims;
    return !!claims && typeof claims === "object" && claims.hasOwnProperty("iat");
  };
  var isAdmin = function(token) {
    var claims = decode(token).claims;
    return typeof claims === "object" && claims["admin"] === true;
  };
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function contains(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  function safeGet(obj, key) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      return obj[key];
    } else {
      return void 0;
    }
  }
  function isEmpty(obj) {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return false;
      }
    }
    return true;
  }
  function map(obj, fn, contextObj) {
    var res = {};
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        res[key] = fn.call(contextObj, obj[key], key, obj);
      }
    }
    return res;
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function querystring(querystringParams) {
    var params = [];
    var _loop_1 = function(key2, value2) {
      if (Array.isArray(value2)) {
        value2.forEach(function(arrayVal) {
          params.push(encodeURIComponent(key2) + "=" + encodeURIComponent(arrayVal));
        });
      } else {
        params.push(encodeURIComponent(key2) + "=" + encodeURIComponent(value2));
      }
    };
    for (var _i = 0, _a = Object.entries(querystringParams); _i < _a.length; _i++) {
      var _b = _a[_i], key = _b[0], value = _b[1];
      _loop_1(key, value);
    }
    return params.length ? "&" + params.join("&") : "";
  }
  function querystringDecode(querystring2) {
    var obj = {};
    var tokens = querystring2.replace(/^\?/, "").split("&");
    tokens.forEach(function(token) {
      if (token) {
        var _a = token.split("="), key = _a[0], value = _a[1];
        obj[decodeURIComponent(key)] = decodeURIComponent(value);
      }
    });
    return obj;
  }
  function extractQuerystring(url) {
    var queryStart = url.indexOf("?");
    if (!queryStart) {
      return "";
    }
    var fragmentStart = url.indexOf("#", queryStart);
    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : void 0);
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var Sha1 = function() {
    function Sha12() {
      this.chain_ = [];
      this.buf_ = [];
      this.W_ = [];
      this.pad_ = [];
      this.inbuf_ = 0;
      this.total_ = 0;
      this.blockSize = 512 / 8;
      this.pad_[0] = 128;
      for (var i = 1; i < this.blockSize; ++i) {
        this.pad_[i] = 0;
      }
      this.reset();
    }
    Sha12.prototype.reset = function() {
      this.chain_[0] = 1732584193;
      this.chain_[1] = 4023233417;
      this.chain_[2] = 2562383102;
      this.chain_[3] = 271733878;
      this.chain_[4] = 3285377520;
      this.inbuf_ = 0;
      this.total_ = 0;
    };
    Sha12.prototype.compress_ = function(buf, offset) {
      if (!offset) {
        offset = 0;
      }
      var W = this.W_;
      if (typeof buf === "string") {
        for (var i = 0; i < 16; i++) {
          W[i] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);
          offset += 4;
        }
      } else {
        for (var i = 0; i < 16; i++) {
          W[i] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];
          offset += 4;
        }
      }
      for (var i = 16; i < 80; i++) {
        var t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
        W[i] = (t << 1 | t >>> 31) & 4294967295;
      }
      var a = this.chain_[0];
      var b = this.chain_[1];
      var c = this.chain_[2];
      var d = this.chain_[3];
      var e = this.chain_[4];
      var f, k;
      for (var i = 0; i < 80; i++) {
        if (i < 40) {
          if (i < 20) {
            f = d ^ b & (c ^ d);
            k = 1518500249;
          } else {
            f = b ^ c ^ d;
            k = 1859775393;
          }
        } else {
          if (i < 60) {
            f = b & c | d & (b | c);
            k = 2400959708;
          } else {
            f = b ^ c ^ d;
            k = 3395469782;
          }
        }
        var t = (a << 5 | a >>> 27) + f + e + k + W[i] & 4294967295;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) & 4294967295;
        b = a;
        a = t;
      }
      this.chain_[0] = this.chain_[0] + a & 4294967295;
      this.chain_[1] = this.chain_[1] + b & 4294967295;
      this.chain_[2] = this.chain_[2] + c & 4294967295;
      this.chain_[3] = this.chain_[3] + d & 4294967295;
      this.chain_[4] = this.chain_[4] + e & 4294967295;
    };
    Sha12.prototype.update = function(bytes, length) {
      if (bytes == null) {
        return;
      }
      if (length === void 0) {
        length = bytes.length;
      }
      var lengthMinusBlock = length - this.blockSize;
      var n = 0;
      var buf = this.buf_;
      var inbuf = this.inbuf_;
      while (n < length) {
        if (inbuf === 0) {
          while (n <= lengthMinusBlock) {
            this.compress_(bytes, n);
            n += this.blockSize;
          }
        }
        if (typeof bytes === "string") {
          while (n < length) {
            buf[inbuf] = bytes.charCodeAt(n);
            ++inbuf;
            ++n;
            if (inbuf === this.blockSize) {
              this.compress_(buf);
              inbuf = 0;
              break;
            }
          }
        } else {
          while (n < length) {
            buf[inbuf] = bytes[n];
            ++inbuf;
            ++n;
            if (inbuf === this.blockSize) {
              this.compress_(buf);
              inbuf = 0;
              break;
            }
          }
        }
      }
      this.inbuf_ = inbuf;
      this.total_ += length;
    };
    Sha12.prototype.digest = function() {
      var digest = [];
      var totalBits = this.total_ * 8;
      if (this.inbuf_ < 56) {
        this.update(this.pad_, 56 - this.inbuf_);
      } else {
        this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
      }
      for (var i = this.blockSize - 1; i >= 56; i--) {
        this.buf_[i] = totalBits & 255;
        totalBits /= 256;
      }
      this.compress_(this.buf_);
      var n = 0;
      for (var i = 0; i < 5; i++) {
        for (var j = 24; j >= 0; j -= 8) {
          digest[n] = this.chain_[i] >> j & 255;
          ++n;
        }
      }
      return digest;
    };
    return Sha12;
  }();
  function createSubscribe(executor, onNoObservers) {
    var proxy = new ObserverProxy(executor, onNoObservers);
    return proxy.subscribe.bind(proxy);
  }
  var ObserverProxy = function() {
    function ObserverProxy2(executor, onNoObservers) {
      var _this = this;
      this.observers = [];
      this.unsubscribes = [];
      this.observerCount = 0;
      this.task = Promise.resolve();
      this.finalized = false;
      this.onNoObservers = onNoObservers;
      this.task.then(function() {
        executor(_this);
      }).catch(function(e) {
        _this.error(e);
      });
    }
    ObserverProxy2.prototype.next = function(value) {
      this.forEachObserver(function(observer) {
        observer.next(value);
      });
    };
    ObserverProxy2.prototype.error = function(error) {
      this.forEachObserver(function(observer) {
        observer.error(error);
      });
      this.close(error);
    };
    ObserverProxy2.prototype.complete = function() {
      this.forEachObserver(function(observer) {
        observer.complete();
      });
      this.close();
    };
    ObserverProxy2.prototype.subscribe = function(nextOrObserver, error, complete) {
      var _this = this;
      var observer;
      if (nextOrObserver === void 0 && error === void 0 && complete === void 0) {
        throw new Error("Missing Observer.");
      }
      if (implementsAnyMethods(nextOrObserver, [
        "next",
        "error",
        "complete"
      ])) {
        observer = nextOrObserver;
      } else {
        observer = {
          next: nextOrObserver,
          error,
          complete
        };
      }
      if (observer.next === void 0) {
        observer.next = noop;
      }
      if (observer.error === void 0) {
        observer.error = noop;
      }
      if (observer.complete === void 0) {
        observer.complete = noop;
      }
      var unsub = this.unsubscribeOne.bind(this, this.observers.length);
      if (this.finalized) {
        this.task.then(function() {
          try {
            if (_this.finalError) {
              observer.error(_this.finalError);
            } else {
              observer.complete();
            }
          } catch (e) {
          }
          return;
        });
      }
      this.observers.push(observer);
      return unsub;
    };
    ObserverProxy2.prototype.unsubscribeOne = function(i) {
      if (this.observers === void 0 || this.observers[i] === void 0) {
        return;
      }
      delete this.observers[i];
      this.observerCount -= 1;
      if (this.observerCount === 0 && this.onNoObservers !== void 0) {
        this.onNoObservers(this);
      }
    };
    ObserverProxy2.prototype.forEachObserver = function(fn) {
      if (this.finalized) {
        return;
      }
      for (var i = 0; i < this.observers.length; i++) {
        this.sendOne(i, fn);
      }
    };
    ObserverProxy2.prototype.sendOne = function(i, fn) {
      var _this = this;
      this.task.then(function() {
        if (_this.observers !== void 0 && _this.observers[i] !== void 0) {
          try {
            fn(_this.observers[i]);
          } catch (e) {
            if (typeof console !== "undefined" && console.error) {
              console.error(e);
            }
          }
        }
      });
    };
    ObserverProxy2.prototype.close = function(err) {
      var _this = this;
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      if (err !== void 0) {
        this.finalError = err;
      }
      this.task.then(function() {
        _this.observers = void 0;
        _this.onNoObservers = void 0;
      });
    };
    return ObserverProxy2;
  }();
  function async(fn, onError) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      Promise.resolve(true).then(function() {
        fn.apply(void 0, args);
      }).catch(function(error) {
        if (onError) {
          onError(error);
        }
      });
    };
  }
  function implementsAnyMethods(obj, methods) {
    if (typeof obj !== "object" || obj === null) {
      return false;
    }
    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
      var method = methods_1[_i];
      if (method in obj && typeof obj[method] === "function") {
        return true;
      }
    }
    return false;
  }
  function noop() {
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var validateArgCount = function(fnName, minCount, maxCount, argCount) {
    var argError;
    if (argCount < minCount) {
      argError = "at least " + minCount;
    } else if (argCount > maxCount) {
      argError = maxCount === 0 ? "none" : "no more than " + maxCount;
    }
    if (argError) {
      var error = fnName + " failed: Was called with " + argCount + (argCount === 1 ? " argument." : " arguments.") + " Expects " + argError + ".";
      throw new Error(error);
    }
  };
  function errorPrefix(fnName, argumentNumber, optional) {
    var argName = "";
    switch (argumentNumber) {
      case 1:
        argName = optional ? "first" : "First";
        break;
      case 2:
        argName = optional ? "second" : "Second";
        break;
      case 3:
        argName = optional ? "third" : "Third";
        break;
      case 4:
        argName = optional ? "fourth" : "Fourth";
        break;
      default:
        throw new Error("errorPrefix called with argumentNumber > 4.  Need to update it?");
    }
    var error = fnName + " failed: ";
    error += argName + " argument ";
    return error;
  }
  function validateNamespace(fnName, argumentNumber, namespace, optional) {
    if (optional && !namespace) {
      return;
    }
    if (typeof namespace !== "string") {
      throw new Error(errorPrefix(fnName, argumentNumber, optional) + "must be a valid firebase namespace.");
    }
  }
  function validateCallback(fnName, argumentNumber, callback, optional) {
    if (optional && !callback) {
      return;
    }
    if (typeof callback !== "function") {
      throw new Error(errorPrefix(fnName, argumentNumber, optional) + "must be a valid function.");
    }
  }
  function validateContextObject(fnName, argumentNumber, context, optional) {
    if (optional && !context) {
      return;
    }
    if (typeof context !== "object" || context === null) {
      throw new Error(errorPrefix(fnName, argumentNumber, optional) + "must be a valid context object.");
    }
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var stringToByteArray$1 = function(str) {
    var out = [];
    var p = 0;
    for (var i = 0; i < str.length; i++) {
      var c = str.charCodeAt(i);
      if (c >= 55296 && c <= 56319) {
        var high = c - 55296;
        i++;
        assert(i < str.length, "Surrogate pair missing trail surrogate.");
        var low = str.charCodeAt(i) - 56320;
        c = 65536 + (high << 10) + low;
      }
      if (c < 128) {
        out[p++] = c;
      } else if (c < 2048) {
        out[p++] = c >> 6 | 192;
        out[p++] = c & 63 | 128;
      } else if (c < 65536) {
        out[p++] = c >> 12 | 224;
        out[p++] = c >> 6 & 63 | 128;
        out[p++] = c & 63 | 128;
      } else {
        out[p++] = c >> 18 | 240;
        out[p++] = c >> 12 & 63 | 128;
        out[p++] = c >> 6 & 63 | 128;
        out[p++] = c & 63 | 128;
      }
    }
    return out;
  };
  var stringLength = function(str) {
    var p = 0;
    for (var i = 0; i < str.length; i++) {
      var c = str.charCodeAt(i);
      if (c < 128) {
        p++;
      } else if (c < 2048) {
        p += 2;
      } else if (c >= 55296 && c <= 56319) {
        p += 4;
        i++;
      } else {
        p += 3;
      }
    }
    return p;
  };
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var DEFAULT_INTERVAL_MILLIS = 1e3;
  var DEFAULT_BACKOFF_FACTOR = 2;
  var MAX_VALUE_MILLIS = 4 * 60 * 60 * 1e3;
  var RANDOM_FACTOR = 0.5;
  function calculateBackoffMillis(backoffCount, intervalMillis, backoffFactor) {
    if (intervalMillis === void 0) {
      intervalMillis = DEFAULT_INTERVAL_MILLIS;
    }
    if (backoffFactor === void 0) {
      backoffFactor = DEFAULT_BACKOFF_FACTOR;
    }
    var currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);
    var randomWait = Math.round(RANDOM_FACTOR * currBaseValue * (Math.random() - 0.5) * 2);
    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function ordinal(i) {
    if (!Number.isFinite(i)) {
      return "" + i;
    }
    return i + indicator(i);
  }
  function indicator(i) {
    i = Math.abs(i);
    var cent = i % 100;
    if (cent >= 10 && cent <= 20) {
      return "th";
    }
    var dec = i % 10;
    if (dec === 1) {
      return "st";
    }
    if (dec === 2) {
      return "nd";
    }
    if (dec === 3) {
      return "rd";
    }
    return "th";
  }
  /**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function getModularInstance(service) {
    if (service && service._delegate) {
      return service._delegate;
    } else {
      return service;
    }
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  CONSTANTS.NODE_CLIENT = true;
  exports2.CONSTANTS = CONSTANTS;
  exports2.Deferred = Deferred;
  exports2.ErrorFactory = ErrorFactory;
  exports2.FirebaseError = FirebaseError;
  exports2.MAX_VALUE_MILLIS = MAX_VALUE_MILLIS;
  exports2.RANDOM_FACTOR = RANDOM_FACTOR;
  exports2.Sha1 = Sha1;
  exports2.areCookiesEnabled = areCookiesEnabled;
  exports2.assert = assert;
  exports2.assertionError = assertionError;
  exports2.async = async;
  exports2.base64 = base64;
  exports2.base64Decode = base64Decode;
  exports2.base64Encode = base64Encode;
  exports2.calculateBackoffMillis = calculateBackoffMillis;
  exports2.contains = contains;
  exports2.createSubscribe = createSubscribe;
  exports2.decode = decode;
  exports2.deepCopy = deepCopy;
  exports2.deepExtend = deepExtend;
  exports2.errorPrefix = errorPrefix;
  exports2.extractQuerystring = extractQuerystring;
  exports2.getModularInstance = getModularInstance;
  exports2.getUA = getUA;
  exports2.isAdmin = isAdmin;
  exports2.isBrowser = isBrowser;
  exports2.isBrowserExtension = isBrowserExtension;
  exports2.isElectron = isElectron;
  exports2.isEmpty = isEmpty;
  exports2.isIE = isIE;
  exports2.isIndexedDBAvailable = isIndexedDBAvailable;
  exports2.isMobileCordova = isMobileCordova;
  exports2.isNode = isNode;
  exports2.isNodeSdk = isNodeSdk;
  exports2.isReactNative = isReactNative;
  exports2.isSafari = isSafari;
  exports2.isUWP = isUWP;
  exports2.isValidFormat = isValidFormat;
  exports2.isValidTimestamp = isValidTimestamp;
  exports2.issuedAtTime = issuedAtTime;
  exports2.jsonEval = jsonEval;
  exports2.map = map;
  exports2.ordinal = ordinal;
  exports2.querystring = querystring;
  exports2.querystringDecode = querystringDecode;
  exports2.safeGet = safeGet;
  exports2.stringLength = stringLength;
  exports2.stringToByteArray = stringToByteArray$1;
  exports2.stringify = stringify;
  exports2.validateArgCount = validateArgCount;
  exports2.validateCallback = validateCallback;
  exports2.validateContextObject = validateContextObject;
  exports2.validateIndexedDBOpenable = validateIndexedDBOpenable;
  exports2.validateNamespace = validateNamespace;
});

// node_modules/@firebase/component/dist/index.cjs.js
var require_index_cjs = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib = require_tslib();
  var util = require_index_node_cjs();
  var Component = function() {
    function Component2(name, instanceFactory, type) {
      this.name = name;
      this.instanceFactory = instanceFactory;
      this.type = type;
      this.multipleInstances = false;
      this.serviceProps = {};
      this.instantiationMode = "LAZY";
      this.onInstanceCreated = null;
    }
    Component2.prototype.setInstantiationMode = function(mode) {
      this.instantiationMode = mode;
      return this;
    };
    Component2.prototype.setMultipleInstances = function(multipleInstances) {
      this.multipleInstances = multipleInstances;
      return this;
    };
    Component2.prototype.setServiceProps = function(props) {
      this.serviceProps = props;
      return this;
    };
    Component2.prototype.setInstanceCreatedCallback = function(callback) {
      this.onInstanceCreated = callback;
      return this;
    };
    return Component2;
  }();
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var DEFAULT_ENTRY_NAME = "[DEFAULT]";
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var Provider = function() {
    function Provider2(name, container) {
      this.name = name;
      this.container = container;
      this.component = null;
      this.instances = new Map();
      this.instancesDeferred = new Map();
    }
    Provider2.prototype.get = function(identifier) {
      if (identifier === void 0) {
        identifier = DEFAULT_ENTRY_NAME;
      }
      var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
      if (!this.instancesDeferred.has(normalizedIdentifier)) {
        var deferred = new util.Deferred();
        this.instancesDeferred.set(normalizedIdentifier, deferred);
        if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
          try {
            var instance = this.getOrInitializeService({
              instanceIdentifier: normalizedIdentifier
            });
            if (instance) {
              deferred.resolve(instance);
            }
          } catch (e) {
          }
        }
      }
      return this.instancesDeferred.get(normalizedIdentifier).promise;
    };
    Provider2.prototype.getImmediate = function(options) {
      var _a = tslib.__assign({identifier: DEFAULT_ENTRY_NAME, optional: false}, options), identifier = _a.identifier, optional = _a.optional;
      var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
        try {
          return this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier
          });
        } catch (e) {
          if (optional) {
            return null;
          } else {
            throw e;
          }
        }
      } else {
        if (optional) {
          return null;
        } else {
          throw Error("Service " + this.name + " is not available");
        }
      }
    };
    Provider2.prototype.getComponent = function() {
      return this.component;
    };
    Provider2.prototype.setComponent = function(component) {
      var e_1, _a;
      if (component.name !== this.name) {
        throw Error("Mismatching Component " + component.name + " for Provider " + this.name + ".");
      }
      if (this.component) {
        throw Error("Component for " + this.name + " has already been provided");
      }
      this.component = component;
      if (!this.shouldAutoInitialize()) {
        return;
      }
      if (isComponentEager(component)) {
        try {
          this.getOrInitializeService({instanceIdentifier: DEFAULT_ENTRY_NAME});
        } catch (e) {
        }
      }
      try {
        for (var _b = tslib.__values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = tslib.__read(_c.value, 2), instanceIdentifier = _d[0], instanceDeferred = _d[1];
          var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
          try {
            var instance = this.getOrInitializeService({
              instanceIdentifier: normalizedIdentifier
            });
            instanceDeferred.resolve(instance);
          } catch (e) {
          }
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    Provider2.prototype.clearInstance = function(identifier) {
      if (identifier === void 0) {
        identifier = DEFAULT_ENTRY_NAME;
      }
      this.instancesDeferred.delete(identifier);
      this.instances.delete(identifier);
    };
    Provider2.prototype.delete = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var services;
        return tslib.__generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              services = Array.from(this.instances.values());
              return [4, Promise.all(tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(services.filter(function(service) {
                return "INTERNAL" in service;
              }).map(function(service) {
                return service.INTERNAL.delete();
              }))), tslib.__read(services.filter(function(service) {
                return "_delete" in service;
              }).map(function(service) {
                return service._delete();
              }))))];
            case 1:
              _a.sent();
              return [2];
          }
        });
      });
    };
    Provider2.prototype.isComponentSet = function() {
      return this.component != null;
    };
    Provider2.prototype.isInitialized = function(identifier) {
      if (identifier === void 0) {
        identifier = DEFAULT_ENTRY_NAME;
      }
      return this.instances.has(identifier);
    };
    Provider2.prototype.initialize = function(opts) {
      var e_2, _a;
      if (opts === void 0) {
        opts = {};
      }
      var _b = opts.instanceIdentifier, instanceIdentifier = _b === void 0 ? DEFAULT_ENTRY_NAME : _b, _c = opts.options, options = _c === void 0 ? {} : _c;
      var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
      if (this.isInitialized(normalizedIdentifier)) {
        throw Error(this.name + "(" + normalizedIdentifier + ") has already been initialized");
      }
      if (!this.isComponentSet()) {
        throw Error("Component " + this.name + " has not been registered yet");
      }
      var instance = this.getOrInitializeService({
        instanceIdentifier: normalizedIdentifier,
        options
      });
      try {
        for (var _d = tslib.__values(this.instancesDeferred.entries()), _e = _d.next(); !_e.done; _e = _d.next()) {
          var _f = tslib.__read(_e.value, 2), instanceIdentifier_1 = _f[0], instanceDeferred = _f[1];
          var normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier_1);
          if (normalizedIdentifier === normalizedDeferredIdentifier) {
            instanceDeferred.resolve(instance);
          }
        }
      } catch (e_2_1) {
        e_2 = {error: e_2_1};
      } finally {
        try {
          if (_e && !_e.done && (_a = _d.return))
            _a.call(_d);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      return instance;
    };
    Provider2.prototype.getOrInitializeService = function(_a) {
      var instanceIdentifier = _a.instanceIdentifier, _b = _a.options, options = _b === void 0 ? {} : _b;
      var instance = this.instances.get(instanceIdentifier);
      if (!instance && this.component) {
        instance = this.component.instanceFactory(this.container, {
          instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
          options
        });
        this.instances.set(instanceIdentifier, instance);
        if (this.component.onInstanceCreated) {
          try {
            this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
          } catch (_c) {
          }
        }
      }
      return instance || null;
    };
    Provider2.prototype.normalizeInstanceIdentifier = function(identifier) {
      if (this.component) {
        return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;
      } else {
        return identifier;
      }
    };
    Provider2.prototype.shouldAutoInitialize = function() {
      return !!this.component && this.component.instantiationMode !== "EXPLICIT";
    };
    return Provider2;
  }();
  function normalizeIdentifierForFactory(identifier) {
    return identifier === DEFAULT_ENTRY_NAME ? void 0 : identifier;
  }
  function isComponentEager(component) {
    return component.instantiationMode === "EAGER";
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var ComponentContainer = function() {
    function ComponentContainer2(name) {
      this.name = name;
      this.providers = new Map();
    }
    ComponentContainer2.prototype.addComponent = function(component) {
      var provider = this.getProvider(component.name);
      if (provider.isComponentSet()) {
        throw new Error("Component " + component.name + " has already been registered with " + this.name);
      }
      provider.setComponent(component);
    };
    ComponentContainer2.prototype.addOrOverwriteComponent = function(component) {
      var provider = this.getProvider(component.name);
      if (provider.isComponentSet()) {
        this.providers.delete(component.name);
      }
      this.addComponent(component);
    };
    ComponentContainer2.prototype.getProvider = function(name) {
      if (this.providers.has(name)) {
        return this.providers.get(name);
      }
      var provider = new Provider(name, this);
      this.providers.set(name, provider);
      return provider;
    };
    ComponentContainer2.prototype.getProviders = function() {
      return Array.from(this.providers.values());
    };
    return ComponentContainer2;
  }();
  exports2.Component = Component;
  exports2.ComponentContainer = ComponentContainer;
  exports2.Provider = Provider;
});

// node_modules/@firebase/logger/dist/index.cjs.js
var require_index_cjs2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++)
      s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
        r[k] = a[j];
    return r;
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var _a;
  var instances = [];
  (function(LogLevel) {
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["VERBOSE"] = 1] = "VERBOSE";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
    LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
  })(exports2.LogLevel || (exports2.LogLevel = {}));
  var levelStringToEnum = {
    debug: exports2.LogLevel.DEBUG,
    verbose: exports2.LogLevel.VERBOSE,
    info: exports2.LogLevel.INFO,
    warn: exports2.LogLevel.WARN,
    error: exports2.LogLevel.ERROR,
    silent: exports2.LogLevel.SILENT
  };
  var defaultLogLevel = exports2.LogLevel.INFO;
  var ConsoleMethod = (_a = {}, _a[exports2.LogLevel.DEBUG] = "log", _a[exports2.LogLevel.VERBOSE] = "log", _a[exports2.LogLevel.INFO] = "info", _a[exports2.LogLevel.WARN] = "warn", _a[exports2.LogLevel.ERROR] = "error", _a);
  var defaultLogHandler = function(instance, logType) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    if (logType < instance.logLevel) {
      return;
    }
    var now = new Date().toISOString();
    var method = ConsoleMethod[logType];
    if (method) {
      console[method].apply(console, __spreadArrays(["[" + now + "]  " + instance.name + ":"], args));
    } else {
      throw new Error("Attempted to log a message with an invalid logType (value: " + logType + ")");
    }
  };
  var Logger = function() {
    function Logger2(name) {
      this.name = name;
      this._logLevel = defaultLogLevel;
      this._logHandler = defaultLogHandler;
      this._userLogHandler = null;
      instances.push(this);
    }
    Object.defineProperty(Logger2.prototype, "logLevel", {
      get: function() {
        return this._logLevel;
      },
      set: function(val) {
        if (!(val in exports2.LogLevel)) {
          throw new TypeError('Invalid value "' + val + '" assigned to `logLevel`');
        }
        this._logLevel = val;
      },
      enumerable: false,
      configurable: true
    });
    Logger2.prototype.setLogLevel = function(val) {
      this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
    };
    Object.defineProperty(Logger2.prototype, "logHandler", {
      get: function() {
        return this._logHandler;
      },
      set: function(val) {
        if (typeof val !== "function") {
          throw new TypeError("Value assigned to `logHandler` must be a function");
        }
        this._logHandler = val;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Logger2.prototype, "userLogHandler", {
      get: function() {
        return this._userLogHandler;
      },
      set: function(val) {
        this._userLogHandler = val;
      },
      enumerable: false,
      configurable: true
    });
    Logger2.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, exports2.LogLevel.DEBUG], args));
      this._logHandler.apply(this, __spreadArrays([this, exports2.LogLevel.DEBUG], args));
    };
    Logger2.prototype.log = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, exports2.LogLevel.VERBOSE], args));
      this._logHandler.apply(this, __spreadArrays([this, exports2.LogLevel.VERBOSE], args));
    };
    Logger2.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, exports2.LogLevel.INFO], args));
      this._logHandler.apply(this, __spreadArrays([this, exports2.LogLevel.INFO], args));
    };
    Logger2.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, exports2.LogLevel.WARN], args));
      this._logHandler.apply(this, __spreadArrays([this, exports2.LogLevel.WARN], args));
    };
    Logger2.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, exports2.LogLevel.ERROR], args));
      this._logHandler.apply(this, __spreadArrays([this, exports2.LogLevel.ERROR], args));
    };
    return Logger2;
  }();
  function setLogLevel(level) {
    instances.forEach(function(inst) {
      inst.setLogLevel(level);
    });
  }
  function setUserLogHandler(logCallback, options) {
    var _loop_1 = function(instance2) {
      var customLogLevel = null;
      if (options && options.level) {
        customLogLevel = levelStringToEnum[options.level];
      }
      if (logCallback === null) {
        instance2.userLogHandler = null;
      } else {
        instance2.userLogHandler = function(instance3, level) {
          var args = [];
          for (var _i2 = 2; _i2 < arguments.length; _i2++) {
            args[_i2 - 2] = arguments[_i2];
          }
          var message = args.map(function(arg) {
            if (arg == null) {
              return null;
            } else if (typeof arg === "string") {
              return arg;
            } else if (typeof arg === "number" || typeof arg === "boolean") {
              return arg.toString();
            } else if (arg instanceof Error) {
              return arg.message;
            } else {
              try {
                return JSON.stringify(arg);
              } catch (ignored) {
                return null;
              }
            }
          }).filter(function(arg) {
            return arg;
          }).join(" ");
          if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance3.logLevel)) {
            logCallback({
              level: exports2.LogLevel[level].toLowerCase(),
              message,
              args,
              type: instance3.name
            });
          }
        };
      }
    };
    for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
      var instance = instances_1[_i];
      _loop_1(instance);
    }
  }
  exports2.Logger = Logger;
  exports2.setLogLevel = setLogLevel;
  exports2.setUserLogHandler = setUserLogHandler;
});

// node_modules/dom-storage/lib/index.js
var require_lib = __commonJS((exports2, module2) => {
  (function() {
    "use strict";
    var fs = require("fs");
    function Storage(path, opts) {
      opts = opts || {};
      var db2;
      Object.defineProperty(this, "___priv_bk___", {
        value: {
          path
        },
        writable: false,
        enumerable: false
      });
      Object.defineProperty(this, "___priv_strict___", {
        value: !!opts.strict,
        writable: false,
        enumerable: false
      });
      Object.defineProperty(this, "___priv_ws___", {
        value: opts.ws || "  ",
        writable: false,
        enumerable: false
      });
      try {
        db2 = JSON.parse(fs.readFileSync(path));
      } catch (e) {
        db2 = {};
      }
      Object.keys(db2).forEach(function(key) {
        this[key] = db2[key];
      }, this);
    }
    Storage.prototype.getItem = function(key) {
      if (this.hasOwnProperty(key)) {
        if (this.___priv_strict___) {
          return String(this[key]);
        } else {
          return this[key];
        }
      }
      return null;
    };
    Storage.prototype.setItem = function(key, val) {
      if (val === void 0) {
        this[key] = null;
      } else if (this.___priv_strict___) {
        this[key] = String(val);
      } else {
        this[key] = val;
      }
      this.___save___();
    };
    Storage.prototype.removeItem = function(key) {
      delete this[key];
      this.___save___();
    };
    Storage.prototype.clear = function() {
      var self2 = this;
      Object.keys(self2).forEach(function(key) {
        self2[key] = void 0;
        delete self2[key];
      });
    };
    Storage.prototype.key = function(i) {
      i = i || 0;
      return Object.keys(this)[i];
    };
    Object.defineProperty(Storage.prototype, "length", {
      get: function() {
        return Object.keys(this).length;
      }
    });
    Storage.prototype.___save___ = function() {
      var self2 = this;
      if (!this.___priv_bk___.path) {
        return;
      }
      if (this.___priv_bk___.lock) {
        this.___priv_bk___.wait = true;
        return;
      }
      this.___priv_bk___.lock = true;
      fs.writeFile(this.___priv_bk___.path, JSON.stringify(this, null, this.___priv_ws___), "utf8", function(e) {
        self2.___priv_bk___.lock = false;
        if (e) {
          console.error("Could not write to database", self2.___priv_bk___.path);
          console.error(e);
          return;
        }
        if (self2.___priv_bk___.wait) {
          self2.___priv_bk___.wait = false;
          self2.___save___();
        }
      });
    };
    Object.defineProperty(Storage, "create", {
      value: function(path, opts) {
        return new Storage(path, opts);
      },
      writable: false,
      enumerable: false
    });
    module2.exports = Storage;
  })();
});

// node_modules/xmlhttprequest/lib/XMLHttpRequest.js
var require_XMLHttpRequest = __commonJS((exports2) => {
  /**
   * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
   *
   * This can be used with JS designed for browsers to improve reuse of code and
   * allow the use of existing libraries.
   *
   * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
   *
   * @author Dan DeFelippi <dan@driverdan.com>
   * @contributor David Ellis <d.f.ellis@ieee.org>
   * @license MIT
   */
  var Url = require("url");
  var spawn = require("child_process").spawn;
  var fs = require("fs");
  exports2.XMLHttpRequest = function() {
    "use strict";
    var self2 = this;
    var http = require("http");
    var https = require("https");
    var request;
    var response;
    var settings = {};
    var disableHeaderCheck = false;
    var defaultHeaders = {
      "User-Agent": "node-XMLHttpRequest",
      Accept: "*/*"
    };
    var headers = {};
    var headersCase = {};
    var forbiddenRequestHeaders = [
      "accept-charset",
      "accept-encoding",
      "access-control-request-headers",
      "access-control-request-method",
      "connection",
      "content-length",
      "content-transfer-encoding",
      "cookie",
      "cookie2",
      "date",
      "expect",
      "host",
      "keep-alive",
      "origin",
      "referer",
      "te",
      "trailer",
      "transfer-encoding",
      "upgrade",
      "via"
    ];
    var forbiddenRequestMethods = [
      "TRACE",
      "TRACK",
      "CONNECT"
    ];
    var sendFlag = false;
    var errorFlag = false;
    var listeners = {};
    this.UNSENT = 0;
    this.OPENED = 1;
    this.HEADERS_RECEIVED = 2;
    this.LOADING = 3;
    this.DONE = 4;
    this.readyState = this.UNSENT;
    this.onreadystatechange = null;
    this.responseText = "";
    this.responseXML = "";
    this.status = null;
    this.statusText = null;
    this.withCredentials = false;
    var isAllowedHttpHeader = function(header) {
      return disableHeaderCheck || header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1;
    };
    var isAllowedHttpMethod = function(method) {
      return method && forbiddenRequestMethods.indexOf(method) === -1;
    };
    this.open = function(method, url, async, user, password) {
      this.abort();
      errorFlag = false;
      if (!isAllowedHttpMethod(method)) {
        throw new Error("SecurityError: Request method not allowed");
      }
      settings = {
        method,
        url: url.toString(),
        async: typeof async !== "boolean" ? true : async,
        user: user || null,
        password: password || null
      };
      setState(this.OPENED);
    };
    this.setDisableHeaderCheck = function(state) {
      disableHeaderCheck = state;
    };
    this.setRequestHeader = function(header, value) {
      if (this.readyState !== this.OPENED) {
        throw new Error("INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN");
      }
      if (!isAllowedHttpHeader(header)) {
        console.warn('Refused to set unsafe header "' + header + '"');
        return;
      }
      if (sendFlag) {
        throw new Error("INVALID_STATE_ERR: send flag is true");
      }
      header = headersCase[header.toLowerCase()] || header;
      headersCase[header.toLowerCase()] = header;
      headers[header] = headers[header] ? headers[header] + ", " + value : value;
    };
    this.getResponseHeader = function(header) {
      if (typeof header === "string" && this.readyState > this.OPENED && response && response.headers && response.headers[header.toLowerCase()] && !errorFlag) {
        return response.headers[header.toLowerCase()];
      }
      return null;
    };
    this.getAllResponseHeaders = function() {
      if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
        return "";
      }
      var result = "";
      for (var i in response.headers) {
        if (i !== "set-cookie" && i !== "set-cookie2") {
          result += i + ": " + response.headers[i] + "\r\n";
        }
      }
      return result.substr(0, result.length - 2);
    };
    this.getRequestHeader = function(name) {
      if (typeof name === "string" && headersCase[name.toLowerCase()]) {
        return headers[headersCase[name.toLowerCase()]];
      }
      return "";
    };
    this.send = function(data) {
      if (this.readyState !== this.OPENED) {
        throw new Error("INVALID_STATE_ERR: connection must be opened before send() is called");
      }
      if (sendFlag) {
        throw new Error("INVALID_STATE_ERR: send has already been called");
      }
      var ssl = false, local = false;
      var url = Url.parse(settings.url);
      var host;
      switch (url.protocol) {
        case "https:":
          ssl = true;
        case "http:":
          host = url.hostname;
          break;
        case "file:":
          local = true;
          break;
        case void 0:
        case null:
        case "":
          host = "localhost";
          break;
        default:
          throw new Error("Protocol not supported.");
      }
      if (local) {
        if (settings.method !== "GET") {
          throw new Error("XMLHttpRequest: Only GET method is supported");
        }
        if (settings.async) {
          fs.readFile(url.pathname, "utf8", function(error, data2) {
            if (error) {
              self2.handleError(error);
            } else {
              self2.status = 200;
              self2.responseText = data2;
              setState(self2.DONE);
            }
          });
        } else {
          try {
            this.responseText = fs.readFileSync(url.pathname, "utf8");
            this.status = 200;
            setState(self2.DONE);
          } catch (e) {
            this.handleError(e);
          }
        }
        return;
      }
      var port = url.port || (ssl ? 443 : 80);
      var uri = url.pathname + (url.search ? url.search : "");
      for (var name in defaultHeaders) {
        if (!headersCase[name.toLowerCase()]) {
          headers[name] = defaultHeaders[name];
        }
      }
      headers.Host = host;
      if (!(ssl && port === 443 || port === 80)) {
        headers.Host += ":" + url.port;
      }
      if (settings.user) {
        if (typeof settings.password === "undefined") {
          settings.password = "";
        }
        var authBuf = new Buffer(settings.user + ":" + settings.password);
        headers.Authorization = "Basic " + authBuf.toString("base64");
      }
      if (settings.method === "GET" || settings.method === "HEAD") {
        data = null;
      } else if (data) {
        headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);
        if (!headers["Content-Type"]) {
          headers["Content-Type"] = "text/plain;charset=UTF-8";
        }
      } else if (settings.method === "POST") {
        headers["Content-Length"] = 0;
      }
      var options = {
        host,
        port,
        path: uri,
        method: settings.method,
        headers,
        agent: false,
        withCredentials: self2.withCredentials
      };
      errorFlag = false;
      if (settings.async) {
        var doRequest = ssl ? https.request : http.request;
        sendFlag = true;
        self2.dispatchEvent("readystatechange");
        var responseHandler = function responseHandler2(resp2) {
          response = resp2;
          if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
            settings.url = response.headers.location;
            var url2 = Url.parse(settings.url);
            host = url2.hostname;
            var newOptions = {
              hostname: url2.hostname,
              port: url2.port,
              path: url2.path,
              method: response.statusCode === 303 ? "GET" : settings.method,
              headers,
              withCredentials: self2.withCredentials
            };
            request = doRequest(newOptions, responseHandler2).on("error", errorHandler);
            request.end();
            return;
          }
          response.setEncoding("utf8");
          setState(self2.HEADERS_RECEIVED);
          self2.status = response.statusCode;
          response.on("data", function(chunk) {
            if (chunk) {
              self2.responseText += chunk;
            }
            if (sendFlag) {
              setState(self2.LOADING);
            }
          });
          response.on("end", function() {
            if (sendFlag) {
              setState(self2.DONE);
              sendFlag = false;
            }
          });
          response.on("error", function(error) {
            self2.handleError(error);
          });
        };
        var errorHandler = function errorHandler2(error) {
          self2.handleError(error);
        };
        request = doRequest(options, responseHandler).on("error", errorHandler);
        if (data) {
          request.write(data);
        }
        request.end();
        self2.dispatchEvent("loadstart");
      } else {
        var contentFile = ".node-xmlhttprequest-content-" + process.pid;
        var syncFile = ".node-xmlhttprequest-sync-" + process.pid;
        fs.writeFileSync(syncFile, "", "utf8");
        var execString = "var http = require('http'), https = require('https'), fs = require('fs');var doRequest = http" + (ssl ? "s" : "") + ".request;var options = " + JSON.stringify(options) + ";var responseText = '';var req = doRequest(options, function(response) {response.setEncoding('utf8');response.on('data', function(chunk) {  responseText += chunk;});response.on('end', function() {fs.writeFileSync('" + contentFile + "', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText}}), 'utf8');fs.unlinkSync('" + syncFile + "');});response.on('error', function(error) {fs.writeFileSync('" + contentFile + "', JSON.stringify({err: error}), 'utf8');fs.unlinkSync('" + syncFile + "');});}).on('error', function(error) {fs.writeFileSync('" + contentFile + "', JSON.stringify({err: error}), 'utf8');fs.unlinkSync('" + syncFile + "');});" + (data ? "req.write('" + JSON.stringify(data).slice(1, -1).replace(/'/g, "\\'") + "');" : "") + "req.end();";
        var syncProc = spawn(process.argv[0], ["-e", execString]);
        while (fs.existsSync(syncFile)) {
        }
        var resp = JSON.parse(fs.readFileSync(contentFile, "utf8"));
        syncProc.stdin.end();
        fs.unlinkSync(contentFile);
        if (resp.err) {
          self2.handleError(resp.err);
        } else {
          response = resp.data;
          self2.status = resp.data.statusCode;
          self2.responseText = resp.data.text;
          setState(self2.DONE);
        }
      }
    };
    this.handleError = function(error) {
      this.status = 0;
      this.statusText = error;
      this.responseText = error.stack;
      errorFlag = true;
      setState(this.DONE);
      this.dispatchEvent("error");
    };
    this.abort = function() {
      if (request) {
        request.abort();
        request = null;
      }
      headers = defaultHeaders;
      this.status = 0;
      this.responseText = "";
      this.responseXML = "";
      errorFlag = true;
      if (this.readyState !== this.UNSENT && (this.readyState !== this.OPENED || sendFlag) && this.readyState !== this.DONE) {
        sendFlag = false;
        setState(this.DONE);
      }
      this.readyState = this.UNSENT;
      this.dispatchEvent("abort");
    };
    this.addEventListener = function(event, callback) {
      if (!(event in listeners)) {
        listeners[event] = [];
      }
      listeners[event].push(callback);
    };
    this.removeEventListener = function(event, callback) {
      if (event in listeners) {
        listeners[event] = listeners[event].filter(function(ev) {
          return ev !== callback;
        });
      }
    };
    this.dispatchEvent = function(event) {
      if (typeof self2["on" + event] === "function") {
        self2["on" + event]();
      }
      if (event in listeners) {
        for (var i = 0, len = listeners[event].length; i < len; i++) {
          listeners[event][i].call(self2);
        }
      }
    };
    var setState = function(state) {
      if (state == self2.LOADING || self2.readyState !== state) {
        self2.readyState = state;
        if (settings.async || self2.readyState < self2.OPENED || self2.readyState === self2.DONE) {
          self2.dispatchEvent("readystatechange");
        }
        if (self2.readyState === self2.DONE && !errorFlag) {
          self2.dispatchEvent("load");
          self2.dispatchEvent("loadend");
        }
      }
    };
  };
});

// node_modules/@firebase/app/dist/index.node.cjs.js
var require_index_node_cjs2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib = require_tslib();
  var util = require_index_node_cjs();
  var component = require_index_cjs();
  var logger$1 = require_index_cjs2();
  var Storage = require_lib();
  var xmlhttprequest = require_XMLHttpRequest();
  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : {default: e};
  }
  var Storage__default = /* @__PURE__ */ _interopDefaultLegacy(Storage);
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var _a;
  var ERRORS = (_a = {}, _a["no-app"] = "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()", _a["bad-app-name"] = "Illegal App name: '{$appName}", _a["duplicate-app"] = "Firebase App named '{$appName}' already exists", _a["app-deleted"] = "Firebase App named '{$appName}' already deleted", _a["invalid-app-argument"] = "firebase.{$appName}() takes either no argument or a Firebase App instance.", _a["invalid-log-argument"] = "First argument to `onLog` must be null or a function.", _a);
  var ERROR_FACTORY = new util.ErrorFactory("app", "Firebase", ERRORS);
  var name = "@firebase/app";
  var version = "0.6.19";
  var name$1 = "@firebase/analytics";
  var name$2 = "@firebase/auth";
  var name$3 = "@firebase/database";
  var name$4 = "@firebase/functions";
  var name$5 = "@firebase/installations";
  var name$6 = "@firebase/messaging";
  var name$7 = "@firebase/performance";
  var name$8 = "@firebase/remote-config";
  var name$9 = "@firebase/storage";
  var name$a = "@firebase/firestore";
  var name$b = "firebase-wrapper";
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var _a$1;
  var DEFAULT_ENTRY_NAME = "[DEFAULT]";
  var PLATFORM_LOG_STRING = (_a$1 = {}, _a$1[name] = "fire-core", _a$1[name$1] = "fire-analytics", _a$1[name$2] = "fire-auth", _a$1[name$3] = "fire-rtdb", _a$1[name$4] = "fire-fn", _a$1[name$5] = "fire-iid", _a$1[name$6] = "fire-fcm", _a$1[name$7] = "fire-perf", _a$1[name$8] = "fire-rc", _a$1[name$9] = "fire-gcs", _a$1[name$a] = "fire-fst", _a$1["fire-js"] = "fire-js", _a$1[name$b] = "fire-js-all", _a$1);
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var logger = new logger$1.Logger("@firebase/app");
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var FirebaseAppImpl = function() {
    function FirebaseAppImpl2(options, config, firebase_) {
      var _this = this;
      this.firebase_ = firebase_;
      this.isDeleted_ = false;
      this.name_ = config.name;
      this.automaticDataCollectionEnabled_ = config.automaticDataCollectionEnabled || false;
      this.options_ = util.deepCopy(options);
      this.container = new component.ComponentContainer(config.name);
      this._addComponent(new component.Component("app", function() {
        return _this;
      }, "PUBLIC"));
      this.firebase_.INTERNAL.components.forEach(function(component2) {
        return _this._addComponent(component2);
      });
    }
    Object.defineProperty(FirebaseAppImpl2.prototype, "automaticDataCollectionEnabled", {
      get: function() {
        this.checkDestroyed_();
        return this.automaticDataCollectionEnabled_;
      },
      set: function(val) {
        this.checkDestroyed_();
        this.automaticDataCollectionEnabled_ = val;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FirebaseAppImpl2.prototype, "name", {
      get: function() {
        this.checkDestroyed_();
        return this.name_;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FirebaseAppImpl2.prototype, "options", {
      get: function() {
        this.checkDestroyed_();
        return this.options_;
      },
      enumerable: false,
      configurable: true
    });
    FirebaseAppImpl2.prototype.delete = function() {
      var _this = this;
      return new Promise(function(resolve) {
        _this.checkDestroyed_();
        resolve();
      }).then(function() {
        _this.firebase_.INTERNAL.removeApp(_this.name_);
        return Promise.all(_this.container.getProviders().map(function(provider) {
          return provider.delete();
        }));
      }).then(function() {
        _this.isDeleted_ = true;
      });
    };
    FirebaseAppImpl2.prototype._getService = function(name2, instanceIdentifier) {
      if (instanceIdentifier === void 0) {
        instanceIdentifier = DEFAULT_ENTRY_NAME;
      }
      this.checkDestroyed_();
      return this.container.getProvider(name2).getImmediate({
        identifier: instanceIdentifier
      });
    };
    FirebaseAppImpl2.prototype._removeServiceInstance = function(name2, instanceIdentifier) {
      if (instanceIdentifier === void 0) {
        instanceIdentifier = DEFAULT_ENTRY_NAME;
      }
      this.container.getProvider(name2).clearInstance(instanceIdentifier);
    };
    FirebaseAppImpl2.prototype._addComponent = function(component2) {
      try {
        this.container.addComponent(component2);
      } catch (e) {
        logger.debug("Component " + component2.name + " failed to register with FirebaseApp " + this.name, e);
      }
    };
    FirebaseAppImpl2.prototype._addOrOverwriteComponent = function(component2) {
      this.container.addOrOverwriteComponent(component2);
    };
    FirebaseAppImpl2.prototype.toJSON = function() {
      return {
        name: this.name,
        automaticDataCollectionEnabled: this.automaticDataCollectionEnabled,
        options: this.options
      };
    };
    FirebaseAppImpl2.prototype.checkDestroyed_ = function() {
      if (this.isDeleted_) {
        throw ERROR_FACTORY.create("app-deleted", {appName: this.name_});
      }
    };
    return FirebaseAppImpl2;
  }();
  FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options || FirebaseAppImpl.prototype.delete || console.log("dc");
  var version$1 = "8.3.3";
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function createFirebaseNamespaceCore(firebaseAppImpl) {
    var apps = {};
    var components = new Map();
    var namespace = {
      __esModule: true,
      initializeApp,
      app: app2,
      registerVersion,
      setLogLevel: logger$1.setLogLevel,
      onLog,
      apps: null,
      SDK_VERSION: version$1,
      INTERNAL: {
        registerComponent,
        removeApp,
        components,
        useAsService
      }
    };
    namespace["default"] = namespace;
    Object.defineProperty(namespace, "apps", {
      get: getApps
    });
    function removeApp(name2) {
      delete apps[name2];
    }
    function app2(name2) {
      name2 = name2 || DEFAULT_ENTRY_NAME;
      if (!util.contains(apps, name2)) {
        throw ERROR_FACTORY.create("no-app", {appName: name2});
      }
      return apps[name2];
    }
    app2["App"] = firebaseAppImpl;
    function initializeApp(options, rawConfig) {
      if (rawConfig === void 0) {
        rawConfig = {};
      }
      if (typeof rawConfig !== "object" || rawConfig === null) {
        var name_1 = rawConfig;
        rawConfig = {name: name_1};
      }
      var config = rawConfig;
      if (config.name === void 0) {
        config.name = DEFAULT_ENTRY_NAME;
      }
      var name2 = config.name;
      if (typeof name2 !== "string" || !name2) {
        throw ERROR_FACTORY.create("bad-app-name", {
          appName: String(name2)
        });
      }
      if (util.contains(apps, name2)) {
        throw ERROR_FACTORY.create("duplicate-app", {appName: name2});
      }
      var app3 = new firebaseAppImpl(options, config, namespace);
      apps[name2] = app3;
      return app3;
    }
    function getApps() {
      return Object.keys(apps).map(function(name2) {
        return apps[name2];
      });
    }
    function registerComponent(component2) {
      var componentName = component2.name;
      if (components.has(componentName)) {
        logger.debug("There were multiple attempts to register component " + componentName + ".");
        return component2.type === "PUBLIC" ? namespace[componentName] : null;
      }
      components.set(componentName, component2);
      if (component2.type === "PUBLIC") {
        var serviceNamespace = function(appArg) {
          if (appArg === void 0) {
            appArg = app2();
          }
          if (typeof appArg[componentName] !== "function") {
            throw ERROR_FACTORY.create("invalid-app-argument", {
              appName: componentName
            });
          }
          return appArg[componentName]();
        };
        if (component2.serviceProps !== void 0) {
          util.deepExtend(serviceNamespace, component2.serviceProps);
        }
        namespace[componentName] = serviceNamespace;
        firebaseAppImpl.prototype[componentName] = function() {
          var args = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            args[_i2] = arguments[_i2];
          }
          var serviceFxn = this._getService.bind(this, componentName);
          return serviceFxn.apply(this, component2.multipleInstances ? args : []);
        };
      }
      for (var _i = 0, _a2 = Object.keys(apps); _i < _a2.length; _i++) {
        var appName = _a2[_i];
        apps[appName]._addComponent(component2);
      }
      return component2.type === "PUBLIC" ? namespace[componentName] : null;
    }
    function registerVersion(libraryKeyOrName, version2, variant) {
      var _a2;
      var library = (_a2 = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a2 !== void 0 ? _a2 : libraryKeyOrName;
      if (variant) {
        library += "-" + variant;
      }
      var libraryMismatch = library.match(/\s|\//);
      var versionMismatch = version2.match(/\s|\//);
      if (libraryMismatch || versionMismatch) {
        var warning = [
          'Unable to register library "' + library + '" with version "' + version2 + '":'
        ];
        if (libraryMismatch) {
          warning.push('library name "' + library + '" contains illegal characters (whitespace or "/")');
        }
        if (libraryMismatch && versionMismatch) {
          warning.push("and");
        }
        if (versionMismatch) {
          warning.push('version name "' + version2 + '" contains illegal characters (whitespace or "/")');
        }
        logger.warn(warning.join(" "));
        return;
      }
      registerComponent(new component.Component(library + "-version", function() {
        return {library, version: version2};
      }, "VERSION"));
    }
    function onLog(logCallback, options) {
      if (logCallback !== null && typeof logCallback !== "function") {
        throw ERROR_FACTORY.create("invalid-log-argument");
      }
      logger$1.setUserLogHandler(logCallback, options);
    }
    function useAsService(app3, name2) {
      if (name2 === "serverAuth") {
        return null;
      }
      var useService = name2;
      return useService;
    }
    return namespace;
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function createFirebaseNamespace() {
    var namespace = createFirebaseNamespaceCore(FirebaseAppImpl);
    namespace.INTERNAL = tslib.__assign(tslib.__assign({}, namespace.INTERNAL), {
      createFirebaseNamespace,
      extendNamespace,
      createSubscribe: util.createSubscribe,
      ErrorFactory: util.ErrorFactory,
      deepExtend: util.deepExtend
    });
    function extendNamespace(props) {
      util.deepExtend(namespace, props);
    }
    return namespace;
  }
  var firebase2 = createFirebaseNamespace();
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var PlatformLoggerService = function() {
    function PlatformLoggerService2(container) {
      this.container = container;
    }
    PlatformLoggerService2.prototype.getPlatformInfoString = function() {
      var providers = this.container.getProviders();
      return providers.map(function(provider) {
        if (isVersionServiceProvider(provider)) {
          var service = provider.getImmediate();
          return service.library + "/" + service.version;
        } else {
          return null;
        }
      }).filter(function(logString) {
        return logString;
      }).join(" ");
    };
    return PlatformLoggerService2;
  }();
  function isVersionServiceProvider(provider) {
    var component2 = provider.getComponent();
    return (component2 === null || component2 === void 0 ? void 0 : component2.type) === "VERSION";
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function registerCoreComponents(firebase3, variant) {
    firebase3.INTERNAL.registerComponent(new component.Component("platform-logger", function(container) {
      return new PlatformLoggerService(container);
    }, "PRIVATE"));
    firebase3.registerVersion(name, version, variant);
    firebase3.registerVersion("fire-js", "");
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  firebase2.INTERNAL.extendNamespace({
    INTERNAL: {
      node: {
        localStorage: new Storage__default["default"](null, {strict: true}),
        sessionStorage: new Storage__default["default"](null, {strict: true}),
        XMLHttpRequest: xmlhttprequest.XMLHttpRequest
      }
    }
  });
  var firebase$1 = firebase2;
  registerCoreComponents(firebase$1, "node");
  exports2.default = firebase$1;
  exports2.firebase = firebase$1;
});

// node_modules/firebase/app/dist/index.cjs.js
var require_index_cjs3 = __commonJS((exports2, module2) => {
  "use strict";
  var firebase2 = require_index_node_cjs2();
  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : {default: e};
  }
  var firebase__default = /* @__PURE__ */ _interopDefaultLegacy(firebase2);
  var name = "firebase";
  var version = "8.3.3";
  /**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  firebase__default["default"].registerVersion(name, version, "app");
  module2.exports = firebase__default["default"];
});

// node_modules/semver/semver.js
var require_semver = __commonJS((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports2.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = exports2.re = [];
  var src = exports2.src = [];
  var t = exports2.tokens = {};
  var R = 0;
  function tok(n) {
    t[n] = R++;
  }
  tok("NUMERICIDENTIFIER");
  src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+";
  tok("NONNUMERICIDENTIFIER");
  src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  tok("MAINVERSION");
  src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
  tok("BUILD");
  src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
  src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
  tok("LOOSE");
  src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGEPLAINLOOSE");
  src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
  tok("XRANGE");
  src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
  tok("COERCERTL");
  re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
  tok("LONETILDE");
  src[t.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
  re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
  re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
  re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
  tok("STAR");
  src[t.STAR] = "(<|>)?=?\\s*\\*";
  for (var i = 0; i < R; i++) {
    debug(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  exports2.parse = parse;
  function parse(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[t.LOOSE] : re[t.FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports2.valid = valid;
  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }
  exports2.clean = clean;
  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
  }
  exports2.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
    if (!m) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.compareBuild = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i2 = 0;
    do {
      var a = this.build[i2];
      var b = other.build[i2];
      debug("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports2.inc = inc;
  function inc(version, release, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports2.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  }
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports2.compareBuild = compareBuild;
  function compareBuild(a, b, loose) {
    var versionA = new SemVer(a, loose);
    var versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  }
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports2.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compareBuild(a, b, loose);
    });
  }
  exports2.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a, b) {
      return exports2.compareBuild(b, a, loose);
    });
  }
  exports2.gt = gt;
  function gt(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports2.neq = neq;
  function neq(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case "===":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a === b;
      case "!==":
        if (typeof a === "object")
          a = a.version;
        if (typeof b === "object")
          b = b.version;
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m[1] !== void 0 ? m[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug("Comparator.test", version, this.options.loose);
    if (this.semver === ANY || version === ANY) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports2.Range = Range;
  function Range(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c) {
      return c.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + range);
    }
    this.format();
  }
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, re[t.COMPARATORTRIM]);
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    var set = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  function isSatisfiable(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  }
  exports2.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c) {
        return c.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("tilde", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug("caret", comp, options);
    var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    return comp.replace(r, function(_, M, m, p, pr) {
      debug("caret", comp, _, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
      } else if (isX(p)) {
        if (M === "0") {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m === "0") {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
      debug("xRange", comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + "." + m + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
      }
      debug("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set, version, options) {
    for (var i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set.length; i2++) {
        debug(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports2.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function(v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports2.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports2.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports2.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  exports2.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  exports2.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports2.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports2.coerce = coerce;
  function coerce(version, options) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    var match = null;
    if (!options.rtl) {
      match = version.match(re[t.COERCE]);
    } else {
      var next;
      while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      re[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
  }
});

// node_modules/@grpc/grpc-js/build/src/constants.js
var require_constants = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports2.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports2.Propagate = exports2.LogVerbosity = exports2.Status = void 0;
  var Status;
  (function(Status2) {
    Status2[Status2["OK"] = 0] = "OK";
    Status2[Status2["CANCELLED"] = 1] = "CANCELLED";
    Status2[Status2["UNKNOWN"] = 2] = "UNKNOWN";
    Status2[Status2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    Status2[Status2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    Status2[Status2["NOT_FOUND"] = 5] = "NOT_FOUND";
    Status2[Status2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    Status2[Status2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    Status2[Status2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    Status2[Status2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    Status2[Status2["ABORTED"] = 10] = "ABORTED";
    Status2[Status2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    Status2[Status2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    Status2[Status2["INTERNAL"] = 13] = "INTERNAL";
    Status2[Status2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    Status2[Status2["DATA_LOSS"] = 15] = "DATA_LOSS";
    Status2[Status2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
  })(Status = exports2.Status || (exports2.Status = {}));
  var LogVerbosity;
  (function(LogVerbosity2) {
    LogVerbosity2[LogVerbosity2["DEBUG"] = 0] = "DEBUG";
    LogVerbosity2[LogVerbosity2["INFO"] = 1] = "INFO";
    LogVerbosity2[LogVerbosity2["ERROR"] = 2] = "ERROR";
  })(LogVerbosity = exports2.LogVerbosity || (exports2.LogVerbosity = {}));
  var Propagate;
  (function(Propagate2) {
    Propagate2[Propagate2["DEADLINE"] = 1] = "DEADLINE";
    Propagate2[Propagate2["CENSUS_STATS_CONTEXT"] = 2] = "CENSUS_STATS_CONTEXT";
    Propagate2[Propagate2["CENSUS_TRACING_CONTEXT"] = 4] = "CENSUS_TRACING_CONTEXT";
    Propagate2[Propagate2["CANCELLATION"] = 8] = "CANCELLATION";
    Propagate2[Propagate2["DEFAULTS"] = 65535] = "DEFAULTS";
  })(Propagate = exports2.Propagate || (exports2.Propagate = {}));
  exports2.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;
  exports2.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;
});

// node_modules/@grpc/grpc-js/build/src/logging.js
var require_logging = __commonJS((exports2) => {
  "use strict";
  var _a;
  var _b;
  var _c;
  var _d;
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.trace = exports2.log = exports2.setLoggerVerbosity = exports2.setLogger = exports2.getLogger = void 0;
  var constants_1 = require_constants();
  var _logger = console;
  var _logVerbosity = constants_1.LogVerbosity.ERROR;
  var verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : "";
  switch (verbosityString) {
    case "DEBUG":
      _logVerbosity = constants_1.LogVerbosity.DEBUG;
      break;
    case "INFO":
      _logVerbosity = constants_1.LogVerbosity.INFO;
      break;
    case "ERROR":
      _logVerbosity = constants_1.LogVerbosity.ERROR;
      break;
    default:
  }
  exports2.getLogger = () => {
    return _logger;
  };
  exports2.setLogger = (logger) => {
    _logger = logger;
  };
  exports2.setLoggerVerbosity = (verbosity) => {
    _logVerbosity = verbosity;
  };
  exports2.log = (severity, ...args) => {
    if (severity >= _logVerbosity && typeof _logger.error === "function") {
      _logger.error(...args);
    }
  };
  var tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : "";
  var enabledTracers = tracersString.split(",");
  var allEnabled = enabledTracers.includes("all");
  function trace(severity, tracer, text) {
    if (allEnabled || enabledTracers.includes(tracer)) {
      exports2.log(severity, new Date().toISOString() + " | " + tracer + " | " + text);
    }
  }
  exports2.trace = trace;
});

// node_modules/@grpc/grpc-js/build/src/metadata.js
var require_metadata = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Metadata = void 0;
  var logging_1 = require_logging();
  var constants_1 = require_constants();
  var LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;
  var LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;
  function isLegalKey(key) {
    return LEGAL_KEY_REGEX.test(key);
  }
  function isLegalNonBinaryValue(value) {
    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);
  }
  function isBinaryKey(key) {
    return key.endsWith("-bin");
  }
  function isCustomMetadata(key) {
    return !key.startsWith("grpc-");
  }
  function normalizeKey(key) {
    return key.toLowerCase();
  }
  function validate(key, value) {
    if (!isLegalKey(key)) {
      throw new Error('Metadata key "' + key + '" contains illegal characters');
    }
    if (value !== null && value !== void 0) {
      if (isBinaryKey(key)) {
        if (!(value instanceof Buffer)) {
          throw new Error("keys that end with '-bin' must have Buffer values");
        }
      } else {
        if (value instanceof Buffer) {
          throw new Error("keys that don't end with '-bin' must have String values");
        }
        if (!isLegalNonBinaryValue(value)) {
          throw new Error('Metadata string value "' + value + '" contains illegal characters');
        }
      }
    }
  }
  var Metadata = class {
    constructor(options) {
      this.internalRepr = new Map();
      if (options === void 0) {
        this.options = {};
      } else {
        this.options = options;
      }
    }
    set(key, value) {
      key = normalizeKey(key);
      validate(key, value);
      this.internalRepr.set(key, [value]);
    }
    add(key, value) {
      key = normalizeKey(key);
      validate(key, value);
      const existingValue = this.internalRepr.get(key);
      if (existingValue === void 0) {
        this.internalRepr.set(key, [value]);
      } else {
        existingValue.push(value);
      }
    }
    remove(key) {
      key = normalizeKey(key);
      validate(key);
      this.internalRepr.delete(key);
    }
    get(key) {
      key = normalizeKey(key);
      validate(key);
      return this.internalRepr.get(key) || [];
    }
    getMap() {
      const result = {};
      this.internalRepr.forEach((values, key) => {
        if (values.length > 0) {
          const v = values[0];
          result[key] = v instanceof Buffer ? v.slice() : v;
        }
      });
      return result;
    }
    clone() {
      const newMetadata = new Metadata(this.options);
      const newInternalRepr = newMetadata.internalRepr;
      this.internalRepr.forEach((value, key) => {
        const clonedValue = value.map((v) => {
          if (v instanceof Buffer) {
            return Buffer.from(v);
          } else {
            return v;
          }
        });
        newInternalRepr.set(key, clonedValue);
      });
      return newMetadata;
    }
    merge(other) {
      other.internalRepr.forEach((values, key) => {
        const mergedValue = (this.internalRepr.get(key) || []).concat(values);
        this.internalRepr.set(key, mergedValue);
      });
    }
    setOptions(options) {
      this.options = options;
    }
    getOptions() {
      return this.options;
    }
    toHttp2Headers() {
      const result = {};
      this.internalRepr.forEach((values, key) => {
        result[key] = values.map((value) => {
          if (value instanceof Buffer) {
            return value.toString("base64");
          } else {
            return value;
          }
        });
      });
      return result;
    }
    _getCoreRepresentation() {
      return this.internalRepr;
    }
    static fromHttp2Headers(headers) {
      const result = new Metadata();
      Object.keys(headers).forEach((key) => {
        if (key.charAt(0) === ":") {
          return;
        }
        const values = headers[key];
        try {
          if (isBinaryKey(key)) {
            if (Array.isArray(values)) {
              values.forEach((value) => {
                result.add(key, Buffer.from(value, "base64"));
              });
            } else if (values !== void 0) {
              if (isCustomMetadata(key)) {
                values.split(",").forEach((v) => {
                  result.add(key, Buffer.from(v.trim(), "base64"));
                });
              } else {
                result.add(key, Buffer.from(values, "base64"));
              }
            }
          } else {
            if (Array.isArray(values)) {
              values.forEach((value) => {
                result.add(key, value);
              });
            } else if (values !== void 0) {
              result.add(key, values);
            }
          }
        } catch (error) {
          const message = `Failed to add metadata entry ${key}: ${values}. ${error.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;
          logging_1.log(constants_1.LogVerbosity.ERROR, message);
        }
      });
      return result;
    }
  };
  exports2.Metadata = Metadata;
});

// node_modules/@grpc/grpc-js/build/src/call-credentials.js
var require_call_credentials = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.CallCredentials = void 0;
  var metadata_1 = require_metadata();
  function isCurrentOauth2Client(client) {
    return "getRequestHeaders" in client && typeof client.getRequestHeaders === "function";
  }
  var CallCredentials = class {
    static createFromMetadataGenerator(metadataGenerator) {
      return new SingleCallCredentials(metadataGenerator);
    }
    static createFromGoogleCredential(googleCredentials) {
      return CallCredentials.createFromMetadataGenerator((options, callback) => {
        let getHeaders;
        if (isCurrentOauth2Client(googleCredentials)) {
          getHeaders = googleCredentials.getRequestHeaders(options.service_url);
        } else {
          getHeaders = new Promise((resolve, reject) => {
            googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {
              if (err) {
                reject(err);
                return;
              }
              resolve(headers);
            });
          });
        }
        getHeaders.then((headers) => {
          const metadata = new metadata_1.Metadata();
          for (const key of Object.keys(headers)) {
            metadata.add(key, headers[key]);
          }
          callback(null, metadata);
        }, (err) => {
          callback(err);
        });
      });
    }
    static createEmpty() {
      return new EmptyCallCredentials();
    }
  };
  exports2.CallCredentials = CallCredentials;
  var ComposedCallCredentials = class extends CallCredentials {
    constructor(creds) {
      super();
      this.creds = creds;
    }
    async generateMetadata(options) {
      const base = new metadata_1.Metadata();
      const generated = await Promise.all(this.creds.map((cred) => cred.generateMetadata(options)));
      for (const gen of generated) {
        base.merge(gen);
      }
      return base;
    }
    compose(other) {
      return new ComposedCallCredentials(this.creds.concat([other]));
    }
    _equals(other) {
      if (this === other) {
        return true;
      }
      if (other instanceof ComposedCallCredentials) {
        return this.creds.every((value, index) => value._equals(other.creds[index]));
      } else {
        return false;
      }
    }
  };
  var SingleCallCredentials = class extends CallCredentials {
    constructor(metadataGenerator) {
      super();
      this.metadataGenerator = metadataGenerator;
    }
    generateMetadata(options) {
      return new Promise((resolve, reject) => {
        this.metadataGenerator(options, (err, metadata) => {
          if (metadata !== void 0) {
            resolve(metadata);
          } else {
            reject(err);
          }
        });
      });
    }
    compose(other) {
      return new ComposedCallCredentials([this, other]);
    }
    _equals(other) {
      if (this === other) {
        return true;
      }
      if (other instanceof SingleCallCredentials) {
        return this.metadataGenerator === other.metadataGenerator;
      } else {
        return false;
      }
    }
  };
  var EmptyCallCredentials = class extends CallCredentials {
    generateMetadata(options) {
      return Promise.resolve(new metadata_1.Metadata());
    }
    compose(other) {
      return other;
    }
    _equals(other) {
      return other instanceof EmptyCallCredentials;
    }
  };
});

// node_modules/@grpc/grpc-js/build/src/filter-stack.js
var require_filter_stack = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.FilterStackFactory = exports2.FilterStack = void 0;
  var FilterStack = class {
    constructor(filters) {
      this.filters = filters;
    }
    sendMetadata(metadata) {
      let result = metadata;
      for (let i = 0; i < this.filters.length; i++) {
        result = this.filters[i].sendMetadata(result);
      }
      return result;
    }
    receiveMetadata(metadata) {
      let result = metadata;
      for (let i = this.filters.length - 1; i >= 0; i--) {
        result = this.filters[i].receiveMetadata(result);
      }
      return result;
    }
    sendMessage(message) {
      let result = message;
      for (let i = 0; i < this.filters.length; i++) {
        result = this.filters[i].sendMessage(result);
      }
      return result;
    }
    receiveMessage(message) {
      let result = message;
      for (let i = this.filters.length - 1; i >= 0; i--) {
        result = this.filters[i].receiveMessage(result);
      }
      return result;
    }
    receiveTrailers(status) {
      let result = status;
      for (let i = this.filters.length - 1; i >= 0; i--) {
        result = this.filters[i].receiveTrailers(result);
      }
      return result;
    }
  };
  exports2.FilterStack = FilterStack;
  var FilterStackFactory = class {
    constructor(factories) {
      this.factories = factories;
    }
    createFilter(callStream) {
      return new FilterStack(this.factories.map((factory) => factory.createFilter(callStream)));
    }
  };
  exports2.FilterStackFactory = FilterStackFactory;
});

// node_modules/@grpc/grpc-js/build/src/stream-decoder.js
var require_stream_decoder = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.StreamDecoder = void 0;
  var ReadState;
  (function(ReadState2) {
    ReadState2[ReadState2["NO_DATA"] = 0] = "NO_DATA";
    ReadState2[ReadState2["READING_SIZE"] = 1] = "READING_SIZE";
    ReadState2[ReadState2["READING_MESSAGE"] = 2] = "READING_MESSAGE";
  })(ReadState || (ReadState = {}));
  var StreamDecoder = class {
    constructor() {
      this.readState = ReadState.NO_DATA;
      this.readCompressFlag = Buffer.alloc(1);
      this.readPartialSize = Buffer.alloc(4);
      this.readSizeRemaining = 4;
      this.readMessageSize = 0;
      this.readPartialMessage = [];
      this.readMessageRemaining = 0;
    }
    write(data) {
      let readHead = 0;
      let toRead;
      const result = [];
      while (readHead < data.length) {
        switch (this.readState) {
          case ReadState.NO_DATA:
            this.readCompressFlag = data.slice(readHead, readHead + 1);
            readHead += 1;
            this.readState = ReadState.READING_SIZE;
            this.readPartialSize.fill(0);
            this.readSizeRemaining = 4;
            this.readMessageSize = 0;
            this.readMessageRemaining = 0;
            this.readPartialMessage = [];
            break;
          case ReadState.READING_SIZE:
            toRead = Math.min(data.length - readHead, this.readSizeRemaining);
            data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);
            this.readSizeRemaining -= toRead;
            readHead += toRead;
            if (this.readSizeRemaining === 0) {
              this.readMessageSize = this.readPartialSize.readUInt32BE(0);
              this.readMessageRemaining = this.readMessageSize;
              if (this.readMessageRemaining > 0) {
                this.readState = ReadState.READING_MESSAGE;
              } else {
                const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);
                this.readState = ReadState.NO_DATA;
                result.push(message);
              }
            }
            break;
          case ReadState.READING_MESSAGE:
            toRead = Math.min(data.length - readHead, this.readMessageRemaining);
            this.readPartialMessage.push(data.slice(readHead, readHead + toRead));
            this.readMessageRemaining -= toRead;
            readHead += toRead;
            if (this.readMessageRemaining === 0) {
              const framedMessageBuffers = [
                this.readCompressFlag,
                this.readPartialSize
              ].concat(this.readPartialMessage);
              const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);
              this.readState = ReadState.NO_DATA;
              result.push(framedMessage);
            }
            break;
          default:
            throw new Error("Unexpected read state");
        }
      }
      return result;
    }
  };
  exports2.StreamDecoder = StreamDecoder;
});

// node_modules/@grpc/grpc-js/build/src/call-stream.js
var require_call_stream = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Http2CallStream = exports2.InterceptingListenerImpl = exports2.isInterceptingListener = void 0;
  var http2 = require("http2");
  var os = require("os");
  var constants_1 = require_constants();
  var filter_stack_1 = require_filter_stack();
  var metadata_1 = require_metadata();
  var stream_decoder_1 = require_stream_decoder();
  var logging = require_logging();
  var constants_2 = require_constants();
  var TRACER_NAME = "call_stream";
  var {HTTP2_HEADER_STATUS, HTTP2_HEADER_CONTENT_TYPE, NGHTTP2_CANCEL} = http2.constants;
  function getSystemErrorName(errno) {
    for (const [name, num] of Object.entries(os.constants.errno)) {
      if (num === errno) {
        return name;
      }
    }
    return "Unknown system error " + errno;
  }
  function isInterceptingListener(listener) {
    return listener.onReceiveMetadata !== void 0 && listener.onReceiveMetadata.length === 1;
  }
  exports2.isInterceptingListener = isInterceptingListener;
  var InterceptingListenerImpl = class {
    constructor(listener, nextListener) {
      this.listener = listener;
      this.nextListener = nextListener;
      this.processingMessage = false;
      this.pendingStatus = null;
    }
    onReceiveMetadata(metadata) {
      this.listener.onReceiveMetadata(metadata, (metadata2) => {
        this.nextListener.onReceiveMetadata(metadata2);
      });
    }
    onReceiveMessage(message) {
      this.processingMessage = true;
      this.listener.onReceiveMessage(message, (msg) => {
        this.processingMessage = false;
        this.nextListener.onReceiveMessage(msg);
        if (this.pendingStatus) {
          this.nextListener.onReceiveStatus(this.pendingStatus);
        }
      });
    }
    onReceiveStatus(status) {
      this.listener.onReceiveStatus(status, (processedStatus) => {
        if (this.processingMessage) {
          this.pendingStatus = processedStatus;
        } else {
          this.nextListener.onReceiveStatus(processedStatus);
        }
      });
    }
  };
  exports2.InterceptingListenerImpl = InterceptingListenerImpl;
  var Http2CallStream = class {
    constructor(methodName, channel, options, filterStackFactory, channelCallCredentials, callNumber) {
      this.methodName = methodName;
      this.channel = channel;
      this.options = options;
      this.channelCallCredentials = channelCallCredentials;
      this.callNumber = callNumber;
      this.http2Stream = null;
      this.pendingRead = false;
      this.isWriteFilterPending = false;
      this.pendingWrite = null;
      this.pendingWriteCallback = null;
      this.writesClosed = false;
      this.decoder = new stream_decoder_1.StreamDecoder();
      this.isReadFilterPending = false;
      this.canPush = false;
      this.readsClosed = false;
      this.statusOutput = false;
      this.unpushedReadMessages = [];
      this.unfilteredReadMessages = [];
      this.mappedStatusCode = constants_1.Status.UNKNOWN;
      this.finalStatus = null;
      this.subchannel = null;
      this.listener = null;
      this.internalError = null;
      this.filterStack = filterStackFactory.createFilter(this);
      this.credentials = channelCallCredentials;
      this.disconnectListener = () => {
        this.endCall({
          code: constants_1.Status.UNAVAILABLE,
          details: "Connection dropped",
          metadata: new metadata_1.Metadata()
        });
      };
      if (this.options.parentCall && this.options.flags & constants_1.Propagate.CANCELLATION) {
        this.options.parentCall.on("cancelled", () => {
          this.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled by parent call");
        });
      }
    }
    outputStatus() {
      if (!this.statusOutput) {
        this.statusOutput = true;
        const filteredStatus = this.filterStack.receiveTrailers(this.finalStatus);
        process.nextTick(() => {
          var _a;
          (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);
        });
        if (this.subchannel) {
          this.subchannel.callUnref();
          this.subchannel.removeDisconnectListener(this.disconnectListener);
        }
      }
    }
    trace(text) {
      logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callNumber + "] " + text);
    }
    endCall(status) {
      if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {
        this.trace("ended with status: code=" + status.code + ' details="' + status.details + '"');
        this.finalStatus = status;
        this.maybeOutputStatus();
      }
      this.destroyHttp2Stream();
    }
    maybeOutputStatus() {
      if (this.finalStatus !== null) {
        if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && this.unfilteredReadMessages.length === 0 && !this.isReadFilterPending) {
          this.outputStatus();
        }
      }
    }
    push(message) {
      this.trace("pushing to reader message of length " + (message instanceof Buffer ? message.length : null));
      this.canPush = false;
      process.nextTick(() => {
        var _a;
        if (this.statusOutput) {
          return;
        }
        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMessage(message);
        this.maybeOutputStatus();
      });
    }
    handleFilterError(error) {
      this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);
    }
    handleFilteredRead(message) {
      if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
        this.maybeOutputStatus();
        return;
      }
      this.isReadFilterPending = false;
      if (this.canPush) {
        this.http2Stream.pause();
        this.push(message);
      } else {
        this.trace("unpushedReadMessages.push message of length " + message.length);
        this.unpushedReadMessages.push(message);
      }
      if (this.unfilteredReadMessages.length > 0) {
        const nextMessage = this.unfilteredReadMessages.shift();
        this.filterReceivedMessage(nextMessage);
      }
    }
    filterReceivedMessage(framedMessage) {
      if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
        this.maybeOutputStatus();
        return;
      }
      this.trace("filterReceivedMessage of length " + framedMessage.length);
      this.isReadFilterPending = true;
      this.filterStack.receiveMessage(Promise.resolve(framedMessage)).then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));
    }
    tryPush(messageBytes) {
      if (this.isReadFilterPending) {
        this.trace("unfilteredReadMessages.push message of length " + (messageBytes && messageBytes.length));
        this.unfilteredReadMessages.push(messageBytes);
      } else {
        this.filterReceivedMessage(messageBytes);
      }
    }
    handleTrailers(headers) {
      let headersString = "";
      for (const header of Object.keys(headers)) {
        headersString += "		" + header + ": " + headers[header] + "\n";
      }
      this.trace("Received server trailers:\n" + headersString);
      let metadata;
      try {
        metadata = metadata_1.Metadata.fromHttp2Headers(headers);
      } catch (e) {
        metadata = new metadata_1.Metadata();
      }
      const metadataMap = metadata.getMap();
      let code = this.mappedStatusCode;
      if (code === constants_1.Status.UNKNOWN && typeof metadataMap["grpc-status"] === "string") {
        const receivedStatus = Number(metadataMap["grpc-status"]);
        if (receivedStatus in constants_1.Status) {
          code = receivedStatus;
          this.trace("received status code " + receivedStatus + " from server");
        }
        metadata.remove("grpc-status");
      }
      let details = "";
      if (typeof metadataMap["grpc-message"] === "string") {
        details = decodeURI(metadataMap["grpc-message"]);
        metadata.remove("grpc-message");
        this.trace('received status details string "' + details + '" from server');
      }
      const status = {code, details, metadata};
      this.endCall(status);
    }
    attachHttp2Stream(stream, subchannel, extraFilterFactory) {
      if (extraFilterFactory !== void 0) {
        this.filterStack = new filter_stack_1.FilterStack([
          this.filterStack,
          extraFilterFactory.createFilter(this)
        ]);
      }
      if (this.finalStatus !== null) {
        stream.close(NGHTTP2_CANCEL);
      } else {
        this.trace("attachHttp2Stream from subchannel " + subchannel.getAddress());
        this.http2Stream = stream;
        this.subchannel = subchannel;
        subchannel.addDisconnectListener(this.disconnectListener);
        subchannel.callRef();
        stream.on("response", (headers, flags) => {
          var _a;
          let headersString = "";
          for (const header of Object.keys(headers)) {
            headersString += "		" + header + ": " + headers[header] + "\n";
          }
          this.trace("Received server headers:\n" + headersString);
          switch (headers[":status"]) {
            case 400:
              this.mappedStatusCode = constants_1.Status.INTERNAL;
              break;
            case 401:
              this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;
              break;
            case 403:
              this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;
              break;
            case 404:
              this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;
              break;
            case 429:
            case 502:
            case 503:
            case 504:
              this.mappedStatusCode = constants_1.Status.UNAVAILABLE;
              break;
            default:
              this.mappedStatusCode = constants_1.Status.UNKNOWN;
          }
          if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {
            this.handleTrailers(headers);
          } else {
            let metadata;
            try {
              metadata = metadata_1.Metadata.fromHttp2Headers(headers);
            } catch (error) {
              this.endCall({
                code: constants_1.Status.UNKNOWN,
                details: error.message,
                metadata: new metadata_1.Metadata()
              });
              return;
            }
            try {
              const finalMetadata = this.filterStack.receiveMetadata(metadata);
              (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMetadata(finalMetadata);
            } catch (error) {
              this.endCall({
                code: constants_1.Status.UNKNOWN,
                details: error.message,
                metadata: new metadata_1.Metadata()
              });
            }
          }
        });
        stream.on("trailers", this.handleTrailers.bind(this));
        stream.on("data", (data) => {
          this.trace("receive HTTP/2 data frame of length " + data.length);
          const messages = this.decoder.write(data);
          for (const message of messages) {
            this.trace("parsed message of length " + message.length);
            this.tryPush(message);
          }
        });
        stream.on("end", () => {
          this.readsClosed = true;
          this.maybeOutputStatus();
        });
        stream.on("close", () => {
          process.nextTick(() => {
            var _a;
            this.trace("HTTP/2 stream closed with code " + stream.rstCode);
            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {
              return;
            }
            let code;
            let details = "";
            switch (stream.rstCode) {
              case http2.constants.NGHTTP2_NO_ERROR:
                if (this.finalStatus !== null) {
                  return;
                }
                code = constants_1.Status.INTERNAL;
                details = `Received RST_STREAM with code ${stream.rstCode}`;
                break;
              case http2.constants.NGHTTP2_REFUSED_STREAM:
                code = constants_1.Status.UNAVAILABLE;
                details = "Stream refused by server";
                break;
              case http2.constants.NGHTTP2_CANCEL:
                code = constants_1.Status.CANCELLED;
                details = "Call cancelled";
                break;
              case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:
                code = constants_1.Status.RESOURCE_EXHAUSTED;
                details = "Bandwidth exhausted";
                break;
              case http2.constants.NGHTTP2_INADEQUATE_SECURITY:
                code = constants_1.Status.PERMISSION_DENIED;
                details = "Protocol not secure enough";
                break;
              case http2.constants.NGHTTP2_INTERNAL_ERROR:
                code = constants_1.Status.INTERNAL;
                if (this.internalError === null) {
                  details = `Received RST_STREAM with code ${stream.rstCode} (Internal server error)`;
                } else {
                  if (this.internalError.errno === os.constants.errno.ECONNRESET) {
                    code = constants_1.Status.UNAVAILABLE;
                    details = this.internalError.message;
                  } else {
                    details = `Received RST_STREAM with code ${stream.rstCode} triggered by internal client error: ${this.internalError.message}`;
                  }
                }
                break;
              default:
                code = constants_1.Status.INTERNAL;
                details = `Received RST_STREAM with code ${stream.rstCode}`;
            }
            this.endCall({code, details, metadata: new metadata_1.Metadata()});
          });
        });
        stream.on("error", (err) => {
          if (err.code !== "ERR_HTTP2_STREAM_ERROR") {
            this.trace("Node error event: message=" + err.message + " code=" + err.code + " errno=" + getSystemErrorName(err.errno) + " syscall=" + err.syscall);
            this.internalError = err;
          }
        });
        if (!this.pendingRead) {
          stream.pause();
        }
        if (this.pendingWrite) {
          if (!this.pendingWriteCallback) {
            throw new Error("Invalid state in write handling code");
          }
          this.trace("sending data chunk of length " + this.pendingWrite.length + " (deferred)");
          stream.write(this.pendingWrite, this.pendingWriteCallback);
        }
        this.maybeCloseWrites();
      }
    }
    start(metadata, listener) {
      this.trace("Sending metadata");
      this.listener = listener;
      this.channel._startCallStream(this, metadata);
    }
    destroyHttp2Stream() {
      var _a;
      if (this.http2Stream !== null && !this.http2Stream.destroyed) {
        let code;
        if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {
          code = http2.constants.NGHTTP2_NO_ERROR;
        } else {
          code = http2.constants.NGHTTP2_CANCEL;
        }
        this.trace("close http2 stream with code " + code);
        this.http2Stream.close(code);
      }
    }
    cancelWithStatus(status, details) {
      this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
      this.endCall({code: status, details, metadata: new metadata_1.Metadata()});
    }
    getDeadline() {
      if (this.options.parentCall && this.options.flags & constants_1.Propagate.DEADLINE) {
        const parentDeadline = this.options.parentCall.getDeadline();
        const selfDeadline = this.options.deadline;
        const parentDeadlineMsecs = parentDeadline instanceof Date ? parentDeadline.getTime() : parentDeadline;
        const selfDeadlineMsecs = selfDeadline instanceof Date ? selfDeadline.getTime() : selfDeadline;
        return Math.min(parentDeadlineMsecs, selfDeadlineMsecs);
      } else {
        return this.options.deadline;
      }
    }
    getCredentials() {
      return this.credentials;
    }
    setCredentials(credentials) {
      this.credentials = this.channelCallCredentials.compose(credentials);
    }
    getStatus() {
      return this.finalStatus;
    }
    getPeer() {
      var _a, _b;
      return (_b = (_a = this.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) !== null && _b !== void 0 ? _b : this.channel.getTarget();
    }
    getMethod() {
      return this.methodName;
    }
    getHost() {
      return this.options.host;
    }
    startRead() {
      if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
        this.readsClosed = true;
        this.maybeOutputStatus();
        return;
      }
      this.canPush = true;
      if (this.http2Stream === null) {
        this.pendingRead = true;
      } else {
        if (this.unpushedReadMessages.length > 0) {
          const nextMessage = this.unpushedReadMessages.shift();
          this.push(nextMessage);
          return;
        }
        this.http2Stream.resume();
      }
    }
    maybeCloseWrites() {
      if (this.writesClosed && !this.isWriteFilterPending && this.http2Stream !== null) {
        this.trace("calling end() on HTTP/2 stream");
        this.http2Stream.end();
      }
    }
    sendMessageWithContext(context, message) {
      var _a;
      this.trace("write() called with message of length " + message.length);
      const writeObj = {
        message,
        flags: context.flags
      };
      const cb = (_a = context.callback) !== null && _a !== void 0 ? _a : () => {
      };
      this.isWriteFilterPending = true;
      this.filterStack.sendMessage(Promise.resolve(writeObj)).then((message2) => {
        this.isWriteFilterPending = false;
        if (this.http2Stream === null) {
          this.trace("deferring writing data chunk of length " + message2.message.length);
          this.pendingWrite = message2.message;
          this.pendingWriteCallback = cb;
        } else {
          this.trace("sending data chunk of length " + message2.message.length);
          this.http2Stream.write(message2.message, cb);
          this.maybeCloseWrites();
        }
      }, this.handleFilterError.bind(this));
    }
    halfClose() {
      this.trace("end() called");
      this.writesClosed = true;
      this.maybeCloseWrites();
    }
  };
  exports2.Http2CallStream = Http2CallStream;
});

// node_modules/@grpc/grpc-js/build/src/tls-helpers.js
var require_tls_helpers = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getDefaultRootsData = exports2.CIPHER_SUITES = void 0;
  var fs = require("fs");
  exports2.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;
  var DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;
  var defaultRootsData = null;
  function getDefaultRootsData() {
    if (DEFAULT_ROOTS_FILE_PATH) {
      if (defaultRootsData === null) {
        defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);
      }
      return defaultRootsData;
    }
    return null;
  }
  exports2.getDefaultRootsData = getDefaultRootsData;
});

// node_modules/extend/index.js
var require_extend = __commonJS((exports2, module2) => {
  "use strict";
  var hasOwn = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var defineProperty = Object.defineProperty;
  var gOPD = Object.getOwnPropertyDescriptor;
  var isArray = function isArray2(arr) {
    if (typeof Array.isArray === "function") {
      return Array.isArray(arr);
    }
    return toStr.call(arr) === "[object Array]";
  };
  var isPlainObject = function isPlainObject2(obj) {
    if (!obj || toStr.call(obj) !== "[object Object]") {
      return false;
    }
    var hasOwnConstructor = hasOwn.call(obj, "constructor");
    var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
      return false;
    }
    var key;
    for (key in obj) {
    }
    return typeof key === "undefined" || hasOwn.call(obj, key);
  };
  var setProperty = function setProperty2(target, options) {
    if (defineProperty && options.name === "__proto__") {
      defineProperty(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true
      });
    } else {
      target[options.name] = options.newValue;
    }
  };
  var getProperty = function getProperty2(obj, name) {
    if (name === "__proto__") {
      if (!hasOwn.call(obj, name)) {
        return void 0;
      } else if (gOPD) {
        return gOPD(obj, name).value;
      }
    }
    return obj[name];
  };
  module2.exports = function extend() {
    var options, name, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (target == null || typeof target !== "object" && typeof target !== "function") {
      target = {};
    }
    for (; i < length; ++i) {
      options = arguments[i];
      if (options != null) {
        for (name in options) {
          src = getProperty(target, name);
          copy = getProperty(options, name);
          if (target !== copy) {
            if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray(src) ? src : [];
              } else {
                clone = src && isPlainObject(src) ? src : {};
              }
              setProperty(target, {name, newValue: extend(deep, clone, copy)});
            } else if (typeof copy !== "undefined") {
              setProperty(target, {name, newValue: copy});
            }
          }
        }
      }
    }
    return target;
  };
});

// node_modules/node-fetch/lib/index.js
var require_lib2 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var Stream = _interopDefault(require("stream"));
  var http = _interopDefault(require("http"));
  var Url = _interopDefault(require("url"));
  var https = _interopDefault(require("https"));
  var zlib = _interopDefault(require("zlib"));
  var Readable = Stream.Readable;
  var BUFFER = Symbol("buffer");
  var TYPE = Symbol("type");
  var Blob2 = class {
    constructor() {
      this[TYPE] = "";
      const blobParts = arguments[0];
      const options = arguments[1];
      const buffers = [];
      let size = 0;
      if (blobParts) {
        const a = blobParts;
        const length = Number(a.length);
        for (let i = 0; i < length; i++) {
          const element = a[i];
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob2) {
            buffer = element[BUFFER];
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length;
          buffers.push(buffer);
        }
      }
      this[BUFFER] = Buffer.concat(buffers);
      let type = options && options.type !== void 0 && String(options.type).toLowerCase();
      if (type && !/[^\u0020-\u007E]/.test(type)) {
        this[TYPE] = type;
      }
    }
    get size() {
      return this[BUFFER].length;
    }
    get type() {
      return this[TYPE];
    }
    text() {
      return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
      const buf = this[BUFFER];
      const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      return Promise.resolve(ab);
    }
    stream() {
      const readable = new Readable();
      readable._read = function() {
      };
      readable.push(this[BUFFER]);
      readable.push(null);
      return readable;
    }
    toString() {
      return "[object Blob]";
    }
    slice() {
      const size = this.size;
      const start = arguments[0];
      const end = arguments[1];
      let relativeStart, relativeEnd;
      if (start === void 0) {
        relativeStart = 0;
      } else if (start < 0) {
        relativeStart = Math.max(size + start, 0);
      } else {
        relativeStart = Math.min(start, size);
      }
      if (end === void 0) {
        relativeEnd = size;
      } else if (end < 0) {
        relativeEnd = Math.max(size + end, 0);
      } else {
        relativeEnd = Math.min(end, size);
      }
      const span = Math.max(relativeEnd - relativeStart, 0);
      const buffer = this[BUFFER];
      const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      const blob = new Blob2([], {type: arguments[2]});
      blob[BUFFER] = slicedBuffer;
      return blob;
    }
  };
  Object.defineProperties(Blob2.prototype, {
    size: {enumerable: true},
    type: {enumerable: true},
    slice: {enumerable: true}
  });
  Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
    value: "Blob",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function FetchError(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  }
  FetchError.prototype = Object.create(Error.prototype);
  FetchError.prototype.constructor = FetchError;
  FetchError.prototype.name = "FetchError";
  var convert;
  try {
    convert = require("encoding").convert;
  } catch (e) {
  }
  var INTERNALS = Symbol("Body internals");
  var PassThrough = Stream.PassThrough;
  function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === void 0 ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (isURLSearchParams(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof Stream)
      ;
    else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof Stream) {
      body.on("error", function(err) {
        const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
        _this[INTERNALS].error = error;
      });
    }
  }
  Body.prototype = {
    get body() {
      return this[INTERNALS].body;
    },
    get bodyUsed() {
      return this[INTERNALS].disturbed;
    },
    arrayBuffer() {
      return consumeBody.call(this).then(function(buf) {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      });
    },
    blob() {
      let ct = this.headers && this.headers.get("content-type") || "";
      return consumeBody.call(this).then(function(buf) {
        return Object.assign(new Blob2([], {
          type: ct.toLowerCase()
        }), {
          [BUFFER]: buf
        });
      });
    },
    json() {
      var _this2 = this;
      return consumeBody.call(this).then(function(buffer) {
        try {
          return JSON.parse(buffer.toString());
        } catch (err) {
          return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
        }
      });
    },
    text() {
      return consumeBody.call(this).then(function(buffer) {
        return buffer.toString();
      });
    },
    buffer() {
      return consumeBody.call(this);
    },
    textConverted() {
      var _this3 = this;
      return consumeBody.call(this).then(function(buffer) {
        return convertBody(buffer, _this3.headers);
      });
    }
  };
  Object.defineProperties(Body.prototype, {
    body: {enumerable: true},
    bodyUsed: {enumerable: true},
    arrayBuffer: {enumerable: true},
    blob: {enumerable: true},
    json: {enumerable: true},
    text: {enumerable: true}
  });
  Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)) {
      if (!(name in proto)) {
        const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
        Object.defineProperty(proto, name, desc);
      }
    }
  };
  function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    if (body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (isBlob(body)) {
      body = body.stream();
    }
    if (Buffer.isBuffer(body)) {
      return Body.Promise.resolve(body);
    }
    if (!(body instanceof Stream)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      body.on("error", function(err) {
        if (err.name === "AbortError") {
          abort = true;
          reject(err);
        } else {
          reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
        }
      });
      body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve(Buffer.concat(accum, accumBytes));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      });
    });
  }
  function convertBody(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (!res) {
        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
        if (res) {
          res.pop();
        }
      }
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  }
  function isURLSearchParams(obj) {
    if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
      return false;
    }
    return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
  }
  function isBlob(obj) {
    return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
  }
  function clone(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof Stream && typeof body.getBoundary !== "function") {
      p1 = new PassThrough();
      p2 = new PassThrough();
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  }
  function extractContentType(body) {
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob(body)) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (ArrayBuffer.isView(body)) {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof Stream) {
      return null;
    } else {
      return "text/plain;charset=UTF-8";
    }
  }
  function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (isBlob(body)) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  }
  function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (isBlob(body)) {
      body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else {
      body.pipe(dest);
    }
  }
  Body.Promise = global.Promise;
  var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === "") {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  }
  function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  }
  function find(map, name) {
    name = name.toLowerCase();
    for (const key in map) {
      if (key.toLowerCase() === name) {
        return key;
      }
    }
    return void 0;
  }
  var MAP = Symbol("map");
  var Headers = class {
    constructor() {
      let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      this[MAP] = Object.create(null);
      if (init instanceof Headers) {
        const rawHeaders = init.raw();
        const headerNames = Object.keys(rawHeaders);
        for (const headerName of headerNames) {
          for (const value of rawHeaders[headerName]) {
            this.append(headerName, value);
          }
        }
        return;
      }
      if (init == null)
        ;
      else if (typeof init === "object") {
        const method = init[Symbol.iterator];
        if (method != null) {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }
          const pairs = [];
          for (const pair of init) {
            if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
              throw new TypeError("Each header pair must be iterable");
            }
            pairs.push(Array.from(pair));
          }
          for (const pair of pairs) {
            if (pair.length !== 2) {
              throw new TypeError("Each header pair must be a name/value tuple");
            }
            this.append(pair[0], pair[1]);
          }
        } else {
          for (const key of Object.keys(init)) {
            const value = init[key];
            this.append(key, value);
          }
        }
      } else {
        throw new TypeError("Provided initializer must be an object");
      }
    }
    get(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key === void 0) {
        return null;
      }
      return this[MAP][key].join(", ");
    }
    forEach(callback) {
      let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
      let pairs = getHeaders(this);
      let i = 0;
      while (i < pairs.length) {
        var _pairs$i = pairs[i];
        const name = _pairs$i[0], value = _pairs$i[1];
        callback.call(thisArg, value, name, this);
        pairs = getHeaders(this);
        i++;
      }
    }
    set(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      this[MAP][key !== void 0 ? key : name] = [value];
    }
    append(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      if (key !== void 0) {
        this[MAP][key].push(value);
      } else {
        this[MAP][name] = [value];
      }
    }
    has(name) {
      name = `${name}`;
      validateName(name);
      return find(this[MAP], name) !== void 0;
    }
    delete(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key !== void 0) {
        delete this[MAP][key];
      }
    }
    raw() {
      return this[MAP];
    }
    keys() {
      return createHeadersIterator(this, "key");
    }
    values() {
      return createHeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
      return createHeadersIterator(this, "key+value");
    }
  };
  Headers.prototype.entries = Headers.prototype[Symbol.iterator];
  Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: "Headers",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Headers.prototype, {
    get: {enumerable: true},
    forEach: {enumerable: true},
    set: {enumerable: true},
    append: {enumerable: true},
    has: {enumerable: true},
    delete: {enumerable: true},
    keys: {enumerable: true},
    values: {enumerable: true},
    entries: {enumerable: true}
  });
  function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === "key" ? function(k) {
      return k.toLowerCase();
    } : kind === "value" ? function(k) {
      return headers[MAP][k].join(", ");
    } : function(k) {
      return [k.toLowerCase(), headers[MAP][k].join(", ")];
    });
  }
  var INTERNAL = Symbol("internal");
  function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind,
      index: 0
    };
    return iterator;
  }
  var HeadersIteratorPrototype = Object.setPrototypeOf({
    next() {
      if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
        throw new TypeError("Value of `this` is not a HeadersIterator");
      }
      var _INTERNAL = this[INTERNAL];
      const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
      const values = getHeaders(target, kind);
      const len = values.length;
      if (index >= len) {
        return {
          value: void 0,
          done: true
        };
      }
      this[INTERNAL].index = index + 1;
      return {
        value: values[index],
        done: false
      };
    }
  }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
  Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: "HeadersIterator",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({__proto__: null}, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== void 0) {
      obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
  }
  function createHeadersLenient(obj) {
    const headers = new Headers();
    for (const name of Object.keys(obj)) {
      if (invalidTokenRegex.test(name)) {
        continue;
      }
      if (Array.isArray(obj[name])) {
        for (const val of obj[name]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name] === void 0) {
            headers[MAP][name] = [val];
          } else {
            headers[MAP][name].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj[name])) {
        headers[MAP][name] = [obj[name]];
      }
    }
    return headers;
  }
  var INTERNALS$1 = Symbol("Response internals");
  var STATUS_CODES = http.STATUS_CODES;
  var Response = class {
    constructor() {
      let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      Body.call(this, body, opts);
      const status = opts.status || 200;
      const headers = new Headers(opts.headers);
      if (body != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(body);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      this[INTERNALS$1] = {
        url: opts.url,
        status,
        statusText: opts.statusText || STATUS_CODES[status],
        headers,
        counter: opts.counter
      };
    }
    get url() {
      return this[INTERNALS$1].url || "";
    }
    get status() {
      return this[INTERNALS$1].status;
    }
    get ok() {
      return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
      return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
      return this[INTERNALS$1].statusText;
    }
    get headers() {
      return this[INTERNALS$1].headers;
    }
    clone() {
      return new Response(clone(this), {
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok,
        redirected: this.redirected
      });
    }
  };
  Body.mixIn(Response.prototype);
  Object.defineProperties(Response.prototype, {
    url: {enumerable: true},
    status: {enumerable: true},
    ok: {enumerable: true},
    redirected: {enumerable: true},
    statusText: {enumerable: true},
    headers: {enumerable: true},
    clone: {enumerable: true}
  });
  Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: "Response",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var INTERNALS$2 = Symbol("Request internals");
  var parse_url = Url.parse;
  var format_url = Url.format;
  var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
  function isRequest(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  }
  function isAbortSignal(signal) {
    const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === "AbortSignal");
  }
  var Request = class {
    constructor(input) {
      let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let parsedURL;
      if (!isRequest(input)) {
        if (input && input.href) {
          parsedURL = parse_url(input.href);
        } else {
          parsedURL = parse_url(`${input}`);
        }
        input = {};
      } else {
        parsedURL = parse_url(input.url);
      }
      let method = init.method || input.method || "GET";
      method = method.toUpperCase();
      if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }
      let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
      Body.call(this, inputBody, {
        timeout: init.timeout || input.timeout || 0,
        size: init.size || input.size || 0
      });
      const headers = new Headers(init.headers || input.headers || {});
      if (inputBody != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(inputBody);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      let signal = isRequest(input) ? input.signal : null;
      if ("signal" in init)
        signal = init.signal;
      if (signal != null && !isAbortSignal(signal)) {
        throw new TypeError("Expected signal to be an instanceof AbortSignal");
      }
      this[INTERNALS$2] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL,
        signal
      };
      this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
      this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
    }
    get method() {
      return this[INTERNALS$2].method;
    }
    get url() {
      return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
      return this[INTERNALS$2].headers;
    }
    get redirect() {
      return this[INTERNALS$2].redirect;
    }
    get signal() {
      return this[INTERNALS$2].signal;
    }
    clone() {
      return new Request(this);
    }
  };
  Body.mixIn(Request.prototype);
  Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: "Request",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Request.prototype, {
    method: {enumerable: true},
    url: {enumerable: true},
    headers: {enumerable: true},
    redirect: {enumerable: true},
    clone: {enumerable: true},
    signal: {enumerable: true}
  });
  function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
      throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress && !headers.has("Accept-Encoding")) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    let agent = request.agent;
    if (typeof agent === "function") {
      agent = agent(parsedURL);
    }
    if (!headers.has("Connection") && !agent) {
      headers.set("Connection", "close");
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent
    });
  }
  function AbortError(message) {
    Error.call(this, message);
    this.type = "aborted";
    this.message = message;
    Error.captureStackTrace(this, this.constructor);
  }
  AbortError.prototype = Object.create(Error.prototype);
  AbortError.prototype.constructor = AbortError;
  AbortError.prototype.name = "AbortError";
  var PassThrough$1 = Stream.PassThrough;
  var resolve_url = Url.resolve;
  function fetch(url, opts) {
    if (!fetch.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch.Promise;
    return new fetch.Promise(function(resolve, reject) {
      const request = new Request(url, opts);
      const options = getNodeRequestOptions(request);
      const send = (options.protocol === "https:" ? https : http).request;
      const signal = request.signal;
      let response = null;
      const abort = function abort2() {
        let error = new AbortError("The user aborted a request.");
        reject(error);
        if (request.body && request.body instanceof Stream.Readable) {
          request.body.destroy(error);
        }
        if (!response || !response.body)
          return;
        response.body.emit("error", error);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = function abortAndFinalize2() {
        abort();
        finalize();
      };
      const req = send(options);
      let reqTimeout;
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      function finalize() {
        req.abort();
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req.on("error", function(err) {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        finalize();
      });
      req.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          const locationURL = location === null ? null : resolve_url(request.url, location);
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                try {
                  headers.set("Location", locationURL);
                } catch (err) {
                  reject(err);
                }
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body,
                signal: request.signal,
                timeout: request.timeout,
                size: request.size
              };
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = void 0;
                requestOpts.headers.delete("content-length");
              }
              resolve(fetch(new Request(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        res.once("end", function() {
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
        });
        let body = res.pipe(new PassThrough$1());
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout,
          counter: request.counter
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        const zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(zlib.createGunzip(zlibOptions));
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1());
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(zlib.createInflate());
            } else {
              body = body.pipe(zlib.createInflateRaw());
            }
            response = new Response(body, response_options);
            resolve(response);
          });
          return;
        }
        if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
          body = body.pipe(zlib.createBrotliDecompress());
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        response = new Response(body, response_options);
        resolve(response);
      });
      writeToStream(req, request);
    });
  }
  fetch.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  };
  fetch.Promise = global.Promise;
  module2.exports = exports2 = fetch;
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.default = exports2;
  exports2.Headers = Headers;
  exports2.Request = Request;
  exports2.Response = Response;
  exports2.FetchError = FetchError;
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS((exports2, module2) => {
  "use strict";
  var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
  isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
  isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
  isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
  isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
  module2.exports = isStream;
});

// node_modules/gaxios/build/src/common.js
var require_common = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.GaxiosError = void 0;
  var GaxiosError = class extends Error {
    constructor(message, options, response) {
      super(message);
      this.response = response;
      this.config = options;
      this.code = response.status.toString();
    }
  };
  exports2.GaxiosError = GaxiosError;
});

// node_modules/gaxios/build/src/retry.js
var require_retry = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getRetryConfig = void 0;
  async function getRetryConfig(err) {
    var _a;
    let config = getConfig(err);
    if (!err || !err.config || !config && !err.config.retry) {
      return {shouldRetry: false};
    }
    config = config || {};
    config.currentRetryAttempt = config.currentRetryAttempt || 0;
    config.retry = config.retry === void 0 || config.retry === null ? 3 : config.retry;
    config.httpMethodsToRetry = config.httpMethodsToRetry || [
      "GET",
      "HEAD",
      "PUT",
      "OPTIONS",
      "DELETE"
    ];
    config.noResponseRetries = config.noResponseRetries === void 0 || config.noResponseRetries === null ? 2 : config.noResponseRetries;
    const retryRanges = [
      [100, 199],
      [429, 429],
      [500, 599]
    ];
    config.statusCodesToRetry = config.statusCodesToRetry || retryRanges;
    err.config.retryConfig = config;
    const shouldRetryFn = config.shouldRetry || shouldRetryRequest;
    if (!await shouldRetryFn(err)) {
      return {shouldRetry: false, config: err.config};
    }
    const retryDelay = config.currentRetryAttempt ? 0 : (_a = config.retryDelay) !== null && _a !== void 0 ? _a : 100;
    const delay = retryDelay + (Math.pow(2, config.currentRetryAttempt) - 1) / 2 * 1e3;
    err.config.retryConfig.currentRetryAttempt += 1;
    const backoff = new Promise((resolve) => {
      setTimeout(resolve, delay);
    });
    if (config.onRetryAttempt) {
      config.onRetryAttempt(err);
    }
    await backoff;
    return {shouldRetry: true, config: err.config};
  }
  exports2.getRetryConfig = getRetryConfig;
  function shouldRetryRequest(err) {
    const config = getConfig(err);
    if (err.name === "AbortError") {
      return false;
    }
    if (!config || config.retry === 0) {
      return false;
    }
    if (!err.response && (config.currentRetryAttempt || 0) >= config.noResponseRetries) {
      return false;
    }
    if (!err.config.method || config.httpMethodsToRetry.indexOf(err.config.method.toUpperCase()) < 0) {
      return false;
    }
    if (err.response && err.response.status) {
      let isInRange = false;
      for (const [min, max] of config.statusCodesToRetry) {
        const status = err.response.status;
        if (status >= min && status <= max) {
          isInRange = true;
          break;
        }
      }
      if (!isInRange) {
        return false;
      }
    }
    config.currentRetryAttempt = config.currentRetryAttempt || 0;
    if (config.currentRetryAttempt >= config.retry) {
      return false;
    }
    return true;
  }
  function getConfig(err) {
    if (err && err.config && err.config.retryConfig) {
      return err.config.retryConfig;
    }
    return;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports2, module2) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common2 = __commonJS((exports2, module2) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module2.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports2, module2) => {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = require_common2()(exports2);
  var {formatters} = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports2, module2) => {
  var tty = require("tty");
  var util = require("util");
  exports2.init = init;
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require("supports-color");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.format(...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  module2.exports = require_common2()(exports2);
  var {formatters} = module2.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports2, module2) => {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module2.exports = require_browser();
  } else {
    module2.exports = require_node();
  }
});

// node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function promisify(fn) {
    return function(req, opts) {
      return new Promise((resolve, reject) => {
        fn.call(this, req, opts, (err, rtn) => {
          if (err) {
            reject(err);
          } else {
            resolve(rtn);
          }
        });
      });
    };
  }
  exports2.default = promisify;
});

// node_modules/agent-base/dist/src/index.js
var require_src2 = __commonJS((exports2, module2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  var events_1 = require("events");
  var debug_1 = __importDefault(require_src());
  var promisify_1 = __importDefault(require_promisify());
  var debug = debug_1.default("agent-base");
  function isAgent(v) {
    return Boolean(v) && typeof v.addRequest === "function";
  }
  function isSecureEndpoint() {
    const {stack} = new Error();
    if (typeof stack !== "string")
      return false;
    return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
  }
  function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
  }
  (function(createAgent2) {
    class Agent extends events_1.EventEmitter {
      constructor(callback, _opts) {
        super();
        let opts = _opts;
        if (typeof callback === "function") {
          this.callback = callback;
        } else if (callback) {
          opts = callback;
        }
        this.timeout = null;
        if (opts && typeof opts.timeout === "number") {
          this.timeout = opts.timeout;
        }
        this.maxFreeSockets = 1;
        this.maxSockets = 1;
        this.maxTotalSockets = Infinity;
        this.sockets = {};
        this.freeSockets = {};
        this.requests = {};
        this.options = {};
      }
      get defaultPort() {
        if (typeof this.explicitDefaultPort === "number") {
          return this.explicitDefaultPort;
        }
        return isSecureEndpoint() ? 443 : 80;
      }
      set defaultPort(v) {
        this.explicitDefaultPort = v;
      }
      get protocol() {
        if (typeof this.explicitProtocol === "string") {
          return this.explicitProtocol;
        }
        return isSecureEndpoint() ? "https:" : "http:";
      }
      set protocol(v) {
        this.explicitProtocol = v;
      }
      callback(req, opts, fn) {
        throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
      }
      addRequest(req, _opts) {
        const opts = Object.assign({}, _opts);
        if (typeof opts.secureEndpoint !== "boolean") {
          opts.secureEndpoint = isSecureEndpoint();
        }
        if (opts.host == null) {
          opts.host = "localhost";
        }
        if (opts.port == null) {
          opts.port = opts.secureEndpoint ? 443 : 80;
        }
        if (opts.protocol == null) {
          opts.protocol = opts.secureEndpoint ? "https:" : "http:";
        }
        if (opts.host && opts.path) {
          delete opts.path;
        }
        delete opts.agent;
        delete opts.hostname;
        delete opts._defaultAgent;
        delete opts.defaultPort;
        delete opts.createConnection;
        req._last = true;
        req.shouldKeepAlive = false;
        let timedOut = false;
        let timeoutId = null;
        const timeoutMs = opts.timeout || this.timeout;
        const onerror = (err) => {
          if (req._hadError)
            return;
          req.emit("error", err);
          req._hadError = true;
        };
        const ontimeout = () => {
          timeoutId = null;
          timedOut = true;
          const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
          err.code = "ETIMEOUT";
          onerror(err);
        };
        const callbackError = (err) => {
          if (timedOut)
            return;
          if (timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          onerror(err);
        };
        const onsocket = (socket) => {
          if (timedOut)
            return;
          if (timeoutId != null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          if (isAgent(socket)) {
            debug("Callback returned another Agent instance %o", socket.constructor.name);
            socket.addRequest(req, opts);
            return;
          }
          if (socket) {
            socket.once("free", () => {
              this.freeSocket(socket, opts);
            });
            req.onSocket(socket);
            return;
          }
          const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
          onerror(err);
        };
        if (typeof this.callback !== "function") {
          onerror(new Error("`callback` is not defined"));
          return;
        }
        if (!this.promisifiedCallback) {
          if (this.callback.length >= 3) {
            debug("Converting legacy callback function to promise");
            this.promisifiedCallback = promisify_1.default(this.callback);
          } else {
            this.promisifiedCallback = this.callback;
          }
        }
        if (typeof timeoutMs === "number" && timeoutMs > 0) {
          timeoutId = setTimeout(ontimeout, timeoutMs);
        }
        if ("port" in opts && typeof opts.port !== "number") {
          opts.port = Number(opts.port);
        }
        try {
          debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
          Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
        } catch (err) {
          Promise.reject(err).catch(callbackError);
        }
      }
      freeSocket(socket, opts) {
        debug("Freeing socket %o %o", socket.constructor.name, opts);
        socket.destroy();
      }
      destroy() {
        debug("Destroying agent %o", this.constructor.name);
      }
    }
    createAgent2.Agent = Agent;
    createAgent2.prototype = createAgent2.Agent.prototype;
  })(createAgent || (createAgent = {}));
  module2.exports = createAgent;
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var debug_1 = __importDefault(require_src());
  var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
  function parseProxyResponse(socket) {
    return new Promise((resolve, reject) => {
      let buffersLength = 0;
      const buffers = [];
      function read() {
        const b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      function cleanup() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("close", onclose);
        socket.removeListener("readable", read);
      }
      function onclose(err) {
        debug("onclose had error %o", err);
      }
      function onend() {
        debug("onend");
      }
      function onerror(err) {
        cleanup();
        debug("onerror %o", err);
        reject(err);
      }
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf("\r\n\r\n");
        if (endOfHeaders === -1) {
          debug("have not received end of HTTP headers yet...");
          read();
          return;
        }
        const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
        const statusCode = +firstLine.split(" ")[1];
        debug("got proxy server response: %o", firstLine);
        resolve({
          statusCode,
          buffered
        });
      }
      socket.on("error", onerror);
      socket.on("close", onclose);
      socket.on("end", onend);
      read();
    });
  }
  exports2.default = parseProxyResponse;
});

// node_modules/https-proxy-agent/dist/agent.js
var require_agent = __commonJS((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var net_1 = __importDefault(require("net"));
  var tls_1 = __importDefault(require("tls"));
  var url_1 = __importDefault(require("url"));
  var assert_1 = __importDefault(require("assert"));
  var debug_1 = __importDefault(require_src());
  var agent_base_1 = require_src2();
  var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
  var debug = debug_1.default("https-proxy-agent:agent");
  var HttpsProxyAgent = class extends agent_base_1.Agent {
    constructor(_opts) {
      let opts;
      if (typeof _opts === "string") {
        opts = url_1.default.parse(_opts);
      } else {
        opts = _opts;
      }
      if (!opts) {
        throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
      }
      debug("creating new HttpsProxyAgent instance: %o", opts);
      super(opts);
      const proxy = Object.assign({}, opts);
      this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
      proxy.host = proxy.hostname || proxy.host;
      if (typeof proxy.port === "string") {
        proxy.port = parseInt(proxy.port, 10);
      }
      if (!proxy.port && proxy.host) {
        proxy.port = this.secureProxy ? 443 : 80;
      }
      if (this.secureProxy && !("ALPNProtocols" in proxy)) {
        proxy.ALPNProtocols = ["http 1.1"];
      }
      if (proxy.host && proxy.path) {
        delete proxy.path;
        delete proxy.pathname;
      }
      this.proxy = proxy;
    }
    callback(req, opts) {
      return __awaiter(this, void 0, void 0, function* () {
        const {proxy, secureProxy} = this;
        let socket;
        if (secureProxy) {
          debug("Creating `tls.Socket`: %o", proxy);
          socket = tls_1.default.connect(proxy);
        } else {
          debug("Creating `net.Socket`: %o", proxy);
          socket = net_1.default.connect(proxy);
        }
        const headers = Object.assign({}, proxy.headers);
        const hostname = `${opts.host}:${opts.port}`;
        let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
        if (proxy.auth) {
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
        }
        let {host, port, secureEndpoint} = opts;
        if (!isDefaultPort(port, secureEndpoint)) {
          host += `:${port}`;
        }
        headers.Host = host;
        headers.Connection = "close";
        for (const name of Object.keys(headers)) {
          payload += `${name}: ${headers[name]}\r
`;
        }
        const proxyResponsePromise = parse_proxy_response_1.default(socket);
        socket.write(`${payload}\r
`);
        const {statusCode, buffered} = yield proxyResponsePromise;
        if (statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            const servername = opts.servername || opts.host;
            if (!servername) {
              throw new Error('Could not determine "servername"');
            }
            debug("Upgrading socket connection to TLS");
            return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
              socket,
              servername
            }));
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net_1.default.Socket();
        fakeSocket.readable = true;
        req.once("socket", (s) => {
          debug("replaying proxy buffer for failed request");
          assert_1.default(s.listenerCount("data") > 0);
          s.push(buffered);
          s.push(null);
        });
        return fakeSocket;
      });
    }
  };
  exports2.default = HttpsProxyAgent;
  function resume(socket) {
    socket.resume();
  }
  function isDefaultPort(port, secure) {
    return Boolean(!secure && port === 80 || secure && port === 443);
  }
  function isHTTPS(protocol) {
    return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
  }
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist = __commonJS((exports2, module2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  var agent_1 = __importDefault(require_agent());
  function createHttpsProxyAgent(opts) {
    return new agent_1.default(opts);
  }
  (function(createHttpsProxyAgent2) {
    createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
    createHttpsProxyAgent2.prototype = agent_1.default.prototype;
  })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
  module2.exports = createHttpsProxyAgent;
});

// node_modules/gaxios/build/src/gaxios.js
var require_gaxios = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Gaxios = void 0;
  var extend_1 = __importDefault(require_extend());
  var node_fetch_1 = __importDefault(require_lib2());
  var querystring_1 = __importDefault(require("querystring"));
  var is_stream_1 = __importDefault(require_is_stream());
  var common_1 = require_common();
  var retry_1 = require_retry();
  var fetch = hasFetch() ? window.fetch : node_fetch_1.default;
  function hasWindow() {
    return typeof window !== "undefined" && !!window;
  }
  function hasFetch() {
    return hasWindow() && !!window.fetch;
  }
  function hasBuffer() {
    return typeof Buffer !== "undefined";
  }
  function hasHeader(options, header) {
    return !!getHeader(options, header);
  }
  function getHeader(options, header) {
    header = header.toLowerCase();
    for (const key of Object.keys((options === null || options === void 0 ? void 0 : options.headers) || {})) {
      if (header === key.toLowerCase()) {
        return options.headers[key];
      }
    }
    return void 0;
  }
  var HttpsProxyAgent;
  function loadProxy() {
    const proxy = process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy;
    if (proxy) {
      HttpsProxyAgent = require_dist();
    }
    return proxy;
  }
  loadProxy();
  function skipProxy(url) {
    var _a;
    const noProxyEnv = (_a = process.env.NO_PROXY) !== null && _a !== void 0 ? _a : process.env.no_proxy;
    if (!noProxyEnv) {
      return false;
    }
    const noProxyUrls = noProxyEnv.split(",");
    const parsedURL = new URL(url);
    return !!noProxyUrls.find((url2) => {
      if (url2.startsWith("*.") || url2.startsWith(".")) {
        url2 = url2.replace("*", "");
        return parsedURL.hostname.endsWith(url2);
      } else {
        return url2 === parsedURL.origin || url2 === parsedURL.hostname;
      }
    });
  }
  function getProxy(url) {
    if (skipProxy(url)) {
      return void 0;
    } else {
      return loadProxy();
    }
  }
  var Gaxios = class {
    constructor(defaults) {
      this.agentCache = new Map();
      this.defaults = defaults || {};
    }
    async request(opts = {}) {
      opts = this.validateOpts(opts);
      return this._request(opts);
    }
    async _defaultAdapter(opts) {
      const fetchImpl = opts.fetchImplementation || fetch;
      const res = await fetchImpl(opts.url, opts);
      const data = await this.getResponseData(opts, res);
      return this.translateResponse(opts, res, data);
    }
    async _request(opts = {}) {
      try {
        let translatedResponse;
        if (opts.adapter) {
          translatedResponse = await opts.adapter(opts, this._defaultAdapter.bind(this));
        } else {
          translatedResponse = await this._defaultAdapter(opts);
        }
        if (!opts.validateStatus(translatedResponse.status)) {
          throw new common_1.GaxiosError(`Request failed with status code ${translatedResponse.status}`, opts, translatedResponse);
        }
        return translatedResponse;
      } catch (e) {
        const err = e;
        err.config = opts;
        const {shouldRetry, config} = await retry_1.getRetryConfig(e);
        if (shouldRetry && config) {
          err.config.retryConfig.currentRetryAttempt = config.retryConfig.currentRetryAttempt;
          return this._request(err.config);
        }
        throw err;
      }
    }
    async getResponseData(opts, res) {
      switch (opts.responseType) {
        case "stream":
          return res.body;
        case "json": {
          let data = await res.text();
          try {
            data = JSON.parse(data);
          } catch (_a) {
          }
          return data;
        }
        case "arraybuffer":
          return res.arrayBuffer();
        case "blob":
          return res.blob();
        default:
          return res.text();
      }
    }
    validateOpts(options) {
      const opts = extend_1.default(true, {}, this.defaults, options);
      if (!opts.url) {
        throw new Error("URL is required.");
      }
      const baseUrl = opts.baseUrl || opts.baseURL;
      if (baseUrl) {
        opts.url = baseUrl + opts.url;
      }
      opts.paramsSerializer = opts.paramsSerializer || this.paramsSerializer;
      if (opts.params && Object.keys(opts.params).length > 0) {
        let additionalQueryParams = opts.paramsSerializer(opts.params);
        if (additionalQueryParams.startsWith("?")) {
          additionalQueryParams = additionalQueryParams.slice(1);
        }
        const prefix = opts.url.includes("?") ? "&" : "?";
        opts.url = opts.url + prefix + additionalQueryParams;
      }
      if (typeof options.maxContentLength === "number") {
        opts.size = options.maxContentLength;
      }
      if (typeof options.maxRedirects === "number") {
        opts.follow = options.maxRedirects;
      }
      opts.headers = opts.headers || {};
      if (opts.data) {
        if (is_stream_1.default.readable(opts.data)) {
          opts.body = opts.data;
        } else if (hasBuffer() && Buffer.isBuffer(opts.data)) {
          opts.body = opts.data;
          if (!hasHeader(opts, "Content-Type")) {
            opts.headers["Content-Type"] = "application/json";
          }
        } else if (typeof opts.data === "object") {
          if (getHeader(opts, "content-type") === "application/x-www-form-urlencoded") {
            opts.body = opts.paramsSerializer(opts.data);
          } else {
            if (!hasHeader(opts, "Content-Type")) {
              opts.headers["Content-Type"] = "application/json";
            }
            opts.body = JSON.stringify(opts.data);
          }
        } else {
          opts.body = opts.data;
        }
      }
      opts.validateStatus = opts.validateStatus || this.validateStatus;
      opts.responseType = opts.responseType || "json";
      if (!opts.headers["Accept"] && opts.responseType === "json") {
        opts.headers["Accept"] = "application/json";
      }
      opts.method = opts.method || "GET";
      const proxy = getProxy(opts.url);
      if (proxy) {
        if (this.agentCache.has(proxy)) {
          opts.agent = this.agentCache.get(proxy);
        } else {
          opts.agent = new HttpsProxyAgent(proxy);
          this.agentCache.set(proxy, opts.agent);
        }
      }
      return opts;
    }
    validateStatus(status) {
      return status >= 200 && status < 300;
    }
    paramsSerializer(params) {
      return querystring_1.default.stringify(params);
    }
    translateResponse(opts, res, data) {
      const headers = {};
      res.headers.forEach((value, key) => {
        headers[key] = value;
      });
      return {
        config: opts,
        data,
        headers,
        status: res.status,
        statusText: res.statusText,
        request: {
          responseURL: res.url
        }
      };
    }
  };
  exports2.Gaxios = Gaxios;
});

// node_modules/gaxios/build/src/index.js
var require_src3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.request = exports2.instance = exports2.Gaxios = void 0;
  var gaxios_1 = require_gaxios();
  Object.defineProperty(exports2, "Gaxios", {enumerable: true, get: function() {
    return gaxios_1.Gaxios;
  }});
  var common_1 = require_common();
  Object.defineProperty(exports2, "GaxiosError", {enumerable: true, get: function() {
    return common_1.GaxiosError;
  }});
  exports2.instance = new gaxios_1.Gaxios();
  async function request(opts) {
    return exports2.instance.request(opts);
  }
  exports2.request = request;
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS((exports2, module2) => {
  (function(globalObject) {
    "use strict";
    var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
    function clone(configObject) {
      var div, convertBase, parseNumeric, P = BigNumber2.prototype = {constructor: BigNumber2, toString: null, valueOf: null}, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "\xA0",
        suffix: ""
      }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
      function BigNumber2(v, b) {
        var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
        if (!(x instanceof BigNumber2))
          return new BigNumber2(v, b);
        if (b == null) {
          if (v && v._isBigNumber === true) {
            x.s = v.s;
            if (!v.c || v.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (v.e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = v.e;
              x.c = v.c.slice();
            }
            return;
          }
          if ((isNum = typeof v == "number") && v * 0 == 0) {
            x.s = 1 / v < 0 ? (v = -v, -1) : 1;
            if (v === ~~v) {
              for (e = 0, i = v; i >= 10; i /= 10, e++)
                ;
              if (e > MAX_EXP) {
                x.c = x.e = null;
              } else {
                x.e = e;
                x.c = [v];
              }
              return;
            }
            str = String(v);
          } else {
            if (!isNumeric.test(str = String(v)))
              return parseNumeric(x, str, isNum);
            x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
          }
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          if ((i = str.search(/e/i)) > 0) {
            if (e < 0)
              e = i;
            e += +str.slice(i + 1);
            str = str.substring(0, i);
          } else if (e < 0) {
            e = str.length;
          }
        } else {
          intCheck(b, 2, ALPHABET.length, "Base");
          if (b == 10) {
            x = new BigNumber2(v);
            return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
          }
          str = String(v);
          if (isNum = typeof v == "number") {
            if (v * 0 != 0)
              return parseNumeric(x, str, isNum, b);
            x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
            if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
              throw Error(tooManyDigits + v);
            }
          } else {
            x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
          }
          alphabet = ALPHABET.slice(0, b);
          e = i = 0;
          for (len = str.length; i < len; i++) {
            if (alphabet.indexOf(c = str.charAt(i)) < 0) {
              if (c == ".") {
                if (i > e) {
                  e = len;
                  continue;
                }
              } else if (!caseChanged) {
                if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                  caseChanged = true;
                  i = -1;
                  e = 0;
                  continue;
                }
              }
              return parseNumeric(x, String(v), isNum, b);
            }
          }
          isNum = false;
          str = convertBase(str, b, 10, x.s);
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          else
            e = str.length;
        }
        for (i = 0; str.charCodeAt(i) === 48; i++)
          ;
        for (len = str.length; str.charCodeAt(--len) === 48; )
          ;
        if (str = str.slice(i, ++len)) {
          len -= i;
          if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error(tooManyDigits + x.s * v);
          }
          if ((e = e - i - 1) > MAX_EXP) {
            x.c = x.e = null;
          } else if (e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = e;
            x.c = [];
            i = (e + 1) % LOG_BASE;
            if (e < 0)
              i += LOG_BASE;
            if (i < len) {
              if (i)
                x.c.push(+str.slice(0, i));
              for (len -= LOG_BASE; i < len; ) {
                x.c.push(+str.slice(i, i += LOG_BASE));
              }
              i = LOG_BASE - (str = str.slice(i)).length;
            } else {
              i -= len;
            }
            for (; i--; str += "0")
              ;
            x.c.push(+str);
          }
        } else {
          x.c = [x.e = 0];
        }
      }
      BigNumber2.clone = clone;
      BigNumber2.ROUND_UP = 0;
      BigNumber2.ROUND_DOWN = 1;
      BigNumber2.ROUND_CEIL = 2;
      BigNumber2.ROUND_FLOOR = 3;
      BigNumber2.ROUND_HALF_UP = 4;
      BigNumber2.ROUND_HALF_DOWN = 5;
      BigNumber2.ROUND_HALF_EVEN = 6;
      BigNumber2.ROUND_HALF_CEIL = 7;
      BigNumber2.ROUND_HALF_FLOOR = 8;
      BigNumber2.EUCLID = 9;
      BigNumber2.config = BigNumber2.set = function(obj) {
        var p, v;
        if (obj != null) {
          if (typeof obj == "object") {
            if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
              v = obj[p];
              intCheck(v, 0, MAX, p);
              DECIMAL_PLACES = v;
            }
            if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
              v = obj[p];
              intCheck(v, 0, 8, p);
              ROUNDING_MODE = v;
            }
            if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
              v = obj[p];
              if (v && v.pop) {
                intCheck(v[0], -MAX, 0, p);
                intCheck(v[1], 0, MAX, p);
                TO_EXP_NEG = v[0];
                TO_EXP_POS = v[1];
              } else {
                intCheck(v, -MAX, MAX, p);
                TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
              }
            }
            if (obj.hasOwnProperty(p = "RANGE")) {
              v = obj[p];
              if (v && v.pop) {
                intCheck(v[0], -MAX, -1, p);
                intCheck(v[1], 1, MAX, p);
                MIN_EXP = v[0];
                MAX_EXP = v[1];
              } else {
                intCheck(v, -MAX, MAX, p);
                if (v) {
                  MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                } else {
                  throw Error(bignumberError + p + " cannot be zero: " + v);
                }
              }
            }
            if (obj.hasOwnProperty(p = "CRYPTO")) {
              v = obj[p];
              if (v === !!v) {
                if (v) {
                  if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = v;
                  } else {
                    CRYPTO = !v;
                    throw Error(bignumberError + "crypto unavailable");
                  }
                } else {
                  CRYPTO = v;
                }
              } else {
                throw Error(bignumberError + p + " not true or false: " + v);
              }
            }
            if (obj.hasOwnProperty(p = "MODULO_MODE")) {
              v = obj[p];
              intCheck(v, 0, 9, p);
              MODULO_MODE = v;
            }
            if (obj.hasOwnProperty(p = "POW_PRECISION")) {
              v = obj[p];
              intCheck(v, 0, MAX, p);
              POW_PRECISION = v;
            }
            if (obj.hasOwnProperty(p = "FORMAT")) {
              v = obj[p];
              if (typeof v == "object")
                FORMAT = v;
              else
                throw Error(bignumberError + p + " not an object: " + v);
            }
            if (obj.hasOwnProperty(p = "ALPHABET")) {
              v = obj[p];
              if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                ALPHABET = v;
              } else {
                throw Error(bignumberError + p + " invalid: " + v);
              }
            }
          } else {
            throw Error(bignumberError + "Object expected: " + obj);
          }
        }
        return {
          DECIMAL_PLACES,
          ROUNDING_MODE,
          EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
          RANGE: [MIN_EXP, MAX_EXP],
          CRYPTO,
          MODULO_MODE,
          POW_PRECISION,
          FORMAT,
          ALPHABET
        };
      };
      BigNumber2.isBigNumber = function(v) {
        if (!v || v._isBigNumber !== true)
          return false;
        if (!BigNumber2.DEBUG)
          return true;
        var i, n, c = v.c, e = v.e, s = v.s;
        out:
          if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1)
                  return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1)
                i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n))
                    break out;
                }
                if (n !== 0)
                  return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
        throw Error(bignumberError + "Invalid BigNumber: " + v);
      };
      BigNumber2.maximum = BigNumber2.max = function() {
        return maxOrMin(arguments, P.lt);
      };
      BigNumber2.minimum = BigNumber2.min = function() {
        return maxOrMin(arguments, P.gt);
      };
      BigNumber2.random = function() {
        var pow2_53 = 9007199254740992;
        var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
          return mathfloor(Math.random() * pow2_53);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(dp) {
          var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
          if (dp == null)
            dp = DECIMAL_PLACES;
          else
            intCheck(dp, 0, MAX);
          k = mathceil(dp / LOG_BASE);
          if (CRYPTO) {
            if (crypto.getRandomValues) {
              a = crypto.getRandomValues(new Uint32Array(k *= 2));
              for (; i < k; ) {
                v = a[i] * 131072 + (a[i + 1] >>> 11);
                if (v >= 9e15) {
                  b = crypto.getRandomValues(new Uint32Array(2));
                  a[i] = b[0];
                  a[i + 1] = b[1];
                } else {
                  c.push(v % 1e14);
                  i += 2;
                }
              }
              i = k / 2;
            } else if (crypto.randomBytes) {
              a = crypto.randomBytes(k *= 7);
              for (; i < k; ) {
                v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                if (v >= 9e15) {
                  crypto.randomBytes(7).copy(a, i);
                } else {
                  c.push(v % 1e14);
                  i += 7;
                }
              }
              i = k / 7;
            } else {
              CRYPTO = false;
              throw Error(bignumberError + "crypto unavailable");
            }
          }
          if (!CRYPTO) {
            for (; i < k; ) {
              v = random53bitInt();
              if (v < 9e15)
                c[i++] = v % 1e14;
            }
          }
          k = c[--i];
          dp %= LOG_BASE;
          if (k && dp) {
            v = POWS_TEN[LOG_BASE - dp];
            c[i] = mathfloor(k / v) * v;
          }
          for (; c[i] === 0; c.pop(), i--)
            ;
          if (i < 0) {
            c = [e = 0];
          } else {
            for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
              ;
            for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
              ;
            if (i < LOG_BASE)
              e -= LOG_BASE - i;
          }
          rand.e = e;
          rand.c = c;
          return rand;
        };
      }();
      BigNumber2.sum = function() {
        var i = 1, args = arguments, sum = new BigNumber2(args[0]);
        for (; i < args.length; )
          sum = sum.plus(args[i++]);
        return sum;
      };
      convertBase = function() {
        var decimal = "0123456789";
        function toBaseOut(str, baseIn, baseOut, alphabet) {
          var j, arr = [0], arrL, i = 0, len = str.length;
          for (; i < len; ) {
            for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
              ;
            arr[0] += alphabet.indexOf(str.charAt(i++));
            for (j = 0; j < arr.length; j++) {
              if (arr[j] > baseOut - 1) {
                if (arr[j + 1] == null)
                  arr[j + 1] = 0;
                arr[j + 1] += arr[j] / baseOut | 0;
                arr[j] %= baseOut;
              }
            }
          }
          return arr.reverse();
        }
        return function(str, baseIn, baseOut, sign, callerIsToString) {
          var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
          if (i >= 0) {
            k = POW_PRECISION;
            POW_PRECISION = 0;
            str = str.replace(".", "");
            y = new BigNumber2(baseIn);
            x = y.pow(str.length - i);
            POW_PRECISION = k;
            y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
            y.e = y.c.length;
          }
          xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
          e = k = xc.length;
          for (; xc[--k] == 0; xc.pop())
            ;
          if (!xc[0])
            return alphabet.charAt(0);
          if (i < 0) {
            --e;
          } else {
            x.c = xc;
            x.e = e;
            x.s = sign;
            x = div(x, y, dp, rm, baseOut);
            xc = x.c;
            r = x.r;
            e = x.e;
          }
          d = e + dp + 1;
          i = xc[d];
          k = baseOut / 2;
          r = r || d < 0 || xc[d + 1] != null;
          r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
          if (d < 1 || !xc[0]) {
            str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
          } else {
            xc.length = d;
            if (r) {
              for (--baseOut; ++xc[--d] > baseOut; ) {
                xc[d] = 0;
                if (!d) {
                  ++e;
                  xc = [1].concat(xc);
                }
              }
            }
            for (k = xc.length; !xc[--k]; )
              ;
            for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
              ;
            str = toFixedPoint(str, e, alphabet.charAt(0));
          }
          return str;
        };
      }();
      div = function() {
        function multiply(x, k, base) {
          var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
          for (x = x.slice(); i--; ) {
            xlo = x[i] % SQRT_BASE;
            xhi = x[i] / SQRT_BASE | 0;
            m = khi * xlo + xhi * klo;
            temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
            carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
            x[i] = temp % base;
          }
          if (carry)
            x = [carry].concat(x);
          return x;
        }
        function compare2(a, b, aL, bL) {
          var i, cmp;
          if (aL != bL) {
            cmp = aL > bL ? 1 : -1;
          } else {
            for (i = cmp = 0; i < aL; i++) {
              if (a[i] != b[i]) {
                cmp = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return cmp;
        }
        function subtract(a, b, aL, base) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b[aL];
          }
          for (; !a[0] && a.length > 1; a.splice(0, 1))
            ;
        }
        return function(x, y, dp, rm, base) {
          var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
          if (!xc || !xc[0] || !yc || !yc[0]) {
            return new BigNumber2(!x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
          }
          q = new BigNumber2(s);
          qc = q.c = [];
          e = x.e - y.e;
          s = dp + e + 1;
          if (!base) {
            base = BASE;
            e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
            s = s / LOG_BASE | 0;
          }
          for (i = 0; yc[i] == (xc[i] || 0); i++)
            ;
          if (yc[i] > (xc[i] || 0))
            e--;
          if (s < 0) {
            qc.push(1);
            more = true;
          } else {
            xL = xc.length;
            yL = yc.length;
            i = 0;
            s += 2;
            n = mathfloor(base / (yc[0] + 1));
            if (n > 1) {
              yc = multiply(yc, n, base);
              xc = multiply(xc, n, base);
              yL = yc.length;
              xL = xc.length;
            }
            xi = yL;
            rem = xc.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; rem[remL++] = 0)
              ;
            yz = yc.slice();
            yz = [0].concat(yz);
            yc0 = yc[0];
            if (yc[1] >= base / 2)
              yc0++;
            do {
              n = 0;
              cmp = compare2(yc, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * base + (rem[1] || 0);
                n = mathfloor(rem0 / yc0);
                if (n > 1) {
                  if (n >= base)
                    n = base - 1;
                  prod = multiply(yc, n, base);
                  prodL = prod.length;
                  remL = rem.length;
                  while (compare2(prod, rem, prodL, remL) == 1) {
                    n--;
                    subtract(prod, yL < prodL ? yz : yc, prodL, base);
                    prodL = prod.length;
                    cmp = 1;
                  }
                } else {
                  if (n == 0) {
                    cmp = n = 1;
                  }
                  prod = yc.slice();
                  prodL = prod.length;
                }
                if (prodL < remL)
                  prod = [0].concat(prod);
                subtract(rem, prod, remL, base);
                remL = rem.length;
                if (cmp == -1) {
                  while (compare2(yc, rem, yL, remL) < 1) {
                    n++;
                    subtract(rem, yL < remL ? yz : yc, remL, base);
                    remL = rem.length;
                  }
                }
              } else if (cmp === 0) {
                n++;
                rem = [0];
              }
              qc[i++] = n;
              if (rem[0]) {
                rem[remL++] = xc[xi] || 0;
              } else {
                rem = [xc[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] != null) && s--);
            more = rem[0] != null;
            if (!qc[0])
              qc.splice(0, 1);
          }
          if (base == BASE) {
            for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
              ;
            round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
          } else {
            q.e = e;
            q.r = +more;
          }
          return q;
        };
      }();
      function format(n, i, rm, id) {
        var c0, e, ne, len, str;
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        if (!n.c)
          return n.toString();
        c0 = n.c[0];
        ne = n.e;
        if (i == null) {
          str = coeffToString(n.c);
          str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
        } else {
          n = round(new BigNumber2(n), i, rm);
          e = n.e;
          str = coeffToString(n.c);
          len = str.length;
          if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
            for (; len < i; str += "0", len++)
              ;
            str = toExponential(str, e);
          } else {
            i -= ne;
            str = toFixedPoint(str, e, "0");
            if (e + 1 > len) {
              if (--i > 0)
                for (str += "."; i--; str += "0")
                  ;
            } else {
              i += e - len;
              if (i > 0) {
                if (e + 1 == len)
                  str += ".";
                for (; i--; str += "0")
                  ;
              }
            }
          }
        }
        return n.s < 0 && c0 ? "-" + str : str;
      }
      function maxOrMin(args, method) {
        var n, i = 1, m = new BigNumber2(args[0]);
        for (; i < args.length; i++) {
          n = new BigNumber2(args[i]);
          if (!n.s) {
            m = n;
            break;
          } else if (method.call(m, n)) {
            m = n;
          }
        }
        return m;
      }
      function normalise(n, c, e) {
        var i = 1, j = c.length;
        for (; !c[--j]; c.pop())
          ;
        for (j = c[0]; j >= 10; j /= 10, i++)
          ;
        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
          n.c = n.e = null;
        } else if (e < MIN_EXP) {
          n.c = [n.e = 0];
        } else {
          n.e = e;
          n.c = c;
        }
        return n;
      }
      parseNumeric = function() {
        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x, str, isNum, b) {
          var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
          if (isInfinityOrNaN.test(s)) {
            x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
          } else {
            if (!isNum) {
              s = s.replace(basePrefix, function(m, p1, p2) {
                base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                return !b || b == base ? p1 : m;
              });
              if (b) {
                base = b;
                s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
              }
              if (str != s)
                return new BigNumber2(s, base);
            }
            if (BigNumber2.DEBUG) {
              throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
            }
            x.s = null;
          }
          x.c = x.e = null;
        };
      }();
      function round(x, sd, rm, r) {
        var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
        if (xc) {
          out: {
            for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
              ;
            i = sd - d;
            if (i < 0) {
              i += LOG_BASE;
              j = sd;
              n = xc[ni = 0];
              rd = n / pows10[d - j - 1] % 10 | 0;
            } else {
              ni = mathceil((i + 1) / LOG_BASE);
              if (ni >= xc.length) {
                if (r) {
                  for (; xc.length <= ni; xc.push(0))
                    ;
                  n = rd = 0;
                  d = 1;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + 1;
                } else {
                  break out;
                }
              } else {
                n = k = xc[ni];
                for (d = 1; k >= 10; k /= 10, d++)
                  ;
                i %= LOG_BASE;
                j = i - LOG_BASE + d;
                rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
              }
            }
            r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
            r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
            if (sd < 1 || !xc[0]) {
              xc.length = 0;
              if (r) {
                sd -= x.e + 1;
                xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                x.e = -sd || 0;
              } else {
                xc[0] = x.e = 0;
              }
              return x;
            }
            if (i == 0) {
              xc.length = ni;
              k = 1;
              ni--;
            } else {
              xc.length = ni + 1;
              k = pows10[LOG_BASE - i];
              xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
            }
            if (r) {
              for (; ; ) {
                if (ni == 0) {
                  for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                    ;
                  j = xc[0] += k;
                  for (k = 1; j >= 10; j /= 10, k++)
                    ;
                  if (i != k) {
                    x.e++;
                    if (xc[0] == BASE)
                      xc[0] = 1;
                  }
                  break;
                } else {
                  xc[ni] += k;
                  if (xc[ni] != BASE)
                    break;
                  xc[ni--] = 0;
                  k = 1;
                }
              }
            }
            for (i = xc.length; xc[--i] === 0; xc.pop())
              ;
          }
          if (x.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (x.e < MIN_EXP) {
            x.c = [x.e = 0];
          }
        }
        return x;
      }
      function valueOf(n) {
        var str, e = n.e;
        if (e === null)
          return n.toString();
        str = coeffToString(n.c);
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
        return n.s < 0 ? "-" + str : str;
      }
      P.absoluteValue = P.abs = function() {
        var x = new BigNumber2(this);
        if (x.s < 0)
          x.s = 1;
        return x;
      };
      P.comparedTo = function(y, b) {
        return compare(this, new BigNumber2(y, b));
      };
      P.decimalPlaces = P.dp = function(dp, rm) {
        var c, n, v, x = this;
        if (dp != null) {
          intCheck(dp, 0, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber2(x), dp + x.e + 1, rm);
        }
        if (!(c = x.c))
          return null;
        n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
        if (v = c[v])
          for (; v % 10 == 0; v /= 10, n--)
            ;
        if (n < 0)
          n = 0;
        return n;
      };
      P.dividedBy = P.div = function(y, b) {
        return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
      };
      P.dividedToIntegerBy = P.idiv = function(y, b) {
        return div(this, new BigNumber2(y, b), 0, 1);
      };
      P.exponentiatedBy = P.pow = function(n, m) {
        var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
        n = new BigNumber2(n);
        if (n.c && !n.isInteger()) {
          throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
        }
        if (m != null)
          m = new BigNumber2(m);
        nIsBig = n.e > 14;
        if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
          y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
          return m ? y.mod(m) : y;
        }
        nIsNeg = n.s < 0;
        if (m) {
          if (m.c ? !m.c[0] : !m.s)
            return new BigNumber2(NaN);
          isModExp = !nIsNeg && x.isInteger() && m.isInteger();
          if (isModExp)
            x = x.mod(m);
        } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
          k = x.s < 0 && isOdd(n) ? -0 : 0;
          if (x.e > -1)
            k = 1 / k;
          return new BigNumber2(nIsNeg ? 1 / k : k);
        } else if (POW_PRECISION) {
          k = mathceil(POW_PRECISION / LOG_BASE + 2);
        }
        if (nIsBig) {
          half = new BigNumber2(0.5);
          if (nIsNeg)
            n.s = 1;
          nIsOdd = isOdd(n);
        } else {
          i = Math.abs(+valueOf(n));
          nIsOdd = i % 2;
        }
        y = new BigNumber2(ONE);
        for (; ; ) {
          if (nIsOdd) {
            y = y.times(x);
            if (!y.c)
              break;
            if (k) {
              if (y.c.length > k)
                y.c.length = k;
            } else if (isModExp) {
              y = y.mod(m);
            }
          }
          if (i) {
            i = mathfloor(i / 2);
            if (i === 0)
              break;
            nIsOdd = i % 2;
          } else {
            n = n.times(half);
            round(n, n.e + 1, 1);
            if (n.e > 14) {
              nIsOdd = isOdd(n);
            } else {
              i = +valueOf(n);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            }
          }
          x = x.times(x);
          if (k) {
            if (x.c && x.c.length > k)
              x.c.length = k;
          } else if (isModExp) {
            x = x.mod(m);
          }
        }
        if (isModExp)
          return y;
        if (nIsNeg)
          y = ONE.div(y);
        return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
      };
      P.integerValue = function(rm) {
        var n = new BigNumber2(this);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(n, n.e + 1, rm);
      };
      P.isEqualTo = P.eq = function(y, b) {
        return compare(this, new BigNumber2(y, b)) === 0;
      };
      P.isFinite = function() {
        return !!this.c;
      };
      P.isGreaterThan = P.gt = function(y, b) {
        return compare(this, new BigNumber2(y, b)) > 0;
      };
      P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
        return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
      };
      P.isInteger = function() {
        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
      };
      P.isLessThan = P.lt = function(y, b) {
        return compare(this, new BigNumber2(y, b)) < 0;
      };
      P.isLessThanOrEqualTo = P.lte = function(y, b) {
        return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
      };
      P.isNaN = function() {
        return !this.s;
      };
      P.isNegative = function() {
        return this.s < 0;
      };
      P.isPositive = function() {
        return this.s > 0;
      };
      P.isZero = function() {
        return !!this.c && this.c[0] == 0;
      };
      P.minus = function(y, b) {
        var i, j, t, xLTy, x = this, a = x.s;
        y = new BigNumber2(y, b);
        b = y.s;
        if (!a || !b)
          return new BigNumber2(NaN);
        if (a != b) {
          y.s = -b;
          return x.plus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
          if (!xc[0] || !yc[0]) {
            return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
          }
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (xLTy = a < 0) {
            a = -a;
            t = xc;
          } else {
            ye = xe;
            t = yc;
          }
          t.reverse();
          for (b = a; b--; t.push(0))
            ;
          t.reverse();
        } else {
          j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
          for (a = b = 0; b < j; b++) {
            if (xc[b] != yc[b]) {
              xLTy = xc[b] < yc[b];
              break;
            }
          }
        }
        if (xLTy)
          t = xc, xc = yc, yc = t, y.s = -y.s;
        b = (j = yc.length) - (i = xc.length);
        if (b > 0)
          for (; b--; xc[i++] = 0)
            ;
        b = BASE - 1;
        for (; j > a; ) {
          if (xc[--j] < yc[j]) {
            for (i = j; i && !xc[--i]; xc[i] = b)
              ;
            --xc[i];
            xc[j] += BASE;
          }
          xc[j] -= yc[j];
        }
        for (; xc[0] == 0; xc.splice(0, 1), --ye)
          ;
        if (!xc[0]) {
          y.s = ROUNDING_MODE == 3 ? -1 : 1;
          y.c = [y.e = 0];
          return y;
        }
        return normalise(y, xc, ye);
      };
      P.modulo = P.mod = function(y, b) {
        var q, s, x = this;
        y = new BigNumber2(y, b);
        if (!x.c || !y.s || y.c && !y.c[0]) {
          return new BigNumber2(NaN);
        } else if (!y.c || x.c && !x.c[0]) {
          return new BigNumber2(x);
        }
        if (MODULO_MODE == 9) {
          s = y.s;
          y.s = 1;
          q = div(x, y, 0, 3);
          y.s = s;
          q.s *= s;
        } else {
          q = div(x, y, 0, MODULO_MODE);
        }
        y = x.minus(q.times(y));
        if (!y.c[0] && MODULO_MODE == 1)
          y.s = x.s;
        return y;
      };
      P.multipliedBy = P.times = function(y, b) {
        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
        if (!xc || !yc || !xc[0] || !yc[0]) {
          if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
            y.c = y.e = y.s = null;
          } else {
            y.s *= x.s;
            if (!xc || !yc) {
              y.c = y.e = null;
            } else {
              y.c = [0];
              y.e = 0;
            }
          }
          return y;
        }
        e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
        y.s *= x.s;
        xcL = xc.length;
        ycL = yc.length;
        if (xcL < ycL)
          zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
        for (i = xcL + ycL, zc = []; i--; zc.push(0))
          ;
        base = BASE;
        sqrtBase = SQRT_BASE;
        for (i = ycL; --i >= 0; ) {
          c = 0;
          ylo = yc[i] % sqrtBase;
          yhi = yc[i] / sqrtBase | 0;
          for (k = xcL, j = i + k; j > i; ) {
            xlo = xc[--k] % sqrtBase;
            xhi = xc[k] / sqrtBase | 0;
            m = yhi * xlo + xhi * ylo;
            xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
            c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
            zc[j--] = xlo % base;
          }
          zc[j] = c;
        }
        if (c) {
          ++e;
        } else {
          zc.splice(0, 1);
        }
        return normalise(y, zc, e);
      };
      P.negated = function() {
        var x = new BigNumber2(this);
        x.s = -x.s || null;
        return x;
      };
      P.plus = function(y, b) {
        var t, x = this, a = x.s;
        y = new BigNumber2(y, b);
        b = y.s;
        if (!a || !b)
          return new BigNumber2(NaN);
        if (a != b) {
          y.s = -b;
          return x.minus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return new BigNumber2(a / 0);
          if (!xc[0] || !yc[0])
            return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (a > 0) {
            ye = xe;
            t = yc;
          } else {
            a = -a;
            t = xc;
          }
          t.reverse();
          for (; a--; t.push(0))
            ;
          t.reverse();
        }
        a = xc.length;
        b = yc.length;
        if (a - b < 0)
          t = yc, yc = xc, xc = t, b = a;
        for (a = 0; b; ) {
          a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
          xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
        }
        if (a) {
          xc = [a].concat(xc);
          ++ye;
        }
        return normalise(y, xc, ye);
      };
      P.precision = P.sd = function(sd, rm) {
        var c, n, v, x = this;
        if (sd != null && sd !== !!sd) {
          intCheck(sd, 1, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber2(x), sd, rm);
        }
        if (!(c = x.c))
          return null;
        v = c.length - 1;
        n = v * LOG_BASE + 1;
        if (v = c[v]) {
          for (; v % 10 == 0; v /= 10, n--)
            ;
          for (v = c[0]; v >= 10; v /= 10, n++)
            ;
        }
        if (sd && x.e + 1 > n)
          n = x.e + 1;
        return n;
      };
      P.shiftedBy = function(k) {
        intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        return this.times("1e" + k);
      };
      P.squareRoot = P.sqrt = function() {
        var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
        if (s !== 1 || !c || !c[0]) {
          return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
        }
        s = Math.sqrt(+valueOf(x));
        if (s == 0 || s == 1 / 0) {
          n = coeffToString(c);
          if ((n.length + e) % 2 == 0)
            n += "0";
          s = Math.sqrt(+n);
          e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new BigNumber2(n);
        } else {
          r = new BigNumber2(s + "");
        }
        if (r.c[0]) {
          e = r.e;
          s = e + dp;
          if (s < 3)
            s = 0;
          for (; ; ) {
            t = r;
            r = half.times(t.plus(div(x, t, dp, 1)));
            if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
              if (r.e < e)
                --s;
              n = n.slice(s - 3, s + 1);
              if (n == "9999" || !rep && n == "4999") {
                if (!rep) {
                  round(t, t.e + DECIMAL_PLACES + 2, 0);
                  if (t.times(t).eq(x)) {
                    r = t;
                    break;
                  }
                }
                dp += 4;
                s += 4;
                rep = 1;
              } else {
                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                  round(r, r.e + DECIMAL_PLACES + 2, 1);
                  m = !r.times(r).eq(x);
                }
                break;
              }
            }
          }
        }
        return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
      };
      P.toExponential = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp++;
        }
        return format(this, dp, rm, 1);
      };
      P.toFixed = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp = dp + this.e + 1;
        }
        return format(this, dp, rm);
      };
      P.toFormat = function(dp, rm, format2) {
        var str, x = this;
        if (format2 == null) {
          if (dp != null && rm && typeof rm == "object") {
            format2 = rm;
            rm = null;
          } else if (dp && typeof dp == "object") {
            format2 = dp;
            dp = rm = null;
          } else {
            format2 = FORMAT;
          }
        } else if (typeof format2 != "object") {
          throw Error(bignumberError + "Argument not an object: " + format2);
        }
        str = x.toFixed(dp, rm);
        if (x.c) {
          var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
          if (g2)
            i = g1, g1 = g2, g2 = i, len -= i;
          if (g1 > 0 && len > 0) {
            i = len % g1 || g1;
            intPart = intDigits.substr(0, i);
            for (; i < len; i += g1)
              intPart += groupSeparator + intDigits.substr(i, g1);
            if (g2 > 0)
              intPart += groupSeparator + intDigits.slice(i);
            if (isNeg)
              intPart = "-" + intPart;
          }
          str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
        }
        return (format2.prefix || "") + str + (format2.suffix || "");
      };
      P.toFraction = function(md) {
        var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
        if (md != null) {
          n = new BigNumber2(md);
          if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
            throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
          }
        }
        if (!xc)
          return new BigNumber2(x);
        d = new BigNumber2(ONE);
        n1 = d0 = new BigNumber2(ONE);
        d1 = n0 = new BigNumber2(ONE);
        s = coeffToString(xc);
        e = d.e = s.length - x.e - 1;
        d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
        md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
        exp = MAX_EXP;
        MAX_EXP = 1 / 0;
        n = new BigNumber2(s);
        n0.c[0] = 0;
        for (; ; ) {
          q = div(n, d, 0, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.comparedTo(md) == 1)
            break;
          d0 = d1;
          d1 = d2;
          n1 = n0.plus(q.times(d2 = n1));
          n0 = d2;
          d = n.minus(q.times(d2 = d));
          n = d2;
        }
        d2 = div(md.minus(d0), d1, 0, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        e = e * 2;
        r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
        MAX_EXP = exp;
        return r;
      };
      P.toNumber = function() {
        return +valueOf(this);
      };
      P.toPrecision = function(sd, rm) {
        if (sd != null)
          intCheck(sd, 1, MAX);
        return format(this, sd, rm, 2);
      };
      P.toString = function(b) {
        var str, n = this, s = n.s, e = n.e;
        if (e === null) {
          if (s) {
            str = "Infinity";
            if (s < 0)
              str = "-" + str;
          } else {
            str = "NaN";
          }
        } else {
          if (b == null) {
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
          } else if (b === 10) {
            n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
            str = toFixedPoint(coeffToString(n.c), n.e, "0");
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
          }
          if (s < 0 && n.c[0])
            str = "-" + str;
        }
        return str;
      };
      P.valueOf = P.toJSON = function() {
        return valueOf(this);
      };
      P._isBigNumber = true;
      if (configObject != null)
        BigNumber2.set(configObject);
      return BigNumber2;
    }
    function bitFloor(n) {
      var i = n | 0;
      return n > 0 || n === i ? i : i - 1;
    }
    function coeffToString(a) {
      var s, z, i = 1, j = a.length, r = a[0] + "";
      for (; i < j; ) {
        s = a[i++] + "";
        z = LOG_BASE - s.length;
        for (; z--; s = "0" + s)
          ;
        r += s;
      }
      for (j = r.length; r.charCodeAt(--j) === 48; )
        ;
      return r.slice(0, j + 1 || 1);
    }
    function compare(x, y) {
      var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
      if (!i || !j)
        return null;
      a = xc && !xc[0];
      b = yc && !yc[0];
      if (a || b)
        return a ? b ? 0 : -j : i;
      if (i != j)
        return i;
      a = i < 0;
      b = k == l;
      if (!xc || !yc)
        return b ? 0 : !xc ^ a ? 1 : -1;
      if (!b)
        return k > l ^ a ? 1 : -1;
      j = (k = xc.length) < (l = yc.length) ? k : l;
      for (i = 0; i < j; i++)
        if (xc[i] != yc[i])
          return xc[i] > yc[i] ^ a ? 1 : -1;
      return k == l ? 0 : k > l ^ a ? 1 : -1;
    }
    function intCheck(n, min, max, name) {
      if (n < min || n > max || n !== mathfloor(n)) {
        throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
      }
    }
    function isOdd(n) {
      var k = n.c.length - 1;
      return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
    }
    function toExponential(str, e) {
      return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
    }
    function toFixedPoint(str, e, z) {
      var len, zs;
      if (e < 0) {
        for (zs = z + "."; ++e; zs += z)
          ;
        str = zs + str;
      } else {
        len = str.length;
        if (++e > len) {
          for (zs = z, e -= len; --e; zs += z)
            ;
          str += zs;
        } else if (e < len) {
          str = str.slice(0, e) + "." + str.slice(e);
        }
      }
      return str;
    }
    BigNumber = clone();
    BigNumber["default"] = BigNumber.BigNumber = BigNumber;
    if (typeof define == "function" && define.amd) {
      define(function() {
        return BigNumber;
      });
    } else if (typeof module2 != "undefined" && module2.exports) {
      module2.exports = BigNumber;
    } else {
      if (!globalObject) {
        globalObject = typeof self != "undefined" && self ? self : window;
      }
      globalObject.BigNumber = BigNumber;
    }
  })(exports2);
});

// node_modules/json-bigint/lib/stringify.js
var require_stringify = __commonJS((exports2, module2) => {
  var BigNumber = require_bignumber();
  var JSON2 = module2.exports;
  (function() {
    "use strict";
    function f(n) {
      return n < 10 ? "0" + n : n;
    }
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    }, rep;
    function quote(string) {
      escapable.lastIndex = 0;
      return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
        var c = meta[a];
        return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string + '"';
    }
    function str(key, holder) {
      var i, k, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
      if (value && typeof value === "object" && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      if (typeof rep === "function") {
        value = rep.call(holder, key, value);
      }
      switch (typeof value) {
        case "string":
          if (isBigNumber) {
            return value;
          } else {
            return quote(value);
          }
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
        case "null":
        case "bigint":
          return String(value);
        case "object":
          if (!value) {
            return "null";
          }
          gap += indent;
          partial = [];
          if (Object.prototype.toString.apply(value) === "[object Array]") {
            length = value.length;
            for (i = 0; i < length; i += 1) {
              partial[i] = str(i, value) || "null";
            }
            v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
            gap = mind;
            return v;
          }
          if (rep && typeof rep === "object") {
            length = rep.length;
            for (i = 0; i < length; i += 1) {
              if (typeof rep[i] === "string") {
                k = rep[i];
                v = str(k, value);
                if (v) {
                  partial.push(quote(k) + (gap ? ": " : ":") + v);
                }
              }
            }
          } else {
            Object.keys(value).forEach(function(k2) {
              var v2 = str(k2, value);
              if (v2) {
                partial.push(quote(k2) + (gap ? ": " : ":") + v2);
              }
            });
          }
          v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
          gap = mind;
          return v;
      }
    }
    if (typeof JSON2.stringify !== "function") {
      JSON2.stringify = function(value, replacer, space) {
        var i;
        gap = "";
        indent = "";
        if (typeof space === "number") {
          for (i = 0; i < space; i += 1) {
            indent += " ";
          }
        } else if (typeof space === "string") {
          indent = space;
        }
        rep = replacer;
        if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
          throw new Error("JSON.stringify");
        }
        return str("", {"": value});
      };
    }
  })();
});

// node_modules/json-bigint/lib/parse.js
var require_parse = __commonJS((exports2, module2) => {
  var BigNumber = null;
  var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
  var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
  var json_parse = function(options) {
    "use strict";
    var _options = {
      strict: false,
      storeAsString: false,
      alwaysParseAsBig: false,
      useNativeBigInt: false,
      protoAction: "error",
      constructorAction: "error"
    };
    if (options !== void 0 && options !== null) {
      if (options.strict === true) {
        _options.strict = true;
      }
      if (options.storeAsString === true) {
        _options.storeAsString = true;
      }
      _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
      _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
      if (typeof options.constructorAction !== "undefined") {
        if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
          _options.constructorAction = options.constructorAction;
        } else {
          throw new Error(`Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`);
        }
      }
      if (typeof options.protoAction !== "undefined") {
        if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
          _options.protoAction = options.protoAction;
        } else {
          throw new Error(`Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`);
        }
      }
    }
    var at, ch, escapee = {
      '"': '"',
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	"
    }, text, error = function(m) {
      throw {
        name: "SyntaxError",
        message: m,
        at,
        text
      };
    }, next = function(c) {
      if (c && c !== ch) {
        error("Expected '" + c + "' instead of '" + ch + "'");
      }
      ch = text.charAt(at);
      at += 1;
      return ch;
    }, number = function() {
      var number2, string2 = "";
      if (ch === "-") {
        string2 = "-";
        next("-");
      }
      while (ch >= "0" && ch <= "9") {
        string2 += ch;
        next();
      }
      if (ch === ".") {
        string2 += ".";
        while (next() && ch >= "0" && ch <= "9") {
          string2 += ch;
        }
      }
      if (ch === "e" || ch === "E") {
        string2 += ch;
        next();
        if (ch === "-" || ch === "+") {
          string2 += ch;
          next();
        }
        while (ch >= "0" && ch <= "9") {
          string2 += ch;
          next();
        }
      }
      number2 = +string2;
      if (!isFinite(number2)) {
        error("Bad number");
      } else {
        if (BigNumber == null)
          BigNumber = require_bignumber();
        if (string2.length > 15)
          return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
        else
          return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
      }
    }, string = function() {
      var hex, i, string2 = "", uffff;
      if (ch === '"') {
        var startAt = at;
        while (next()) {
          if (ch === '"') {
            if (at - 1 > startAt)
              string2 += text.substring(startAt, at - 1);
            next();
            return string2;
          }
          if (ch === "\\") {
            if (at - 1 > startAt)
              string2 += text.substring(startAt, at - 1);
            next();
            if (ch === "u") {
              uffff = 0;
              for (i = 0; i < 4; i += 1) {
                hex = parseInt(next(), 16);
                if (!isFinite(hex)) {
                  break;
                }
                uffff = uffff * 16 + hex;
              }
              string2 += String.fromCharCode(uffff);
            } else if (typeof escapee[ch] === "string") {
              string2 += escapee[ch];
            } else {
              break;
            }
            startAt = at;
          }
        }
      }
      error("Bad string");
    }, white = function() {
      while (ch && ch <= " ") {
        next();
      }
    }, word = function() {
      switch (ch) {
        case "t":
          next("t");
          next("r");
          next("u");
          next("e");
          return true;
        case "f":
          next("f");
          next("a");
          next("l");
          next("s");
          next("e");
          return false;
        case "n":
          next("n");
          next("u");
          next("l");
          next("l");
          return null;
      }
      error("Unexpected '" + ch + "'");
    }, value, array = function() {
      var array2 = [];
      if (ch === "[") {
        next("[");
        white();
        if (ch === "]") {
          next("]");
          return array2;
        }
        while (ch) {
          array2.push(value());
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          next(",");
          white();
        }
      }
      error("Bad array");
    }, object = function() {
      var key, object2 = Object.create(null);
      if (ch === "{") {
        next("{");
        white();
        if (ch === "}") {
          next("}");
          return object2;
        }
        while (ch) {
          key = string();
          white();
          next(":");
          if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
            error('Duplicate key "' + key + '"');
          }
          if (suspectProtoRx.test(key) === true) {
            if (_options.protoAction === "error") {
              error("Object contains forbidden prototype property");
            } else if (_options.protoAction === "ignore") {
              value();
            } else {
              object2[key] = value();
            }
          } else if (suspectConstructorRx.test(key) === true) {
            if (_options.constructorAction === "error") {
              error("Object contains forbidden constructor property");
            } else if (_options.constructorAction === "ignore") {
              value();
            } else {
              object2[key] = value();
            }
          } else {
            object2[key] = value();
          }
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          next(",");
          white();
        }
      }
      error("Bad object");
    };
    value = function() {
      white();
      switch (ch) {
        case "{":
          return object();
        case "[":
          return array();
        case '"':
          return string();
        case "-":
          return number();
        default:
          return ch >= "0" && ch <= "9" ? number() : word();
      }
    };
    return function(source, reviver) {
      var result;
      text = source + "";
      at = 0;
      ch = " ";
      result = value();
      white();
      if (ch) {
        error("Syntax error");
      }
      return typeof reviver === "function" ? function walk(holder, key) {
        var k, v, value2 = holder[key];
        if (value2 && typeof value2 === "object") {
          Object.keys(value2).forEach(function(k2) {
            v = walk(value2, k2);
            if (v !== void 0) {
              value2[k2] = v;
            } else {
              delete value2[k2];
            }
          });
        }
        return reviver.call(holder, key, value2);
      }({"": result}, "") : result;
    };
  };
  module2.exports = json_parse;
});

// node_modules/json-bigint/index.js
var require_json_bigint = __commonJS((exports2, module2) => {
  var json_stringify = require_stringify().stringify;
  var json_parse = require_parse();
  module2.exports = function(options) {
    return {
      parse: json_parse(options),
      stringify: json_stringify
    };
  };
  module2.exports.parse = json_parse();
  module2.exports.stringify = json_stringify;
});

// node_modules/gcp-metadata/build/src/index.js
var require_src4 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.requestTimeout = exports2.resetIsAvailableCache = exports2.isAvailable = exports2.project = exports2.instance = exports2.HEADERS = exports2.HEADER_VALUE = exports2.HEADER_NAME = exports2.SECONDARY_HOST_ADDRESS = exports2.HOST_ADDRESS = exports2.BASE_PATH = void 0;
  var gaxios_1 = require_src3();
  var jsonBigint = require_json_bigint();
  exports2.BASE_PATH = "/computeMetadata/v1";
  exports2.HOST_ADDRESS = "http://169.254.169.254";
  exports2.SECONDARY_HOST_ADDRESS = "http://metadata.google.internal.";
  exports2.HEADER_NAME = "Metadata-Flavor";
  exports2.HEADER_VALUE = "Google";
  exports2.HEADERS = Object.freeze({[exports2.HEADER_NAME]: exports2.HEADER_VALUE});
  function getBaseUrl(baseUrl) {
    if (!baseUrl) {
      baseUrl = process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST || exports2.HOST_ADDRESS;
    }
    if (!/^https?:\/\//.test(baseUrl)) {
      baseUrl = `http://${baseUrl}`;
    }
    return new URL(exports2.BASE_PATH, baseUrl).href;
  }
  function validate(options) {
    Object.keys(options).forEach((key) => {
      switch (key) {
        case "params":
        case "property":
        case "headers":
          break;
        case "qs":
          throw new Error("'qs' is not a valid configuration option. Please use 'params' instead.");
        default:
          throw new Error(`'${key}' is not a valid configuration option.`);
      }
    });
  }
  async function metadataAccessor(type, options, noResponseRetries = 3, fastFail = false) {
    options = options || {};
    if (typeof options === "string") {
      options = {property: options};
    }
    let property = "";
    if (typeof options === "object" && options.property) {
      property = "/" + options.property;
    }
    validate(options);
    try {
      const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;
      const res = await requestMethod({
        url: `${getBaseUrl()}/${type}${property}`,
        headers: Object.assign({}, exports2.HEADERS, options.headers),
        retryConfig: {noResponseRetries},
        params: options.params,
        responseType: "text",
        timeout: requestTimeout()
      });
      if (res.headers[exports2.HEADER_NAME.toLowerCase()] !== exports2.HEADER_VALUE) {
        throw new Error(`Invalid response from metadata service: incorrect ${exports2.HEADER_NAME} header.`);
      } else if (!res.data) {
        throw new Error("Invalid response from the metadata service");
      }
      if (typeof res.data === "string") {
        try {
          return jsonBigint.parse(res.data);
        } catch (_a) {
        }
      }
      return res.data;
    } catch (e) {
      if (e.response && e.response.status !== 200) {
        e.message = `Unsuccessful response status code. ${e.message}`;
      }
      throw e;
    }
  }
  async function fastFailMetadataRequest(options) {
    const secondaryOptions = __objSpread(__objSpread({}, options), {
      url: options.url.replace(getBaseUrl(), getBaseUrl(exports2.SECONDARY_HOST_ADDRESS))
    });
    let responded = false;
    const r1 = gaxios_1.request(options).then((res) => {
      responded = true;
      return res;
    }).catch((err) => {
      if (responded) {
        return r2;
      } else {
        responded = true;
        throw err;
      }
    });
    const r2 = gaxios_1.request(secondaryOptions).then((res) => {
      responded = true;
      return res;
    }).catch((err) => {
      if (responded) {
        return r1;
      } else {
        responded = true;
        throw err;
      }
    });
    return Promise.race([r1, r2]);
  }
  function instance(options) {
    return metadataAccessor("instance", options);
  }
  exports2.instance = instance;
  function project(options) {
    return metadataAccessor("project", options);
  }
  exports2.project = project;
  function detectGCPAvailableRetries() {
    return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;
  }
  var cachedIsAvailableResponse;
  async function isAvailable() {
    try {
      if (cachedIsAvailableResponse === void 0) {
        cachedIsAvailableResponse = metadataAccessor("instance", void 0, detectGCPAvailableRetries(), !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST));
      }
      await cachedIsAvailableResponse;
      return true;
    } catch (err) {
      if (process.env.DEBUG_AUTH) {
        console.info(err);
      }
      if (err.type === "request-timeout") {
        return false;
      }
      if (err.response && err.response.status === 404) {
        return false;
      } else {
        if (!(err.response && err.response.status === 404) && (!err.code || ![
          "EHOSTDOWN",
          "EHOSTUNREACH",
          "ENETUNREACH",
          "ENOENT",
          "ENOTFOUND",
          "ECONNREFUSED"
        ].includes(err.code))) {
          let code = "UNKNOWN";
          if (err.code)
            code = err.code;
          process.emitWarning(`received unexpected error = ${err.message} code = ${code}`, "MetadataLookupWarning");
        }
        return false;
      }
    }
  }
  exports2.isAvailable = isAvailable;
  function resetIsAvailableCache() {
    cachedIsAvailableResponse = void 0;
  }
  exports2.resetIsAvailableCache = resetIsAvailableCache;
  function requestTimeout() {
    return process.env.K_SERVICE || process.env.FUNCTION_NAME ? 0 : 3e3;
  }
  exports2.requestTimeout = requestTimeout;
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS((exports2) => {
  "use strict";
  exports2.byteLength = byteLength;
  exports2.toByteArray = toByteArray;
  exports2.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0; i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
});

// node_modules/fast-text-encoding/text.min.js
var require_text_min = __commonJS((exports2) => {
  (function(l) {
    function m() {
    }
    function k(a, c) {
      a = a === void 0 ? "utf-8" : a;
      c = c === void 0 ? {fatal: false} : c;
      if (r.indexOf(a.toLowerCase()) === -1)
        throw new RangeError("Failed to construct 'TextDecoder': The encoding label provided ('" + a + "') is invalid.");
      if (c.fatal)
        throw Error("Failed to construct 'TextDecoder': the 'fatal' option is unsupported.");
    }
    function t(a) {
      return Buffer.from(a.buffer, a.byteOffset, a.byteLength).toString("utf-8");
    }
    function u(a) {
      var c = URL.createObjectURL(new Blob([a], {type: "text/plain;charset=UTF-8"}));
      try {
        var f = new XMLHttpRequest();
        f.open("GET", c, false);
        f.send();
        return f.responseText;
      } catch (e) {
        return q(a);
      } finally {
        URL.revokeObjectURL(c);
      }
    }
    function q(a) {
      for (var c = 0, f = Math.min(65536, a.length + 1), e = new Uint16Array(f), h = [], d = 0; ; ) {
        var b = c < a.length;
        if (!b || d >= f - 1) {
          h.push(String.fromCharCode.apply(null, e.subarray(0, d)));
          if (!b)
            return h.join("");
          a = a.subarray(c);
          d = c = 0;
        }
        b = a[c++];
        if ((b & 128) === 0)
          e[d++] = b;
        else if ((b & 224) === 192) {
          var g = a[c++] & 63;
          e[d++] = (b & 31) << 6 | g;
        } else if ((b & 240) === 224) {
          g = a[c++] & 63;
          var n = a[c++] & 63;
          e[d++] = (b & 31) << 12 | g << 6 | n;
        } else if ((b & 248) === 240) {
          g = a[c++] & 63;
          n = a[c++] & 63;
          var v = a[c++] & 63;
          b = (b & 7) << 18 | g << 12 | n << 6 | v;
          65535 < b && (b -= 65536, e[d++] = b >>> 10 & 1023 | 55296, b = 56320 | b & 1023);
          e[d++] = b;
        }
      }
    }
    if (l.TextEncoder && l.TextDecoder)
      return false;
    var r = ["utf-8", "utf8", "unicode-1-1-utf-8"];
    Object.defineProperty(m.prototype, "encoding", {value: "utf-8"});
    m.prototype.encode = function(a, c) {
      c = c === void 0 ? {stream: false} : c;
      if (c.stream)
        throw Error("Failed to encode: the 'stream' option is unsupported.");
      c = 0;
      for (var f = a.length, e = 0, h = Math.max(32, f + (f >>> 1) + 7), d = new Uint8Array(h >>> 3 << 3); c < f; ) {
        var b = a.charCodeAt(c++);
        if (55296 <= b && 56319 >= b) {
          if (c < f) {
            var g = a.charCodeAt(c);
            (g & 64512) === 56320 && (++c, b = ((b & 1023) << 10) + (g & 1023) + 65536);
          }
          if (55296 <= b && 56319 >= b)
            continue;
        }
        e + 4 > d.length && (h += 8, h *= 1 + c / a.length * 2, h = h >>> 3 << 3, g = new Uint8Array(h), g.set(d), d = g);
        if ((b & 4294967168) === 0)
          d[e++] = b;
        else {
          if ((b & 4294965248) === 0)
            d[e++] = b >>> 6 & 31 | 192;
          else if ((b & 4294901760) === 0)
            d[e++] = b >>> 12 & 15 | 224, d[e++] = b >>> 6 & 63 | 128;
          else if ((b & 4292870144) === 0)
            d[e++] = b >>> 18 & 7 | 240, d[e++] = b >>> 12 & 63 | 128, d[e++] = b >>> 6 & 63 | 128;
          else
            continue;
          d[e++] = b & 63 | 128;
        }
      }
      return d.slice ? d.slice(0, e) : d.subarray(0, e);
    };
    Object.defineProperty(k.prototype, "encoding", {value: "utf-8"});
    Object.defineProperty(k.prototype, "fatal", {value: false});
    Object.defineProperty(k.prototype, "ignoreBOM", {value: false});
    var p = q;
    typeof Buffer === "function" && Buffer.from ? p = t : typeof Blob === "function" && typeof URL === "function" && typeof URL.createObjectURL === "function" && (p = u);
    k.prototype.decode = function(a, c) {
      c = c === void 0 ? {stream: false} : c;
      if (c.stream)
        throw Error("Failed to decode: the 'stream' option is unsupported.");
      a = a instanceof Uint8Array ? a : a.buffer instanceof ArrayBuffer ? new Uint8Array(a.buffer) : new Uint8Array(a);
      return p(a);
    };
    l.TextEncoder = m;
    l.TextDecoder = k;
  })(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports2);
});

// node_modules/google-auth-library/build/src/crypto/browser/crypto.js
var require_crypto = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.BrowserCrypto = void 0;
  var base64js = require_base64_js();
  if (typeof process === "undefined" && typeof TextEncoder === "undefined") {
    require_text_min();
  }
  var BrowserCrypto = class {
    constructor() {
      if (typeof window === "undefined" || window.crypto === void 0 || window.crypto.subtle === void 0) {
        throw new Error("SubtleCrypto not found. Make sure it's an https:// website.");
      }
    }
    async sha256DigestBase64(str) {
      const inputBuffer = new TextEncoder().encode(str);
      const outputBuffer = await window.crypto.subtle.digest("SHA-256", inputBuffer);
      return base64js.fromByteArray(new Uint8Array(outputBuffer));
    }
    randomBytesBase64(count) {
      const array = new Uint8Array(count);
      window.crypto.getRandomValues(array);
      return base64js.fromByteArray(array);
    }
    static padBase64(base64) {
      while (base64.length % 4 !== 0) {
        base64 += "=";
      }
      return base64;
    }
    async verify(pubkey, data, signature) {
      const algo = {
        name: "RSASSA-PKCS1-v1_5",
        hash: {name: "SHA-256"}
      };
      const dataArray = new TextEncoder().encode(data);
      const signatureArray = base64js.toByteArray(BrowserCrypto.padBase64(signature));
      const cryptoKey = await window.crypto.subtle.importKey("jwk", pubkey, algo, true, ["verify"]);
      const result = await window.crypto.subtle.verify(algo, cryptoKey, signatureArray, dataArray);
      return result;
    }
    async sign(privateKey, data) {
      const algo = {
        name: "RSASSA-PKCS1-v1_5",
        hash: {name: "SHA-256"}
      };
      const dataArray = new TextEncoder().encode(data);
      const cryptoKey = await window.crypto.subtle.importKey("jwk", privateKey, algo, true, ["sign"]);
      const result = await window.crypto.subtle.sign(algo, cryptoKey, dataArray);
      return base64js.fromByteArray(new Uint8Array(result));
    }
    decodeBase64StringUtf8(base64) {
      const uint8array = base64js.toByteArray(BrowserCrypto.padBase64(base64));
      const result = new TextDecoder().decode(uint8array);
      return result;
    }
    encodeBase64StringUtf8(text) {
      const uint8array = new TextEncoder().encode(text);
      const result = base64js.fromByteArray(uint8array);
      return result;
    }
  };
  exports2.BrowserCrypto = BrowserCrypto;
});

// node_modules/google-auth-library/build/src/crypto/node/crypto.js
var require_crypto2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.NodeCrypto = void 0;
  var crypto2 = require("crypto");
  var NodeCrypto = class {
    async sha256DigestBase64(str) {
      return crypto2.createHash("sha256").update(str).digest("base64");
    }
    randomBytesBase64(count) {
      return crypto2.randomBytes(count).toString("base64");
    }
    async verify(pubkey, data, signature) {
      const verifier = crypto2.createVerify("sha256");
      verifier.update(data);
      verifier.end();
      return verifier.verify(pubkey, signature, "base64");
    }
    async sign(privateKey, data) {
      const signer = crypto2.createSign("RSA-SHA256");
      signer.update(data);
      signer.end();
      return signer.sign(privateKey, "base64");
    }
    decodeBase64StringUtf8(base64) {
      return Buffer.from(base64, "base64").toString("utf-8");
    }
    encodeBase64StringUtf8(text) {
      return Buffer.from(text, "utf-8").toString("base64");
    }
  };
  exports2.NodeCrypto = NodeCrypto;
});

// node_modules/google-auth-library/build/src/crypto/crypto.js
var require_crypto3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.hasBrowserCrypto = exports2.createCrypto = void 0;
  var crypto_1 = require_crypto();
  var crypto_2 = require_crypto2();
  function createCrypto() {
    if (hasBrowserCrypto()) {
      return new crypto_1.BrowserCrypto();
    }
    return new crypto_2.NodeCrypto();
  }
  exports2.createCrypto = createCrypto;
  function hasBrowserCrypto() {
    return typeof window !== "undefined" && typeof window.crypto !== "undefined" && typeof window.crypto.subtle !== "undefined";
  }
  exports2.hasBrowserCrypto = hasBrowserCrypto;
});

// node_modules/google-auth-library/build/src/options.js
var require_options = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.validate = void 0;
  function validate(options) {
    const vpairs = [
      {invalid: "uri", expected: "url"},
      {invalid: "json", expected: "data"},
      {invalid: "qs", expected: "params"}
    ];
    for (const pair of vpairs) {
      if (options[pair.invalid]) {
        const e = `'${pair.invalid}' is not a valid configuration option. Please use '${pair.expected}' instead. This library is using Axios for requests. Please see https://github.com/axios/axios to learn more about the valid request options.`;
        throw new Error(e);
      }
    }
  }
  exports2.validate = validate;
});

// node_modules/google-auth-library/package.json
var require_package = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "google-auth-library",
    version: "6.1.6",
    author: "Google Inc.",
    description: "Google APIs Authentication Client Library for Node.js",
    engines: {
      node: ">=10"
    },
    main: "./build/src/index.js",
    types: "./build/src/index.d.ts",
    repository: "googleapis/google-auth-library-nodejs.git",
    keywords: [
      "google",
      "api",
      "google apis",
      "client",
      "client library"
    ],
    dependencies: {
      arrify: "^2.0.0",
      "base64-js": "^1.3.0",
      "ecdsa-sig-formatter": "^1.0.11",
      "fast-text-encoding": "^1.0.0",
      gaxios: "^4.0.0",
      "gcp-metadata": "^4.2.0",
      gtoken: "^5.0.4",
      jws: "^4.0.0",
      "lru-cache": "^6.0.0"
    },
    devDependencies: {
      "@compodoc/compodoc": "^1.1.7",
      "@types/base64-js": "^1.2.5",
      "@types/chai": "^4.1.7",
      "@types/jws": "^3.1.0",
      "@types/lru-cache": "^5.0.0",
      "@types/mocha": "^8.0.0",
      "@types/mv": "^2.1.0",
      "@types/ncp": "^2.0.1",
      "@types/node": "^10.5.1",
      "@types/sinon": "^9.0.0",
      "@types/tmp": "^0.2.0",
      "assert-rejects": "^1.0.0",
      c8: "^7.0.0",
      chai: "^4.2.0",
      codecov: "^3.0.2",
      execa: "^5.0.0",
      gts: "^2.0.0",
      "is-docker": "^2.0.0",
      karma: "^6.0.0",
      "karma-chrome-launcher": "^3.0.0",
      "karma-coverage": "^2.0.0",
      "karma-firefox-launcher": "^2.0.0",
      "karma-mocha": "^2.0.0",
      "karma-remap-coverage": "^0.1.5",
      "karma-sourcemap-loader": "^0.3.7",
      "karma-webpack": "^4.0.0",
      keypair: "^1.0.1",
      linkinator: "^2.0.0",
      mocha: "^8.0.0",
      mv: "^2.1.1",
      ncp: "^2.0.0",
      nock: "^13.0.0",
      "null-loader": "^4.0.0",
      puppeteer: "^5.0.0",
      sinon: "^9.0.0",
      tmp: "^0.2.0",
      "ts-loader": "^8.0.0",
      typescript: "^3.8.3",
      webpack: "^4.20.2",
      "webpack-cli": "^4.0.0",
      "@microsoft/api-documenter": "^7.8.10",
      "@microsoft/api-extractor": "^7.8.10"
    },
    files: [
      "build/src",
      "!build/src/**/*.map"
    ],
    scripts: {
      test: "c8 mocha build/test",
      clean: "gts clean",
      prepare: "npm run compile",
      lint: "gts check",
      compile: "tsc -p .",
      fix: "gts fix",
      pretest: "npm run compile",
      docs: "compodoc src/",
      "samples-test": "cd samples/ && npm link ../ && npm test && cd ../",
      "system-test": "mocha build/system-test --timeout 60000",
      "presystem-test": "npm run compile",
      webpack: "webpack",
      "browser-test": "karma start",
      "docs-test": "linkinator docs",
      "predocs-test": "npm run docs",
      prelint: "cd samples; npm link ../; npm install",
      precompile: "gts clean",
      "api-extractor": "api-extractor run --local",
      "api-documenter": "api-documenter yaml --input-folder=temp"
    },
    license: "Apache-2.0"
  };
});

// node_modules/google-auth-library/build/src/transporters.js
var require_transporters = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.DefaultTransporter = void 0;
  var gaxios_1 = require_src3();
  var options_1 = require_options();
  var pkg = require_package();
  var PRODUCT_NAME = "google-api-nodejs-client";
  var DefaultTransporter = class {
    configure(opts = {}) {
      opts.headers = opts.headers || {};
      if (typeof window === "undefined") {
        const uaValue = opts.headers["User-Agent"];
        if (!uaValue) {
          opts.headers["User-Agent"] = DefaultTransporter.USER_AGENT;
        } else if (!uaValue.includes(`${PRODUCT_NAME}/`)) {
          opts.headers["User-Agent"] = `${uaValue} ${DefaultTransporter.USER_AGENT}`;
        }
        const authVersion = `auth/${pkg.version}`;
        if (opts.headers["x-goog-api-client"] && !opts.headers["x-goog-api-client"].includes(authVersion)) {
          opts.headers["x-goog-api-client"] = `${opts.headers["x-goog-api-client"]} ${authVersion}`;
        } else if (!opts.headers["x-goog-api-client"]) {
          const nodeVersion = process.version.replace(/^v/, "");
          opts.headers["x-goog-api-client"] = `gl-node/${nodeVersion} ${authVersion}`;
        }
      }
      return opts;
    }
    request(opts, callback) {
      opts = this.configure(opts);
      try {
        options_1.validate(opts);
      } catch (e) {
        if (callback) {
          return callback(e);
        } else {
          throw e;
        }
      }
      if (callback) {
        gaxios_1.request(opts).then((r) => {
          callback(null, r);
        }, (e) => {
          callback(this.processError(e));
        });
      } else {
        return gaxios_1.request(opts).catch((e) => {
          throw this.processError(e);
        });
      }
    }
    processError(e) {
      const res = e.response;
      const err = e;
      const body = res ? res.data : null;
      if (res && body && body.error && res.status !== 200) {
        if (typeof body.error === "string") {
          err.message = body.error;
          err.code = res.status.toString();
        } else if (Array.isArray(body.error.errors)) {
          err.message = body.error.errors.map((err2) => err2.message).join("\n");
          err.code = body.error.code;
          err.errors = body.error.errors;
        } else {
          err.message = body.error.message;
          err.code = body.error.code || res.status;
        }
      } else if (res && res.status >= 400) {
        err.message = body;
        err.code = res.status.toString();
      }
      return err;
    }
  };
  exports2.DefaultTransporter = DefaultTransporter;
  DefaultTransporter.USER_AGENT = `${PRODUCT_NAME}/${pkg.version}`;
});

// node_modules/arrify/index.js
var require_arrify = __commonJS((exports2, module2) => {
  "use strict";
  var arrify = (value) => {
    if (value === null || value === void 0) {
      return [];
    }
    if (Array.isArray(value)) {
      return value;
    }
    if (typeof value === "string") {
      return [value];
    }
    if (typeof value[Symbol.iterator] === "function") {
      return [...value];
    }
    return [value];
  };
  module2.exports = arrify;
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports2, module2) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = require("buffer");
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS((exports2, module2) => {
  "use strict";
  function getParamSize(keySize) {
    var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
    return result;
  }
  var paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521)
  };
  function getParamBytesForAlg(alg) {
    var paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
      return paramBytes;
    }
    throw new Error('Unknown algorithm "' + alg + '"');
  }
  module2.exports = getParamBytesForAlg;
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS((exports2, module2) => {
  "use strict";
  var Buffer2 = require_safe_buffer().Buffer;
  var getParamBytesForAlg = require_param_bytes_for_alg();
  var MAX_OCTET = 128;
  var CLASS_UNIVERSAL = 0;
  var PRIMITIVE_BIT = 32;
  var TAG_SEQ = 16;
  var TAG_INT = 2;
  var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
  var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
  function base64Url(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function signatureAsBuffer(signature) {
    if (Buffer2.isBuffer(signature)) {
      return signature;
    } else if (typeof signature === "string") {
      return Buffer2.from(signature, "base64");
    }
    throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
  }
  function derToJose(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var maxEncodedParamLength = paramBytes + 1;
    var inputLength = signature.length;
    var offset = 0;
    if (signature[offset++] !== ENCODED_TAG_SEQ) {
      throw new Error('Could not find expected "seq"');
    }
    var seqLength = signature[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
      seqLength = signature[offset++];
    }
    if (inputLength - offset < seqLength) {
      throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
    }
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "r"');
    }
    var rLength = signature[offset++];
    if (inputLength - offset - 2 < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
    }
    if (maxEncodedParamLength < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var rOffset = offset;
    offset += rLength;
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "s"');
    }
    var sLength = signature[offset++];
    if (inputLength - offset !== sLength) {
      throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
    }
    if (maxEncodedParamLength < sLength) {
      throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var sOffset = offset;
    offset += sLength;
    if (offset !== inputLength) {
      throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
    }
    var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
    var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
    for (offset = 0; offset < rPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
    offset = paramBytes;
    for (var o = offset; offset < o + sPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
    dst = dst.toString("base64");
    dst = base64Url(dst);
    return dst;
  }
  function countPadding(buf, start, stop) {
    var padding = 0;
    while (start + padding < stop && buf[start + padding] === 0) {
      ++padding;
    }
    var needsSign = buf[start + padding] >= MAX_OCTET;
    if (needsSign) {
      --padding;
    }
    return padding;
  }
  function joseToDer(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
      throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
    }
    var rPadding = countPadding(signature, 0, paramBytes);
    var sPadding = countPadding(signature, paramBytes, signature.length);
    var rLength = paramBytes - rPadding;
    var sLength = paramBytes - sPadding;
    var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
    var shortLength = rsBytes < MAX_OCTET;
    var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
    var offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
      dst[offset++] = rsBytes;
    } else {
      dst[offset++] = MAX_OCTET | 1;
      dst[offset++] = rsBytes & 255;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
      dst[offset++] = 0;
      offset += signature.copy(dst, offset, 0, paramBytes);
    } else {
      offset += signature.copy(dst, offset, rPadding, paramBytes);
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
      dst[offset++] = 0;
      signature.copy(dst, offset, paramBytes);
    } else {
      signature.copy(dst, offset, paramBytes + sPadding);
    }
    return dst;
  }
  module2.exports = {
    derToJose,
    joseToDer
  };
});

// node_modules/google-auth-library/build/src/auth/authclient.js
var require_authclient = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.AuthClient = void 0;
  var events_1 = require("events");
  var transporters_1 = require_transporters();
  var AuthClient = class extends events_1.EventEmitter {
    constructor() {
      super(...arguments);
      this.transporter = new transporters_1.DefaultTransporter();
      this.credentials = {};
    }
    setCredentials(credentials) {
      this.credentials = credentials;
    }
    addSharedMetadataHeaders(headers) {
      if (!headers["x-goog-user-project"] && this.quotaProjectId) {
        headers["x-goog-user-project"] = this.quotaProjectId;
      }
      return headers;
    }
  };
  exports2.AuthClient = AuthClient;
});

// node_modules/google-auth-library/build/src/auth/loginticket.js
var require_loginticket = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.LoginTicket = void 0;
  var LoginTicket = class {
    constructor(env, pay) {
      this.envelope = env;
      this.payload = pay;
    }
    getEnvelope() {
      return this.envelope;
    }
    getPayload() {
      return this.payload;
    }
    getUserId() {
      const payload = this.getPayload();
      if (payload && payload.sub) {
        return payload.sub;
      }
      return null;
    }
    getAttributes() {
      return {envelope: this.getEnvelope(), payload: this.getPayload()};
    }
  };
  exports2.LoginTicket = LoginTicket;
});

// node_modules/google-auth-library/build/src/auth/oauth2client.js
var require_oauth2client = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.OAuth2Client = exports2.CertificateFormat = exports2.CodeChallengeMethod = void 0;
  var querystring = require("querystring");
  var stream = require("stream");
  var formatEcdsa = require_ecdsa_sig_formatter();
  var crypto_1 = require_crypto3();
  var authclient_1 = require_authclient();
  var loginticket_1 = require_loginticket();
  var CodeChallengeMethod;
  (function(CodeChallengeMethod2) {
    CodeChallengeMethod2["Plain"] = "plain";
    CodeChallengeMethod2["S256"] = "S256";
  })(CodeChallengeMethod = exports2.CodeChallengeMethod || (exports2.CodeChallengeMethod = {}));
  var CertificateFormat;
  (function(CertificateFormat2) {
    CertificateFormat2["PEM"] = "PEM";
    CertificateFormat2["JWK"] = "JWK";
  })(CertificateFormat = exports2.CertificateFormat || (exports2.CertificateFormat = {}));
  var OAuth2Client = class extends authclient_1.AuthClient {
    constructor(optionsOrClientId, clientSecret, redirectUri) {
      super();
      this.certificateCache = {};
      this.certificateExpiry = null;
      this.certificateCacheFormat = CertificateFormat.PEM;
      this.refreshTokenPromises = new Map();
      const opts = optionsOrClientId && typeof optionsOrClientId === "object" ? optionsOrClientId : {clientId: optionsOrClientId, clientSecret, redirectUri};
      this._clientId = opts.clientId;
      this._clientSecret = opts.clientSecret;
      this.redirectUri = opts.redirectUri;
      this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis || 5 * 60 * 1e3;
      this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;
    }
    generateAuthUrl(opts = {}) {
      if (opts.code_challenge_method && !opts.code_challenge) {
        throw new Error("If a code_challenge_method is provided, code_challenge must be included.");
      }
      opts.response_type = opts.response_type || "code";
      opts.client_id = opts.client_id || this._clientId;
      opts.redirect_uri = opts.redirect_uri || this.redirectUri;
      if (opts.scope instanceof Array) {
        opts.scope = opts.scope.join(" ");
      }
      const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;
      return rootUrl + "?" + querystring.stringify(opts);
    }
    generateCodeVerifier() {
      throw new Error("generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.");
    }
    async generateCodeVerifierAsync() {
      const crypto2 = crypto_1.createCrypto();
      const randomString = crypto2.randomBytesBase64(96);
      const codeVerifier = randomString.replace(/\+/g, "~").replace(/=/g, "_").replace(/\//g, "-");
      const unencodedCodeChallenge = await crypto2.sha256DigestBase64(codeVerifier);
      const codeChallenge = unencodedCodeChallenge.split("=")[0].replace(/\+/g, "-").replace(/\//g, "_");
      return {codeVerifier, codeChallenge};
    }
    getToken(codeOrOptions, callback) {
      const options = typeof codeOrOptions === "string" ? {code: codeOrOptions} : codeOrOptions;
      if (callback) {
        this.getTokenAsync(options).then((r) => callback(null, r.tokens, r.res), (e) => callback(e, null, e.response));
      } else {
        return this.getTokenAsync(options);
      }
    }
    async getTokenAsync(options) {
      const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;
      const values = {
        code: options.code,
        client_id: options.client_id || this._clientId,
        client_secret: this._clientSecret,
        redirect_uri: options.redirect_uri || this.redirectUri,
        grant_type: "authorization_code",
        code_verifier: options.codeVerifier
      };
      const res = await this.transporter.request({
        method: "POST",
        url,
        data: querystring.stringify(values),
        headers: {"Content-Type": "application/x-www-form-urlencoded"}
      });
      const tokens = res.data;
      if (res.data && res.data.expires_in) {
        tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1e3;
        delete tokens.expires_in;
      }
      this.emit("tokens", tokens);
      return {tokens, res};
    }
    async refreshToken(refreshToken) {
      if (!refreshToken) {
        return this.refreshTokenNoCache(refreshToken);
      }
      if (this.refreshTokenPromises.has(refreshToken)) {
        return this.refreshTokenPromises.get(refreshToken);
      }
      const p = this.refreshTokenNoCache(refreshToken).then((r) => {
        this.refreshTokenPromises.delete(refreshToken);
        return r;
      }, (e) => {
        this.refreshTokenPromises.delete(refreshToken);
        throw e;
      });
      this.refreshTokenPromises.set(refreshToken, p);
      return p;
    }
    async refreshTokenNoCache(refreshToken) {
      if (!refreshToken) {
        throw new Error("No refresh token is set.");
      }
      const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;
      const data = {
        refresh_token: refreshToken,
        client_id: this._clientId,
        client_secret: this._clientSecret,
        grant_type: "refresh_token"
      };
      const res = await this.transporter.request({
        method: "POST",
        url,
        data: querystring.stringify(data),
        headers: {"Content-Type": "application/x-www-form-urlencoded"}
      });
      const tokens = res.data;
      if (res.data && res.data.expires_in) {
        tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1e3;
        delete tokens.expires_in;
      }
      this.emit("tokens", tokens);
      return {tokens, res};
    }
    refreshAccessToken(callback) {
      if (callback) {
        this.refreshAccessTokenAsync().then((r) => callback(null, r.credentials, r.res), callback);
      } else {
        return this.refreshAccessTokenAsync();
      }
    }
    async refreshAccessTokenAsync() {
      const r = await this.refreshToken(this.credentials.refresh_token);
      const tokens = r.tokens;
      tokens.refresh_token = this.credentials.refresh_token;
      this.credentials = tokens;
      return {credentials: this.credentials, res: r.res};
    }
    getAccessToken(callback) {
      if (callback) {
        this.getAccessTokenAsync().then((r) => callback(null, r.token, r.res), callback);
      } else {
        return this.getAccessTokenAsync();
      }
    }
    async getAccessTokenAsync() {
      const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();
      if (shouldRefresh) {
        if (!this.credentials.refresh_token) {
          throw new Error("No refresh token is set.");
        }
        const r = await this.refreshAccessTokenAsync();
        if (!r.credentials || r.credentials && !r.credentials.access_token) {
          throw new Error("Could not refresh access token.");
        }
        return {token: r.credentials.access_token, res: r.res};
      } else {
        return {token: this.credentials.access_token};
      }
    }
    async getRequestHeaders(url) {
      const headers = (await this.getRequestMetadataAsync(url)).headers;
      return headers;
    }
    async getRequestMetadataAsync(url) {
      const thisCreds = this.credentials;
      if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {
        throw new Error("No access, refresh token or API key is set.");
      }
      if (thisCreds.access_token && !this.isTokenExpiring()) {
        thisCreds.token_type = thisCreds.token_type || "Bearer";
        const headers2 = {
          Authorization: thisCreds.token_type + " " + thisCreds.access_token
        };
        return {headers: this.addSharedMetadataHeaders(headers2)};
      }
      if (this.apiKey) {
        return {headers: {"X-Goog-Api-Key": this.apiKey}};
      }
      let r = null;
      let tokens = null;
      try {
        r = await this.refreshToken(thisCreds.refresh_token);
        tokens = r.tokens;
      } catch (err) {
        const e = err;
        if (e.response && (e.response.status === 403 || e.response.status === 404)) {
          e.message = `Could not refresh access token: ${e.message}`;
        }
        throw e;
      }
      const credentials = this.credentials;
      credentials.token_type = credentials.token_type || "Bearer";
      tokens.refresh_token = credentials.refresh_token;
      this.credentials = tokens;
      const headers = {
        Authorization: credentials.token_type + " " + tokens.access_token
      };
      return {headers: this.addSharedMetadataHeaders(headers), res: r.res};
    }
    static getRevokeTokenUrl(token) {
      const parameters = querystring.stringify({token});
      return `${OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_}?${parameters}`;
    }
    revokeToken(token, callback) {
      const opts = {
        url: OAuth2Client.getRevokeTokenUrl(token),
        method: "POST"
      };
      if (callback) {
        this.transporter.request(opts).then((r) => callback(null, r), callback);
      } else {
        return this.transporter.request(opts);
      }
    }
    revokeCredentials(callback) {
      if (callback) {
        this.revokeCredentialsAsync().then((res) => callback(null, res), callback);
      } else {
        return this.revokeCredentialsAsync();
      }
    }
    async revokeCredentialsAsync() {
      const token = this.credentials.access_token;
      this.credentials = {};
      if (token) {
        return this.revokeToken(token);
      } else {
        throw new Error("No access token to revoke.");
      }
    }
    request(opts, callback) {
      if (callback) {
        this.requestAsync(opts).then((r) => callback(null, r), (e) => {
          return callback(e, e.response);
        });
      } else {
        return this.requestAsync(opts);
      }
    }
    async requestAsync(opts, retry = false) {
      let r2;
      try {
        const r = await this.getRequestMetadataAsync(opts.url);
        opts.headers = opts.headers || {};
        if (r.headers && r.headers["x-goog-user-project"]) {
          opts.headers["x-goog-user-project"] = r.headers["x-goog-user-project"];
        }
        if (r.headers && r.headers.Authorization) {
          opts.headers.Authorization = r.headers.Authorization;
        }
        if (this.apiKey) {
          opts.headers["X-Goog-Api-Key"] = this.apiKey;
        }
        r2 = await this.transporter.request(opts);
      } catch (e) {
        const res = e.response;
        if (res) {
          const statusCode = res.status;
          const mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure);
          const isReadableStream = res.config.data instanceof stream.Readable;
          const isAuthErr = statusCode === 401 || statusCode === 403;
          if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) {
            await this.refreshAccessTokenAsync();
            return this.requestAsync(opts, true);
          }
        }
        throw e;
      }
      return r2;
    }
    verifyIdToken(options, callback) {
      if (callback && typeof callback !== "function") {
        throw new Error("This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.");
      }
      if (callback) {
        this.verifyIdTokenAsync(options).then((r) => callback(null, r), callback);
      } else {
        return this.verifyIdTokenAsync(options);
      }
    }
    async verifyIdTokenAsync(options) {
      if (!options.idToken) {
        throw new Error("The verifyIdToken method requires an ID Token");
      }
      const response = await this.getFederatedSignonCertsAsync();
      const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);
      return login;
    }
    async getTokenInfo(accessToken) {
      const {data} = await this.transporter.request({
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Authorization: `Bearer ${accessToken}`
        },
        url: OAuth2Client.GOOGLE_TOKEN_INFO_URL
      });
      const info = Object.assign({
        expiry_date: new Date().getTime() + data.expires_in * 1e3,
        scopes: data.scope.split(" ")
      }, data);
      delete info.expires_in;
      delete info.scope;
      return info;
    }
    getFederatedSignonCerts(callback) {
      if (callback) {
        this.getFederatedSignonCertsAsync().then((r) => callback(null, r.certs, r.res), callback);
      } else {
        return this.getFederatedSignonCertsAsync();
      }
    }
    async getFederatedSignonCertsAsync() {
      const nowTime = new Date().getTime();
      const format = crypto_1.hasBrowserCrypto() ? CertificateFormat.JWK : CertificateFormat.PEM;
      if (this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format) {
        return {certs: this.certificateCache, format};
      }
      let res;
      let url;
      switch (format) {
        case CertificateFormat.PEM:
          url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;
          break;
        case CertificateFormat.JWK:
          url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;
          break;
        default:
          throw new Error(`Unsupported certificate format ${format}`);
      }
      try {
        res = await this.transporter.request({url});
      } catch (e) {
        e.message = `Failed to retrieve verification certificates: ${e.message}`;
        throw e;
      }
      const cacheControl = res ? res.headers["cache-control"] : void 0;
      let cacheAge = -1;
      if (cacheControl) {
        const pattern = new RegExp("max-age=([0-9]*)");
        const regexResult = pattern.exec(cacheControl);
        if (regexResult && regexResult.length === 2) {
          cacheAge = Number(regexResult[1]) * 1e3;
        }
      }
      let certificates = {};
      switch (format) {
        case CertificateFormat.PEM:
          certificates = res.data;
          break;
        case CertificateFormat.JWK:
          for (const key of res.data.keys) {
            certificates[key.kid] = key;
          }
          break;
        default:
          throw new Error(`Unsupported certificate format ${format}`);
      }
      const now = new Date();
      this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);
      this.certificateCache = certificates;
      this.certificateCacheFormat = format;
      return {certs: certificates, format, res};
    }
    getIapPublicKeys(callback) {
      if (callback) {
        this.getIapPublicKeysAsync().then((r) => callback(null, r.pubkeys, r.res), callback);
      } else {
        return this.getIapPublicKeysAsync();
      }
    }
    async getIapPublicKeysAsync() {
      let res;
      const url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;
      try {
        res = await this.transporter.request({url});
      } catch (e) {
        e.message = `Failed to retrieve verification certificates: ${e.message}`;
        throw e;
      }
      return {pubkeys: res.data, res};
    }
    verifySignedJwtWithCerts() {
      throw new Error("verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.");
    }
    async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {
      const crypto2 = crypto_1.createCrypto();
      if (!maxExpiry) {
        maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;
      }
      const segments = jwt.split(".");
      if (segments.length !== 3) {
        throw new Error("Wrong number of segments in token: " + jwt);
      }
      const signed = segments[0] + "." + segments[1];
      let signature = segments[2];
      let envelope;
      let payload;
      try {
        envelope = JSON.parse(crypto2.decodeBase64StringUtf8(segments[0]));
      } catch (err) {
        err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;
        throw err;
      }
      if (!envelope) {
        throw new Error("Can't parse token envelope: " + segments[0]);
      }
      try {
        payload = JSON.parse(crypto2.decodeBase64StringUtf8(segments[1]));
      } catch (err) {
        err.message = `Can't parse token payload '${segments[0]}`;
        throw err;
      }
      if (!payload) {
        throw new Error("Can't parse token payload: " + segments[1]);
      }
      if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {
        throw new Error("No pem found for envelope: " + JSON.stringify(envelope));
      }
      const cert = certs[envelope.kid];
      if (envelope.alg === "ES256") {
        signature = formatEcdsa.joseToDer(signature, "ES256").toString("base64");
      }
      const verified = await crypto2.verify(cert, signed, signature);
      if (!verified) {
        throw new Error("Invalid token signature: " + jwt);
      }
      if (!payload.iat) {
        throw new Error("No issue time in token: " + JSON.stringify(payload));
      }
      if (!payload.exp) {
        throw new Error("No expiration time in token: " + JSON.stringify(payload));
      }
      const iat = Number(payload.iat);
      if (isNaN(iat))
        throw new Error("iat field using invalid format");
      const exp = Number(payload.exp);
      if (isNaN(exp))
        throw new Error("exp field using invalid format");
      const now = new Date().getTime() / 1e3;
      if (exp >= now + maxExpiry) {
        throw new Error("Expiration time too far in future: " + JSON.stringify(payload));
      }
      const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;
      const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;
      if (now < earliest) {
        throw new Error("Token used too early, " + now + " < " + earliest + ": " + JSON.stringify(payload));
      }
      if (now > latest) {
        throw new Error("Token used too late, " + now + " > " + latest + ": " + JSON.stringify(payload));
      }
      if (issuers && issuers.indexOf(payload.iss) < 0) {
        throw new Error("Invalid issuer, expected one of [" + issuers + "], but got " + payload.iss);
      }
      if (typeof requiredAudience !== "undefined" && requiredAudience !== null) {
        const aud = payload.aud;
        let audVerified = false;
        if (requiredAudience.constructor === Array) {
          audVerified = requiredAudience.indexOf(aud) > -1;
        } else {
          audVerified = aud === requiredAudience;
        }
        if (!audVerified) {
          throw new Error("Wrong recipient, payload audience != requiredAudience");
        }
      }
      return new loginticket_1.LoginTicket(envelope, payload);
    }
    isTokenExpiring() {
      const expiryDate = this.credentials.expiry_date;
      return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;
    }
  };
  exports2.OAuth2Client = OAuth2Client;
  OAuth2Client.GOOGLE_TOKEN_INFO_URL = "https://oauth2.googleapis.com/tokeninfo";
  OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = "https://accounts.google.com/o/oauth2/v2/auth";
  OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = "https://oauth2.googleapis.com/token";
  OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = "https://oauth2.googleapis.com/revoke";
  OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = "https://www.googleapis.com/oauth2/v1/certs";
  OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = "https://www.googleapis.com/oauth2/v3/certs";
  OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = "https://www.gstatic.com/iap/verify/public_key";
  OAuth2Client.CLOCK_SKEW_SECS_ = 300;
  OAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;
  OAuth2Client.ISSUERS_ = [
    "accounts.google.com",
    "https://accounts.google.com"
  ];
});

// node_modules/google-auth-library/build/src/auth/computeclient.js
var require_computeclient = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Compute = void 0;
  var arrify = require_arrify();
  var gcpMetadata = require_src4();
  var oauth2client_1 = require_oauth2client();
  var Compute = class extends oauth2client_1.OAuth2Client {
    constructor(options = {}) {
      super(options);
      this.credentials = {expiry_date: 1, refresh_token: "compute-placeholder"};
      this.serviceAccountEmail = options.serviceAccountEmail || "default";
      this.scopes = arrify(options.scopes);
    }
    async refreshTokenNoCache(refreshToken) {
      const tokenPath = `service-accounts/${this.serviceAccountEmail}/token`;
      let data;
      try {
        const instanceOptions = {
          property: tokenPath
        };
        if (this.scopes.length > 0) {
          instanceOptions.params = {
            scopes: this.scopes.join(",")
          };
        }
        data = await gcpMetadata.instance(instanceOptions);
      } catch (e) {
        e.message = `Could not refresh access token: ${e.message}`;
        this.wrapError(e);
        throw e;
      }
      const tokens = data;
      if (data && data.expires_in) {
        tokens.expiry_date = new Date().getTime() + data.expires_in * 1e3;
        delete tokens.expires_in;
      }
      this.emit("tokens", tokens);
      return {tokens, res: null};
    }
    async fetchIdToken(targetAudience) {
      const idTokenPath = `service-accounts/${this.serviceAccountEmail}/identity?format=full&audience=${targetAudience}`;
      let idToken;
      try {
        const instanceOptions = {
          property: idTokenPath
        };
        idToken = await gcpMetadata.instance(instanceOptions);
      } catch (e) {
        e.message = `Could not fetch ID token: ${e.message}`;
        throw e;
      }
      return idToken;
    }
    wrapError(e) {
      const res = e.response;
      if (res && res.status) {
        e.code = res.status.toString();
        if (res.status === 403) {
          e.message = "A Forbidden error was returned while attempting to retrieve an access token for the Compute Engine built-in service account. This may be because the Compute Engine instance does not have the correct permission scopes specified: " + e.message;
        } else if (res.status === 404) {
          e.message = "A Not Found error was returned while attempting to retrieve an accesstoken for the Compute Engine built-in service account. This may be because the Compute Engine instance does not have any permission scopes specified: " + e.message;
        }
      }
    }
  };
  exports2.Compute = Compute;
});

// node_modules/google-auth-library/build/src/auth/idtokenclient.js
var require_idtokenclient = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.IdTokenClient = void 0;
  var oauth2client_1 = require_oauth2client();
  var IdTokenClient = class extends oauth2client_1.OAuth2Client {
    constructor(options) {
      super();
      this.targetAudience = options.targetAudience;
      this.idTokenProvider = options.idTokenProvider;
    }
    async getRequestMetadataAsync(url) {
      if (!this.credentials.id_token || (this.credentials.expiry_date || 0) < Date.now()) {
        const idToken = await this.idTokenProvider.fetchIdToken(this.targetAudience);
        this.credentials = {
          id_token: idToken,
          expiry_date: this.getIdTokenExpiryDate(idToken)
        };
      }
      const headers = {
        Authorization: "Bearer " + this.credentials.id_token
      };
      return {headers};
    }
    getIdTokenExpiryDate(idToken) {
      const payloadB64 = idToken.split(".")[1];
      if (payloadB64) {
        const payload = JSON.parse(Buffer.from(payloadB64, "base64").toString("ascii"));
        return payload.exp * 1e3;
      }
    }
  };
  exports2.IdTokenClient = IdTokenClient;
});

// node_modules/google-auth-library/build/src/auth/envDetect.js
var require_envDetect = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getEnv = exports2.clear = exports2.GCPEnv = void 0;
  var gcpMetadata = require_src4();
  var GCPEnv;
  (function(GCPEnv2) {
    GCPEnv2["APP_ENGINE"] = "APP_ENGINE";
    GCPEnv2["KUBERNETES_ENGINE"] = "KUBERNETES_ENGINE";
    GCPEnv2["CLOUD_FUNCTIONS"] = "CLOUD_FUNCTIONS";
    GCPEnv2["COMPUTE_ENGINE"] = "COMPUTE_ENGINE";
    GCPEnv2["NONE"] = "NONE";
  })(GCPEnv = exports2.GCPEnv || (exports2.GCPEnv = {}));
  var envPromise;
  function clear() {
    envPromise = void 0;
  }
  exports2.clear = clear;
  async function getEnv() {
    if (envPromise) {
      return envPromise;
    }
    envPromise = getEnvMemoized();
    return envPromise;
  }
  exports2.getEnv = getEnv;
  async function getEnvMemoized() {
    let env = GCPEnv.NONE;
    if (isAppEngine()) {
      env = GCPEnv.APP_ENGINE;
    } else if (isCloudFunction()) {
      env = GCPEnv.CLOUD_FUNCTIONS;
    } else if (await isComputeEngine()) {
      if (await isKubernetesEngine()) {
        env = GCPEnv.KUBERNETES_ENGINE;
      } else {
        env = GCPEnv.COMPUTE_ENGINE;
      }
    } else {
      env = GCPEnv.NONE;
    }
    return env;
  }
  function isAppEngine() {
    return !!(process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME);
  }
  function isCloudFunction() {
    return !!(process.env.FUNCTION_NAME || process.env.FUNCTION_TARGET);
  }
  async function isKubernetesEngine() {
    try {
      await gcpMetadata.instance("attributes/cluster-name");
      return true;
    } catch (e) {
      return false;
    }
  }
  async function isComputeEngine() {
    return gcpMetadata.isAvailable();
  }
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS((exports2, module2) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var Stream = require("stream");
  var util = require("util");
  function DataStream(data) {
    this.buffer = null;
    this.writable = true;
    this.readable = true;
    if (!data) {
      this.buffer = Buffer2.alloc(0);
      return this;
    }
    if (typeof data.pipe === "function") {
      this.buffer = Buffer2.alloc(0);
      data.pipe(this);
      return this;
    }
    if (data.length || typeof data === "object") {
      this.buffer = data;
      this.writable = false;
      process.nextTick(function() {
        this.emit("end", data);
        this.readable = false;
        this.emit("close");
      }.bind(this));
      return this;
    }
    throw new TypeError("Unexpected data type (" + typeof data + ")");
  }
  util.inherits(DataStream, Stream);
  DataStream.prototype.write = function write(data) {
    this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
    this.emit("data", data);
  };
  DataStream.prototype.end = function end(data) {
    if (data)
      this.write(data);
    this.emit("end", data);
    this.emit("close");
    this.writable = false;
    this.readable = false;
  };
  module2.exports = DataStream;
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS((exports2, module2) => {
  "use strict";
  var Buffer2 = require("buffer").Buffer;
  var SlowBuffer = require("buffer").SlowBuffer;
  module2.exports = bufferEq;
  function bufferEq(a, b) {
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    var c = 0;
    for (var i = 0; i < a.length; i++) {
      c |= a[i] ^ b[i];
    }
    return c === 0;
  }
  bufferEq.install = function() {
    Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
      return bufferEq(this, that);
    };
  };
  var origBufEqual = Buffer2.prototype.equal;
  var origSlowBufEqual = SlowBuffer.prototype.equal;
  bufferEq.restore = function() {
    Buffer2.prototype.equal = origBufEqual;
    SlowBuffer.prototype.equal = origSlowBufEqual;
  };
});

// node_modules/jwa/index.js
var require_jwa = __commonJS((exports2, module2) => {
  var bufferEqual = require_buffer_equal_constant_time();
  var Buffer2 = require_safe_buffer().Buffer;
  var crypto2 = require("crypto");
  var formatEcdsa = require_ecdsa_sig_formatter();
  var util = require("util");
  var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
  var MSG_INVALID_SECRET = "secret must be a string or buffer";
  var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
  var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
  var supportsKeyObjects = typeof crypto2.createPublicKey === "function";
  if (supportsKeyObjects) {
    MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
    MSG_INVALID_SECRET += "or a KeyObject";
  }
  function checkIsPublicKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.type !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.asymmetricKeyType !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
  }
  function checkIsPrivateKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (typeof key === "object") {
      return;
    }
    throw typeError(MSG_INVALID_SIGNER_KEY);
  }
  function checkIsSecretKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return key;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (key.type !== "secret") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_SECRET);
    }
  }
  function fromBase64(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function toBase64(base64url) {
    base64url = base64url.toString();
    var padding = 4 - base64url.length % 4;
    if (padding !== 4) {
      for (var i = 0; i < padding; ++i) {
        base64url += "=";
      }
    }
    return base64url.replace(/\-/g, "+").replace(/_/g, "/");
  }
  function typeError(template) {
    var args = [].slice.call(arguments, 1);
    var errMsg = util.format.bind(util, template).apply(null, args);
    return new TypeError(errMsg);
  }
  function bufferOrString(obj) {
    return Buffer2.isBuffer(obj) || typeof obj === "string";
  }
  function normalizeInput(thing) {
    if (!bufferOrString(thing))
      thing = JSON.stringify(thing);
    return thing;
  }
  function createHmacSigner(bits) {
    return function sign(thing, secret) {
      checkIsSecretKey(secret);
      thing = normalizeInput(thing);
      var hmac = crypto2.createHmac("sha" + bits, secret);
      var sig = (hmac.update(thing), hmac.digest("base64"));
      return fromBase64(sig);
    };
  }
  function createHmacVerifier(bits) {
    return function verify(thing, signature, secret) {
      var computedSig = createHmacSigner(bits)(thing, secret);
      return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
    };
  }
  function createKeySigner(bits) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto2.createSign("RSA-SHA" + bits);
      var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
      return fromBase64(sig);
    };
  }
  function createKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto2.createVerify("RSA-SHA" + bits);
      verifier.update(thing);
      return verifier.verify(publicKey, signature, "base64");
    };
  }
  function createPSSKeySigner(bits) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto2.createSign("RSA-SHA" + bits);
      var sig = (signer.update(thing), signer.sign({
        key: privateKey,
        padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
      }, "base64"));
      return fromBase64(sig);
    };
  }
  function createPSSKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto2.createVerify("RSA-SHA" + bits);
      verifier.update(thing);
      return verifier.verify({
        key: publicKey,
        padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
      }, signature, "base64");
    };
  }
  function createECDSASigner(bits) {
    var inner = createKeySigner(bits);
    return function sign() {
      var signature = inner.apply(null, arguments);
      signature = formatEcdsa.derToJose(signature, "ES" + bits);
      return signature;
    };
  }
  function createECDSAVerifer(bits) {
    var inner = createKeyVerifier(bits);
    return function verify(thing, signature, publicKey) {
      signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
      var result = inner(thing, signature, publicKey);
      return result;
    };
  }
  function createNoneSigner() {
    return function sign() {
      return "";
    };
  }
  function createNoneVerifier() {
    return function verify(thing, signature) {
      return signature === "";
    };
  }
  module2.exports = function jwa(algorithm) {
    var signerFactories = {
      hs: createHmacSigner,
      rs: createKeySigner,
      ps: createPSSKeySigner,
      es: createECDSASigner,
      none: createNoneSigner
    };
    var verifierFactories = {
      hs: createHmacVerifier,
      rs: createKeyVerifier,
      ps: createPSSKeyVerifier,
      es: createECDSAVerifer,
      none: createNoneVerifier
    };
    var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
    if (!match)
      throw typeError(MSG_INVALID_ALGORITHM, algorithm);
    var algo = (match[1] || match[3]).toLowerCase();
    var bits = match[2];
    return {
      sign: signerFactories[algo](bits),
      verify: verifierFactories[algo](bits)
    };
  };
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS((exports2, module2) => {
  var Buffer2 = require("buffer").Buffer;
  module2.exports = function toString(obj) {
    if (typeof obj === "string")
      return obj;
    if (typeof obj === "number" || Buffer2.isBuffer(obj))
      return obj.toString();
    return JSON.stringify(obj);
  };
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS((exports2, module2) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream = require("stream");
  var toString = require_tostring();
  var util = require("util");
  function base64url(string, encoding) {
    return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function jwsSecuredInput(header, payload, encoding) {
    encoding = encoding || "utf8";
    var encodedHeader = base64url(toString(header), "binary");
    var encodedPayload = base64url(toString(payload), encoding);
    return util.format("%s.%s", encodedHeader, encodedPayload);
  }
  function jwsSign(opts) {
    var header = opts.header;
    var payload = opts.payload;
    var secretOrKey = opts.secret || opts.privateKey;
    var encoding = opts.encoding;
    var algo = jwa(header.alg);
    var securedInput = jwsSecuredInput(header, payload, encoding);
    var signature = algo.sign(securedInput, secretOrKey);
    return util.format("%s.%s", securedInput, signature);
  }
  function SignStream(opts) {
    var secret = opts.secret || opts.privateKey || opts.key;
    var secretStream = new DataStream(secret);
    this.readable = true;
    this.header = opts.header;
    this.encoding = opts.encoding;
    this.secret = this.privateKey = this.key = secretStream;
    this.payload = new DataStream(opts.payload);
    this.secret.once("close", function() {
      if (!this.payload.writable && this.readable)
        this.sign();
    }.bind(this));
    this.payload.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.sign();
    }.bind(this));
  }
  util.inherits(SignStream, Stream);
  SignStream.prototype.sign = function sign() {
    try {
      var signature = jwsSign({
        header: this.header,
        payload: this.payload.buffer,
        secret: this.secret.buffer,
        encoding: this.encoding
      });
      this.emit("done", signature);
      this.emit("data", signature);
      this.emit("end");
      this.readable = false;
      return signature;
    } catch (e) {
      this.readable = false;
      this.emit("error", e);
      this.emit("close");
    }
  };
  SignStream.sign = jwsSign;
  module2.exports = SignStream;
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS((exports2, module2) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream = require("stream");
  var toString = require_tostring();
  var util = require("util");
  var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
  function isObject(thing) {
    return Object.prototype.toString.call(thing) === "[object Object]";
  }
  function safeJsonParse(thing) {
    if (isObject(thing))
      return thing;
    try {
      return JSON.parse(thing);
    } catch (e) {
      return void 0;
    }
  }
  function headerFromJWS(jwsSig) {
    var encodedHeader = jwsSig.split(".", 1)[0];
    return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
  }
  function securedInputFromJWS(jwsSig) {
    return jwsSig.split(".", 2).join(".");
  }
  function signatureFromJWS(jwsSig) {
    return jwsSig.split(".")[2];
  }
  function payloadFromJWS(jwsSig, encoding) {
    encoding = encoding || "utf8";
    var payload = jwsSig.split(".")[1];
    return Buffer2.from(payload, "base64").toString(encoding);
  }
  function isValidJws(string) {
    return JWS_REGEX.test(string) && !!headerFromJWS(string);
  }
  function jwsVerify(jwsSig, algorithm, secretOrKey) {
    if (!algorithm) {
      var err = new Error("Missing algorithm parameter for jws.verify");
      err.code = "MISSING_ALGORITHM";
      throw err;
    }
    jwsSig = toString(jwsSig);
    var signature = signatureFromJWS(jwsSig);
    var securedInput = securedInputFromJWS(jwsSig);
    var algo = jwa(algorithm);
    return algo.verify(securedInput, signature, secretOrKey);
  }
  function jwsDecode(jwsSig, opts) {
    opts = opts || {};
    jwsSig = toString(jwsSig);
    if (!isValidJws(jwsSig))
      return null;
    var header = headerFromJWS(jwsSig);
    if (!header)
      return null;
    var payload = payloadFromJWS(jwsSig);
    if (header.typ === "JWT" || opts.json)
      payload = JSON.parse(payload, opts.encoding);
    return {
      header,
      payload,
      signature: signatureFromJWS(jwsSig)
    };
  }
  function VerifyStream(opts) {
    opts = opts || {};
    var secretOrKey = opts.secret || opts.publicKey || opts.key;
    var secretStream = new DataStream(secretOrKey);
    this.readable = true;
    this.algorithm = opts.algorithm;
    this.encoding = opts.encoding;
    this.secret = this.publicKey = this.key = secretStream;
    this.signature = new DataStream(opts.signature);
    this.secret.once("close", function() {
      if (!this.signature.writable && this.readable)
        this.verify();
    }.bind(this));
    this.signature.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.verify();
    }.bind(this));
  }
  util.inherits(VerifyStream, Stream);
  VerifyStream.prototype.verify = function verify() {
    try {
      var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
      var obj = jwsDecode(this.signature.buffer, this.encoding);
      this.emit("done", valid, obj);
      this.emit("data", valid);
      this.emit("end");
      this.readable = false;
      return valid;
    } catch (e) {
      this.readable = false;
      this.emit("error", e);
      this.emit("close");
    }
  };
  VerifyStream.decode = jwsDecode;
  VerifyStream.isValid = isValidJws;
  VerifyStream.verify = jwsVerify;
  module2.exports = VerifyStream;
});

// node_modules/jws/index.js
var require_jws = __commonJS((exports2) => {
  var SignStream = require_sign_stream();
  var VerifyStream = require_verify_stream();
  var ALGORITHMS = [
    "HS256",
    "HS384",
    "HS512",
    "RS256",
    "RS384",
    "RS512",
    "PS256",
    "PS384",
    "PS512",
    "ES256",
    "ES384",
    "ES512"
  ];
  exports2.ALGORITHMS = ALGORITHMS;
  exports2.sign = SignStream.sign;
  exports2.verify = VerifyStream.verify;
  exports2.decode = VerifyStream.decode;
  exports2.isValid = VerifyStream.isValid;
  exports2.createSign = function createSign(opts) {
    return new SignStream(opts);
  };
  exports2.createVerify = function createVerify(opts) {
    return new VerifyStream(opts);
  };
});

// node_modules/node-forge/lib/forge.js
var require_forge = __commonJS((exports2, module2) => {
  module2.exports = {
    options: {
      usePureJavaScript: false
    }
  };
});

// node_modules/node-forge/lib/baseN.js
var require_baseN = __commonJS((exports2, module2) => {
  var api = {};
  module2.exports = api;
  var _reverseAlphabets = {};
  api.encode = function(input, alphabet, maxline) {
    if (typeof alphabet !== "string") {
      throw new TypeError('"alphabet" must be a string.');
    }
    if (maxline !== void 0 && typeof maxline !== "number") {
      throw new TypeError('"maxline" must be a number.');
    }
    var output = "";
    if (!(input instanceof Uint8Array)) {
      output = _encodeWithByteBuffer(input, alphabet);
    } else {
      var i = 0;
      var base = alphabet.length;
      var first = alphabet.charAt(0);
      var digits = [0];
      for (i = 0; i < input.length; ++i) {
        for (var j = 0, carry = input[i]; j < digits.length; ++j) {
          carry += digits[j] << 8;
          digits[j] = carry % base;
          carry = carry / base | 0;
        }
        while (carry > 0) {
          digits.push(carry % base);
          carry = carry / base | 0;
        }
      }
      for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
        output += first;
      }
      for (i = digits.length - 1; i >= 0; --i) {
        output += alphabet[digits[i]];
      }
    }
    if (maxline) {
      var regex = new RegExp(".{1," + maxline + "}", "g");
      output = output.match(regex).join("\r\n");
    }
    return output;
  };
  api.decode = function(input, alphabet) {
    if (typeof input !== "string") {
      throw new TypeError('"input" must be a string.');
    }
    if (typeof alphabet !== "string") {
      throw new TypeError('"alphabet" must be a string.');
    }
    var table = _reverseAlphabets[alphabet];
    if (!table) {
      table = _reverseAlphabets[alphabet] = [];
      for (var i = 0; i < alphabet.length; ++i) {
        table[alphabet.charCodeAt(i)] = i;
      }
    }
    input = input.replace(/\s/g, "");
    var base = alphabet.length;
    var first = alphabet.charAt(0);
    var bytes = [0];
    for (var i = 0; i < input.length; i++) {
      var value = table[input.charCodeAt(i)];
      if (value === void 0) {
        return;
      }
      for (var j = 0, carry = value; j < bytes.length; ++j) {
        carry += bytes[j] * base;
        bytes[j] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (var k = 0; input[k] === first && k < input.length - 1; ++k) {
      bytes.push(0);
    }
    if (typeof Buffer !== "undefined") {
      return Buffer.from(bytes.reverse());
    }
    return new Uint8Array(bytes.reverse());
  };
  function _encodeWithByteBuffer(input, alphabet) {
    var i = 0;
    var base = alphabet.length;
    var first = alphabet.charAt(0);
    var digits = [0];
    for (i = 0; i < input.length(); ++i) {
      for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % base;
        carry = carry / base | 0;
      }
      while (carry > 0) {
        digits.push(carry % base);
        carry = carry / base | 0;
      }
    }
    var output = "";
    for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
      output += first;
    }
    for (i = digits.length - 1; i >= 0; --i) {
      output += alphabet[digits[i]];
    }
    return output;
  }
});

// node_modules/node-forge/lib/util.js
var require_util = __commonJS((exports2, module2) => {
  var forge = require_forge();
  var baseN = require_baseN();
  var util = module2.exports = forge.util = forge.util || {};
  (function() {
    if (typeof process !== "undefined" && process.nextTick && !process.browser) {
      util.nextTick = process.nextTick;
      if (typeof setImmediate === "function") {
        util.setImmediate = setImmediate;
      } else {
        util.setImmediate = util.nextTick;
      }
      return;
    }
    if (typeof setImmediate === "function") {
      util.setImmediate = function() {
        return setImmediate.apply(void 0, arguments);
      };
      util.nextTick = function(callback) {
        return setImmediate(callback);
      };
      return;
    }
    util.setImmediate = function(callback) {
      setTimeout(callback, 0);
    };
    if (typeof window !== "undefined" && typeof window.postMessage === "function") {
      let handler2 = function(event) {
        if (event.source === window && event.data === msg) {
          event.stopPropagation();
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }
      };
      var handler = handler2;
      var msg = "forge.setImmediate";
      var callbacks = [];
      util.setImmediate = function(callback) {
        callbacks.push(callback);
        if (callbacks.length === 1) {
          window.postMessage(msg, "*");
        }
      };
      window.addEventListener("message", handler2, true);
    }
    if (typeof MutationObserver !== "undefined") {
      var now = Date.now();
      var attr = true;
      var div = document.createElement("div");
      var callbacks = [];
      new MutationObserver(function() {
        var copy = callbacks.slice();
        callbacks.length = 0;
        copy.forEach(function(callback) {
          callback();
        });
      }).observe(div, {attributes: true});
      var oldSetImmediate = util.setImmediate;
      util.setImmediate = function(callback) {
        if (Date.now() - now > 15) {
          now = Date.now();
          oldSetImmediate(callback);
        } else {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            div.setAttribute("a", attr = !attr);
          }
        }
      };
    }
    util.nextTick = util.setImmediate;
  })();
  util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
  util.globalScope = function() {
    if (util.isNodejs) {
      return global;
    }
    return typeof self === "undefined" ? window : self;
  }();
  util.isArray = Array.isArray || function(x) {
    return Object.prototype.toString.call(x) === "[object Array]";
  };
  util.isArrayBuffer = function(x) {
    return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
  };
  util.isArrayBufferView = function(x) {
    return x && util.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
  };
  function _checkBitsParam(n) {
    if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
      throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
    }
  }
  util.ByteBuffer = ByteStringBuffer;
  function ByteStringBuffer(b) {
    this.data = "";
    this.read = 0;
    if (typeof b === "string") {
      this.data = b;
    } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
      if (typeof Buffer !== "undefined" && b instanceof Buffer) {
        this.data = b.toString("binary");
      } else {
        var arr = new Uint8Array(b);
        try {
          this.data = String.fromCharCode.apply(null, arr);
        } catch (e) {
          for (var i = 0; i < arr.length; ++i) {
            this.putByte(arr[i]);
          }
        }
      }
    } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
      this.data = b.data;
      this.read = b.read;
    }
    this._constructedStringLength = 0;
  }
  util.ByteStringBuffer = ByteStringBuffer;
  var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
  util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
    this._constructedStringLength += x;
    if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
      this.data.substr(0, 1);
      this._constructedStringLength = 0;
    }
  };
  util.ByteStringBuffer.prototype.length = function() {
    return this.data.length - this.read;
  };
  util.ByteStringBuffer.prototype.isEmpty = function() {
    return this.length() <= 0;
  };
  util.ByteStringBuffer.prototype.putByte = function(b) {
    return this.putBytes(String.fromCharCode(b));
  };
  util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
    b = String.fromCharCode(b);
    var d = this.data;
    while (n > 0) {
      if (n & 1) {
        d += b;
      }
      n >>>= 1;
      if (n > 0) {
        b += b;
      }
    }
    this.data = d;
    this._optimizeConstructedString(n);
    return this;
  };
  util.ByteStringBuffer.prototype.putBytes = function(bytes) {
    this.data += bytes;
    this._optimizeConstructedString(bytes.length);
    return this;
  };
  util.ByteStringBuffer.prototype.putString = function(str) {
    return this.putBytes(util.encodeUtf8(str));
  };
  util.ByteStringBuffer.prototype.putInt16 = function(i) {
    return this.putBytes(String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
  };
  util.ByteStringBuffer.prototype.putInt24 = function(i) {
    return this.putBytes(String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
  };
  util.ByteStringBuffer.prototype.putInt32 = function(i) {
    return this.putBytes(String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
  };
  util.ByteStringBuffer.prototype.putInt16Le = function(i) {
    return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255));
  };
  util.ByteStringBuffer.prototype.putInt24Le = function(i) {
    return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255));
  };
  util.ByteStringBuffer.prototype.putInt32Le = function(i) {
    return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255));
  };
  util.ByteStringBuffer.prototype.putInt = function(i, n) {
    _checkBitsParam(n);
    var bytes = "";
    do {
      n -= 8;
      bytes += String.fromCharCode(i >> n & 255);
    } while (n > 0);
    return this.putBytes(bytes);
  };
  util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
    if (i < 0) {
      i += 2 << n - 1;
    }
    return this.putInt(i, n);
  };
  util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
    return this.putBytes(buffer.getBytes());
  };
  util.ByteStringBuffer.prototype.getByte = function() {
    return this.data.charCodeAt(this.read++);
  };
  util.ByteStringBuffer.prototype.getInt16 = function() {
    var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
    this.read += 2;
    return rval;
  };
  util.ByteStringBuffer.prototype.getInt24 = function() {
    var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
    this.read += 3;
    return rval;
  };
  util.ByteStringBuffer.prototype.getInt32 = function() {
    var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
    this.read += 4;
    return rval;
  };
  util.ByteStringBuffer.prototype.getInt16Le = function() {
    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
    this.read += 2;
    return rval;
  };
  util.ByteStringBuffer.prototype.getInt24Le = function() {
    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
    this.read += 3;
    return rval;
  };
  util.ByteStringBuffer.prototype.getInt32Le = function() {
    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
    this.read += 4;
    return rval;
  };
  util.ByteStringBuffer.prototype.getInt = function(n) {
    _checkBitsParam(n);
    var rval = 0;
    do {
      rval = (rval << 8) + this.data.charCodeAt(this.read++);
      n -= 8;
    } while (n > 0);
    return rval;
  };
  util.ByteStringBuffer.prototype.getSignedInt = function(n) {
    var x = this.getInt(n);
    var max = 2 << n - 2;
    if (x >= max) {
      x -= max << 1;
    }
    return x;
  };
  util.ByteStringBuffer.prototype.getBytes = function(count) {
    var rval;
    if (count) {
      count = Math.min(this.length(), count);
      rval = this.data.slice(this.read, this.read + count);
      this.read += count;
    } else if (count === 0) {
      rval = "";
    } else {
      rval = this.read === 0 ? this.data : this.data.slice(this.read);
      this.clear();
    }
    return rval;
  };
  util.ByteStringBuffer.prototype.bytes = function(count) {
    return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
  };
  util.ByteStringBuffer.prototype.at = function(i) {
    return this.data.charCodeAt(this.read + i);
  };
  util.ByteStringBuffer.prototype.setAt = function(i, b) {
    this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
    return this;
  };
  util.ByteStringBuffer.prototype.last = function() {
    return this.data.charCodeAt(this.data.length - 1);
  };
  util.ByteStringBuffer.prototype.copy = function() {
    var c = util.createBuffer(this.data);
    c.read = this.read;
    return c;
  };
  util.ByteStringBuffer.prototype.compact = function() {
    if (this.read > 0) {
      this.data = this.data.slice(this.read);
      this.read = 0;
    }
    return this;
  };
  util.ByteStringBuffer.prototype.clear = function() {
    this.data = "";
    this.read = 0;
    return this;
  };
  util.ByteStringBuffer.prototype.truncate = function(count) {
    var len = Math.max(0, this.length() - count);
    this.data = this.data.substr(this.read, len);
    this.read = 0;
    return this;
  };
  util.ByteStringBuffer.prototype.toHex = function() {
    var rval = "";
    for (var i = this.read; i < this.data.length; ++i) {
      var b = this.data.charCodeAt(i);
      if (b < 16) {
        rval += "0";
      }
      rval += b.toString(16);
    }
    return rval;
  };
  util.ByteStringBuffer.prototype.toString = function() {
    return util.decodeUtf8(this.bytes());
  };
  function DataBuffer(b, options) {
    options = options || {};
    this.read = options.readOffset || 0;
    this.growSize = options.growSize || 1024;
    var isArrayBuffer = util.isArrayBuffer(b);
    var isArrayBufferView = util.isArrayBufferView(b);
    if (isArrayBuffer || isArrayBufferView) {
      if (isArrayBuffer) {
        this.data = new DataView(b);
      } else {
        this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
      }
      this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
      return;
    }
    this.data = new DataView(new ArrayBuffer(0));
    this.write = 0;
    if (b !== null && b !== void 0) {
      this.putBytes(b);
    }
    if ("writeOffset" in options) {
      this.write = options.writeOffset;
    }
  }
  util.DataBuffer = DataBuffer;
  util.DataBuffer.prototype.length = function() {
    return this.write - this.read;
  };
  util.DataBuffer.prototype.isEmpty = function() {
    return this.length() <= 0;
  };
  util.DataBuffer.prototype.accommodate = function(amount, growSize) {
    if (this.length() >= amount) {
      return this;
    }
    growSize = Math.max(growSize || this.growSize, amount);
    var src = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
    var dst = new Uint8Array(this.length() + growSize);
    dst.set(src);
    this.data = new DataView(dst.buffer);
    return this;
  };
  util.DataBuffer.prototype.putByte = function(b) {
    this.accommodate(1);
    this.data.setUint8(this.write++, b);
    return this;
  };
  util.DataBuffer.prototype.fillWithByte = function(b, n) {
    this.accommodate(n);
    for (var i = 0; i < n; ++i) {
      this.data.setUint8(b);
    }
    return this;
  };
  util.DataBuffer.prototype.putBytes = function(bytes, encoding) {
    if (util.isArrayBufferView(bytes)) {
      var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
      var len = src.byteLength - src.byteOffset;
      this.accommodate(len);
      var dst = new Uint8Array(this.data.buffer, this.write);
      dst.set(src);
      this.write += len;
      return this;
    }
    if (util.isArrayBuffer(bytes)) {
      var src = new Uint8Array(bytes);
      this.accommodate(src.byteLength);
      var dst = new Uint8Array(this.data.buffer);
      dst.set(src, this.write);
      this.write += src.byteLength;
      return this;
    }
    if (bytes instanceof util.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util.isArrayBufferView(bytes.data)) {
      var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
      this.accommodate(src.byteLength);
      var dst = new Uint8Array(bytes.data.byteLength, this.write);
      dst.set(src);
      this.write += src.byteLength;
      return this;
    }
    if (bytes instanceof util.ByteStringBuffer) {
      bytes = bytes.data;
      encoding = "binary";
    }
    encoding = encoding || "binary";
    if (typeof bytes === "string") {
      var view;
      if (encoding === "hex") {
        this.accommodate(Math.ceil(bytes.length / 2));
        view = new Uint8Array(this.data.buffer, this.write);
        this.write += util.binary.hex.decode(bytes, view, this.write);
        return this;
      }
      if (encoding === "base64") {
        this.accommodate(Math.ceil(bytes.length / 4) * 3);
        view = new Uint8Array(this.data.buffer, this.write);
        this.write += util.binary.base64.decode(bytes, view, this.write);
        return this;
      }
      if (encoding === "utf8") {
        bytes = util.encodeUtf8(bytes);
        encoding = "binary";
      }
      if (encoding === "binary" || encoding === "raw") {
        this.accommodate(bytes.length);
        view = new Uint8Array(this.data.buffer, this.write);
        this.write += util.binary.raw.decode(view);
        return this;
      }
      if (encoding === "utf16") {
        this.accommodate(bytes.length * 2);
        view = new Uint16Array(this.data.buffer, this.write);
        this.write += util.text.utf16.encode(view);
        return this;
      }
      throw new Error("Invalid encoding: " + encoding);
    }
    throw Error("Invalid parameter: " + bytes);
  };
  util.DataBuffer.prototype.putBuffer = function(buffer) {
    this.putBytes(buffer);
    buffer.clear();
    return this;
  };
  util.DataBuffer.prototype.putString = function(str) {
    return this.putBytes(str, "utf16");
  };
  util.DataBuffer.prototype.putInt16 = function(i) {
    this.accommodate(2);
    this.data.setInt16(this.write, i);
    this.write += 2;
    return this;
  };
  util.DataBuffer.prototype.putInt24 = function(i) {
    this.accommodate(3);
    this.data.setInt16(this.write, i >> 8 & 65535);
    this.data.setInt8(this.write, i >> 16 & 255);
    this.write += 3;
    return this;
  };
  util.DataBuffer.prototype.putInt32 = function(i) {
    this.accommodate(4);
    this.data.setInt32(this.write, i);
    this.write += 4;
    return this;
  };
  util.DataBuffer.prototype.putInt16Le = function(i) {
    this.accommodate(2);
    this.data.setInt16(this.write, i, true);
    this.write += 2;
    return this;
  };
  util.DataBuffer.prototype.putInt24Le = function(i) {
    this.accommodate(3);
    this.data.setInt8(this.write, i >> 16 & 255);
    this.data.setInt16(this.write, i >> 8 & 65535, true);
    this.write += 3;
    return this;
  };
  util.DataBuffer.prototype.putInt32Le = function(i) {
    this.accommodate(4);
    this.data.setInt32(this.write, i, true);
    this.write += 4;
    return this;
  };
  util.DataBuffer.prototype.putInt = function(i, n) {
    _checkBitsParam(n);
    this.accommodate(n / 8);
    do {
      n -= 8;
      this.data.setInt8(this.write++, i >> n & 255);
    } while (n > 0);
    return this;
  };
  util.DataBuffer.prototype.putSignedInt = function(i, n) {
    _checkBitsParam(n);
    this.accommodate(n / 8);
    if (i < 0) {
      i += 2 << n - 1;
    }
    return this.putInt(i, n);
  };
  util.DataBuffer.prototype.getByte = function() {
    return this.data.getInt8(this.read++);
  };
  util.DataBuffer.prototype.getInt16 = function() {
    var rval = this.data.getInt16(this.read);
    this.read += 2;
    return rval;
  };
  util.DataBuffer.prototype.getInt24 = function() {
    var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
    this.read += 3;
    return rval;
  };
  util.DataBuffer.prototype.getInt32 = function() {
    var rval = this.data.getInt32(this.read);
    this.read += 4;
    return rval;
  };
  util.DataBuffer.prototype.getInt16Le = function() {
    var rval = this.data.getInt16(this.read, true);
    this.read += 2;
    return rval;
  };
  util.DataBuffer.prototype.getInt24Le = function() {
    var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
    this.read += 3;
    return rval;
  };
  util.DataBuffer.prototype.getInt32Le = function() {
    var rval = this.data.getInt32(this.read, true);
    this.read += 4;
    return rval;
  };
  util.DataBuffer.prototype.getInt = function(n) {
    _checkBitsParam(n);
    var rval = 0;
    do {
      rval = (rval << 8) + this.data.getInt8(this.read++);
      n -= 8;
    } while (n > 0);
    return rval;
  };
  util.DataBuffer.prototype.getSignedInt = function(n) {
    var x = this.getInt(n);
    var max = 2 << n - 2;
    if (x >= max) {
      x -= max << 1;
    }
    return x;
  };
  util.DataBuffer.prototype.getBytes = function(count) {
    var rval;
    if (count) {
      count = Math.min(this.length(), count);
      rval = this.data.slice(this.read, this.read + count);
      this.read += count;
    } else if (count === 0) {
      rval = "";
    } else {
      rval = this.read === 0 ? this.data : this.data.slice(this.read);
      this.clear();
    }
    return rval;
  };
  util.DataBuffer.prototype.bytes = function(count) {
    return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
  };
  util.DataBuffer.prototype.at = function(i) {
    return this.data.getUint8(this.read + i);
  };
  util.DataBuffer.prototype.setAt = function(i, b) {
    this.data.setUint8(i, b);
    return this;
  };
  util.DataBuffer.prototype.last = function() {
    return this.data.getUint8(this.write - 1);
  };
  util.DataBuffer.prototype.copy = function() {
    return new util.DataBuffer(this);
  };
  util.DataBuffer.prototype.compact = function() {
    if (this.read > 0) {
      var src = new Uint8Array(this.data.buffer, this.read);
      var dst = new Uint8Array(src.byteLength);
      dst.set(src);
      this.data = new DataView(dst);
      this.write -= this.read;
      this.read = 0;
    }
    return this;
  };
  util.DataBuffer.prototype.clear = function() {
    this.data = new DataView(new ArrayBuffer(0));
    this.read = this.write = 0;
    return this;
  };
  util.DataBuffer.prototype.truncate = function(count) {
    this.write = Math.max(0, this.length() - count);
    this.read = Math.min(this.read, this.write);
    return this;
  };
  util.DataBuffer.prototype.toHex = function() {
    var rval = "";
    for (var i = this.read; i < this.data.byteLength; ++i) {
      var b = this.data.getUint8(i);
      if (b < 16) {
        rval += "0";
      }
      rval += b.toString(16);
    }
    return rval;
  };
  util.DataBuffer.prototype.toString = function(encoding) {
    var view = new Uint8Array(this.data, this.read, this.length());
    encoding = encoding || "utf8";
    if (encoding === "binary" || encoding === "raw") {
      return util.binary.raw.encode(view);
    }
    if (encoding === "hex") {
      return util.binary.hex.encode(view);
    }
    if (encoding === "base64") {
      return util.binary.base64.encode(view);
    }
    if (encoding === "utf8") {
      return util.text.utf8.decode(view);
    }
    if (encoding === "utf16") {
      return util.text.utf16.decode(view);
    }
    throw new Error("Invalid encoding: " + encoding);
  };
  util.createBuffer = function(input, encoding) {
    encoding = encoding || "raw";
    if (input !== void 0 && encoding === "utf8") {
      input = util.encodeUtf8(input);
    }
    return new util.ByteBuffer(input);
  };
  util.fillString = function(c, n) {
    var s = "";
    while (n > 0) {
      if (n & 1) {
        s += c;
      }
      n >>>= 1;
      if (n > 0) {
        c += c;
      }
    }
    return s;
  };
  util.xorBytes = function(s1, s2, n) {
    var s3 = "";
    var b = "";
    var t = "";
    var i = 0;
    var c = 0;
    for (; n > 0; --n, ++i) {
      b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
      if (c >= 10) {
        s3 += t;
        t = "";
        c = 0;
      }
      t += String.fromCharCode(b);
      ++c;
    }
    s3 += t;
    return s3;
  };
  util.hexToBytes = function(hex) {
    var rval = "";
    var i = 0;
    if (hex.length & true) {
      i = 1;
      rval += String.fromCharCode(parseInt(hex[0], 16));
    }
    for (; i < hex.length; i += 2) {
      rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    }
    return rval;
  };
  util.bytesToHex = function(bytes) {
    return util.createBuffer(bytes).toHex();
  };
  util.int32ToBytes = function(i) {
    return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
  };
  var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var _base64Idx = [
    62,
    -1,
    -1,
    -1,
    63,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    -1,
    -1,
    -1,
    64,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51
  ];
  var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  util.encode64 = function(input, maxline) {
    var line = "";
    var output = "";
    var chr1, chr2, chr3;
    var i = 0;
    while (i < input.length) {
      chr1 = input.charCodeAt(i++);
      chr2 = input.charCodeAt(i++);
      chr3 = input.charCodeAt(i++);
      line += _base64.charAt(chr1 >> 2);
      line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
      if (isNaN(chr2)) {
        line += "==";
      } else {
        line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
        line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
      }
      if (maxline && line.length > maxline) {
        output += line.substr(0, maxline) + "\r\n";
        line = line.substr(maxline);
      }
    }
    output += line;
    return output;
  };
  util.decode64 = function(input) {
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    var output = "";
    var enc1, enc2, enc3, enc4;
    var i = 0;
    while (i < input.length) {
      enc1 = _base64Idx[input.charCodeAt(i++) - 43];
      enc2 = _base64Idx[input.charCodeAt(i++) - 43];
      enc3 = _base64Idx[input.charCodeAt(i++) - 43];
      enc4 = _base64Idx[input.charCodeAt(i++) - 43];
      output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
      if (enc3 !== 64) {
        output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
        if (enc4 !== 64) {
          output += String.fromCharCode((enc3 & 3) << 6 | enc4);
        }
      }
    }
    return output;
  };
  util.encodeUtf8 = function(str) {
    return unescape(encodeURIComponent(str));
  };
  util.decodeUtf8 = function(str) {
    return decodeURIComponent(escape(str));
  };
  util.binary = {
    raw: {},
    hex: {},
    base64: {},
    base58: {},
    baseN: {
      encode: baseN.encode,
      decode: baseN.decode
    }
  };
  util.binary.raw.encode = function(bytes) {
    return String.fromCharCode.apply(null, bytes);
  };
  util.binary.raw.decode = function(str, output, offset) {
    var out = output;
    if (!out) {
      out = new Uint8Array(str.length);
    }
    offset = offset || 0;
    var j = offset;
    for (var i = 0; i < str.length; ++i) {
      out[j++] = str.charCodeAt(i);
    }
    return output ? j - offset : out;
  };
  util.binary.hex.encode = util.bytesToHex;
  util.binary.hex.decode = function(hex, output, offset) {
    var out = output;
    if (!out) {
      out = new Uint8Array(Math.ceil(hex.length / 2));
    }
    offset = offset || 0;
    var i = 0, j = offset;
    if (hex.length & 1) {
      i = 1;
      out[j++] = parseInt(hex[0], 16);
    }
    for (; i < hex.length; i += 2) {
      out[j++] = parseInt(hex.substr(i, 2), 16);
    }
    return output ? j - offset : out;
  };
  util.binary.base64.encode = function(input, maxline) {
    var line = "";
    var output = "";
    var chr1, chr2, chr3;
    var i = 0;
    while (i < input.byteLength) {
      chr1 = input[i++];
      chr2 = input[i++];
      chr3 = input[i++];
      line += _base64.charAt(chr1 >> 2);
      line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
      if (isNaN(chr2)) {
        line += "==";
      } else {
        line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
        line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
      }
      if (maxline && line.length > maxline) {
        output += line.substr(0, maxline) + "\r\n";
        line = line.substr(maxline);
      }
    }
    output += line;
    return output;
  };
  util.binary.base64.decode = function(input, output, offset) {
    var out = output;
    if (!out) {
      out = new Uint8Array(Math.ceil(input.length / 4) * 3);
    }
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    offset = offset || 0;
    var enc1, enc2, enc3, enc4;
    var i = 0, j = offset;
    while (i < input.length) {
      enc1 = _base64Idx[input.charCodeAt(i++) - 43];
      enc2 = _base64Idx[input.charCodeAt(i++) - 43];
      enc3 = _base64Idx[input.charCodeAt(i++) - 43];
      enc4 = _base64Idx[input.charCodeAt(i++) - 43];
      out[j++] = enc1 << 2 | enc2 >> 4;
      if (enc3 !== 64) {
        out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
        if (enc4 !== 64) {
          out[j++] = (enc3 & 3) << 6 | enc4;
        }
      }
    }
    return output ? j - offset : out.subarray(0, j);
  };
  util.binary.base58.encode = function(input, maxline) {
    return util.binary.baseN.encode(input, _base58, maxline);
  };
  util.binary.base58.decode = function(input, maxline) {
    return util.binary.baseN.decode(input, _base58, maxline);
  };
  util.text = {
    utf8: {},
    utf16: {}
  };
  util.text.utf8.encode = function(str, output, offset) {
    str = util.encodeUtf8(str);
    var out = output;
    if (!out) {
      out = new Uint8Array(str.length);
    }
    offset = offset || 0;
    var j = offset;
    for (var i = 0; i < str.length; ++i) {
      out[j++] = str.charCodeAt(i);
    }
    return output ? j - offset : out;
  };
  util.text.utf8.decode = function(bytes) {
    return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
  };
  util.text.utf16.encode = function(str, output, offset) {
    var out = output;
    if (!out) {
      out = new Uint8Array(str.length * 2);
    }
    var view = new Uint16Array(out.buffer);
    offset = offset || 0;
    var j = offset;
    var k = offset;
    for (var i = 0; i < str.length; ++i) {
      view[k++] = str.charCodeAt(i);
      j += 2;
    }
    return output ? j - offset : out;
  };
  util.text.utf16.decode = function(bytes) {
    return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
  };
  util.deflate = function(api, bytes, raw) {
    bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);
    if (raw) {
      var start = 2;
      var flg = bytes.charCodeAt(1);
      if (flg & 32) {
        start = 6;
      }
      bytes = bytes.substring(start, bytes.length - 4);
    }
    return bytes;
  };
  util.inflate = function(api, bytes, raw) {
    var rval = api.inflate(util.encode64(bytes)).rval;
    return rval === null ? null : util.decode64(rval);
  };
  var _setStorageObject = function(api, id, obj) {
    if (!api) {
      throw new Error("WebStorage not available.");
    }
    var rval;
    if (obj === null) {
      rval = api.removeItem(id);
    } else {
      obj = util.encode64(JSON.stringify(obj));
      rval = api.setItem(id, obj);
    }
    if (typeof rval !== "undefined" && rval.rval !== true) {
      var error = new Error(rval.error.message);
      error.id = rval.error.id;
      error.name = rval.error.name;
      throw error;
    }
  };
  var _getStorageObject = function(api, id) {
    if (!api) {
      throw new Error("WebStorage not available.");
    }
    var rval = api.getItem(id);
    if (api.init) {
      if (rval.rval === null) {
        if (rval.error) {
          var error = new Error(rval.error.message);
          error.id = rval.error.id;
          error.name = rval.error.name;
          throw error;
        }
        rval = null;
      } else {
        rval = rval.rval;
      }
    }
    if (rval !== null) {
      rval = JSON.parse(util.decode64(rval));
    }
    return rval;
  };
  var _setItem = function(api, id, key, data) {
    var obj = _getStorageObject(api, id);
    if (obj === null) {
      obj = {};
    }
    obj[key] = data;
    _setStorageObject(api, id, obj);
  };
  var _getItem = function(api, id, key) {
    var rval = _getStorageObject(api, id);
    if (rval !== null) {
      rval = key in rval ? rval[key] : null;
    }
    return rval;
  };
  var _removeItem = function(api, id, key) {
    var obj = _getStorageObject(api, id);
    if (obj !== null && key in obj) {
      delete obj[key];
      var empty = true;
      for (var prop in obj) {
        empty = false;
        break;
      }
      if (empty) {
        obj = null;
      }
      _setStorageObject(api, id, obj);
    }
  };
  var _clearItems = function(api, id) {
    _setStorageObject(api, id, null);
  };
  var _callStorageFunction = function(func, args, location) {
    var rval = null;
    if (typeof location === "undefined") {
      location = ["web", "flash"];
    }
    var type;
    var done = false;
    var exception = null;
    for (var idx in location) {
      type = location[idx];
      try {
        if (type === "flash" || type === "both") {
          if (args[0] === null) {
            throw new Error("Flash local storage not available.");
          }
          rval = func.apply(this, args);
          done = type === "flash";
        }
        if (type === "web" || type === "both") {
          args[0] = localStorage;
          rval = func.apply(this, args);
          done = true;
        }
      } catch (ex) {
        exception = ex;
      }
      if (done) {
        break;
      }
    }
    if (!done) {
      throw exception;
    }
    return rval;
  };
  util.setItem = function(api, id, key, data, location) {
    _callStorageFunction(_setItem, arguments, location);
  };
  util.getItem = function(api, id, key, location) {
    return _callStorageFunction(_getItem, arguments, location);
  };
  util.removeItem = function(api, id, key, location) {
    _callStorageFunction(_removeItem, arguments, location);
  };
  util.clearItems = function(api, id, location) {
    _callStorageFunction(_clearItems, arguments, location);
  };
  util.parseUrl = function(str) {
    var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
    regex.lastIndex = 0;
    var m = regex.exec(str);
    var url = m === null ? null : {
      full: str,
      scheme: m[1],
      host: m[2],
      port: m[3],
      path: m[4]
    };
    if (url) {
      url.fullHost = url.host;
      if (url.port) {
        if (url.port !== 80 && url.scheme === "http") {
          url.fullHost += ":" + url.port;
        } else if (url.port !== 443 && url.scheme === "https") {
          url.fullHost += ":" + url.port;
        }
      } else if (url.scheme === "http") {
        url.port = 80;
      } else if (url.scheme === "https") {
        url.port = 443;
      }
      url.full = url.scheme + "://" + url.fullHost;
    }
    return url;
  };
  var _queryVariables = null;
  util.getQueryVariables = function(query) {
    var parse = function(q) {
      var rval2 = {};
      var kvpairs = q.split("&");
      for (var i = 0; i < kvpairs.length; i++) {
        var pos = kvpairs[i].indexOf("=");
        var key;
        var val;
        if (pos > 0) {
          key = kvpairs[i].substring(0, pos);
          val = kvpairs[i].substring(pos + 1);
        } else {
          key = kvpairs[i];
          val = null;
        }
        if (!(key in rval2)) {
          rval2[key] = [];
        }
        if (!(key in Object.prototype) && val !== null) {
          rval2[key].push(unescape(val));
        }
      }
      return rval2;
    };
    var rval;
    if (typeof query === "undefined") {
      if (_queryVariables === null) {
        if (typeof window !== "undefined" && window.location && window.location.search) {
          _queryVariables = parse(window.location.search.substring(1));
        } else {
          _queryVariables = {};
        }
      }
      rval = _queryVariables;
    } else {
      rval = parse(query);
    }
    return rval;
  };
  util.parseFragment = function(fragment) {
    var fp = fragment;
    var fq = "";
    var pos = fragment.indexOf("?");
    if (pos > 0) {
      fp = fragment.substring(0, pos);
      fq = fragment.substring(pos + 1);
    }
    var path = fp.split("/");
    if (path.length > 0 && path[0] === "") {
      path.shift();
    }
    var query = fq === "" ? {} : util.getQueryVariables(fq);
    return {
      pathString: fp,
      queryString: fq,
      path,
      query
    };
  };
  util.makeRequest = function(reqString) {
    var frag = util.parseFragment(reqString);
    var req = {
      path: frag.pathString,
      query: frag.queryString,
      getPath: function(i) {
        return typeof i === "undefined" ? frag.path : frag.path[i];
      },
      getQuery: function(k, i) {
        var rval;
        if (typeof k === "undefined") {
          rval = frag.query;
        } else {
          rval = frag.query[k];
          if (rval && typeof i !== "undefined") {
            rval = rval[i];
          }
        }
        return rval;
      },
      getQueryLast: function(k, _default) {
        var rval;
        var vals = req.getQuery(k);
        if (vals) {
          rval = vals[vals.length - 1];
        } else {
          rval = _default;
        }
        return rval;
      }
    };
    return req;
  };
  util.makeLink = function(path, query, fragment) {
    path = jQuery.isArray(path) ? path.join("/") : path;
    var qstr = jQuery.param(query || {});
    fragment = fragment || "";
    return path + (qstr.length > 0 ? "?" + qstr : "") + (fragment.length > 0 ? "#" + fragment : "");
  };
  util.isEmpty = function(obj) {
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        return false;
      }
    }
    return true;
  };
  util.format = function(format) {
    var re = /%./g;
    var match;
    var part;
    var argi = 0;
    var parts = [];
    var last = 0;
    while (match = re.exec(format)) {
      part = format.substring(last, re.lastIndex - 2);
      if (part.length > 0) {
        parts.push(part);
      }
      last = re.lastIndex;
      var code = match[0][1];
      switch (code) {
        case "s":
        case "o":
          if (argi < arguments.length) {
            parts.push(arguments[argi++ + 1]);
          } else {
            parts.push("<?>");
          }
          break;
        case "%":
          parts.push("%");
          break;
        default:
          parts.push("<%" + code + "?>");
      }
    }
    parts.push(format.substring(last));
    return parts.join("");
  };
  util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
    var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
    var d = dec_point === void 0 ? "," : dec_point;
    var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
    var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
    var j = i.length > 3 ? i.length % 3 : 0;
    return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
  };
  util.formatSize = function(size) {
    if (size >= 1073741824) {
      size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
    } else if (size >= 1048576) {
      size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB";
    } else if (size >= 1024) {
      size = util.formatNumber(size / 1024, 0) + " KiB";
    } else {
      size = util.formatNumber(size, 0) + " bytes";
    }
    return size;
  };
  util.bytesFromIP = function(ip) {
    if (ip.indexOf(".") !== -1) {
      return util.bytesFromIPv4(ip);
    }
    if (ip.indexOf(":") !== -1) {
      return util.bytesFromIPv6(ip);
    }
    return null;
  };
  util.bytesFromIPv4 = function(ip) {
    ip = ip.split(".");
    if (ip.length !== 4) {
      return null;
    }
    var b = util.createBuffer();
    for (var i = 0; i < ip.length; ++i) {
      var num = parseInt(ip[i], 10);
      if (isNaN(num)) {
        return null;
      }
      b.putByte(num);
    }
    return b.getBytes();
  };
  util.bytesFromIPv6 = function(ip) {
    var blanks = 0;
    ip = ip.split(":").filter(function(e) {
      if (e.length === 0)
        ++blanks;
      return true;
    });
    var zeros = (8 - ip.length + blanks) * 2;
    var b = util.createBuffer();
    for (var i = 0; i < 8; ++i) {
      if (!ip[i] || ip[i].length === 0) {
        b.fillWithByte(0, zeros);
        zeros = 0;
        continue;
      }
      var bytes = util.hexToBytes(ip[i]);
      if (bytes.length < 2) {
        b.putByte(0);
      }
      b.putBytes(bytes);
    }
    return b.getBytes();
  };
  util.bytesToIP = function(bytes) {
    if (bytes.length === 4) {
      return util.bytesToIPv4(bytes);
    }
    if (bytes.length === 16) {
      return util.bytesToIPv6(bytes);
    }
    return null;
  };
  util.bytesToIPv4 = function(bytes) {
    if (bytes.length !== 4) {
      return null;
    }
    var ip = [];
    for (var i = 0; i < bytes.length; ++i) {
      ip.push(bytes.charCodeAt(i));
    }
    return ip.join(".");
  };
  util.bytesToIPv6 = function(bytes) {
    if (bytes.length !== 16) {
      return null;
    }
    var ip = [];
    var zeroGroups = [];
    var zeroMaxGroup = 0;
    for (var i = 0; i < bytes.length; i += 2) {
      var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);
      while (hex[0] === "0" && hex !== "0") {
        hex = hex.substr(1);
      }
      if (hex === "0") {
        var last = zeroGroups[zeroGroups.length - 1];
        var idx = ip.length;
        if (!last || idx !== last.end + 1) {
          zeroGroups.push({start: idx, end: idx});
        } else {
          last.end = idx;
          if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
            zeroMaxGroup = zeroGroups.length - 1;
          }
        }
      }
      ip.push(hex);
    }
    if (zeroGroups.length > 0) {
      var group = zeroGroups[zeroMaxGroup];
      if (group.end - group.start > 0) {
        ip.splice(group.start, group.end - group.start + 1, "");
        if (group.start === 0) {
          ip.unshift("");
        }
        if (group.end === 7) {
          ip.push("");
        }
      }
    }
    return ip.join(":");
  };
  util.estimateCores = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    if ("cores" in util && !options.update) {
      return callback(null, util.cores);
    }
    if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
      util.cores = navigator.hardwareConcurrency;
      return callback(null, util.cores);
    }
    if (typeof Worker === "undefined") {
      util.cores = 1;
      return callback(null, util.cores);
    }
    if (typeof Blob === "undefined") {
      util.cores = 2;
      return callback(null, util.cores);
    }
    var blobUrl = URL.createObjectURL(new Blob([
      "(",
      function() {
        self.addEventListener("message", function(e) {
          var st = Date.now();
          var et = st + 4;
          while (Date.now() < et)
            ;
          self.postMessage({st, et});
        });
      }.toString(),
      ")()"
    ], {type: "application/javascript"}));
    sample([], 5, 16);
    function sample(max, samples, numWorkers) {
      if (samples === 0) {
        var avg = Math.floor(max.reduce(function(avg2, x) {
          return avg2 + x;
        }, 0) / max.length);
        util.cores = Math.max(1, avg);
        URL.revokeObjectURL(blobUrl);
        return callback(null, util.cores);
      }
      map(numWorkers, function(err, results) {
        max.push(reduce(numWorkers, results));
        sample(max, samples - 1, numWorkers);
      });
    }
    function map(numWorkers, callback2) {
      var workers = [];
      var results = [];
      for (var i = 0; i < numWorkers; ++i) {
        var worker = new Worker(blobUrl);
        worker.addEventListener("message", function(e) {
          results.push(e.data);
          if (results.length === numWorkers) {
            for (var i2 = 0; i2 < numWorkers; ++i2) {
              workers[i2].terminate();
            }
            callback2(null, results);
          }
        });
        workers.push(worker);
      }
      for (var i = 0; i < numWorkers; ++i) {
        workers[i].postMessage(i);
      }
    }
    function reduce(numWorkers, results) {
      var overlaps = [];
      for (var n = 0; n < numWorkers; ++n) {
        var r1 = results[n];
        var overlap = overlaps[n] = [];
        for (var i = 0; i < numWorkers; ++i) {
          if (n === i) {
            continue;
          }
          var r2 = results[i];
          if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
            overlap.push(i);
          }
        }
      }
      return overlaps.reduce(function(max, overlap2) {
        return Math.max(max, overlap2.length);
      }, 0);
    }
  };
});

// node_modules/node-forge/lib/cipher.js
var require_cipher = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util();
  module2.exports = forge.cipher = forge.cipher || {};
  forge.cipher.algorithms = forge.cipher.algorithms || {};
  forge.cipher.createCipher = function(algorithm, key) {
    var api = algorithm;
    if (typeof api === "string") {
      api = forge.cipher.getAlgorithm(api);
      if (api) {
        api = api();
      }
    }
    if (!api) {
      throw new Error("Unsupported algorithm: " + algorithm);
    }
    return new forge.cipher.BlockCipher({
      algorithm: api,
      key,
      decrypt: false
    });
  };
  forge.cipher.createDecipher = function(algorithm, key) {
    var api = algorithm;
    if (typeof api === "string") {
      api = forge.cipher.getAlgorithm(api);
      if (api) {
        api = api();
      }
    }
    if (!api) {
      throw new Error("Unsupported algorithm: " + algorithm);
    }
    return new forge.cipher.BlockCipher({
      algorithm: api,
      key,
      decrypt: true
    });
  };
  forge.cipher.registerAlgorithm = function(name, algorithm) {
    name = name.toUpperCase();
    forge.cipher.algorithms[name] = algorithm;
  };
  forge.cipher.getAlgorithm = function(name) {
    name = name.toUpperCase();
    if (name in forge.cipher.algorithms) {
      return forge.cipher.algorithms[name];
    }
    return null;
  };
  var BlockCipher = forge.cipher.BlockCipher = function(options) {
    this.algorithm = options.algorithm;
    this.mode = this.algorithm.mode;
    this.blockSize = this.mode.blockSize;
    this._finish = false;
    this._input = null;
    this.output = null;
    this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
    this._decrypt = options.decrypt;
    this.algorithm.initialize(options);
  };
  BlockCipher.prototype.start = function(options) {
    options = options || {};
    var opts = {};
    for (var key in options) {
      opts[key] = options[key];
    }
    opts.decrypt = this._decrypt;
    this._finish = false;
    this._input = forge.util.createBuffer();
    this.output = options.output || forge.util.createBuffer();
    this.mode.start(opts);
  };
  BlockCipher.prototype.update = function(input) {
    if (input) {
      this._input.putBuffer(input);
    }
    while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
    }
    this._input.compact();
  };
  BlockCipher.prototype.finish = function(pad) {
    if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
      this.mode.pad = function(input) {
        return pad(this.blockSize, input, false);
      };
      this.mode.unpad = function(output) {
        return pad(this.blockSize, output, true);
      };
    }
    var options = {};
    options.decrypt = this._decrypt;
    options.overflow = this._input.length() % this.blockSize;
    if (!this._decrypt && this.mode.pad) {
      if (!this.mode.pad(this._input, options)) {
        return false;
      }
    }
    this._finish = true;
    this.update();
    if (this._decrypt && this.mode.unpad) {
      if (!this.mode.unpad(this.output, options)) {
        return false;
      }
    }
    if (this.mode.afterFinish) {
      if (!this.mode.afterFinish(this.output, options)) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util();
  forge.cipher = forge.cipher || {};
  var modes = module2.exports = forge.cipher.modes = forge.cipher.modes || {};
  modes.ecb = function(options) {
    options = options || {};
    this.name = "ECB";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = new Array(this._ints);
    this._outBlock = new Array(this._ints);
  };
  modes.ecb.prototype.start = function(options) {
  };
  modes.ecb.prototype.encrypt = function(input, output, finish) {
    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
      return true;
    }
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32();
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(this._outBlock[i]);
    }
  };
  modes.ecb.prototype.decrypt = function(input, output, finish) {
    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
      return true;
    }
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32();
    }
    this.cipher.decrypt(this._inBlock, this._outBlock);
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(this._outBlock[i]);
    }
  };
  modes.ecb.prototype.pad = function(input, options) {
    var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
    input.fillWithByte(padding, padding);
    return true;
  };
  modes.ecb.prototype.unpad = function(output, options) {
    if (options.overflow > 0) {
      return false;
    }
    var len = output.length();
    var count = output.at(len - 1);
    if (count > this.blockSize << 2) {
      return false;
    }
    output.truncate(count);
    return true;
  };
  modes.cbc = function(options) {
    options = options || {};
    this.name = "CBC";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = new Array(this._ints);
    this._outBlock = new Array(this._ints);
  };
  modes.cbc.prototype.start = function(options) {
    if (options.iv === null) {
      if (!this._prev) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = this._prev.slice(0);
    } else if (!("iv" in options)) {
      throw new Error("Invalid IV parameter.");
    } else {
      this._iv = transformIV(options.iv, this.blockSize);
      this._prev = this._iv.slice(0);
    }
  };
  modes.cbc.prototype.encrypt = function(input, output, finish) {
    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
      return true;
    }
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._prev[i] ^ input.getInt32();
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(this._outBlock[i]);
    }
    this._prev = this._outBlock;
  };
  modes.cbc.prototype.decrypt = function(input, output, finish) {
    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
      return true;
    }
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32();
    }
    this.cipher.decrypt(this._inBlock, this._outBlock);
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(this._prev[i] ^ this._outBlock[i]);
    }
    this._prev = this._inBlock.slice(0);
  };
  modes.cbc.prototype.pad = function(input, options) {
    var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
    input.fillWithByte(padding, padding);
    return true;
  };
  modes.cbc.prototype.unpad = function(output, options) {
    if (options.overflow > 0) {
      return false;
    }
    var len = output.length();
    var count = output.at(len - 1);
    if (count > this.blockSize << 2) {
      return false;
    }
    output.truncate(count);
    return true;
  };
  modes.cfb = function(options) {
    options = options || {};
    this.name = "CFB";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = null;
    this._outBlock = new Array(this._ints);
    this._partialBlock = new Array(this._ints);
    this._partialOutput = forge.util.createBuffer();
    this._partialBytes = 0;
  };
  modes.cfb.prototype.start = function(options) {
    if (!("iv" in options)) {
      throw new Error("Invalid IV parameter.");
    }
    this._iv = transformIV(options.iv, this.blockSize);
    this._inBlock = this._iv.slice(0);
    this._partialBytes = 0;
  };
  modes.cfb.prototype.encrypt = function(input, output, finish) {
    var inputLength = input.length();
    if (inputLength === 0) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    if (this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
        output.putInt32(this._inBlock[i]);
      }
      return;
    }
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i = 0; i < this._ints; ++i) {
      this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
      this._partialOutput.putInt32(this._partialBlock[i]);
    }
    if (partialBytes > 0) {
      input.read -= this.blockSize;
    } else {
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = this._partialBlock[i];
      }
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish) {
      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }
    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
    this._partialBytes = 0;
  };
  modes.cfb.prototype.decrypt = function(input, output, finish) {
    var inputLength = input.length();
    if (inputLength === 0) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    if (this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
        output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
      }
      return;
    }
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i = 0; i < this._ints; ++i) {
      this._partialBlock[i] = input.getInt32();
      this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
    }
    if (partialBytes > 0) {
      input.read -= this.blockSize;
    } else {
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = this._partialBlock[i];
      }
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish) {
      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }
    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
    this._partialBytes = 0;
  };
  modes.ofb = function(options) {
    options = options || {};
    this.name = "OFB";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = null;
    this._outBlock = new Array(this._ints);
    this._partialOutput = forge.util.createBuffer();
    this._partialBytes = 0;
  };
  modes.ofb.prototype.start = function(options) {
    if (!("iv" in options)) {
      throw new Error("Invalid IV parameter.");
    }
    this._iv = transformIV(options.iv, this.blockSize);
    this._inBlock = this._iv.slice(0);
    this._partialBytes = 0;
  };
  modes.ofb.prototype.encrypt = function(input, output, finish) {
    var inputLength = input.length();
    if (input.length() === 0) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    if (this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(input.getInt32() ^ this._outBlock[i]);
        this._inBlock[i] = this._outBlock[i];
      }
      return;
    }
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i = 0; i < this._ints; ++i) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    }
    if (partialBytes > 0) {
      input.read -= this.blockSize;
    } else {
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = this._outBlock[i];
      }
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish) {
      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }
    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
    this._partialBytes = 0;
  };
  modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
  modes.ctr = function(options) {
    options = options || {};
    this.name = "CTR";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = null;
    this._outBlock = new Array(this._ints);
    this._partialOutput = forge.util.createBuffer();
    this._partialBytes = 0;
  };
  modes.ctr.prototype.start = function(options) {
    if (!("iv" in options)) {
      throw new Error("Invalid IV parameter.");
    }
    this._iv = transformIV(options.iv, this.blockSize);
    this._inBlock = this._iv.slice(0);
    this._partialBytes = 0;
  };
  modes.ctr.prototype.encrypt = function(input, output, finish) {
    var inputLength = input.length();
    if (inputLength === 0) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    if (this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
    } else {
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    }
    inc32(this._inBlock);
  };
  modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
  modes.gcm = function(options) {
    options = options || {};
    this.name = "GCM";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = new Array(this._ints);
    this._outBlock = new Array(this._ints);
    this._partialOutput = forge.util.createBuffer();
    this._partialBytes = 0;
    this._R = 3774873600;
  };
  modes.gcm.prototype.start = function(options) {
    if (!("iv" in options)) {
      throw new Error("Invalid IV parameter.");
    }
    var iv = forge.util.createBuffer(options.iv);
    this._cipherLength = 0;
    var additionalData;
    if ("additionalData" in options) {
      additionalData = forge.util.createBuffer(options.additionalData);
    } else {
      additionalData = forge.util.createBuffer();
    }
    if ("tagLength" in options) {
      this._tagLength = options.tagLength;
    } else {
      this._tagLength = 128;
    }
    this._tag = null;
    if (options.decrypt) {
      this._tag = forge.util.createBuffer(options.tag).getBytes();
      if (this._tag.length !== this._tagLength / 8) {
        throw new Error("Authentication tag does not match tag length.");
      }
    }
    this._hashBlock = new Array(this._ints);
    this.tag = null;
    this._hashSubkey = new Array(this._ints);
    this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
    this.componentBits = 4;
    this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
    var ivLength = iv.length();
    if (ivLength === 12) {
      this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
    } else {
      this._j0 = [0, 0, 0, 0];
      while (iv.length() > 0) {
        this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
      }
      this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
    }
    this._inBlock = this._j0.slice(0);
    inc32(this._inBlock);
    this._partialBytes = 0;
    additionalData = forge.util.createBuffer(additionalData);
    this._aDataLength = from64To32(additionalData.length() * 8);
    var overflow = additionalData.length() % this.blockSize;
    if (overflow) {
      additionalData.fillWithByte(0, this.blockSize - overflow);
    }
    this._s = [0, 0, 0, 0];
    while (additionalData.length() > 0) {
      this._s = this.ghash(this._hashSubkey, this._s, [
        additionalData.getInt32(),
        additionalData.getInt32(),
        additionalData.getInt32(),
        additionalData.getInt32()
      ]);
    }
  };
  modes.gcm.prototype.encrypt = function(input, output, finish) {
    var inputLength = input.length();
    if (inputLength === 0) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    if (this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i] ^= input.getInt32());
      }
      this._cipherLength += this.blockSize;
    } else {
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
      if (partialBytes <= 0 || finish) {
        if (finish) {
          var overflow = inputLength % this.blockSize;
          this._cipherLength += overflow;
          this._partialOutput.truncate(this.blockSize - overflow);
        } else {
          this._cipherLength += this.blockSize;
        }
        for (var i = 0; i < this._ints; ++i) {
          this._outBlock[i] = this._partialOutput.getInt32();
        }
        this._partialOutput.read -= this.blockSize;
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        input.read -= this.blockSize;
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    }
    this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
    inc32(this._inBlock);
  };
  modes.gcm.prototype.decrypt = function(input, output, finish) {
    var inputLength = input.length();
    if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    inc32(this._inBlock);
    this._hashBlock[0] = input.getInt32();
    this._hashBlock[1] = input.getInt32();
    this._hashBlock[2] = input.getInt32();
    this._hashBlock[3] = input.getInt32();
    this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
    }
    if (inputLength < this.blockSize) {
      this._cipherLength += inputLength % this.blockSize;
    } else {
      this._cipherLength += this.blockSize;
    }
  };
  modes.gcm.prototype.afterFinish = function(output, options) {
    var rval = true;
    if (options.decrypt && options.overflow) {
      output.truncate(this.blockSize - options.overflow);
    }
    this.tag = forge.util.createBuffer();
    var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
    this._s = this.ghash(this._hashSubkey, this._s, lengths);
    var tag = [];
    this.cipher.encrypt(this._j0, tag);
    for (var i = 0; i < this._ints; ++i) {
      this.tag.putInt32(this._s[i] ^ tag[i]);
    }
    this.tag.truncate(this.tag.length() % (this._tagLength / 8));
    if (options.decrypt && this.tag.bytes() !== this._tag) {
      rval = false;
    }
    return rval;
  };
  modes.gcm.prototype.multiply = function(x, y) {
    var z_i = [0, 0, 0, 0];
    var v_i = y.slice(0);
    for (var i = 0; i < 128; ++i) {
      var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
      if (x_i) {
        z_i[0] ^= v_i[0];
        z_i[1] ^= v_i[1];
        z_i[2] ^= v_i[2];
        z_i[3] ^= v_i[3];
      }
      this.pow(v_i, v_i);
    }
    return z_i;
  };
  modes.gcm.prototype.pow = function(x, out) {
    var lsb = x[3] & 1;
    for (var i = 3; i > 0; --i) {
      out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
    }
    out[0] = x[0] >>> 1;
    if (lsb) {
      out[0] ^= this._R;
    }
  };
  modes.gcm.prototype.tableMultiply = function(x) {
    var z = [0, 0, 0, 0];
    for (var i = 0; i < 32; ++i) {
      var idx = i / 8 | 0;
      var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;
      var ah = this._m[i][x_i];
      z[0] ^= ah[0];
      z[1] ^= ah[1];
      z[2] ^= ah[2];
      z[3] ^= ah[3];
    }
    return z;
  };
  modes.gcm.prototype.ghash = function(h, y, x) {
    y[0] ^= x[0];
    y[1] ^= x[1];
    y[2] ^= x[2];
    y[3] ^= x[3];
    return this.tableMultiply(y);
  };
  modes.gcm.prototype.generateHashTable = function(h, bits) {
    var multiplier = 8 / bits;
    var perInt = 4 * multiplier;
    var size = 16 * multiplier;
    var m = new Array(size);
    for (var i = 0; i < size; ++i) {
      var tmp = [0, 0, 0, 0];
      var idx = i / perInt | 0;
      var shft = (perInt - 1 - i % perInt) * bits;
      tmp[idx] = 1 << bits - 1 << shft;
      m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
    }
    return m;
  };
  modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
    var size = 1 << bits;
    var half = size >>> 1;
    var m = new Array(size);
    m[half] = mid.slice(0);
    var i = half >>> 1;
    while (i > 0) {
      this.pow(m[2 * i], m[i] = []);
      i >>= 1;
    }
    i = 2;
    while (i < half) {
      for (var j = 1; j < i; ++j) {
        var m_i = m[i];
        var m_j = m[j];
        m[i + j] = [
          m_i[0] ^ m_j[0],
          m_i[1] ^ m_j[1],
          m_i[2] ^ m_j[2],
          m_i[3] ^ m_j[3]
        ];
      }
      i *= 2;
    }
    m[0] = [0, 0, 0, 0];
    for (i = half + 1; i < size; ++i) {
      var c = m[i ^ half];
      m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
    }
    return m;
  };
  function transformIV(iv, blockSize) {
    if (typeof iv === "string") {
      iv = forge.util.createBuffer(iv);
    }
    if (forge.util.isArray(iv) && iv.length > 4) {
      var tmp = iv;
      iv = forge.util.createBuffer();
      for (var i = 0; i < tmp.length; ++i) {
        iv.putByte(tmp[i]);
      }
    }
    if (iv.length() < blockSize) {
      throw new Error("Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes.");
    }
    if (!forge.util.isArray(iv)) {
      var ints = [];
      var blocks = blockSize / 4;
      for (var i = 0; i < blocks; ++i) {
        ints.push(iv.getInt32());
      }
      iv = ints;
    }
    return iv;
  }
  function inc32(block) {
    block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
  }
  function from64To32(num) {
    return [num / 4294967296 | 0, num & 4294967295];
  }
});

// node_modules/node-forge/lib/aes.js
var require_aes = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_cipher();
  require_cipherModes();
  require_util();
  module2.exports = forge.aes = forge.aes || {};
  forge.aes.startEncrypting = function(key, iv, output, mode) {
    var cipher = _createCipher({
      key,
      output,
      decrypt: false,
      mode
    });
    cipher.start(iv);
    return cipher;
  };
  forge.aes.createEncryptionCipher = function(key, mode) {
    return _createCipher({
      key,
      output: null,
      decrypt: false,
      mode
    });
  };
  forge.aes.startDecrypting = function(key, iv, output, mode) {
    var cipher = _createCipher({
      key,
      output,
      decrypt: true,
      mode
    });
    cipher.start(iv);
    return cipher;
  };
  forge.aes.createDecryptionCipher = function(key, mode) {
    return _createCipher({
      key,
      output: null,
      decrypt: true,
      mode
    });
  };
  forge.aes.Algorithm = function(name, mode) {
    if (!init) {
      initialize();
    }
    var self2 = this;
    self2.name = name;
    self2.mode = new mode({
      blockSize: 16,
      cipher: {
        encrypt: function(inBlock, outBlock) {
          return _updateBlock(self2._w, inBlock, outBlock, false);
        },
        decrypt: function(inBlock, outBlock) {
          return _updateBlock(self2._w, inBlock, outBlock, true);
        }
      }
    });
    self2._init = false;
  };
  forge.aes.Algorithm.prototype.initialize = function(options) {
    if (this._init) {
      return;
    }
    var key = options.key;
    var tmp;
    if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
      key = forge.util.createBuffer(key);
    } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
      tmp = key;
      key = forge.util.createBuffer();
      for (var i = 0; i < tmp.length; ++i) {
        key.putByte(tmp[i]);
      }
    }
    if (!forge.util.isArray(key)) {
      tmp = key;
      key = [];
      var len = tmp.length();
      if (len === 16 || len === 24 || len === 32) {
        len = len >>> 2;
        for (var i = 0; i < len; ++i) {
          key.push(tmp.getInt32());
        }
      }
    }
    if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
      throw new Error("Invalid key parameter.");
    }
    var mode = this.mode.name;
    var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
    this._w = _expandKey(key, options.decrypt && !encryptOp);
    this._init = true;
  };
  forge.aes._expandKey = function(key, decrypt) {
    if (!init) {
      initialize();
    }
    return _expandKey(key, decrypt);
  };
  forge.aes._updateBlock = _updateBlock;
  registerAlgorithm("AES-ECB", forge.cipher.modes.ecb);
  registerAlgorithm("AES-CBC", forge.cipher.modes.cbc);
  registerAlgorithm("AES-CFB", forge.cipher.modes.cfb);
  registerAlgorithm("AES-OFB", forge.cipher.modes.ofb);
  registerAlgorithm("AES-CTR", forge.cipher.modes.ctr);
  registerAlgorithm("AES-GCM", forge.cipher.modes.gcm);
  function registerAlgorithm(name, mode) {
    var factory = function() {
      return new forge.aes.Algorithm(name, mode);
    };
    forge.cipher.registerAlgorithm(name, factory);
  }
  var init = false;
  var Nb = 4;
  var sbox;
  var isbox;
  var rcon;
  var mix;
  var imix;
  function initialize() {
    init = true;
    rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
    var xtime = new Array(256);
    for (var i = 0; i < 128; ++i) {
      xtime[i] = i << 1;
      xtime[i + 128] = i + 128 << 1 ^ 283;
    }
    sbox = new Array(256);
    isbox = new Array(256);
    mix = new Array(4);
    imix = new Array(4);
    for (var i = 0; i < 4; ++i) {
      mix[i] = new Array(256);
      imix[i] = new Array(256);
    }
    var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
    for (var i = 0; i < 256; ++i) {
      sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
      sx = sx >> 8 ^ sx & 255 ^ 99;
      sbox[e] = sx;
      isbox[sx] = e;
      sx2 = xtime[sx];
      e2 = xtime[e];
      e4 = xtime[e2];
      e8 = xtime[e4];
      me = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2);
      ime = (e2 ^ e4 ^ e8) << 24 ^ (e ^ e8) << 16 ^ (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8);
      for (var n = 0; n < 4; ++n) {
        mix[n][e] = me;
        imix[n][sx] = ime;
        me = me << 24 | me >>> 8;
        ime = ime << 24 | ime >>> 8;
      }
      if (e === 0) {
        e = ei = 1;
      } else {
        e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
        ei ^= xtime[xtime[ei]];
      }
    }
  }
  function _expandKey(key, decrypt) {
    var w = key.slice(0);
    var temp, iNk = 1;
    var Nk = w.length;
    var Nr1 = Nk + 6 + 1;
    var end = Nb * Nr1;
    for (var i = Nk; i < end; ++i) {
      temp = w[i - 1];
      if (i % Nk === 0) {
        temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
        iNk++;
      } else if (Nk > 6 && i % Nk === 4) {
        temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
      }
      w[i] = w[i - Nk] ^ temp;
    }
    if (decrypt) {
      var tmp;
      var m0 = imix[0];
      var m1 = imix[1];
      var m2 = imix[2];
      var m3 = imix[3];
      var wnew = w.slice(0);
      end = w.length;
      for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
        if (i === 0 || i === end - Nb) {
          wnew[i] = w[wi];
          wnew[i + 1] = w[wi + 3];
          wnew[i + 2] = w[wi + 2];
          wnew[i + 3] = w[wi + 1];
        } else {
          for (var n = 0; n < Nb; ++n) {
            tmp = w[wi + n];
            wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
          }
        }
      }
      w = wnew;
    }
    return w;
  }
  function _updateBlock(w, input, output, decrypt) {
    var Nr = w.length / 4 - 1;
    var m0, m1, m2, m3, sub;
    if (decrypt) {
      m0 = imix[0];
      m1 = imix[1];
      m2 = imix[2];
      m3 = imix[3];
      sub = isbox;
    } else {
      m0 = mix[0];
      m1 = mix[1];
      m2 = mix[2];
      m3 = mix[3];
      sub = sbox;
    }
    var a, b, c, d, a2, b2, c2;
    a = input[0] ^ w[0];
    b = input[decrypt ? 3 : 1] ^ w[1];
    c = input[2] ^ w[2];
    d = input[decrypt ? 1 : 3] ^ w[3];
    var i = 3;
    for (var round = 1; round < Nr; ++round) {
      a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
      b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
      c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
      d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
      a = a2;
      b = b2;
      c = c2;
    }
    output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];
    output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];
    output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];
    output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];
  }
  function _createCipher(options) {
    options = options || {};
    var mode = (options.mode || "CBC").toUpperCase();
    var algorithm = "AES-" + mode;
    var cipher;
    if (options.decrypt) {
      cipher = forge.cipher.createDecipher(algorithm, options.key);
    } else {
      cipher = forge.cipher.createCipher(algorithm, options.key);
    }
    var start = cipher.start;
    cipher.start = function(iv, options2) {
      var output = null;
      if (options2 instanceof forge.util.ByteBuffer) {
        output = options2;
        options2 = {};
      }
      options2 = options2 || {};
      options2.output = output;
      options2.iv = iv;
      start.call(cipher, options2);
    };
    return cipher;
  }
});

// node_modules/node-forge/lib/oids.js
var require_oids = __commonJS((exports2, module2) => {
  var forge = require_forge();
  forge.pki = forge.pki || {};
  var oids = module2.exports = forge.pki.oids = forge.oids = forge.oids || {};
  function _IN(id, name) {
    oids[id] = name;
    oids[name] = id;
  }
  function _I_(id, name) {
    oids[id] = name;
  }
  _IN("1.2.840.113549.1.1.1", "rsaEncryption");
  _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
  _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
  _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
  _IN("1.2.840.113549.1.1.8", "mgf1");
  _IN("1.2.840.113549.1.1.9", "pSpecified");
  _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
  _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
  _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
  _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
  _IN("1.3.101.112", "EdDSA25519");
  _IN("1.2.840.10040.4.3", "dsa-with-sha1");
  _IN("1.3.14.3.2.7", "desCBC");
  _IN("1.3.14.3.2.26", "sha1");
  _IN("2.16.840.1.101.3.4.2.1", "sha256");
  _IN("2.16.840.1.101.3.4.2.2", "sha384");
  _IN("2.16.840.1.101.3.4.2.3", "sha512");
  _IN("1.2.840.113549.2.5", "md5");
  _IN("1.2.840.113549.1.7.1", "data");
  _IN("1.2.840.113549.1.7.2", "signedData");
  _IN("1.2.840.113549.1.7.3", "envelopedData");
  _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
  _IN("1.2.840.113549.1.7.5", "digestedData");
  _IN("1.2.840.113549.1.7.6", "encryptedData");
  _IN("1.2.840.113549.1.9.1", "emailAddress");
  _IN("1.2.840.113549.1.9.2", "unstructuredName");
  _IN("1.2.840.113549.1.9.3", "contentType");
  _IN("1.2.840.113549.1.9.4", "messageDigest");
  _IN("1.2.840.113549.1.9.5", "signingTime");
  _IN("1.2.840.113549.1.9.6", "counterSignature");
  _IN("1.2.840.113549.1.9.7", "challengePassword");
  _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
  _IN("1.2.840.113549.1.9.14", "extensionRequest");
  _IN("1.2.840.113549.1.9.20", "friendlyName");
  _IN("1.2.840.113549.1.9.21", "localKeyId");
  _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
  _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
  _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
  _IN("1.2.840.113549.1.12.10.1.3", "certBag");
  _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
  _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
  _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
  _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
  _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
  _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
  _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
  _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
  _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
  _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
  _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
  _IN("1.2.840.113549.2.7", "hmacWithSHA1");
  _IN("1.2.840.113549.2.8", "hmacWithSHA224");
  _IN("1.2.840.113549.2.9", "hmacWithSHA256");
  _IN("1.2.840.113549.2.10", "hmacWithSHA384");
  _IN("1.2.840.113549.2.11", "hmacWithSHA512");
  _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
  _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
  _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
  _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
  _IN("2.5.4.3", "commonName");
  _IN("2.5.4.5", "serialName");
  _IN("2.5.4.6", "countryName");
  _IN("2.5.4.7", "localityName");
  _IN("2.5.4.8", "stateOrProvinceName");
  _IN("2.5.4.9", "streetAddress");
  _IN("2.5.4.10", "organizationName");
  _IN("2.5.4.11", "organizationalUnitName");
  _IN("2.5.4.13", "description");
  _IN("2.5.4.15", "businessCategory");
  _IN("2.5.4.17", "postalCode");
  _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
  _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
  _IN("2.16.840.1.113730.1.1", "nsCertType");
  _IN("2.16.840.1.113730.1.13", "nsComment");
  _I_("2.5.29.1", "authorityKeyIdentifier");
  _I_("2.5.29.2", "keyAttributes");
  _I_("2.5.29.3", "certificatePolicies");
  _I_("2.5.29.4", "keyUsageRestriction");
  _I_("2.5.29.5", "policyMapping");
  _I_("2.5.29.6", "subtreesConstraint");
  _I_("2.5.29.7", "subjectAltName");
  _I_("2.5.29.8", "issuerAltName");
  _I_("2.5.29.9", "subjectDirectoryAttributes");
  _I_("2.5.29.10", "basicConstraints");
  _I_("2.5.29.11", "nameConstraints");
  _I_("2.5.29.12", "policyConstraints");
  _I_("2.5.29.13", "basicConstraints");
  _IN("2.5.29.14", "subjectKeyIdentifier");
  _IN("2.5.29.15", "keyUsage");
  _I_("2.5.29.16", "privateKeyUsagePeriod");
  _IN("2.5.29.17", "subjectAltName");
  _IN("2.5.29.18", "issuerAltName");
  _IN("2.5.29.19", "basicConstraints");
  _I_("2.5.29.20", "cRLNumber");
  _I_("2.5.29.21", "cRLReason");
  _I_("2.5.29.22", "expirationDate");
  _I_("2.5.29.23", "instructionCode");
  _I_("2.5.29.24", "invalidityDate");
  _I_("2.5.29.25", "cRLDistributionPoints");
  _I_("2.5.29.26", "issuingDistributionPoint");
  _I_("2.5.29.27", "deltaCRLIndicator");
  _I_("2.5.29.28", "issuingDistributionPoint");
  _I_("2.5.29.29", "certificateIssuer");
  _I_("2.5.29.30", "nameConstraints");
  _IN("2.5.29.31", "cRLDistributionPoints");
  _IN("2.5.29.32", "certificatePolicies");
  _I_("2.5.29.33", "policyMappings");
  _I_("2.5.29.34", "policyConstraints");
  _IN("2.5.29.35", "authorityKeyIdentifier");
  _I_("2.5.29.36", "policyConstraints");
  _IN("2.5.29.37", "extKeyUsage");
  _I_("2.5.29.46", "freshestCRL");
  _I_("2.5.29.54", "inhibitAnyPolicy");
  _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
  _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
  _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
  _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
  _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
  _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
  _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
});

// node_modules/node-forge/lib/asn1.js
var require_asn1 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util();
  require_oids();
  var asn1 = module2.exports = forge.asn1 = forge.asn1 || {};
  asn1.Class = {
    UNIVERSAL: 0,
    APPLICATION: 64,
    CONTEXT_SPECIFIC: 128,
    PRIVATE: 192
  };
  asn1.Type = {
    NONE: 0,
    BOOLEAN: 1,
    INTEGER: 2,
    BITSTRING: 3,
    OCTETSTRING: 4,
    NULL: 5,
    OID: 6,
    ODESC: 7,
    EXTERNAL: 8,
    REAL: 9,
    ENUMERATED: 10,
    EMBEDDED: 11,
    UTF8: 12,
    ROID: 13,
    SEQUENCE: 16,
    SET: 17,
    PRINTABLESTRING: 19,
    IA5STRING: 22,
    UTCTIME: 23,
    GENERALIZEDTIME: 24,
    BMPSTRING: 30
  };
  asn1.create = function(tagClass, type, constructed, value, options) {
    if (forge.util.isArray(value)) {
      var tmp = [];
      for (var i = 0; i < value.length; ++i) {
        if (value[i] !== void 0) {
          tmp.push(value[i]);
        }
      }
      value = tmp;
    }
    var obj = {
      tagClass,
      type,
      constructed,
      composed: constructed || forge.util.isArray(value),
      value
    };
    if (options && "bitStringContents" in options) {
      obj.bitStringContents = options.bitStringContents;
      obj.original = asn1.copy(obj);
    }
    return obj;
  };
  asn1.copy = function(obj, options) {
    var copy;
    if (forge.util.isArray(obj)) {
      copy = [];
      for (var i = 0; i < obj.length; ++i) {
        copy.push(asn1.copy(obj[i], options));
      }
      return copy;
    }
    if (typeof obj === "string") {
      return obj;
    }
    copy = {
      tagClass: obj.tagClass,
      type: obj.type,
      constructed: obj.constructed,
      composed: obj.composed,
      value: asn1.copy(obj.value, options)
    };
    if (options && !options.excludeBitStringContents) {
      copy.bitStringContents = obj.bitStringContents;
    }
    return copy;
  };
  asn1.equals = function(obj1, obj2, options) {
    if (forge.util.isArray(obj1)) {
      if (!forge.util.isArray(obj2)) {
        return false;
      }
      if (obj1.length !== obj2.length) {
        return false;
      }
      for (var i = 0; i < obj1.length; ++i) {
        if (!asn1.equals(obj1[i], obj2[i])) {
          return false;
        }
      }
      return true;
    }
    if (typeof obj1 !== typeof obj2) {
      return false;
    }
    if (typeof obj1 === "string") {
      return obj1 === obj2;
    }
    var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
    if (options && options.includeBitStringContents) {
      equal = equal && obj1.bitStringContents === obj2.bitStringContents;
    }
    return equal;
  };
  asn1.getBerValueLength = function(b) {
    var b2 = b.getByte();
    if (b2 === 128) {
      return void 0;
    }
    var length;
    var longForm = b2 & 128;
    if (!longForm) {
      length = b2;
    } else {
      length = b.getInt((b2 & 127) << 3);
    }
    return length;
  };
  function _checkBufferLength(bytes, remaining, n) {
    if (n > remaining) {
      var error = new Error("Too few bytes to parse DER.");
      error.available = bytes.length();
      error.remaining = remaining;
      error.requested = n;
      throw error;
    }
  }
  var _getValueLength = function(bytes, remaining) {
    var b2 = bytes.getByte();
    remaining--;
    if (b2 === 128) {
      return void 0;
    }
    var length;
    var longForm = b2 & 128;
    if (!longForm) {
      length = b2;
    } else {
      var longFormBytes = b2 & 127;
      _checkBufferLength(bytes, remaining, longFormBytes);
      length = bytes.getInt(longFormBytes << 3);
    }
    if (length < 0) {
      throw new Error("Negative length: " + length);
    }
    return length;
  };
  asn1.fromDer = function(bytes, options) {
    if (options === void 0) {
      options = {
        strict: true,
        decodeBitStrings: true
      };
    }
    if (typeof options === "boolean") {
      options = {
        strict: options,
        decodeBitStrings: true
      };
    }
    if (!("strict" in options)) {
      options.strict = true;
    }
    if (!("decodeBitStrings" in options)) {
      options.decodeBitStrings = true;
    }
    if (typeof bytes === "string") {
      bytes = forge.util.createBuffer(bytes);
    }
    return _fromDer(bytes, bytes.length(), 0, options);
  };
  function _fromDer(bytes, remaining, depth, options) {
    var start;
    _checkBufferLength(bytes, remaining, 2);
    var b1 = bytes.getByte();
    remaining--;
    var tagClass = b1 & 192;
    var type = b1 & 31;
    start = bytes.length();
    var length = _getValueLength(bytes, remaining);
    remaining -= start - bytes.length();
    if (length !== void 0 && length > remaining) {
      if (options.strict) {
        var error = new Error("Too few bytes to read ASN.1 value.");
        error.available = bytes.length();
        error.remaining = remaining;
        error.requested = length;
        throw error;
      }
      length = remaining;
    }
    var value;
    var bitStringContents;
    var constructed = (b1 & 32) === 32;
    if (constructed) {
      value = [];
      if (length === void 0) {
        for (; ; ) {
          _checkBufferLength(bytes, remaining, 2);
          if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
            bytes.getBytes(2);
            remaining -= 2;
            break;
          }
          start = bytes.length();
          value.push(_fromDer(bytes, remaining, depth + 1, options));
          remaining -= start - bytes.length();
        }
      } else {
        while (length > 0) {
          start = bytes.length();
          value.push(_fromDer(bytes, length, depth + 1, options));
          remaining -= start - bytes.length();
          length -= start - bytes.length();
        }
      }
    }
    if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
      bitStringContents = bytes.bytes(length);
    }
    if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING && length > 1) {
      var savedRead = bytes.read;
      var savedRemaining = remaining;
      var unused = 0;
      if (type === asn1.Type.BITSTRING) {
        _checkBufferLength(bytes, remaining, 1);
        unused = bytes.getByte();
        remaining--;
      }
      if (unused === 0) {
        try {
          start = bytes.length();
          var subOptions = {
            verbose: options.verbose,
            strict: true,
            decodeBitStrings: true
          };
          var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
          var used = start - bytes.length();
          remaining -= used;
          if (type == asn1.Type.BITSTRING) {
            used++;
          }
          var tc = composed.tagClass;
          if (used === length && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
            value = [composed];
          }
        } catch (ex) {
        }
      }
      if (value === void 0) {
        bytes.read = savedRead;
        remaining = savedRemaining;
      }
    }
    if (value === void 0) {
      if (length === void 0) {
        if (options.strict) {
          throw new Error("Non-constructed ASN.1 object of indefinite length.");
        }
        length = remaining;
      }
      if (type === asn1.Type.BMPSTRING) {
        value = "";
        for (; length > 0; length -= 2) {
          _checkBufferLength(bytes, remaining, 2);
          value += String.fromCharCode(bytes.getInt16());
          remaining -= 2;
        }
      } else {
        value = bytes.getBytes(length);
      }
    }
    var asn1Options = bitStringContents === void 0 ? null : {
      bitStringContents
    };
    return asn1.create(tagClass, type, constructed, value, asn1Options);
  }
  asn1.toDer = function(obj) {
    var bytes = forge.util.createBuffer();
    var b1 = obj.tagClass | obj.type;
    var value = forge.util.createBuffer();
    var useBitStringContents = false;
    if ("bitStringContents" in obj) {
      useBitStringContents = true;
      if (obj.original) {
        useBitStringContents = asn1.equals(obj, obj.original);
      }
    }
    if (useBitStringContents) {
      value.putBytes(obj.bitStringContents);
    } else if (obj.composed) {
      if (obj.constructed) {
        b1 |= 32;
      } else {
        value.putByte(0);
      }
      for (var i = 0; i < obj.value.length; ++i) {
        if (obj.value[i] !== void 0) {
          value.putBuffer(asn1.toDer(obj.value[i]));
        }
      }
    } else {
      if (obj.type === asn1.Type.BMPSTRING) {
        for (var i = 0; i < obj.value.length; ++i) {
          value.putInt16(obj.value.charCodeAt(i));
        }
      } else {
        if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
          value.putBytes(obj.value.substr(1));
        } else {
          value.putBytes(obj.value);
        }
      }
    }
    bytes.putByte(b1);
    if (value.length() <= 127) {
      bytes.putByte(value.length() & 127);
    } else {
      var len = value.length();
      var lenBytes = "";
      do {
        lenBytes += String.fromCharCode(len & 255);
        len = len >>> 8;
      } while (len > 0);
      bytes.putByte(lenBytes.length | 128);
      for (var i = lenBytes.length - 1; i >= 0; --i) {
        bytes.putByte(lenBytes.charCodeAt(i));
      }
    }
    bytes.putBuffer(value);
    return bytes;
  };
  asn1.oidToDer = function(oid) {
    var values = oid.split(".");
    var bytes = forge.util.createBuffer();
    bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
    var last, valueBytes, value, b;
    for (var i = 2; i < values.length; ++i) {
      last = true;
      valueBytes = [];
      value = parseInt(values[i], 10);
      do {
        b = value & 127;
        value = value >>> 7;
        if (!last) {
          b |= 128;
        }
        valueBytes.push(b);
        last = false;
      } while (value > 0);
      for (var n = valueBytes.length - 1; n >= 0; --n) {
        bytes.putByte(valueBytes[n]);
      }
    }
    return bytes;
  };
  asn1.derToOid = function(bytes) {
    var oid;
    if (typeof bytes === "string") {
      bytes = forge.util.createBuffer(bytes);
    }
    var b = bytes.getByte();
    oid = Math.floor(b / 40) + "." + b % 40;
    var value = 0;
    while (bytes.length() > 0) {
      b = bytes.getByte();
      value = value << 7;
      if (b & 128) {
        value += b & 127;
      } else {
        oid += "." + (value + b);
        value = 0;
      }
    }
    return oid;
  };
  asn1.utcTimeToDate = function(utc) {
    var date = new Date();
    var year = parseInt(utc.substr(0, 2), 10);
    year = year >= 50 ? 1900 + year : 2e3 + year;
    var MM = parseInt(utc.substr(2, 2), 10) - 1;
    var DD = parseInt(utc.substr(4, 2), 10);
    var hh = parseInt(utc.substr(6, 2), 10);
    var mm = parseInt(utc.substr(8, 2), 10);
    var ss = 0;
    if (utc.length > 11) {
      var c = utc.charAt(10);
      var end = 10;
      if (c !== "+" && c !== "-") {
        ss = parseInt(utc.substr(10, 2), 10);
        end += 2;
      }
    }
    date.setUTCFullYear(year, MM, DD);
    date.setUTCHours(hh, mm, ss, 0);
    if (end) {
      c = utc.charAt(end);
      if (c === "+" || c === "-") {
        var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
        var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
        var offset = hhoffset * 60 + mmoffset;
        offset *= 6e4;
        if (c === "+") {
          date.setTime(+date - offset);
        } else {
          date.setTime(+date + offset);
        }
      }
    }
    return date;
  };
  asn1.generalizedTimeToDate = function(gentime) {
    var date = new Date();
    var YYYY = parseInt(gentime.substr(0, 4), 10);
    var MM = parseInt(gentime.substr(4, 2), 10) - 1;
    var DD = parseInt(gentime.substr(6, 2), 10);
    var hh = parseInt(gentime.substr(8, 2), 10);
    var mm = parseInt(gentime.substr(10, 2), 10);
    var ss = parseInt(gentime.substr(12, 2), 10);
    var fff = 0;
    var offset = 0;
    var isUTC = false;
    if (gentime.charAt(gentime.length - 1) === "Z") {
      isUTC = true;
    }
    var end = gentime.length - 5, c = gentime.charAt(end);
    if (c === "+" || c === "-") {
      var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
      var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
      offset = hhoffset * 60 + mmoffset;
      offset *= 6e4;
      if (c === "+") {
        offset *= -1;
      }
      isUTC = true;
    }
    if (gentime.charAt(14) === ".") {
      fff = parseFloat(gentime.substr(14), 10) * 1e3;
    }
    if (isUTC) {
      date.setUTCFullYear(YYYY, MM, DD);
      date.setUTCHours(hh, mm, ss, fff);
      date.setTime(+date + offset);
    } else {
      date.setFullYear(YYYY, MM, DD);
      date.setHours(hh, mm, ss, fff);
    }
    return date;
  };
  asn1.dateToUtcTime = function(date) {
    if (typeof date === "string") {
      return date;
    }
    var rval = "";
    var format = [];
    format.push(("" + date.getUTCFullYear()).substr(2));
    format.push("" + (date.getUTCMonth() + 1));
    format.push("" + date.getUTCDate());
    format.push("" + date.getUTCHours());
    format.push("" + date.getUTCMinutes());
    format.push("" + date.getUTCSeconds());
    for (var i = 0; i < format.length; ++i) {
      if (format[i].length < 2) {
        rval += "0";
      }
      rval += format[i];
    }
    rval += "Z";
    return rval;
  };
  asn1.dateToGeneralizedTime = function(date) {
    if (typeof date === "string") {
      return date;
    }
    var rval = "";
    var format = [];
    format.push("" + date.getUTCFullYear());
    format.push("" + (date.getUTCMonth() + 1));
    format.push("" + date.getUTCDate());
    format.push("" + date.getUTCHours());
    format.push("" + date.getUTCMinutes());
    format.push("" + date.getUTCSeconds());
    for (var i = 0; i < format.length; ++i) {
      if (format[i].length < 2) {
        rval += "0";
      }
      rval += format[i];
    }
    rval += "Z";
    return rval;
  };
  asn1.integerToDer = function(x) {
    var rval = forge.util.createBuffer();
    if (x >= -128 && x < 128) {
      return rval.putSignedInt(x, 8);
    }
    if (x >= -32768 && x < 32768) {
      return rval.putSignedInt(x, 16);
    }
    if (x >= -8388608 && x < 8388608) {
      return rval.putSignedInt(x, 24);
    }
    if (x >= -2147483648 && x < 2147483648) {
      return rval.putSignedInt(x, 32);
    }
    var error = new Error("Integer too large; max is 32-bits.");
    error.integer = x;
    throw error;
  };
  asn1.derToInteger = function(bytes) {
    if (typeof bytes === "string") {
      bytes = forge.util.createBuffer(bytes);
    }
    var n = bytes.length() * 8;
    if (n > 32) {
      throw new Error("Integer too large; max is 32-bits.");
    }
    return bytes.getSignedInt(n);
  };
  asn1.validate = function(obj, v, capture, errors) {
    var rval = false;
    if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
      if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
        rval = true;
        if (v.value && forge.util.isArray(v.value)) {
          var j = 0;
          for (var i = 0; rval && i < v.value.length; ++i) {
            rval = v.value[i].optional || false;
            if (obj.value[j]) {
              rval = asn1.validate(obj.value[j], v.value[i], capture, errors);
              if (rval) {
                ++j;
              } else if (v.value[i].optional) {
                rval = true;
              }
            }
            if (!rval && errors) {
              errors.push("[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"');
            }
          }
        }
        if (rval && capture) {
          if (v.capture) {
            capture[v.capture] = obj.value;
          }
          if (v.captureAsn1) {
            capture[v.captureAsn1] = obj;
          }
          if (v.captureBitStringContents && "bitStringContents" in obj) {
            capture[v.captureBitStringContents] = obj.bitStringContents;
          }
          if (v.captureBitStringValue && "bitStringContents" in obj) {
            var value;
            if (obj.bitStringContents.length < 2) {
              capture[v.captureBitStringValue] = "";
            } else {
              var unused = obj.bitStringContents.charCodeAt(0);
              if (unused !== 0) {
                throw new Error("captureBitStringValue only supported for zero unused bits");
              }
              capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
            }
          }
        }
      } else if (errors) {
        errors.push("[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"');
      }
    } else if (errors) {
      if (obj.tagClass !== v.tagClass) {
        errors.push("[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"');
      }
      if (obj.type !== v.type) {
        errors.push("[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"');
      }
    }
    return rval;
  };
  var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
  asn1.prettyPrint = function(obj, level, indentation) {
    var rval = "";
    level = level || 0;
    indentation = indentation || 2;
    if (level > 0) {
      rval += "\n";
    }
    var indent = "";
    for (var i = 0; i < level * indentation; ++i) {
      indent += " ";
    }
    rval += indent + "Tag: ";
    switch (obj.tagClass) {
      case asn1.Class.UNIVERSAL:
        rval += "Universal:";
        break;
      case asn1.Class.APPLICATION:
        rval += "Application:";
        break;
      case asn1.Class.CONTEXT_SPECIFIC:
        rval += "Context-Specific:";
        break;
      case asn1.Class.PRIVATE:
        rval += "Private:";
        break;
    }
    if (obj.tagClass === asn1.Class.UNIVERSAL) {
      rval += obj.type;
      switch (obj.type) {
        case asn1.Type.NONE:
          rval += " (None)";
          break;
        case asn1.Type.BOOLEAN:
          rval += " (Boolean)";
          break;
        case asn1.Type.INTEGER:
          rval += " (Integer)";
          break;
        case asn1.Type.BITSTRING:
          rval += " (Bit string)";
          break;
        case asn1.Type.OCTETSTRING:
          rval += " (Octet string)";
          break;
        case asn1.Type.NULL:
          rval += " (Null)";
          break;
        case asn1.Type.OID:
          rval += " (Object Identifier)";
          break;
        case asn1.Type.ODESC:
          rval += " (Object Descriptor)";
          break;
        case asn1.Type.EXTERNAL:
          rval += " (External or Instance of)";
          break;
        case asn1.Type.REAL:
          rval += " (Real)";
          break;
        case asn1.Type.ENUMERATED:
          rval += " (Enumerated)";
          break;
        case asn1.Type.EMBEDDED:
          rval += " (Embedded PDV)";
          break;
        case asn1.Type.UTF8:
          rval += " (UTF8)";
          break;
        case asn1.Type.ROID:
          rval += " (Relative Object Identifier)";
          break;
        case asn1.Type.SEQUENCE:
          rval += " (Sequence)";
          break;
        case asn1.Type.SET:
          rval += " (Set)";
          break;
        case asn1.Type.PRINTABLESTRING:
          rval += " (Printable String)";
          break;
        case asn1.Type.IA5String:
          rval += " (IA5String (ASCII))";
          break;
        case asn1.Type.UTCTIME:
          rval += " (UTC time)";
          break;
        case asn1.Type.GENERALIZEDTIME:
          rval += " (Generalized time)";
          break;
        case asn1.Type.BMPSTRING:
          rval += " (BMP String)";
          break;
      }
    } else {
      rval += obj.type;
    }
    rval += "\n";
    rval += indent + "Constructed: " + obj.constructed + "\n";
    if (obj.composed) {
      var subvalues = 0;
      var sub = "";
      for (var i = 0; i < obj.value.length; ++i) {
        if (obj.value[i] !== void 0) {
          subvalues += 1;
          sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
          if (i + 1 < obj.value.length) {
            sub += ",";
          }
        }
      }
      rval += indent + "Sub values: " + subvalues + sub;
    } else {
      rval += indent + "Value: ";
      if (obj.type === asn1.Type.OID) {
        var oid = asn1.derToOid(obj.value);
        rval += oid;
        if (forge.pki && forge.pki.oids) {
          if (oid in forge.pki.oids) {
            rval += " (" + forge.pki.oids[oid] + ") ";
          }
        }
      }
      if (obj.type === asn1.Type.INTEGER) {
        try {
          rval += asn1.derToInteger(obj.value);
        } catch (ex) {
          rval += "0x" + forge.util.bytesToHex(obj.value);
        }
      } else if (obj.type === asn1.Type.BITSTRING) {
        if (obj.value.length > 1) {
          rval += "0x" + forge.util.bytesToHex(obj.value.slice(1));
        } else {
          rval += "(none)";
        }
        if (obj.value.length > 0) {
          var unused = obj.value.charCodeAt(0);
          if (unused == 1) {
            rval += " (1 unused bit shown)";
          } else if (unused > 1) {
            rval += " (" + unused + " unused bits shown)";
          }
        }
      } else if (obj.type === asn1.Type.OCTETSTRING) {
        if (!_nonLatinRegex.test(obj.value)) {
          rval += "(" + obj.value + ") ";
        }
        rval += "0x" + forge.util.bytesToHex(obj.value);
      } else if (obj.type === asn1.Type.UTF8) {
        rval += forge.util.decodeUtf8(obj.value);
      } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
        rval += obj.value;
      } else if (_nonLatinRegex.test(obj.value)) {
        rval += "0x" + forge.util.bytesToHex(obj.value);
      } else if (obj.value.length === 0) {
        rval += "[null]";
      } else {
        rval += obj.value;
      }
    }
    return rval;
  };
});

// node_modules/node-forge/lib/md.js
var require_md = __commonJS((exports2, module2) => {
  var forge = require_forge();
  module2.exports = forge.md = forge.md || {};
  forge.md.algorithms = forge.md.algorithms || {};
});

// node_modules/node-forge/lib/hmac.js
var require_hmac = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_md();
  require_util();
  var hmac = module2.exports = forge.hmac = forge.hmac || {};
  hmac.create = function() {
    var _key = null;
    var _md = null;
    var _ipadding = null;
    var _opadding = null;
    var ctx = {};
    ctx.start = function(md, key) {
      if (md !== null) {
        if (typeof md === "string") {
          md = md.toLowerCase();
          if (md in forge.md.algorithms) {
            _md = forge.md.algorithms[md].create();
          } else {
            throw new Error('Unknown hash algorithm "' + md + '"');
          }
        } else {
          _md = md;
        }
      }
      if (key === null) {
        key = _key;
      } else {
        if (typeof key === "string") {
          key = forge.util.createBuffer(key);
        } else if (forge.util.isArray(key)) {
          var tmp = key;
          key = forge.util.createBuffer();
          for (var i = 0; i < tmp.length; ++i) {
            key.putByte(tmp[i]);
          }
        }
        var keylen = key.length();
        if (keylen > _md.blockLength) {
          _md.start();
          _md.update(key.bytes());
          key = _md.digest();
        }
        _ipadding = forge.util.createBuffer();
        _opadding = forge.util.createBuffer();
        keylen = key.length();
        for (var i = 0; i < keylen; ++i) {
          var tmp = key.at(i);
          _ipadding.putByte(54 ^ tmp);
          _opadding.putByte(92 ^ tmp);
        }
        if (keylen < _md.blockLength) {
          var tmp = _md.blockLength - keylen;
          for (var i = 0; i < tmp; ++i) {
            _ipadding.putByte(54);
            _opadding.putByte(92);
          }
        }
        _key = key;
        _ipadding = _ipadding.bytes();
        _opadding = _opadding.bytes();
      }
      _md.start();
      _md.update(_ipadding);
    };
    ctx.update = function(bytes) {
      _md.update(bytes);
    };
    ctx.getMac = function() {
      var inner = _md.digest().bytes();
      _md.start();
      _md.update(_opadding);
      _md.update(inner);
      return _md.digest();
    };
    ctx.digest = ctx.getMac;
    return ctx;
  };
});

// node_modules/node-forge/lib/md5.js
var require_md5 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_md();
  require_util();
  var md5 = module2.exports = forge.md5 = forge.md5 || {};
  forge.md.md5 = forge.md.algorithms.md5 = md5;
  md5.create = function() {
    if (!_initialized) {
      _init();
    }
    var _state = null;
    var _input = forge.util.createBuffer();
    var _w = new Array(16);
    var md = {
      algorithm: "md5",
      blockLength: 64,
      digestLength: 16,
      messageLength: 0,
      fullMessageLength: null,
      messageLengthSize: 8
    };
    md.start = function() {
      md.messageLength = 0;
      md.fullMessageLength = md.messageLength64 = [];
      var int32s = md.messageLengthSize / 4;
      for (var i = 0; i < int32s; ++i) {
        md.fullMessageLength.push(0);
      }
      _input = forge.util.createBuffer();
      _state = {
        h0: 1732584193,
        h1: 4023233417,
        h2: 2562383102,
        h3: 271733878
      };
      return md;
    };
    md.start();
    md.update = function(msg, encoding) {
      if (encoding === "utf8") {
        msg = forge.util.encodeUtf8(msg);
      }
      var len = msg.length;
      md.messageLength += len;
      len = [len / 4294967296 >>> 0, len >>> 0];
      for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
        md.fullMessageLength[i] += len[1];
        len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
        md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
        len[0] = len[1] / 4294967296 >>> 0;
      }
      _input.putBytes(msg);
      _update(_state, _w, _input);
      if (_input.read > 2048 || _input.length() === 0) {
        _input.compact();
      }
      return md;
    };
    md.digest = function() {
      var finalBlock = forge.util.createBuffer();
      finalBlock.putBytes(_input.bytes());
      var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
      var overflow = remaining & md.blockLength - 1;
      finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
      var bits, carry = 0;
      for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
        bits = md.fullMessageLength[i] * 8 + carry;
        carry = bits / 4294967296 >>> 0;
        finalBlock.putInt32Le(bits >>> 0);
      }
      var s2 = {
        h0: _state.h0,
        h1: _state.h1,
        h2: _state.h2,
        h3: _state.h3
      };
      _update(s2, _w, finalBlock);
      var rval = forge.util.createBuffer();
      rval.putInt32Le(s2.h0);
      rval.putInt32Le(s2.h1);
      rval.putInt32Le(s2.h2);
      rval.putInt32Le(s2.h3);
      return rval;
    };
    return md;
  };
  var _padding = null;
  var _g = null;
  var _r = null;
  var _k = null;
  var _initialized = false;
  function _init() {
    _padding = String.fromCharCode(128);
    _padding += forge.util.fillString(String.fromCharCode(0), 64);
    _g = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      1,
      6,
      11,
      0,
      5,
      10,
      15,
      4,
      9,
      14,
      3,
      8,
      13,
      2,
      7,
      12,
      5,
      8,
      11,
      14,
      1,
      4,
      7,
      10,
      13,
      0,
      3,
      6,
      9,
      12,
      15,
      2,
      0,
      7,
      14,
      5,
      12,
      3,
      10,
      1,
      8,
      15,
      6,
      13,
      4,
      11,
      2,
      9
    ];
    _r = [
      7,
      12,
      17,
      22,
      7,
      12,
      17,
      22,
      7,
      12,
      17,
      22,
      7,
      12,
      17,
      22,
      5,
      9,
      14,
      20,
      5,
      9,
      14,
      20,
      5,
      9,
      14,
      20,
      5,
      9,
      14,
      20,
      4,
      11,
      16,
      23,
      4,
      11,
      16,
      23,
      4,
      11,
      16,
      23,
      4,
      11,
      16,
      23,
      6,
      10,
      15,
      21,
      6,
      10,
      15,
      21,
      6,
      10,
      15,
      21,
      6,
      10,
      15,
      21
    ];
    _k = new Array(64);
    for (var i = 0; i < 64; ++i) {
      _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 4294967296);
    }
    _initialized = true;
  }
  function _update(s, w, bytes) {
    var t, a, b, c, d, f, r, i;
    var len = bytes.length();
    while (len >= 64) {
      a = s.h0;
      b = s.h1;
      c = s.h2;
      d = s.h3;
      for (i = 0; i < 16; ++i) {
        w[i] = bytes.getInt32Le();
        f = d ^ b & (c ^ d);
        t = a + f + _k[i] + w[i];
        r = _r[i];
        a = d;
        d = c;
        c = b;
        b += t << r | t >>> 32 - r;
      }
      for (; i < 32; ++i) {
        f = c ^ d & (b ^ c);
        t = a + f + _k[i] + w[_g[i]];
        r = _r[i];
        a = d;
        d = c;
        c = b;
        b += t << r | t >>> 32 - r;
      }
      for (; i < 48; ++i) {
        f = b ^ c ^ d;
        t = a + f + _k[i] + w[_g[i]];
        r = _r[i];
        a = d;
        d = c;
        c = b;
        b += t << r | t >>> 32 - r;
      }
      for (; i < 64; ++i) {
        f = c ^ (b | ~d);
        t = a + f + _k[i] + w[_g[i]];
        r = _r[i];
        a = d;
        d = c;
        c = b;
        b += t << r | t >>> 32 - r;
      }
      s.h0 = s.h0 + a | 0;
      s.h1 = s.h1 + b | 0;
      s.h2 = s.h2 + c | 0;
      s.h3 = s.h3 + d | 0;
      len -= 64;
    }
  }
});

// node_modules/node-forge/lib/pem.js
var require_pem = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util();
  var pem = module2.exports = forge.pem = forge.pem || {};
  pem.encode = function(msg, options) {
    options = options || {};
    var rval = "-----BEGIN " + msg.type + "-----\r\n";
    var header;
    if (msg.procType) {
      header = {
        name: "Proc-Type",
        values: [String(msg.procType.version), msg.procType.type]
      };
      rval += foldHeader(header);
    }
    if (msg.contentDomain) {
      header = {name: "Content-Domain", values: [msg.contentDomain]};
      rval += foldHeader(header);
    }
    if (msg.dekInfo) {
      header = {name: "DEK-Info", values: [msg.dekInfo.algorithm]};
      if (msg.dekInfo.parameters) {
        header.values.push(msg.dekInfo.parameters);
      }
      rval += foldHeader(header);
    }
    if (msg.headers) {
      for (var i = 0; i < msg.headers.length; ++i) {
        rval += foldHeader(msg.headers[i]);
      }
    }
    if (msg.procType) {
      rval += "\r\n";
    }
    rval += forge.util.encode64(msg.body, options.maxline || 64) + "\r\n";
    rval += "-----END " + msg.type + "-----\r\n";
    return rval;
  };
  pem.decode = function(str) {
    var rval = [];
    var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
    var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
    var rCRLF = /\r?\n/;
    var match;
    while (true) {
      match = rMessage.exec(str);
      if (!match) {
        break;
      }
      var msg = {
        type: match[1],
        procType: null,
        contentDomain: null,
        dekInfo: null,
        headers: [],
        body: forge.util.decode64(match[3])
      };
      rval.push(msg);
      if (!match[2]) {
        continue;
      }
      var lines = match[2].split(rCRLF);
      var li = 0;
      while (match && li < lines.length) {
        var line = lines[li].replace(/\s+$/, "");
        for (var nl = li + 1; nl < lines.length; ++nl) {
          var next = lines[nl];
          if (!/\s/.test(next[0])) {
            break;
          }
          line += next;
          li = nl;
        }
        match = line.match(rHeader);
        if (match) {
          var header = {name: match[1], values: []};
          var values = match[2].split(",");
          for (var vi = 0; vi < values.length; ++vi) {
            header.values.push(ltrim(values[vi]));
          }
          if (!msg.procType) {
            if (header.name !== "Proc-Type") {
              throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
            } else if (header.values.length !== 2) {
              throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
            }
            msg.procType = {version: values[0], type: values[1]};
          } else if (!msg.contentDomain && header.name === "Content-Domain") {
            msg.contentDomain = values[0] || "";
          } else if (!msg.dekInfo && header.name === "DEK-Info") {
            if (header.values.length === 0) {
              throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
            }
            msg.dekInfo = {algorithm: values[0], parameters: values[1] || null};
          } else {
            msg.headers.push(header);
          }
        }
        ++li;
      }
      if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
        throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
      }
    }
    if (rval.length === 0) {
      throw new Error("Invalid PEM formatted message.");
    }
    return rval;
  };
  function foldHeader(header) {
    var rval = header.name + ": ";
    var values = [];
    var insertSpace = function(match, $1) {
      return " " + $1;
    };
    for (var i = 0; i < header.values.length; ++i) {
      values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
    }
    rval += values.join(",") + "\r\n";
    var length = 0;
    var candidate = -1;
    for (var i = 0; i < rval.length; ++i, ++length) {
      if (length > 65 && candidate !== -1) {
        var insert = rval[candidate];
        if (insert === ",") {
          ++candidate;
          rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
        } else {
          rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
        }
        length = i - candidate - 1;
        candidate = -1;
        ++i;
      } else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") {
        candidate = i;
      }
    }
    return rval;
  }
  function ltrim(str) {
    return str.replace(/^\s+/, "");
  }
});

// node_modules/node-forge/lib/des.js
var require_des = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_cipher();
  require_cipherModes();
  require_util();
  module2.exports = forge.des = forge.des || {};
  forge.des.startEncrypting = function(key, iv, output, mode) {
    var cipher = _createCipher({
      key,
      output,
      decrypt: false,
      mode: mode || (iv === null ? "ECB" : "CBC")
    });
    cipher.start(iv);
    return cipher;
  };
  forge.des.createEncryptionCipher = function(key, mode) {
    return _createCipher({
      key,
      output: null,
      decrypt: false,
      mode
    });
  };
  forge.des.startDecrypting = function(key, iv, output, mode) {
    var cipher = _createCipher({
      key,
      output,
      decrypt: true,
      mode: mode || (iv === null ? "ECB" : "CBC")
    });
    cipher.start(iv);
    return cipher;
  };
  forge.des.createDecryptionCipher = function(key, mode) {
    return _createCipher({
      key,
      output: null,
      decrypt: true,
      mode
    });
  };
  forge.des.Algorithm = function(name, mode) {
    var self2 = this;
    self2.name = name;
    self2.mode = new mode({
      blockSize: 8,
      cipher: {
        encrypt: function(inBlock, outBlock) {
          return _updateBlock(self2._keys, inBlock, outBlock, false);
        },
        decrypt: function(inBlock, outBlock) {
          return _updateBlock(self2._keys, inBlock, outBlock, true);
        }
      }
    });
    self2._init = false;
  };
  forge.des.Algorithm.prototype.initialize = function(options) {
    if (this._init) {
      return;
    }
    var key = forge.util.createBuffer(options.key);
    if (this.name.indexOf("3DES") === 0) {
      if (key.length() !== 24) {
        throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
      }
    }
    this._keys = _createKeys(key);
    this._init = true;
  };
  registerAlgorithm("DES-ECB", forge.cipher.modes.ecb);
  registerAlgorithm("DES-CBC", forge.cipher.modes.cbc);
  registerAlgorithm("DES-CFB", forge.cipher.modes.cfb);
  registerAlgorithm("DES-OFB", forge.cipher.modes.ofb);
  registerAlgorithm("DES-CTR", forge.cipher.modes.ctr);
  registerAlgorithm("3DES-ECB", forge.cipher.modes.ecb);
  registerAlgorithm("3DES-CBC", forge.cipher.modes.cbc);
  registerAlgorithm("3DES-CFB", forge.cipher.modes.cfb);
  registerAlgorithm("3DES-OFB", forge.cipher.modes.ofb);
  registerAlgorithm("3DES-CTR", forge.cipher.modes.ctr);
  function registerAlgorithm(name, mode) {
    var factory = function() {
      return new forge.des.Algorithm(name, mode);
    };
    forge.cipher.registerAlgorithm(name, factory);
  }
  var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
  var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
  var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
  var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
  var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
  var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
  var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
  var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
  function _createKeys(key) {
    var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
    var iterations = key.length() > 8 ? 3 : 1;
    var keys = [];
    var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
    var n = 0, tmp;
    for (var j = 0; j < iterations; j++) {
      var left = key.getInt32();
      var right = key.getInt32();
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (right >>> -16 ^ left) & 65535;
      left ^= tmp;
      right ^= tmp << -16;
      tmp = (left >>> 2 ^ right) & 858993459;
      right ^= tmp;
      left ^= tmp << 2;
      tmp = (right >>> -16 ^ left) & 65535;
      left ^= tmp;
      right ^= tmp << -16;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = left << 8 | right >>> 20 & 240;
      left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
      right = tmp;
      for (var i = 0; i < shifts.length; ++i) {
        if (shifts[i]) {
          left = left << 2 | left >>> 26;
          right = right << 2 | right >>> 26;
        } else {
          left = left << 1 | left >>> 27;
          right = right << 1 | right >>> 27;
        }
        left &= -15;
        right &= -15;
        var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
        var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
        tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
        keys[n++] = lefttmp ^ tmp;
        keys[n++] = righttmp ^ tmp << 16;
      }
    }
    return keys;
  }
  function _updateBlock(keys, input, output, decrypt) {
    var iterations = keys.length === 32 ? 3 : 9;
    var looping;
    if (iterations === 3) {
      looping = decrypt ? [30, -2, -2] : [0, 32, 2];
    } else {
      looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
    }
    var tmp;
    var left = input[0];
    var right = input[1];
    tmp = (left >>> 4 ^ right) & 252645135;
    right ^= tmp;
    left ^= tmp << 4;
    tmp = (left >>> 16 ^ right) & 65535;
    right ^= tmp;
    left ^= tmp << 16;
    tmp = (right >>> 2 ^ left) & 858993459;
    left ^= tmp;
    right ^= tmp << 2;
    tmp = (right >>> 8 ^ left) & 16711935;
    left ^= tmp;
    right ^= tmp << 8;
    tmp = (left >>> 1 ^ right) & 1431655765;
    right ^= tmp;
    left ^= tmp << 1;
    left = left << 1 | left >>> 31;
    right = right << 1 | right >>> 31;
    for (var j = 0; j < iterations; j += 3) {
      var endloop = looping[j + 1];
      var loopinc = looping[j + 2];
      for (var i = looping[j]; i != endloop; i += loopinc) {
        var right1 = right ^ keys[i];
        var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];
        tmp = left;
        left = right;
        right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
      }
      tmp = left;
      left = right;
      right = tmp;
    }
    left = left >>> 1 | left << 31;
    right = right >>> 1 | right << 31;
    tmp = (left >>> 1 ^ right) & 1431655765;
    right ^= tmp;
    left ^= tmp << 1;
    tmp = (right >>> 8 ^ left) & 16711935;
    left ^= tmp;
    right ^= tmp << 8;
    tmp = (right >>> 2 ^ left) & 858993459;
    left ^= tmp;
    right ^= tmp << 2;
    tmp = (left >>> 16 ^ right) & 65535;
    right ^= tmp;
    left ^= tmp << 16;
    tmp = (left >>> 4 ^ right) & 252645135;
    right ^= tmp;
    left ^= tmp << 4;
    output[0] = left;
    output[1] = right;
  }
  function _createCipher(options) {
    options = options || {};
    var mode = (options.mode || "CBC").toUpperCase();
    var algorithm = "DES-" + mode;
    var cipher;
    if (options.decrypt) {
      cipher = forge.cipher.createDecipher(algorithm, options.key);
    } else {
      cipher = forge.cipher.createCipher(algorithm, options.key);
    }
    var start = cipher.start;
    cipher.start = function(iv, options2) {
      var output = null;
      if (options2 instanceof forge.util.ByteBuffer) {
        output = options2;
        options2 = {};
      }
      options2 = options2 || {};
      options2.output = output;
      options2.iv = iv;
      start.call(cipher, options2);
    };
    return cipher;
  }
});

// node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf2 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_hmac();
  require_md();
  require_util();
  var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
  var crypto2;
  if (forge.util.isNodejs && !forge.options.usePureJavaScript) {
    crypto2 = require("crypto");
  }
  module2.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {
    if (typeof md === "function") {
      callback = md;
      md = null;
    }
    if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto2.pbkdf2 && (md === null || typeof md !== "object") && (crypto2.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
      if (typeof md !== "string") {
        md = "sha1";
      }
      p = Buffer.from(p, "binary");
      s = Buffer.from(s, "binary");
      if (!callback) {
        if (crypto2.pbkdf2Sync.length === 4) {
          return crypto2.pbkdf2Sync(p, s, c, dkLen).toString("binary");
        }
        return crypto2.pbkdf2Sync(p, s, c, dkLen, md).toString("binary");
      }
      if (crypto2.pbkdf2Sync.length === 4) {
        return crypto2.pbkdf2(p, s, c, dkLen, function(err2, key) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key.toString("binary"));
        });
      }
      return crypto2.pbkdf2(p, s, c, dkLen, md, function(err2, key) {
        if (err2) {
          return callback(err2);
        }
        callback(null, key.toString("binary"));
      });
    }
    if (typeof md === "undefined" || md === null) {
      md = "sha1";
    }
    if (typeof md === "string") {
      if (!(md in forge.md.algorithms)) {
        throw new Error("Unknown hash algorithm: " + md);
      }
      md = forge.md[md].create();
    }
    var hLen = md.digestLength;
    if (dkLen > 4294967295 * hLen) {
      var err = new Error("Derived key is too long.");
      if (callback) {
        return callback(err);
      }
      throw err;
    }
    var len = Math.ceil(dkLen / hLen);
    var r = dkLen - (len - 1) * hLen;
    var prf = forge.hmac.create();
    prf.start(md, p);
    var dk = "";
    var xor, u_c, u_c1;
    if (!callback) {
      for (var i = 1; i <= len; ++i) {
        prf.start(null, null);
        prf.update(s);
        prf.update(forge.util.int32ToBytes(i));
        xor = u_c1 = prf.digest().getBytes();
        for (var j = 2; j <= c; ++j) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor = forge.util.xorBytes(xor, u_c, hLen);
          u_c1 = u_c;
        }
        dk += i < len ? xor : xor.substr(0, r);
      }
      return dk;
    }
    var i = 1, j;
    function outer() {
      if (i > len) {
        return callback(null, dk);
      }
      prf.start(null, null);
      prf.update(s);
      prf.update(forge.util.int32ToBytes(i));
      xor = u_c1 = prf.digest().getBytes();
      j = 2;
      inner();
    }
    function inner() {
      if (j <= c) {
        prf.start(null, null);
        prf.update(u_c1);
        u_c = prf.digest().getBytes();
        xor = forge.util.xorBytes(xor, u_c, hLen);
        u_c1 = u_c;
        ++j;
        return forge.util.setImmediate(inner);
      }
      dk += i < len ? xor : xor.substr(0, r);
      ++i;
      outer();
    }
    outer();
  };
});

// node_modules/node-forge/lib/sha256.js
var require_sha256 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_md();
  require_util();
  var sha256 = module2.exports = forge.sha256 = forge.sha256 || {};
  forge.md.sha256 = forge.md.algorithms.sha256 = sha256;
  sha256.create = function() {
    if (!_initialized) {
      _init();
    }
    var _state = null;
    var _input = forge.util.createBuffer();
    var _w = new Array(64);
    var md = {
      algorithm: "sha256",
      blockLength: 64,
      digestLength: 32,
      messageLength: 0,
      fullMessageLength: null,
      messageLengthSize: 8
    };
    md.start = function() {
      md.messageLength = 0;
      md.fullMessageLength = md.messageLength64 = [];
      var int32s = md.messageLengthSize / 4;
      for (var i = 0; i < int32s; ++i) {
        md.fullMessageLength.push(0);
      }
      _input = forge.util.createBuffer();
      _state = {
        h0: 1779033703,
        h1: 3144134277,
        h2: 1013904242,
        h3: 2773480762,
        h4: 1359893119,
        h5: 2600822924,
        h6: 528734635,
        h7: 1541459225
      };
      return md;
    };
    md.start();
    md.update = function(msg, encoding) {
      if (encoding === "utf8") {
        msg = forge.util.encodeUtf8(msg);
      }
      var len = msg.length;
      md.messageLength += len;
      len = [len / 4294967296 >>> 0, len >>> 0];
      for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
        md.fullMessageLength[i] += len[1];
        len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
        md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
        len[0] = len[1] / 4294967296 >>> 0;
      }
      _input.putBytes(msg);
      _update(_state, _w, _input);
      if (_input.read > 2048 || _input.length() === 0) {
        _input.compact();
      }
      return md;
    };
    md.digest = function() {
      var finalBlock = forge.util.createBuffer();
      finalBlock.putBytes(_input.bytes());
      var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
      var overflow = remaining & md.blockLength - 1;
      finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
      var next, carry;
      var bits = md.fullMessageLength[0] * 8;
      for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
        next = md.fullMessageLength[i + 1] * 8;
        carry = next / 4294967296 >>> 0;
        bits += carry;
        finalBlock.putInt32(bits >>> 0);
        bits = next >>> 0;
      }
      finalBlock.putInt32(bits);
      var s2 = {
        h0: _state.h0,
        h1: _state.h1,
        h2: _state.h2,
        h3: _state.h3,
        h4: _state.h4,
        h5: _state.h5,
        h6: _state.h6,
        h7: _state.h7
      };
      _update(s2, _w, finalBlock);
      var rval = forge.util.createBuffer();
      rval.putInt32(s2.h0);
      rval.putInt32(s2.h1);
      rval.putInt32(s2.h2);
      rval.putInt32(s2.h3);
      rval.putInt32(s2.h4);
      rval.putInt32(s2.h5);
      rval.putInt32(s2.h6);
      rval.putInt32(s2.h7);
      return rval;
    };
    return md;
  };
  var _padding = null;
  var _initialized = false;
  var _k = null;
  function _init() {
    _padding = String.fromCharCode(128);
    _padding += forge.util.fillString(String.fromCharCode(0), 64);
    _k = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    _initialized = true;
  }
  function _update(s, w, bytes) {
    var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
    var len = bytes.length();
    while (len >= 64) {
      for (i = 0; i < 16; ++i) {
        w[i] = bytes.getInt32();
      }
      for (; i < 64; ++i) {
        t1 = w[i - 2];
        t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
        t2 = w[i - 15];
        t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
        w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
      }
      a = s.h0;
      b = s.h1;
      c = s.h2;
      d = s.h3;
      e = s.h4;
      f = s.h5;
      g = s.h6;
      h = s.h7;
      for (i = 0; i < 64; ++i) {
        s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
        ch = g ^ e & (f ^ g);
        s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
        maj = a & b | c & (a ^ b);
        t1 = h + s1 + ch + _k[i] + w[i];
        t2 = s0 + maj;
        h = g;
        g = f;
        f = e;
        e = d + t1 >>> 0;
        d = c;
        c = b;
        b = a;
        a = t1 + t2 >>> 0;
      }
      s.h0 = s.h0 + a | 0;
      s.h1 = s.h1 + b | 0;
      s.h2 = s.h2 + c | 0;
      s.h3 = s.h3 + d | 0;
      s.h4 = s.h4 + e | 0;
      s.h5 = s.h5 + f | 0;
      s.h6 = s.h6 + g | 0;
      s.h7 = s.h7 + h | 0;
      len -= 64;
    }
  }
});

// node_modules/node-forge/lib/prng.js
var require_prng = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util();
  var _crypto = null;
  if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions["node-webkit"]) {
    _crypto = require("crypto");
  }
  var prng = module2.exports = forge.prng = forge.prng || {};
  prng.create = function(plugin) {
    var ctx = {
      plugin,
      key: null,
      seed: null,
      time: null,
      reseeds: 0,
      generated: 0,
      keyBytes: ""
    };
    var md = plugin.md;
    var pools = new Array(32);
    for (var i = 0; i < 32; ++i) {
      pools[i] = md.create();
    }
    ctx.pools = pools;
    ctx.pool = 0;
    ctx.generate = function(count, callback) {
      if (!callback) {
        return ctx.generateSync(count);
      }
      var cipher = ctx.plugin.cipher;
      var increment = ctx.plugin.increment;
      var formatKey = ctx.plugin.formatKey;
      var formatSeed = ctx.plugin.formatSeed;
      var b = forge.util.createBuffer();
      ctx.key = null;
      generate();
      function generate(err) {
        if (err) {
          return callback(err);
        }
        if (b.length() >= count) {
          return callback(null, b.getBytes(count));
        }
        if (ctx.generated > 1048575) {
          ctx.key = null;
        }
        if (ctx.key === null) {
          return forge.util.nextTick(function() {
            _reseed(generate);
          });
        }
        var bytes = cipher(ctx.key, ctx.seed);
        ctx.generated += bytes.length;
        b.putBytes(bytes);
        ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
        ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        forge.util.setImmediate(generate);
      }
    };
    ctx.generateSync = function(count) {
      var cipher = ctx.plugin.cipher;
      var increment = ctx.plugin.increment;
      var formatKey = ctx.plugin.formatKey;
      var formatSeed = ctx.plugin.formatSeed;
      ctx.key = null;
      var b = forge.util.createBuffer();
      while (b.length() < count) {
        if (ctx.generated > 1048575) {
          ctx.key = null;
        }
        if (ctx.key === null) {
          _reseedSync();
        }
        var bytes = cipher(ctx.key, ctx.seed);
        ctx.generated += bytes.length;
        b.putBytes(bytes);
        ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
        ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
      }
      return b.getBytes(count);
    };
    function _reseed(callback) {
      if (ctx.pools[0].messageLength >= 32) {
        _seed();
        return callback();
      }
      var needed = 32 - ctx.pools[0].messageLength << 5;
      ctx.seedFile(needed, function(err, bytes) {
        if (err) {
          return callback(err);
        }
        ctx.collect(bytes);
        _seed();
        callback();
      });
    }
    function _reseedSync() {
      if (ctx.pools[0].messageLength >= 32) {
        return _seed();
      }
      var needed = 32 - ctx.pools[0].messageLength << 5;
      ctx.collect(ctx.seedFileSync(needed));
      _seed();
    }
    function _seed() {
      ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
      var md2 = ctx.plugin.md.create();
      md2.update(ctx.keyBytes);
      var _2powK = 1;
      for (var k = 0; k < 32; ++k) {
        if (ctx.reseeds % _2powK === 0) {
          md2.update(ctx.pools[k].digest().getBytes());
          ctx.pools[k].start();
        }
        _2powK = _2powK << 1;
      }
      ctx.keyBytes = md2.digest().getBytes();
      md2.start();
      md2.update(ctx.keyBytes);
      var seedBytes = md2.digest().getBytes();
      ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
      ctx.seed = ctx.plugin.formatSeed(seedBytes);
      ctx.generated = 0;
    }
    function defaultSeedFile(needed) {
      var getRandomValues = null;
      var globalScope = forge.util.globalScope;
      var _crypto2 = globalScope.crypto || globalScope.msCrypto;
      if (_crypto2 && _crypto2.getRandomValues) {
        getRandomValues = function(arr) {
          return _crypto2.getRandomValues(arr);
        };
      }
      var b = forge.util.createBuffer();
      if (getRandomValues) {
        while (b.length() < needed) {
          var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
          var entropy = new Uint32Array(Math.floor(count));
          try {
            getRandomValues(entropy);
            for (var i2 = 0; i2 < entropy.length; ++i2) {
              b.putInt32(entropy[i2]);
            }
          } catch (e) {
            if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
              throw e;
            }
          }
        }
      }
      if (b.length() < needed) {
        var hi, lo, next;
        var seed = Math.floor(Math.random() * 65536);
        while (b.length() < needed) {
          lo = 16807 * (seed & 65535);
          hi = 16807 * (seed >> 16);
          lo += (hi & 32767) << 16;
          lo += hi >> 15;
          lo = (lo & 2147483647) + (lo >> 31);
          seed = lo & 4294967295;
          for (var i2 = 0; i2 < 3; ++i2) {
            next = seed >>> (i2 << 3);
            next ^= Math.floor(Math.random() * 256);
            b.putByte(String.fromCharCode(next & 255));
          }
        }
      }
      return b.getBytes(needed);
    }
    if (_crypto) {
      ctx.seedFile = function(needed, callback) {
        _crypto.randomBytes(needed, function(err, bytes) {
          if (err) {
            return callback(err);
          }
          callback(null, bytes.toString());
        });
      };
      ctx.seedFileSync = function(needed) {
        return _crypto.randomBytes(needed).toString();
      };
    } else {
      ctx.seedFile = function(needed, callback) {
        try {
          callback(null, defaultSeedFile(needed));
        } catch (e) {
          callback(e);
        }
      };
      ctx.seedFileSync = defaultSeedFile;
    }
    ctx.collect = function(bytes) {
      var count = bytes.length;
      for (var i2 = 0; i2 < count; ++i2) {
        ctx.pools[ctx.pool].update(bytes.substr(i2, 1));
        ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
      }
    };
    ctx.collectInt = function(i2, n) {
      var bytes = "";
      for (var x = 0; x < n; x += 8) {
        bytes += String.fromCharCode(i2 >> x & 255);
      }
      ctx.collect(bytes);
    };
    ctx.registerWorker = function(worker) {
      if (worker === self) {
        ctx.seedFile = function(needed, callback) {
          function listener2(e) {
            var data = e.data;
            if (data.forge && data.forge.prng) {
              self.removeEventListener("message", listener2);
              callback(data.forge.prng.err, data.forge.prng.bytes);
            }
          }
          self.addEventListener("message", listener2);
          self.postMessage({forge: {prng: {needed}}});
        };
      } else {
        var listener = function(e) {
          var data = e.data;
          if (data.forge && data.forge.prng) {
            ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
              worker.postMessage({forge: {prng: {err, bytes}}});
            });
          }
        };
        worker.addEventListener("message", listener);
      }
    };
    return ctx;
  };
});

// node_modules/node-forge/lib/random.js
var require_random = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_aes();
  require_sha256();
  require_prng();
  require_util();
  (function() {
    if (forge.random && forge.random.getBytes) {
      module2.exports = forge.random;
      return;
    }
    (function(jQuery2) {
      var prng_aes = {};
      var _prng_aes_output = new Array(4);
      var _prng_aes_buffer = forge.util.createBuffer();
      prng_aes.formatKey = function(key2) {
        var tmp = forge.util.createBuffer(key2);
        key2 = new Array(4);
        key2[0] = tmp.getInt32();
        key2[1] = tmp.getInt32();
        key2[2] = tmp.getInt32();
        key2[3] = tmp.getInt32();
        return forge.aes._expandKey(key2, false);
      };
      prng_aes.formatSeed = function(seed) {
        var tmp = forge.util.createBuffer(seed);
        seed = new Array(4);
        seed[0] = tmp.getInt32();
        seed[1] = tmp.getInt32();
        seed[2] = tmp.getInt32();
        seed[3] = tmp.getInt32();
        return seed;
      };
      prng_aes.cipher = function(key2, seed) {
        forge.aes._updateBlock(key2, seed, _prng_aes_output, false);
        _prng_aes_buffer.putInt32(_prng_aes_output[0]);
        _prng_aes_buffer.putInt32(_prng_aes_output[1]);
        _prng_aes_buffer.putInt32(_prng_aes_output[2]);
        _prng_aes_buffer.putInt32(_prng_aes_output[3]);
        return _prng_aes_buffer.getBytes();
      };
      prng_aes.increment = function(seed) {
        ++seed[3];
        return seed;
      };
      prng_aes.md = forge.md.sha256;
      function spawnPrng() {
        var ctx = forge.prng.create(prng_aes);
        ctx.getBytes = function(count, callback) {
          return ctx.generate(count, callback);
        };
        ctx.getBytesSync = function(count) {
          return ctx.generate(count);
        };
        return ctx;
      }
      var _ctx = spawnPrng();
      var getRandomValues = null;
      var globalScope = forge.util.globalScope;
      var _crypto = globalScope.crypto || globalScope.msCrypto;
      if (_crypto && _crypto.getRandomValues) {
        getRandomValues = function(arr) {
          return _crypto.getRandomValues(arr);
        };
      }
      if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {
        if (typeof window === "undefined" || window.document === void 0) {
        }
        _ctx.collectInt(+new Date(), 32);
        if (typeof navigator !== "undefined") {
          var _navBytes = "";
          for (var key in navigator) {
            try {
              if (typeof navigator[key] == "string") {
                _navBytes += navigator[key];
              }
            } catch (e) {
            }
          }
          _ctx.collect(_navBytes);
          _navBytes = null;
        }
        if (jQuery2) {
          jQuery2().mousemove(function(e) {
            _ctx.collectInt(e.clientX, 16);
            _ctx.collectInt(e.clientY, 16);
          });
          jQuery2().keypress(function(e) {
            _ctx.collectInt(e.charCode, 8);
          });
        }
      }
      if (!forge.random) {
        forge.random = _ctx;
      } else {
        for (var key in _ctx) {
          forge.random[key] = _ctx[key];
        }
      }
      forge.random.createInstance = spawnPrng;
      module2.exports = forge.random;
    })(typeof jQuery !== "undefined" ? jQuery : null);
  })();
});

// node_modules/node-forge/lib/rc2.js
var require_rc2 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util();
  var piTable = [
    217,
    120,
    249,
    196,
    25,
    221,
    181,
    237,
    40,
    233,
    253,
    121,
    74,
    160,
    216,
    157,
    198,
    126,
    55,
    131,
    43,
    118,
    83,
    142,
    98,
    76,
    100,
    136,
    68,
    139,
    251,
    162,
    23,
    154,
    89,
    245,
    135,
    179,
    79,
    19,
    97,
    69,
    109,
    141,
    9,
    129,
    125,
    50,
    189,
    143,
    64,
    235,
    134,
    183,
    123,
    11,
    240,
    149,
    33,
    34,
    92,
    107,
    78,
    130,
    84,
    214,
    101,
    147,
    206,
    96,
    178,
    28,
    115,
    86,
    192,
    20,
    167,
    140,
    241,
    220,
    18,
    117,
    202,
    31,
    59,
    190,
    228,
    209,
    66,
    61,
    212,
    48,
    163,
    60,
    182,
    38,
    111,
    191,
    14,
    218,
    70,
    105,
    7,
    87,
    39,
    242,
    29,
    155,
    188,
    148,
    67,
    3,
    248,
    17,
    199,
    246,
    144,
    239,
    62,
    231,
    6,
    195,
    213,
    47,
    200,
    102,
    30,
    215,
    8,
    232,
    234,
    222,
    128,
    82,
    238,
    247,
    132,
    170,
    114,
    172,
    53,
    77,
    106,
    42,
    150,
    26,
    210,
    113,
    90,
    21,
    73,
    116,
    75,
    159,
    208,
    94,
    4,
    24,
    164,
    236,
    194,
    224,
    65,
    110,
    15,
    81,
    203,
    204,
    36,
    145,
    175,
    80,
    161,
    244,
    112,
    57,
    153,
    124,
    58,
    133,
    35,
    184,
    180,
    122,
    252,
    2,
    54,
    91,
    37,
    85,
    151,
    49,
    45,
    93,
    250,
    152,
    227,
    138,
    146,
    174,
    5,
    223,
    41,
    16,
    103,
    108,
    186,
    201,
    211,
    0,
    230,
    207,
    225,
    158,
    168,
    44,
    99,
    22,
    1,
    63,
    88,
    226,
    137,
    169,
    13,
    56,
    52,
    27,
    171,
    51,
    255,
    176,
    187,
    72,
    12,
    95,
    185,
    177,
    205,
    46,
    197,
    243,
    219,
    71,
    229,
    165,
    156,
    119,
    10,
    166,
    32,
    104,
    254,
    127,
    193,
    173
  ];
  var s = [1, 2, 3, 5];
  var rol = function(word, bits) {
    return word << bits & 65535 | (word & 65535) >> 16 - bits;
  };
  var ror = function(word, bits) {
    return (word & 65535) >> bits | word << 16 - bits & 65535;
  };
  module2.exports = forge.rc2 = forge.rc2 || {};
  forge.rc2.expandKey = function(key, effKeyBits) {
    if (typeof key === "string") {
      key = forge.util.createBuffer(key);
    }
    effKeyBits = effKeyBits || 128;
    var L = key;
    var T = key.length();
    var T1 = effKeyBits;
    var T8 = Math.ceil(T1 / 8);
    var TM = 255 >> (T1 & 7);
    var i;
    for (i = T; i < 128; i++) {
      L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
    }
    L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
    for (i = 127 - T8; i >= 0; i--) {
      L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
    }
    return L;
  };
  var createCipher = function(key, bits, encrypt) {
    var _finish = false, _input = null, _output = null, _iv = null;
    var mixRound, mashRound;
    var i, j, K = [];
    key = forge.rc2.expandKey(key, bits);
    for (i = 0; i < 64; i++) {
      K.push(key.getInt16Le());
    }
    if (encrypt) {
      mixRound = function(R) {
        for (i = 0; i < 4; i++) {
          R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
          R[i] = rol(R[i], s[i]);
          j++;
        }
      };
      mashRound = function(R) {
        for (i = 0; i < 4; i++) {
          R[i] += K[R[(i + 3) % 4] & 63];
        }
      };
    } else {
      mixRound = function(R) {
        for (i = 3; i >= 0; i--) {
          R[i] = ror(R[i], s[i]);
          R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
          j--;
        }
      };
      mashRound = function(R) {
        for (i = 3; i >= 0; i--) {
          R[i] -= K[R[(i + 3) % 4] & 63];
        }
      };
    }
    var runPlan = function(plan) {
      var R = [];
      for (i = 0; i < 4; i++) {
        var val = _input.getInt16Le();
        if (_iv !== null) {
          if (encrypt) {
            val ^= _iv.getInt16Le();
          } else {
            _iv.putInt16Le(val);
          }
        }
        R.push(val & 65535);
      }
      j = encrypt ? 0 : 63;
      for (var ptr = 0; ptr < plan.length; ptr++) {
        for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
          plan[ptr][1](R);
        }
      }
      for (i = 0; i < 4; i++) {
        if (_iv !== null) {
          if (encrypt) {
            _iv.putInt16Le(R[i]);
          } else {
            R[i] ^= _iv.getInt16Le();
          }
        }
        _output.putInt16Le(R[i]);
      }
    };
    var cipher = null;
    cipher = {
      start: function(iv, output) {
        if (iv) {
          if (typeof iv === "string") {
            iv = forge.util.createBuffer(iv);
          }
        }
        _finish = false;
        _input = forge.util.createBuffer();
        _output = output || new forge.util.createBuffer();
        _iv = iv;
        cipher.output = _output;
      },
      update: function(input) {
        if (!_finish) {
          _input.putBuffer(input);
        }
        while (_input.length() >= 8) {
          runPlan([
            [5, mixRound],
            [1, mashRound],
            [6, mixRound],
            [1, mashRound],
            [5, mixRound]
          ]);
        }
      },
      finish: function(pad) {
        var rval = true;
        if (encrypt) {
          if (pad) {
            rval = pad(8, _input, !encrypt);
          } else {
            var padding = _input.length() === 8 ? 8 : 8 - _input.length();
            _input.fillWithByte(padding, padding);
          }
        }
        if (rval) {
          _finish = true;
          cipher.update();
        }
        if (!encrypt) {
          rval = _input.length() === 0;
          if (rval) {
            if (pad) {
              rval = pad(8, _output, !encrypt);
            } else {
              var len = _output.length();
              var count = _output.at(len - 1);
              if (count > len) {
                rval = false;
              } else {
                _output.truncate(count);
              }
            }
          }
        }
        return rval;
      }
    };
    return cipher;
  };
  forge.rc2.startEncrypting = function(key, iv, output) {
    var cipher = forge.rc2.createEncryptionCipher(key, 128);
    cipher.start(iv, output);
    return cipher;
  };
  forge.rc2.createEncryptionCipher = function(key, bits) {
    return createCipher(key, bits, true);
  };
  forge.rc2.startDecrypting = function(key, iv, output) {
    var cipher = forge.rc2.createDecryptionCipher(key, 128);
    cipher.start(iv, output);
    return cipher;
  };
  forge.rc2.createDecryptionCipher = function(key, bits) {
    return createCipher(key, bits, false);
  };
});

// node_modules/node-forge/lib/jsbn.js
var require_jsbn = __commonJS((exports2, module2) => {
  var forge = require_forge();
  module2.exports = forge.jsbn = forge.jsbn || {};
  var dbits;
  var canary = 244837814094590;
  var j_lm = (canary & 16777215) == 15715070;
  function BigInteger(a, b, c) {
    this.data = [];
    if (a != null)
      if (typeof a == "number")
        this.fromNumber(a, b, c);
      else if (b == null && typeof a != "string")
        this.fromString(a, 256);
      else
        this.fromString(a, b);
  }
  forge.jsbn.BigInteger = BigInteger;
  function nbi() {
    return new BigInteger(null);
  }
  function am1(i, x, w, j, c, n) {
    while (--n >= 0) {
      var v = x * this.data[i++] + w.data[j] + c;
      c = Math.floor(v / 67108864);
      w.data[j++] = v & 67108863;
    }
    return c;
  }
  function am2(i, x, w, j, c, n) {
    var xl = x & 32767, xh = x >> 15;
    while (--n >= 0) {
      var l = this.data[i] & 32767;
      var h = this.data[i++] >> 15;
      var m = xh * l + h * xl;
      l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
      w.data[j++] = l & 1073741823;
    }
    return c;
  }
  function am3(i, x, w, j, c, n) {
    var xl = x & 16383, xh = x >> 14;
    while (--n >= 0) {
      var l = this.data[i] & 16383;
      var h = this.data[i++] >> 14;
      var m = xh * l + h * xl;
      l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
      c = (l >> 28) + (m >> 14) + xh * h;
      w.data[j++] = l & 268435455;
    }
    return c;
  }
  if (typeof navigator === "undefined") {
    BigInteger.prototype.am = am3;
    dbits = 28;
  } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
    BigInteger.prototype.am = am2;
    dbits = 30;
  } else if (j_lm && navigator.appName != "Netscape") {
    BigInteger.prototype.am = am1;
    dbits = 26;
  } else {
    BigInteger.prototype.am = am3;
    dbits = 28;
  }
  BigInteger.prototype.DB = dbits;
  BigInteger.prototype.DM = (1 << dbits) - 1;
  BigInteger.prototype.DV = 1 << dbits;
  var BI_FP = 52;
  BigInteger.prototype.FV = Math.pow(2, BI_FP);
  BigInteger.prototype.F1 = BI_FP - dbits;
  BigInteger.prototype.F2 = 2 * dbits - BI_FP;
  var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
  var BI_RC = new Array();
  var rr;
  var vv;
  rr = "0".charCodeAt(0);
  for (vv = 0; vv <= 9; ++vv)
    BI_RC[rr++] = vv;
  rr = "a".charCodeAt(0);
  for (vv = 10; vv < 36; ++vv)
    BI_RC[rr++] = vv;
  rr = "A".charCodeAt(0);
  for (vv = 10; vv < 36; ++vv)
    BI_RC[rr++] = vv;
  function int2char(n) {
    return BI_RM.charAt(n);
  }
  function intAt(s, i) {
    var c = BI_RC[s.charCodeAt(i)];
    return c == null ? -1 : c;
  }
  function bnpCopyTo(r) {
    for (var i = this.t - 1; i >= 0; --i)
      r.data[i] = this.data[i];
    r.t = this.t;
    r.s = this.s;
  }
  function bnpFromInt(x) {
    this.t = 1;
    this.s = x < 0 ? -1 : 0;
    if (x > 0)
      this.data[0] = x;
    else if (x < -1)
      this.data[0] = x + this.DV;
    else
      this.t = 0;
  }
  function nbv(i) {
    var r = nbi();
    r.fromInt(i);
    return r;
  }
  function bnpFromString(s, b) {
    var k;
    if (b == 16)
      k = 4;
    else if (b == 8)
      k = 3;
    else if (b == 256)
      k = 8;
    else if (b == 2)
      k = 1;
    else if (b == 32)
      k = 5;
    else if (b == 4)
      k = 2;
    else {
      this.fromRadix(s, b);
      return;
    }
    this.t = 0;
    this.s = 0;
    var i = s.length, mi = false, sh = 0;
    while (--i >= 0) {
      var x = k == 8 ? s[i] & 255 : intAt(s, i);
      if (x < 0) {
        if (s.charAt(i) == "-")
          mi = true;
        continue;
      }
      mi = false;
      if (sh == 0)
        this.data[this.t++] = x;
      else if (sh + k > this.DB) {
        this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
        this.data[this.t++] = x >> this.DB - sh;
      } else
        this.data[this.t - 1] |= x << sh;
      sh += k;
      if (sh >= this.DB)
        sh -= this.DB;
    }
    if (k == 8 && (s[0] & 128) != 0) {
      this.s = -1;
      if (sh > 0)
        this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
    }
    this.clamp();
    if (mi)
      BigInteger.ZERO.subTo(this, this);
  }
  function bnpClamp() {
    var c = this.s & this.DM;
    while (this.t > 0 && this.data[this.t - 1] == c)
      --this.t;
  }
  function bnToString(b) {
    if (this.s < 0)
      return "-" + this.negate().toString(b);
    var k;
    if (b == 16)
      k = 4;
    else if (b == 8)
      k = 3;
    else if (b == 2)
      k = 1;
    else if (b == 32)
      k = 5;
    else if (b == 4)
      k = 2;
    else
      return this.toRadix(b);
    var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
    var p = this.DB - i * this.DB % k;
    if (i-- > 0) {
      if (p < this.DB && (d = this.data[i] >> p) > 0) {
        m = true;
        r = int2char(d);
      }
      while (i >= 0) {
        if (p < k) {
          d = (this.data[i] & (1 << p) - 1) << k - p;
          d |= this.data[--i] >> (p += this.DB - k);
        } else {
          d = this.data[i] >> (p -= k) & km;
          if (p <= 0) {
            p += this.DB;
            --i;
          }
        }
        if (d > 0)
          m = true;
        if (m)
          r += int2char(d);
      }
    }
    return m ? r : "0";
  }
  function bnNegate() {
    var r = nbi();
    BigInteger.ZERO.subTo(this, r);
    return r;
  }
  function bnAbs() {
    return this.s < 0 ? this.negate() : this;
  }
  function bnCompareTo(a) {
    var r = this.s - a.s;
    if (r != 0)
      return r;
    var i = this.t;
    r = i - a.t;
    if (r != 0)
      return this.s < 0 ? -r : r;
    while (--i >= 0)
      if ((r = this.data[i] - a.data[i]) != 0)
        return r;
    return 0;
  }
  function nbits(x) {
    var r = 1, t;
    if ((t = x >>> 16) != 0) {
      x = t;
      r += 16;
    }
    if ((t = x >> 8) != 0) {
      x = t;
      r += 8;
    }
    if ((t = x >> 4) != 0) {
      x = t;
      r += 4;
    }
    if ((t = x >> 2) != 0) {
      x = t;
      r += 2;
    }
    if ((t = x >> 1) != 0) {
      x = t;
      r += 1;
    }
    return r;
  }
  function bnBitLength() {
    if (this.t <= 0)
      return 0;
    return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
  }
  function bnpDLShiftTo(n, r) {
    var i;
    for (i = this.t - 1; i >= 0; --i)
      r.data[i + n] = this.data[i];
    for (i = n - 1; i >= 0; --i)
      r.data[i] = 0;
    r.t = this.t + n;
    r.s = this.s;
  }
  function bnpDRShiftTo(n, r) {
    for (var i = n; i < this.t; ++i)
      r.data[i - n] = this.data[i];
    r.t = Math.max(this.t - n, 0);
    r.s = this.s;
  }
  function bnpLShiftTo(n, r) {
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << cbs) - 1;
    var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
    for (i = this.t - 1; i >= 0; --i) {
      r.data[i + ds + 1] = this.data[i] >> cbs | c;
      c = (this.data[i] & bm) << bs;
    }
    for (i = ds - 1; i >= 0; --i)
      r.data[i] = 0;
    r.data[ds] = c;
    r.t = this.t + ds + 1;
    r.s = this.s;
    r.clamp();
  }
  function bnpRShiftTo(n, r) {
    r.s = this.s;
    var ds = Math.floor(n / this.DB);
    if (ds >= this.t) {
      r.t = 0;
      return;
    }
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << bs) - 1;
    r.data[0] = this.data[ds] >> bs;
    for (var i = ds + 1; i < this.t; ++i) {
      r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
      r.data[i - ds] = this.data[i] >> bs;
    }
    if (bs > 0)
      r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
    r.t = this.t - ds;
    r.clamp();
  }
  function bnpSubTo(a, r) {
    var i = 0, c = 0, m = Math.min(a.t, this.t);
    while (i < m) {
      c += this.data[i] - a.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }
    if (a.t < this.t) {
      c -= a.s;
      while (i < this.t) {
        c += this.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += this.s;
    } else {
      c += this.s;
      while (i < a.t) {
        c -= a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      c -= a.s;
    }
    r.s = c < 0 ? -1 : 0;
    if (c < -1)
      r.data[i++] = this.DV + c;
    else if (c > 0)
      r.data[i++] = c;
    r.t = i;
    r.clamp();
  }
  function bnpMultiplyTo(a, r) {
    var x = this.abs(), y = a.abs();
    var i = x.t;
    r.t = i + y.t;
    while (--i >= 0)
      r.data[i] = 0;
    for (i = 0; i < y.t; ++i)
      r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
    r.s = 0;
    r.clamp();
    if (this.s != a.s)
      BigInteger.ZERO.subTo(r, r);
  }
  function bnpSquareTo(r) {
    var x = this.abs();
    var i = r.t = 2 * x.t;
    while (--i >= 0)
      r.data[i] = 0;
    for (i = 0; i < x.t - 1; ++i) {
      var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
      if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
        r.data[i + x.t] -= x.DV;
        r.data[i + x.t + 1] = 1;
      }
    }
    if (r.t > 0)
      r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
    r.s = 0;
    r.clamp();
  }
  function bnpDivRemTo(m, q, r) {
    var pm = m.abs();
    if (pm.t <= 0)
      return;
    var pt = this.abs();
    if (pt.t < pm.t) {
      if (q != null)
        q.fromInt(0);
      if (r != null)
        this.copyTo(r);
      return;
    }
    if (r == null)
      r = nbi();
    var y = nbi(), ts = this.s, ms = m.s;
    var nsh = this.DB - nbits(pm.data[pm.t - 1]);
    if (nsh > 0) {
      pm.lShiftTo(nsh, y);
      pt.lShiftTo(nsh, r);
    } else {
      pm.copyTo(y);
      pt.copyTo(r);
    }
    var ys = y.t;
    var y0 = y.data[ys - 1];
    if (y0 == 0)
      return;
    var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
    var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
    var i = r.t, j = i - ys, t = q == null ? nbi() : q;
    y.dlShiftTo(j, t);
    if (r.compareTo(t) >= 0) {
      r.data[r.t++] = 1;
      r.subTo(t, r);
    }
    BigInteger.ONE.dlShiftTo(ys, t);
    t.subTo(y, y);
    while (y.t < ys)
      y.data[y.t++] = 0;
    while (--j >= 0) {
      var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
      if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
        y.dlShiftTo(j, t);
        r.subTo(t, r);
        while (r.data[i] < --qd)
          r.subTo(t, r);
      }
    }
    if (q != null) {
      r.drShiftTo(ys, q);
      if (ts != ms)
        BigInteger.ZERO.subTo(q, q);
    }
    r.t = ys;
    r.clamp();
    if (nsh > 0)
      r.rShiftTo(nsh, r);
    if (ts < 0)
      BigInteger.ZERO.subTo(r, r);
  }
  function bnMod(a) {
    var r = nbi();
    this.abs().divRemTo(a, null, r);
    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
      a.subTo(r, r);
    return r;
  }
  function Classic(m) {
    this.m = m;
  }
  function cConvert(x) {
    if (x.s < 0 || x.compareTo(this.m) >= 0)
      return x.mod(this.m);
    else
      return x;
  }
  function cRevert(x) {
    return x;
  }
  function cReduce(x) {
    x.divRemTo(this.m, null, x);
  }
  function cMulTo(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
  }
  function cSqrTo(x, r) {
    x.squareTo(r);
    this.reduce(r);
  }
  Classic.prototype.convert = cConvert;
  Classic.prototype.revert = cRevert;
  Classic.prototype.reduce = cReduce;
  Classic.prototype.mulTo = cMulTo;
  Classic.prototype.sqrTo = cSqrTo;
  function bnpInvDigit() {
    if (this.t < 1)
      return 0;
    var x = this.data[0];
    if ((x & 1) == 0)
      return 0;
    var y = x & 3;
    y = y * (2 - (x & 15) * y) & 15;
    y = y * (2 - (x & 255) * y) & 255;
    y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
    y = y * (2 - x * y % this.DV) % this.DV;
    return y > 0 ? this.DV - y : -y;
  }
  function Montgomery(m) {
    this.m = m;
    this.mp = m.invDigit();
    this.mpl = this.mp & 32767;
    this.mph = this.mp >> 15;
    this.um = (1 << m.DB - 15) - 1;
    this.mt2 = 2 * m.t;
  }
  function montConvert(x) {
    var r = nbi();
    x.abs().dlShiftTo(this.m.t, r);
    r.divRemTo(this.m, null, r);
    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
      this.m.subTo(r, r);
    return r;
  }
  function montRevert(x) {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }
  function montReduce(x) {
    while (x.t <= this.mt2)
      x.data[x.t++] = 0;
    for (var i = 0; i < this.m.t; ++i) {
      var j = x.data[i] & 32767;
      var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
      j = i + this.m.t;
      x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
      while (x.data[j] >= x.DV) {
        x.data[j] -= x.DV;
        x.data[++j]++;
      }
    }
    x.clamp();
    x.drShiftTo(this.m.t, x);
    if (x.compareTo(this.m) >= 0)
      x.subTo(this.m, x);
  }
  function montSqrTo(x, r) {
    x.squareTo(r);
    this.reduce(r);
  }
  function montMulTo(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
  }
  Montgomery.prototype.convert = montConvert;
  Montgomery.prototype.revert = montRevert;
  Montgomery.prototype.reduce = montReduce;
  Montgomery.prototype.mulTo = montMulTo;
  Montgomery.prototype.sqrTo = montSqrTo;
  function bnpIsEven() {
    return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
  }
  function bnpExp(e, z) {
    if (e > 4294967295 || e < 1)
      return BigInteger.ONE;
    var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
    g.copyTo(r);
    while (--i >= 0) {
      z.sqrTo(r, r2);
      if ((e & 1 << i) > 0)
        z.mulTo(r2, g, r);
      else {
        var t = r;
        r = r2;
        r2 = t;
      }
    }
    return z.revert(r);
  }
  function bnModPowInt(e, m) {
    var z;
    if (e < 256 || m.isEven())
      z = new Classic(m);
    else
      z = new Montgomery(m);
    return this.exp(e, z);
  }
  BigInteger.prototype.copyTo = bnpCopyTo;
  BigInteger.prototype.fromInt = bnpFromInt;
  BigInteger.prototype.fromString = bnpFromString;
  BigInteger.prototype.clamp = bnpClamp;
  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
  BigInteger.prototype.drShiftTo = bnpDRShiftTo;
  BigInteger.prototype.lShiftTo = bnpLShiftTo;
  BigInteger.prototype.rShiftTo = bnpRShiftTo;
  BigInteger.prototype.subTo = bnpSubTo;
  BigInteger.prototype.multiplyTo = bnpMultiplyTo;
  BigInteger.prototype.squareTo = bnpSquareTo;
  BigInteger.prototype.divRemTo = bnpDivRemTo;
  BigInteger.prototype.invDigit = bnpInvDigit;
  BigInteger.prototype.isEven = bnpIsEven;
  BigInteger.prototype.exp = bnpExp;
  BigInteger.prototype.toString = bnToString;
  BigInteger.prototype.negate = bnNegate;
  BigInteger.prototype.abs = bnAbs;
  BigInteger.prototype.compareTo = bnCompareTo;
  BigInteger.prototype.bitLength = bnBitLength;
  BigInteger.prototype.mod = bnMod;
  BigInteger.prototype.modPowInt = bnModPowInt;
  BigInteger.ZERO = nbv(0);
  BigInteger.ONE = nbv(1);
  function bnClone() {
    var r = nbi();
    this.copyTo(r);
    return r;
  }
  function bnIntValue() {
    if (this.s < 0) {
      if (this.t == 1)
        return this.data[0] - this.DV;
      else if (this.t == 0)
        return -1;
    } else if (this.t == 1)
      return this.data[0];
    else if (this.t == 0)
      return 0;
    return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
  }
  function bnByteValue() {
    return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
  }
  function bnShortValue() {
    return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
  }
  function bnpChunkSize(r) {
    return Math.floor(Math.LN2 * this.DB / Math.log(r));
  }
  function bnSigNum() {
    if (this.s < 0)
      return -1;
    else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
      return 0;
    else
      return 1;
  }
  function bnpToRadix(b) {
    if (b == null)
      b = 10;
    if (this.signum() == 0 || b < 2 || b > 36)
      return "0";
    var cs = this.chunkSize(b);
    var a = Math.pow(b, cs);
    var d = nbv(a), y = nbi(), z = nbi(), r = "";
    this.divRemTo(d, y, z);
    while (y.signum() > 0) {
      r = (a + z.intValue()).toString(b).substr(1) + r;
      y.divRemTo(d, y, z);
    }
    return z.intValue().toString(b) + r;
  }
  function bnpFromRadix(s, b) {
    this.fromInt(0);
    if (b == null)
      b = 10;
    var cs = this.chunkSize(b);
    var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
    for (var i = 0; i < s.length; ++i) {
      var x = intAt(s, i);
      if (x < 0) {
        if (s.charAt(i) == "-" && this.signum() == 0)
          mi = true;
        continue;
      }
      w = b * w + x;
      if (++j >= cs) {
        this.dMultiply(d);
        this.dAddOffset(w, 0);
        j = 0;
        w = 0;
      }
    }
    if (j > 0) {
      this.dMultiply(Math.pow(b, j));
      this.dAddOffset(w, 0);
    }
    if (mi)
      BigInteger.ZERO.subTo(this, this);
  }
  function bnpFromNumber(a, b, c) {
    if (typeof b == "number") {
      if (a < 2)
        this.fromInt(1);
      else {
        this.fromNumber(a, c);
        if (!this.testBit(a - 1))
          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
        if (this.isEven())
          this.dAddOffset(1, 0);
        while (!this.isProbablePrime(b)) {
          this.dAddOffset(2, 0);
          if (this.bitLength() > a)
            this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
        }
      }
    } else {
      var x = new Array(), t = a & 7;
      x.length = (a >> 3) + 1;
      b.nextBytes(x);
      if (t > 0)
        x[0] &= (1 << t) - 1;
      else
        x[0] = 0;
      this.fromString(x, 256);
    }
  }
  function bnToByteArray() {
    var i = this.t, r = new Array();
    r[0] = this.s;
    var p = this.DB - i * this.DB % 8, d, k = 0;
    if (i-- > 0) {
      if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p)
        r[k++] = d | this.s << this.DB - p;
      while (i >= 0) {
        if (p < 8) {
          d = (this.data[i] & (1 << p) - 1) << 8 - p;
          d |= this.data[--i] >> (p += this.DB - 8);
        } else {
          d = this.data[i] >> (p -= 8) & 255;
          if (p <= 0) {
            p += this.DB;
            --i;
          }
        }
        if ((d & 128) != 0)
          d |= -256;
        if (k == 0 && (this.s & 128) != (d & 128))
          ++k;
        if (k > 0 || d != this.s)
          r[k++] = d;
      }
    }
    return r;
  }
  function bnEquals(a) {
    return this.compareTo(a) == 0;
  }
  function bnMin(a) {
    return this.compareTo(a) < 0 ? this : a;
  }
  function bnMax(a) {
    return this.compareTo(a) > 0 ? this : a;
  }
  function bnpBitwiseTo(a, op, r) {
    var i, f, m = Math.min(a.t, this.t);
    for (i = 0; i < m; ++i)
      r.data[i] = op(this.data[i], a.data[i]);
    if (a.t < this.t) {
      f = a.s & this.DM;
      for (i = m; i < this.t; ++i)
        r.data[i] = op(this.data[i], f);
      r.t = this.t;
    } else {
      f = this.s & this.DM;
      for (i = m; i < a.t; ++i)
        r.data[i] = op(f, a.data[i]);
      r.t = a.t;
    }
    r.s = op(this.s, a.s);
    r.clamp();
  }
  function op_and(x, y) {
    return x & y;
  }
  function bnAnd(a) {
    var r = nbi();
    this.bitwiseTo(a, op_and, r);
    return r;
  }
  function op_or(x, y) {
    return x | y;
  }
  function bnOr(a) {
    var r = nbi();
    this.bitwiseTo(a, op_or, r);
    return r;
  }
  function op_xor(x, y) {
    return x ^ y;
  }
  function bnXor(a) {
    var r = nbi();
    this.bitwiseTo(a, op_xor, r);
    return r;
  }
  function op_andnot(x, y) {
    return x & ~y;
  }
  function bnAndNot(a) {
    var r = nbi();
    this.bitwiseTo(a, op_andnot, r);
    return r;
  }
  function bnNot() {
    var r = nbi();
    for (var i = 0; i < this.t; ++i)
      r.data[i] = this.DM & ~this.data[i];
    r.t = this.t;
    r.s = ~this.s;
    return r;
  }
  function bnShiftLeft(n) {
    var r = nbi();
    if (n < 0)
      this.rShiftTo(-n, r);
    else
      this.lShiftTo(n, r);
    return r;
  }
  function bnShiftRight(n) {
    var r = nbi();
    if (n < 0)
      this.lShiftTo(-n, r);
    else
      this.rShiftTo(n, r);
    return r;
  }
  function lbit(x) {
    if (x == 0)
      return -1;
    var r = 0;
    if ((x & 65535) == 0) {
      x >>= 16;
      r += 16;
    }
    if ((x & 255) == 0) {
      x >>= 8;
      r += 8;
    }
    if ((x & 15) == 0) {
      x >>= 4;
      r += 4;
    }
    if ((x & 3) == 0) {
      x >>= 2;
      r += 2;
    }
    if ((x & 1) == 0)
      ++r;
    return r;
  }
  function bnGetLowestSetBit() {
    for (var i = 0; i < this.t; ++i)
      if (this.data[i] != 0)
        return i * this.DB + lbit(this.data[i]);
    if (this.s < 0)
      return this.t * this.DB;
    return -1;
  }
  function cbit(x) {
    var r = 0;
    while (x != 0) {
      x &= x - 1;
      ++r;
    }
    return r;
  }
  function bnBitCount() {
    var r = 0, x = this.s & this.DM;
    for (var i = 0; i < this.t; ++i)
      r += cbit(this.data[i] ^ x);
    return r;
  }
  function bnTestBit(n) {
    var j = Math.floor(n / this.DB);
    if (j >= this.t)
      return this.s != 0;
    return (this.data[j] & 1 << n % this.DB) != 0;
  }
  function bnpChangeBit(n, op) {
    var r = BigInteger.ONE.shiftLeft(n);
    this.bitwiseTo(r, op, r);
    return r;
  }
  function bnSetBit(n) {
    return this.changeBit(n, op_or);
  }
  function bnClearBit(n) {
    return this.changeBit(n, op_andnot);
  }
  function bnFlipBit(n) {
    return this.changeBit(n, op_xor);
  }
  function bnpAddTo(a, r) {
    var i = 0, c = 0, m = Math.min(a.t, this.t);
    while (i < m) {
      c += this.data[i] + a.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }
    if (a.t < this.t) {
      c += a.s;
      while (i < this.t) {
        c += this.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += this.s;
    } else {
      c += this.s;
      while (i < a.t) {
        c += a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += a.s;
    }
    r.s = c < 0 ? -1 : 0;
    if (c > 0)
      r.data[i++] = c;
    else if (c < -1)
      r.data[i++] = this.DV + c;
    r.t = i;
    r.clamp();
  }
  function bnAdd(a) {
    var r = nbi();
    this.addTo(a, r);
    return r;
  }
  function bnSubtract(a) {
    var r = nbi();
    this.subTo(a, r);
    return r;
  }
  function bnMultiply(a) {
    var r = nbi();
    this.multiplyTo(a, r);
    return r;
  }
  function bnDivide(a) {
    var r = nbi();
    this.divRemTo(a, r, null);
    return r;
  }
  function bnRemainder(a) {
    var r = nbi();
    this.divRemTo(a, null, r);
    return r;
  }
  function bnDivideAndRemainder(a) {
    var q = nbi(), r = nbi();
    this.divRemTo(a, q, r);
    return new Array(q, r);
  }
  function bnpDMultiply(n) {
    this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
    ++this.t;
    this.clamp();
  }
  function bnpDAddOffset(n, w) {
    if (n == 0)
      return;
    while (this.t <= w)
      this.data[this.t++] = 0;
    this.data[w] += n;
    while (this.data[w] >= this.DV) {
      this.data[w] -= this.DV;
      if (++w >= this.t)
        this.data[this.t++] = 0;
      ++this.data[w];
    }
  }
  function NullExp() {
  }
  function nNop(x) {
    return x;
  }
  function nMulTo(x, y, r) {
    x.multiplyTo(y, r);
  }
  function nSqrTo(x, r) {
    x.squareTo(r);
  }
  NullExp.prototype.convert = nNop;
  NullExp.prototype.revert = nNop;
  NullExp.prototype.mulTo = nMulTo;
  NullExp.prototype.sqrTo = nSqrTo;
  function bnPow(e) {
    return this.exp(e, new NullExp());
  }
  function bnpMultiplyLowerTo(a, n, r) {
    var i = Math.min(this.t + a.t, n);
    r.s = 0;
    r.t = i;
    while (i > 0)
      r.data[--i] = 0;
    var j;
    for (j = r.t - this.t; i < j; ++i)
      r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
    for (j = Math.min(a.t, n); i < j; ++i)
      this.am(0, a.data[i], r, i, 0, n - i);
    r.clamp();
  }
  function bnpMultiplyUpperTo(a, n, r) {
    --n;
    var i = r.t = this.t + a.t - n;
    r.s = 0;
    while (--i >= 0)
      r.data[i] = 0;
    for (i = Math.max(n - this.t, 0); i < a.t; ++i)
      r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
    r.clamp();
    r.drShiftTo(1, r);
  }
  function Barrett(m) {
    this.r2 = nbi();
    this.q3 = nbi();
    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
    this.mu = this.r2.divide(m);
    this.m = m;
  }
  function barrettConvert(x) {
    if (x.s < 0 || x.t > 2 * this.m.t)
      return x.mod(this.m);
    else if (x.compareTo(this.m) < 0)
      return x;
    else {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
  }
  function barrettRevert(x) {
    return x;
  }
  function barrettReduce(x) {
    x.drShiftTo(this.m.t - 1, this.r2);
    if (x.t > this.m.t + 1) {
      x.t = this.m.t + 1;
      x.clamp();
    }
    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
    while (x.compareTo(this.r2) < 0)
      x.dAddOffset(1, this.m.t + 1);
    x.subTo(this.r2, x);
    while (x.compareTo(this.m) >= 0)
      x.subTo(this.m, x);
  }
  function barrettSqrTo(x, r) {
    x.squareTo(r);
    this.reduce(r);
  }
  function barrettMulTo(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
  }
  Barrett.prototype.convert = barrettConvert;
  Barrett.prototype.revert = barrettRevert;
  Barrett.prototype.reduce = barrettReduce;
  Barrett.prototype.mulTo = barrettMulTo;
  Barrett.prototype.sqrTo = barrettSqrTo;
  function bnModPow(e, m) {
    var i = e.bitLength(), k, r = nbv(1), z;
    if (i <= 0)
      return r;
    else if (i < 18)
      k = 1;
    else if (i < 48)
      k = 3;
    else if (i < 144)
      k = 4;
    else if (i < 768)
      k = 5;
    else
      k = 6;
    if (i < 8)
      z = new Classic(m);
    else if (m.isEven())
      z = new Barrett(m);
    else
      z = new Montgomery(m);
    var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
    g[1] = z.convert(this);
    if (k > 1) {
      var g2 = nbi();
      z.sqrTo(g[1], g2);
      while (n <= km) {
        g[n] = nbi();
        z.mulTo(g2, g[n - 2], g[n]);
        n += 2;
      }
    }
    var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
    i = nbits(e.data[j]) - 1;
    while (j >= 0) {
      if (i >= k1)
        w = e.data[j] >> i - k1 & km;
      else {
        w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
        if (j > 0)
          w |= e.data[j - 1] >> this.DB + i - k1;
      }
      n = k;
      while ((w & 1) == 0) {
        w >>= 1;
        --n;
      }
      if ((i -= n) < 0) {
        i += this.DB;
        --j;
      }
      if (is1) {
        g[w].copyTo(r);
        is1 = false;
      } else {
        while (n > 1) {
          z.sqrTo(r, r2);
          z.sqrTo(r2, r);
          n -= 2;
        }
        if (n > 0)
          z.sqrTo(r, r2);
        else {
          t = r;
          r = r2;
          r2 = t;
        }
        z.mulTo(r2, g[w], r);
      }
      while (j >= 0 && (e.data[j] & 1 << i) == 0) {
        z.sqrTo(r, r2);
        t = r;
        r = r2;
        r2 = t;
        if (--i < 0) {
          i = this.DB - 1;
          --j;
        }
      }
    }
    return z.revert(r);
  }
  function bnGCD(a) {
    var x = this.s < 0 ? this.negate() : this.clone();
    var y = a.s < 0 ? a.negate() : a.clone();
    if (x.compareTo(y) < 0) {
      var t = x;
      x = y;
      y = t;
    }
    var i = x.getLowestSetBit(), g = y.getLowestSetBit();
    if (g < 0)
      return x;
    if (i < g)
      g = i;
    if (g > 0) {
      x.rShiftTo(g, x);
      y.rShiftTo(g, y);
    }
    while (x.signum() > 0) {
      if ((i = x.getLowestSetBit()) > 0)
        x.rShiftTo(i, x);
      if ((i = y.getLowestSetBit()) > 0)
        y.rShiftTo(i, y);
      if (x.compareTo(y) >= 0) {
        x.subTo(y, x);
        x.rShiftTo(1, x);
      } else {
        y.subTo(x, y);
        y.rShiftTo(1, y);
      }
    }
    if (g > 0)
      y.lShiftTo(g, y);
    return y;
  }
  function bnpModInt(n) {
    if (n <= 0)
      return 0;
    var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
    if (this.t > 0)
      if (d == 0)
        r = this.data[0] % n;
      else
        for (var i = this.t - 1; i >= 0; --i)
          r = (d * r + this.data[i]) % n;
    return r;
  }
  function bnModInverse(m) {
    var ac = m.isEven();
    if (this.isEven() && ac || m.signum() == 0)
      return BigInteger.ZERO;
    var u = m.clone(), v = this.clone();
    var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
    while (u.signum() != 0) {
      while (u.isEven()) {
        u.rShiftTo(1, u);
        if (ac) {
          if (!a.isEven() || !b.isEven()) {
            a.addTo(this, a);
            b.subTo(m, b);
          }
          a.rShiftTo(1, a);
        } else if (!b.isEven())
          b.subTo(m, b);
        b.rShiftTo(1, b);
      }
      while (v.isEven()) {
        v.rShiftTo(1, v);
        if (ac) {
          if (!c.isEven() || !d.isEven()) {
            c.addTo(this, c);
            d.subTo(m, d);
          }
          c.rShiftTo(1, c);
        } else if (!d.isEven())
          d.subTo(m, d);
        d.rShiftTo(1, d);
      }
      if (u.compareTo(v) >= 0) {
        u.subTo(v, u);
        if (ac)
          a.subTo(c, a);
        b.subTo(d, b);
      } else {
        v.subTo(u, v);
        if (ac)
          c.subTo(a, c);
        d.subTo(b, d);
      }
    }
    if (v.compareTo(BigInteger.ONE) != 0)
      return BigInteger.ZERO;
    if (d.compareTo(m) >= 0)
      return d.subtract(m);
    if (d.signum() < 0)
      d.addTo(m, d);
    else
      return d;
    if (d.signum() < 0)
      return d.add(m);
    else
      return d;
  }
  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
  function bnIsProbablePrime(t) {
    var i, x = this.abs();
    if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
      for (i = 0; i < lowprimes.length; ++i)
        if (x.data[0] == lowprimes[i])
          return true;
      return false;
    }
    if (x.isEven())
      return false;
    i = 1;
    while (i < lowprimes.length) {
      var m = lowprimes[i], j = i + 1;
      while (j < lowprimes.length && m < lplim)
        m *= lowprimes[j++];
      m = x.modInt(m);
      while (i < j)
        if (m % lowprimes[i++] == 0)
          return false;
    }
    return x.millerRabin(t);
  }
  function bnpMillerRabin(t) {
    var n1 = this.subtract(BigInteger.ONE);
    var k = n1.getLowestSetBit();
    if (k <= 0)
      return false;
    var r = n1.shiftRight(k);
    var prng = bnGetPrng();
    var a;
    for (var i = 0; i < t; ++i) {
      do {
        a = new BigInteger(this.bitLength(), prng);
      } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
      var y = a.modPow(r, this);
      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
        var j = 1;
        while (j++ < k && y.compareTo(n1) != 0) {
          y = y.modPowInt(2, this);
          if (y.compareTo(BigInteger.ONE) == 0)
            return false;
        }
        if (y.compareTo(n1) != 0)
          return false;
      }
    }
    return true;
  }
  function bnGetPrng() {
    return {
      nextBytes: function(x) {
        for (var i = 0; i < x.length; ++i) {
          x[i] = Math.floor(Math.random() * 256);
        }
      }
    };
  }
  BigInteger.prototype.chunkSize = bnpChunkSize;
  BigInteger.prototype.toRadix = bnpToRadix;
  BigInteger.prototype.fromRadix = bnpFromRadix;
  BigInteger.prototype.fromNumber = bnpFromNumber;
  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
  BigInteger.prototype.changeBit = bnpChangeBit;
  BigInteger.prototype.addTo = bnpAddTo;
  BigInteger.prototype.dMultiply = bnpDMultiply;
  BigInteger.prototype.dAddOffset = bnpDAddOffset;
  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
  BigInteger.prototype.modInt = bnpModInt;
  BigInteger.prototype.millerRabin = bnpMillerRabin;
  BigInteger.prototype.clone = bnClone;
  BigInteger.prototype.intValue = bnIntValue;
  BigInteger.prototype.byteValue = bnByteValue;
  BigInteger.prototype.shortValue = bnShortValue;
  BigInteger.prototype.signum = bnSigNum;
  BigInteger.prototype.toByteArray = bnToByteArray;
  BigInteger.prototype.equals = bnEquals;
  BigInteger.prototype.min = bnMin;
  BigInteger.prototype.max = bnMax;
  BigInteger.prototype.and = bnAnd;
  BigInteger.prototype.or = bnOr;
  BigInteger.prototype.xor = bnXor;
  BigInteger.prototype.andNot = bnAndNot;
  BigInteger.prototype.not = bnNot;
  BigInteger.prototype.shiftLeft = bnShiftLeft;
  BigInteger.prototype.shiftRight = bnShiftRight;
  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
  BigInteger.prototype.bitCount = bnBitCount;
  BigInteger.prototype.testBit = bnTestBit;
  BigInteger.prototype.setBit = bnSetBit;
  BigInteger.prototype.clearBit = bnClearBit;
  BigInteger.prototype.flipBit = bnFlipBit;
  BigInteger.prototype.add = bnAdd;
  BigInteger.prototype.subtract = bnSubtract;
  BigInteger.prototype.multiply = bnMultiply;
  BigInteger.prototype.divide = bnDivide;
  BigInteger.prototype.remainder = bnRemainder;
  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
  BigInteger.prototype.modPow = bnModPow;
  BigInteger.prototype.modInverse = bnModInverse;
  BigInteger.prototype.pow = bnPow;
  BigInteger.prototype.gcd = bnGCD;
  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
});

// node_modules/node-forge/lib/sha1.js
var require_sha1 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_md();
  require_util();
  var sha1 = module2.exports = forge.sha1 = forge.sha1 || {};
  forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
  sha1.create = function() {
    if (!_initialized) {
      _init();
    }
    var _state = null;
    var _input = forge.util.createBuffer();
    var _w = new Array(80);
    var md = {
      algorithm: "sha1",
      blockLength: 64,
      digestLength: 20,
      messageLength: 0,
      fullMessageLength: null,
      messageLengthSize: 8
    };
    md.start = function() {
      md.messageLength = 0;
      md.fullMessageLength = md.messageLength64 = [];
      var int32s = md.messageLengthSize / 4;
      for (var i = 0; i < int32s; ++i) {
        md.fullMessageLength.push(0);
      }
      _input = forge.util.createBuffer();
      _state = {
        h0: 1732584193,
        h1: 4023233417,
        h2: 2562383102,
        h3: 271733878,
        h4: 3285377520
      };
      return md;
    };
    md.start();
    md.update = function(msg, encoding) {
      if (encoding === "utf8") {
        msg = forge.util.encodeUtf8(msg);
      }
      var len = msg.length;
      md.messageLength += len;
      len = [len / 4294967296 >>> 0, len >>> 0];
      for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
        md.fullMessageLength[i] += len[1];
        len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
        md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
        len[0] = len[1] / 4294967296 >>> 0;
      }
      _input.putBytes(msg);
      _update(_state, _w, _input);
      if (_input.read > 2048 || _input.length() === 0) {
        _input.compact();
      }
      return md;
    };
    md.digest = function() {
      var finalBlock = forge.util.createBuffer();
      finalBlock.putBytes(_input.bytes());
      var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
      var overflow = remaining & md.blockLength - 1;
      finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
      var next, carry;
      var bits = md.fullMessageLength[0] * 8;
      for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
        next = md.fullMessageLength[i + 1] * 8;
        carry = next / 4294967296 >>> 0;
        bits += carry;
        finalBlock.putInt32(bits >>> 0);
        bits = next >>> 0;
      }
      finalBlock.putInt32(bits);
      var s2 = {
        h0: _state.h0,
        h1: _state.h1,
        h2: _state.h2,
        h3: _state.h3,
        h4: _state.h4
      };
      _update(s2, _w, finalBlock);
      var rval = forge.util.createBuffer();
      rval.putInt32(s2.h0);
      rval.putInt32(s2.h1);
      rval.putInt32(s2.h2);
      rval.putInt32(s2.h3);
      rval.putInt32(s2.h4);
      return rval;
    };
    return md;
  };
  var _padding = null;
  var _initialized = false;
  function _init() {
    _padding = String.fromCharCode(128);
    _padding += forge.util.fillString(String.fromCharCode(0), 64);
    _initialized = true;
  }
  function _update(s, w, bytes) {
    var t, a, b, c, d, e, f, i;
    var len = bytes.length();
    while (len >= 64) {
      a = s.h0;
      b = s.h1;
      c = s.h2;
      d = s.h3;
      e = s.h4;
      for (i = 0; i < 16; ++i) {
        t = bytes.getInt32();
        w[i] = t;
        f = d ^ b & (c ^ d);
        t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      for (; i < 20; ++i) {
        t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
        t = t << 1 | t >>> 31;
        w[i] = t;
        f = d ^ b & (c ^ d);
        t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      for (; i < 32; ++i) {
        t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
        t = t << 1 | t >>> 31;
        w[i] = t;
        f = b ^ c ^ d;
        t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      for (; i < 40; ++i) {
        t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
        t = t << 2 | t >>> 30;
        w[i] = t;
        f = b ^ c ^ d;
        t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      for (; i < 60; ++i) {
        t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
        t = t << 2 | t >>> 30;
        w[i] = t;
        f = b & c | d & (b ^ c);
        t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      for (; i < 80; ++i) {
        t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
        t = t << 2 | t >>> 30;
        w[i] = t;
        f = b ^ c ^ d;
        t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      s.h0 = s.h0 + a | 0;
      s.h1 = s.h1 + b | 0;
      s.h2 = s.h2 + c | 0;
      s.h3 = s.h3 + d | 0;
      s.h4 = s.h4 + e | 0;
      len -= 64;
    }
  }
});

// node_modules/node-forge/lib/pkcs1.js
var require_pkcs1 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util();
  require_random();
  require_sha1();
  var pkcs1 = module2.exports = forge.pkcs1 = forge.pkcs1 || {};
  pkcs1.encode_rsa_oaep = function(key, message, options) {
    var label;
    var seed;
    var md;
    var mgf1Md;
    if (typeof options === "string") {
      label = options;
      seed = arguments[3] || void 0;
      md = arguments[4] || void 0;
    } else if (options) {
      label = options.label || void 0;
      seed = options.seed || void 0;
      md = options.md || void 0;
      if (options.mgf1 && options.mgf1.md) {
        mgf1Md = options.mgf1.md;
      }
    }
    if (!md) {
      md = forge.md.sha1.create();
    } else {
      md.start();
    }
    if (!mgf1Md) {
      mgf1Md = md;
    }
    var keyLength = Math.ceil(key.n.bitLength() / 8);
    var maxLength = keyLength - 2 * md.digestLength - 2;
    if (message.length > maxLength) {
      var error = new Error("RSAES-OAEP input message length is too long.");
      error.length = message.length;
      error.maxLength = maxLength;
      throw error;
    }
    if (!label) {
      label = "";
    }
    md.update(label, "raw");
    var lHash = md.digest();
    var PS = "";
    var PS_length = maxLength - message.length;
    for (var i = 0; i < PS_length; i++) {
      PS += "\0";
    }
    var DB = lHash.getBytes() + PS + "" + message;
    if (!seed) {
      seed = forge.random.getBytes(md.digestLength);
    } else if (seed.length !== md.digestLength) {
      var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
      error.seedLength = seed.length;
      error.digestLength = md.digestLength;
      throw error;
    }
    var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
    var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
    var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
    var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);
    return "\0" + maskedSeed + maskedDB;
  };
  pkcs1.decode_rsa_oaep = function(key, em, options) {
    var label;
    var md;
    var mgf1Md;
    if (typeof options === "string") {
      label = options;
      md = arguments[3] || void 0;
    } else if (options) {
      label = options.label || void 0;
      md = options.md || void 0;
      if (options.mgf1 && options.mgf1.md) {
        mgf1Md = options.mgf1.md;
      }
    }
    var keyLength = Math.ceil(key.n.bitLength() / 8);
    if (em.length !== keyLength) {
      var error = new Error("RSAES-OAEP encoded message length is invalid.");
      error.length = em.length;
      error.expectedLength = keyLength;
      throw error;
    }
    if (md === void 0) {
      md = forge.md.sha1.create();
    } else {
      md.start();
    }
    if (!mgf1Md) {
      mgf1Md = md;
    }
    if (keyLength < 2 * md.digestLength + 2) {
      throw new Error("RSAES-OAEP key is too short for the hash function.");
    }
    if (!label) {
      label = "";
    }
    md.update(label, "raw");
    var lHash = md.digest().getBytes();
    var y = em.charAt(0);
    var maskedSeed = em.substring(1, md.digestLength + 1);
    var maskedDB = em.substring(1 + md.digestLength);
    var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
    var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
    var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
    var db2 = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
    var lHashPrime = db2.substring(0, md.digestLength);
    var error = y !== "\0";
    for (var i = 0; i < md.digestLength; ++i) {
      error |= lHash.charAt(i) !== lHashPrime.charAt(i);
    }
    var in_ps = 1;
    var index = md.digestLength;
    for (var j = md.digestLength; j < db2.length; j++) {
      var code = db2.charCodeAt(j);
      var is_0 = code & 1 ^ 1;
      var error_mask = in_ps ? 65534 : 0;
      error |= code & error_mask;
      in_ps = in_ps & is_0;
      index += in_ps;
    }
    if (error || db2.charCodeAt(index) !== 1) {
      throw new Error("Invalid RSAES-OAEP padding.");
    }
    return db2.substring(index + 1);
  };
  function rsa_mgf1(seed, maskLength, hash) {
    if (!hash) {
      hash = forge.md.sha1.create();
    }
    var t = "";
    var count = Math.ceil(maskLength / hash.digestLength);
    for (var i = 0; i < count; ++i) {
      var c = String.fromCharCode(i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, i & 255);
      hash.start();
      hash.update(seed + c);
      t += hash.digest().getBytes();
    }
    return t.substring(0, maskLength);
  }
});

// node_modules/node-forge/lib/prime.js
var require_prime = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util();
  require_jsbn();
  require_random();
  (function() {
    if (forge.prime) {
      module2.exports = forge.prime;
      return;
    }
    var prime = module2.exports = forge.prime = forge.prime || {};
    var BigInteger = forge.jsbn.BigInteger;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var THIRTY = new BigInteger(null);
    THIRTY.fromInt(30);
    var op_or = function(x, y) {
      return x | y;
    };
    prime.generateProbablePrime = function(bits, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var algorithm = options.algorithm || "PRIMEINC";
      if (typeof algorithm === "string") {
        algorithm = {name: algorithm};
      }
      algorithm.options = algorithm.options || {};
      var prng = options.prng || forge.random;
      var rng = {
        nextBytes: function(x) {
          var b = prng.getBytesSync(x.length);
          for (var i = 0; i < x.length; ++i) {
            x[i] = b.charCodeAt(i);
          }
        }
      };
      if (algorithm.name === "PRIMEINC") {
        return primeincFindPrime(bits, rng, algorithm.options, callback);
      }
      throw new Error("Invalid prime generation algorithm: " + algorithm.name);
    };
    function primeincFindPrime(bits, rng, options, callback) {
      if ("workers" in options) {
        return primeincFindPrimeWithWorkers(bits, rng, options, callback);
      }
      return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
    }
    function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
      var num = generateRandom(bits, rng);
      var deltaIdx = 0;
      var mrTests = getMillerRabinTests(num.bitLength());
      if ("millerRabinTests" in options) {
        mrTests = options.millerRabinTests;
      }
      var maxBlockTime = 10;
      if ("maxBlockTime" in options) {
        maxBlockTime = options.maxBlockTime;
      }
      _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
    }
    function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
      var start = +new Date();
      do {
        if (num.bitLength() > bits) {
          num = generateRandom(bits, rng);
        }
        if (num.isProbablePrime(mrTests)) {
          return callback(null, num);
        }
        num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
      } while (maxBlockTime < 0 || +new Date() - start < maxBlockTime);
      forge.util.setImmediate(function() {
        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
      });
    }
    function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
      if (typeof Worker === "undefined") {
        return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
      }
      var num = generateRandom(bits, rng);
      var numWorkers = options.workers;
      var workLoad = options.workLoad || 100;
      var range = workLoad * 30 / 8;
      var workerScript = options.workerScript || "forge/prime.worker.js";
      if (numWorkers === -1) {
        return forge.util.estimateCores(function(err, cores) {
          if (err) {
            cores = 2;
          }
          numWorkers = cores - 1;
          generate();
        });
      }
      generate();
      function generate() {
        numWorkers = Math.max(1, numWorkers);
        var workers = [];
        for (var i = 0; i < numWorkers; ++i) {
          workers[i] = new Worker(workerScript);
        }
        var running = numWorkers;
        for (var i = 0; i < numWorkers; ++i) {
          workers[i].addEventListener("message", workerMessage);
        }
        var found = false;
        function workerMessage(e) {
          if (found) {
            return;
          }
          --running;
          var data = e.data;
          if (data.found) {
            for (var i2 = 0; i2 < workers.length; ++i2) {
              workers[i2].terminate();
            }
            found = true;
            return callback(null, new BigInteger(data.prime, 16));
          }
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng);
          }
          var hex = num.toString(16);
          e.target.postMessage({
            hex,
            workLoad
          });
          num.dAddOffset(range, 0);
        }
      }
    }
    function generateRandom(bits, rng) {
      var num = new BigInteger(bits, rng);
      var bits1 = bits - 1;
      if (!num.testBit(bits1)) {
        num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
      }
      num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
      return num;
    }
    function getMillerRabinTests(bits) {
      if (bits <= 100)
        return 27;
      if (bits <= 150)
        return 18;
      if (bits <= 200)
        return 15;
      if (bits <= 250)
        return 12;
      if (bits <= 300)
        return 9;
      if (bits <= 350)
        return 8;
      if (bits <= 400)
        return 7;
      if (bits <= 500)
        return 6;
      if (bits <= 600)
        return 5;
      if (bits <= 800)
        return 4;
      if (bits <= 1250)
        return 3;
      return 2;
    }
  })();
});

// node_modules/node-forge/lib/rsa.js
var require_rsa = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_asn1();
  require_jsbn();
  require_oids();
  require_pkcs1();
  require_prime();
  require_random();
  require_util();
  if (typeof BigInteger === "undefined") {
    BigInteger = forge.jsbn.BigInteger;
  }
  var BigInteger;
  var _crypto = forge.util.isNodejs ? require("crypto") : null;
  var asn1 = forge.asn1;
  var util = forge.util;
  forge.pki = forge.pki || {};
  module2.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
  var pki = forge.pki;
  var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
  var privateKeyValidator = {
    name: "PrivateKeyInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "PrivateKeyInfo.version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyVersion"
    }, {
      name: "PrivateKeyInfo.privateKeyAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "privateKeyOid"
      }]
    }, {
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: "privateKey"
    }]
  };
  var rsaPrivateKeyValidator = {
    name: "RSAPrivateKey",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "RSAPrivateKey.version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyVersion"
    }, {
      name: "RSAPrivateKey.modulus",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyModulus"
    }, {
      name: "RSAPrivateKey.publicExponent",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyPublicExponent"
    }, {
      name: "RSAPrivateKey.privateExponent",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyPrivateExponent"
    }, {
      name: "RSAPrivateKey.prime1",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyPrime1"
    }, {
      name: "RSAPrivateKey.prime2",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyPrime2"
    }, {
      name: "RSAPrivateKey.exponent1",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyExponent1"
    }, {
      name: "RSAPrivateKey.exponent2",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyExponent2"
    }, {
      name: "RSAPrivateKey.coefficient",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyCoefficient"
    }]
  };
  var rsaPublicKeyValidator = {
    name: "RSAPublicKey",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "RSAPublicKey.modulus",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "publicKeyModulus"
    }, {
      name: "RSAPublicKey.exponent",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "publicKeyExponent"
    }]
  };
  var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
    name: "SubjectPublicKeyInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: "subjectPublicKeyInfo",
    value: [{
      name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "publicKeyOid"
      }]
    }, {
      name: "SubjectPublicKeyInfo.subjectPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.BITSTRING,
      constructed: false,
      value: [{
        name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        optional: true,
        captureAsn1: "rsaPublicKey"
      }]
    }]
  };
  var emsaPkcs1v15encode = function(md) {
    var oid;
    if (md.algorithm in pki.oids) {
      oid = pki.oids[md.algorithm];
    } else {
      var error = new Error("Unknown message digest algorithm.");
      error.algorithm = md.algorithm;
      throw error;
    }
    var oidBytes = asn1.oidToDer(oid).getBytes();
    var digestInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var digestAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));
    digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ""));
    var digest = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, md.digest().getBytes());
    digestInfo.value.push(digestAlgorithm);
    digestInfo.value.push(digest);
    return asn1.toDer(digestInfo).getBytes();
  };
  var _modPow = function(x, key, pub) {
    if (pub) {
      return x.modPow(key.e, key.n);
    }
    if (!key.p || !key.q) {
      return x.modPow(key.d, key.n);
    }
    if (!key.dP) {
      key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
    }
    if (!key.dQ) {
      key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
    }
    if (!key.qInv) {
      key.qInv = key.q.modInverse(key.p);
    }
    var r;
    do {
      r = new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)), 16);
    } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
    x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
    var xp = x.mod(key.p).modPow(key.dP, key.p);
    var xq = x.mod(key.q).modPow(key.dQ, key.q);
    while (xp.compareTo(xq) < 0) {
      xp = xp.add(key.p);
    }
    var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
    y = y.multiply(r.modInverse(key.n)).mod(key.n);
    return y;
  };
  pki.rsa.encrypt = function(m, key, bt) {
    var pub = bt;
    var eb;
    var k = Math.ceil(key.n.bitLength() / 8);
    if (bt !== false && bt !== true) {
      pub = bt === 2;
      eb = _encodePkcs1_v1_5(m, key, bt);
    } else {
      eb = forge.util.createBuffer();
      eb.putBytes(m);
    }
    var x = new BigInteger(eb.toHex(), 16);
    var y = _modPow(x, key, pub);
    var yhex = y.toString(16);
    var ed = forge.util.createBuffer();
    var zeros = k - Math.ceil(yhex.length / 2);
    while (zeros > 0) {
      ed.putByte(0);
      --zeros;
    }
    ed.putBytes(forge.util.hexToBytes(yhex));
    return ed.getBytes();
  };
  pki.rsa.decrypt = function(ed, key, pub, ml) {
    var k = Math.ceil(key.n.bitLength() / 8);
    if (ed.length !== k) {
      var error = new Error("Encrypted message length is invalid.");
      error.length = ed.length;
      error.expected = k;
      throw error;
    }
    var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);
    if (y.compareTo(key.n) >= 0) {
      throw new Error("Encrypted message is invalid.");
    }
    var x = _modPow(y, key, pub);
    var xhex = x.toString(16);
    var eb = forge.util.createBuffer();
    var zeros = k - Math.ceil(xhex.length / 2);
    while (zeros > 0) {
      eb.putByte(0);
      --zeros;
    }
    eb.putBytes(forge.util.hexToBytes(xhex));
    if (ml !== false) {
      return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
    }
    return eb.getBytes();
  };
  pki.rsa.createKeyPairGenerationState = function(bits, e, options) {
    if (typeof bits === "string") {
      bits = parseInt(bits, 10);
    }
    bits = bits || 2048;
    options = options || {};
    var prng = options.prng || forge.random;
    var rng = {
      nextBytes: function(x) {
        var b = prng.getBytesSync(x.length);
        for (var i = 0; i < x.length; ++i) {
          x[i] = b.charCodeAt(i);
        }
      }
    };
    var algorithm = options.algorithm || "PRIMEINC";
    var rval;
    if (algorithm === "PRIMEINC") {
      rval = {
        algorithm,
        state: 0,
        bits,
        rng,
        eInt: e || 65537,
        e: new BigInteger(null),
        p: null,
        q: null,
        qBits: bits >> 1,
        pBits: bits - (bits >> 1),
        pqState: 0,
        num: null,
        keys: null
      };
      rval.e.fromInt(rval.eInt);
    } else {
      throw new Error("Invalid key generation algorithm: " + algorithm);
    }
    return rval;
  };
  pki.rsa.stepKeyPairGenerationState = function(state, n) {
    if (!("algorithm" in state)) {
      state.algorithm = "PRIMEINC";
    }
    var THIRTY = new BigInteger(null);
    THIRTY.fromInt(30);
    var deltaIdx = 0;
    var op_or = function(x, y) {
      return x | y;
    };
    var t1 = +new Date();
    var t2;
    var total = 0;
    while (state.keys === null && (n <= 0 || total < n)) {
      if (state.state === 0) {
        var bits = state.p === null ? state.pBits : state.qBits;
        var bits1 = bits - 1;
        if (state.pqState === 0) {
          state.num = new BigInteger(bits, state.rng);
          if (!state.num.testBit(bits1)) {
            state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, state.num);
          }
          state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
          deltaIdx = 0;
          ++state.pqState;
        } else if (state.pqState === 1) {
          if (state.num.bitLength() > bits) {
            state.pqState = 0;
          } else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) {
            ++state.pqState;
          } else {
            state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
          }
        } else if (state.pqState === 2) {
          state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
        } else if (state.pqState === 3) {
          state.pqState = 0;
          if (state.p === null) {
            state.p = state.num;
          } else {
            state.q = state.num;
          }
          if (state.p !== null && state.q !== null) {
            ++state.state;
          }
          state.num = null;
        }
      } else if (state.state === 1) {
        if (state.p.compareTo(state.q) < 0) {
          state.num = state.p;
          state.p = state.q;
          state.q = state.num;
        }
        ++state.state;
      } else if (state.state === 2) {
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        ++state.state;
      } else if (state.state === 3) {
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
          ++state.state;
        } else {
          state.p = null;
          state.q = null;
          state.state = 0;
        }
      } else if (state.state === 4) {
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() === state.bits) {
          ++state.state;
        } else {
          state.q = null;
          state.state = 0;
        }
      } else if (state.state === 5) {
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
      }
      t2 = +new Date();
      total += t2 - t1;
      t1 = t2;
    }
    return state.keys !== null;
  };
  pki.rsa.generateKeyPair = function(bits, e, options, callback) {
    if (arguments.length === 1) {
      if (typeof bits === "object") {
        options = bits;
        bits = void 0;
      } else if (typeof bits === "function") {
        callback = bits;
        bits = void 0;
      }
    } else if (arguments.length === 2) {
      if (typeof bits === "number") {
        if (typeof e === "function") {
          callback = e;
          e = void 0;
        } else if (typeof e !== "number") {
          options = e;
          e = void 0;
        }
      } else {
        options = bits;
        callback = e;
        bits = void 0;
        e = void 0;
      }
    } else if (arguments.length === 3) {
      if (typeof e === "number") {
        if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
      } else {
        callback = options;
        options = e;
        e = void 0;
      }
    }
    options = options || {};
    if (bits === void 0) {
      bits = options.bits || 2048;
    }
    if (e === void 0) {
      e = options.e || 65537;
    }
    if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
      if (callback) {
        if (_detectNodeCrypto("generateKeyPair")) {
          return _crypto.generateKeyPair("rsa", {
            modulusLength: bits,
            publicExponent: e,
            publicKeyEncoding: {
              type: "spki",
              format: "pem"
            },
            privateKeyEncoding: {
              type: "pkcs8",
              format: "pem"
            }
          }, function(err, pub, priv) {
            if (err) {
              return callback(err);
            }
            callback(null, {
              privateKey: pki.privateKeyFromPem(priv),
              publicKey: pki.publicKeyFromPem(pub)
            });
          });
        }
        if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
          return util.globalScope.crypto.subtle.generateKey({
            name: "RSASSA-PKCS1-v1_5",
            modulusLength: bits,
            publicExponent: _intToUint8Array(e),
            hash: {name: "SHA-256"}
          }, true, ["sign", "verify"]).then(function(pair) {
            return util.globalScope.crypto.subtle.exportKey("pkcs8", pair.privateKey);
          }).then(void 0, function(err) {
            callback(err);
          }).then(function(pkcs8) {
            if (pkcs8) {
              var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
              callback(null, {
                privateKey,
                publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
              });
            }
          });
        }
        if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
          var genOp = util.globalScope.msCrypto.subtle.generateKey({
            name: "RSASSA-PKCS1-v1_5",
            modulusLength: bits,
            publicExponent: _intToUint8Array(e),
            hash: {name: "SHA-256"}
          }, true, ["sign", "verify"]);
          genOp.oncomplete = function(e2) {
            var pair = e2.target.result;
            var exportOp = util.globalScope.msCrypto.subtle.exportKey("pkcs8", pair.privateKey);
            exportOp.oncomplete = function(e3) {
              var pkcs8 = e3.target.result;
              var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
              callback(null, {
                privateKey,
                publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
              });
            };
            exportOp.onerror = function(err) {
              callback(err);
            };
          };
          genOp.onerror = function(err) {
            callback(err);
          };
          return;
        }
      } else {
        if (_detectNodeCrypto("generateKeyPairSync")) {
          var keypair = _crypto.generateKeyPairSync("rsa", {
            modulusLength: bits,
            publicExponent: e,
            publicKeyEncoding: {
              type: "spki",
              format: "pem"
            },
            privateKeyEncoding: {
              type: "pkcs8",
              format: "pem"
            }
          });
          return {
            privateKey: pki.privateKeyFromPem(keypair.privateKey),
            publicKey: pki.publicKeyFromPem(keypair.publicKey)
          };
        }
      }
    }
    var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
    if (!callback) {
      pki.rsa.stepKeyPairGenerationState(state, 0);
      return state.keys;
    }
    _generateKeyPair(state, options, callback);
  };
  pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
    var key = {
      n,
      e
    };
    key.encrypt = function(data, scheme, schemeOptions) {
      if (typeof scheme === "string") {
        scheme = scheme.toUpperCase();
      } else if (scheme === void 0) {
        scheme = "RSAES-PKCS1-V1_5";
      }
      if (scheme === "RSAES-PKCS1-V1_5") {
        scheme = {
          encode: function(m, key2, pub) {
            return _encodePkcs1_v1_5(m, key2, 2).getBytes();
          }
        };
      } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
        scheme = {
          encode: function(m, key2) {
            return forge.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);
          }
        };
      } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
        scheme = {encode: function(e3) {
          return e3;
        }};
      } else if (typeof scheme === "string") {
        throw new Error('Unsupported encryption scheme: "' + scheme + '".');
      }
      var e2 = scheme.encode(data, key, true);
      return pki.rsa.encrypt(e2, key, true);
    };
    key.verify = function(digest, signature, scheme) {
      if (typeof scheme === "string") {
        scheme = scheme.toUpperCase();
      } else if (scheme === void 0) {
        scheme = "RSASSA-PKCS1-V1_5";
      }
      if (scheme === "RSASSA-PKCS1-V1_5") {
        scheme = {
          verify: function(digest2, d2) {
            d2 = _decodePkcs1_v1_5(d2, key, true);
            var obj = asn1.fromDer(d2);
            return digest2 === obj.value[1].value;
          }
        };
      } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
        scheme = {
          verify: function(digest2, d2) {
            d2 = _decodePkcs1_v1_5(d2, key, true);
            return digest2 === d2;
          }
        };
      }
      var d = pki.rsa.decrypt(signature, key, true, false);
      return scheme.verify(digest, d, key.n.bitLength());
    };
    return key;
  };
  pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
    var key = {
      n,
      e,
      d,
      p,
      q,
      dP,
      dQ,
      qInv
    };
    key.decrypt = function(data, scheme, schemeOptions) {
      if (typeof scheme === "string") {
        scheme = scheme.toUpperCase();
      } else if (scheme === void 0) {
        scheme = "RSAES-PKCS1-V1_5";
      }
      var d2 = pki.rsa.decrypt(data, key, false, false);
      if (scheme === "RSAES-PKCS1-V1_5") {
        scheme = {decode: _decodePkcs1_v1_5};
      } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
        scheme = {
          decode: function(d3, key2) {
            return forge.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
          }
        };
      } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
        scheme = {decode: function(d3) {
          return d3;
        }};
      } else {
        throw new Error('Unsupported encryption scheme: "' + scheme + '".');
      }
      return scheme.decode(d2, key, false);
    };
    key.sign = function(md, scheme) {
      var bt = false;
      if (typeof scheme === "string") {
        scheme = scheme.toUpperCase();
      }
      if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
        scheme = {encode: emsaPkcs1v15encode};
        bt = 1;
      } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
        scheme = {encode: function() {
          return md;
        }};
        bt = 1;
      }
      var d2 = scheme.encode(md, key.n.bitLength());
      return pki.rsa.encrypt(d2, key, bt);
    };
    return key;
  };
  pki.wrapRsaPrivateKey = function(rsaKey) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(rsaKey).getBytes())
    ]);
  };
  pki.privateKeyFromAsn1 = function(obj) {
    var capture = {};
    var errors = [];
    if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
      obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
    }
    capture = {};
    errors = [];
    if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
      var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
      error.errors = errors;
      throw error;
    }
    var n, e, d, p, q, dP, dQ, qInv;
    n = forge.util.createBuffer(capture.privateKeyModulus).toHex();
    e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
    d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
    p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
    q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
    dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
    dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
    qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();
    return pki.setRsaPrivateKey(new BigInteger(n, 16), new BigInteger(e, 16), new BigInteger(d, 16), new BigInteger(p, 16), new BigInteger(q, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16));
  };
  pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.d)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.p)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.q)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dP)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dQ)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.qInv))
    ]);
  };
  pki.publicKeyFromAsn1 = function(obj) {
    var capture = {};
    var errors = [];
    if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        var error = new Error("Cannot read public key. Unknown OID.");
        error.oid = oid;
        throw error;
      }
      obj = capture.rsaPublicKey;
    }
    errors = [];
    if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
      var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
      error.errors = errors;
      throw error;
    }
    var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
    var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();
    return pki.setRsaPublicKey(new BigInteger(n, 16), new BigInteger(e, 16));
  };
  pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
        pki.publicKeyToRSAPublicKey(key)
      ])
    ]);
  };
  pki.publicKeyToRSAPublicKey = function(key) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e))
    ]);
  };
  function _encodePkcs1_v1_5(m, key, bt) {
    var eb = forge.util.createBuffer();
    var k = Math.ceil(key.n.bitLength() / 8);
    if (m.length > k - 11) {
      var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
      error.length = m.length;
      error.max = k - 11;
      throw error;
    }
    eb.putByte(0);
    eb.putByte(bt);
    var padNum = k - 3 - m.length;
    var padByte;
    if (bt === 0 || bt === 1) {
      padByte = bt === 0 ? 0 : 255;
      for (var i = 0; i < padNum; ++i) {
        eb.putByte(padByte);
      }
    } else {
      while (padNum > 0) {
        var numZeros = 0;
        var padBytes = forge.random.getBytes(padNum);
        for (var i = 0; i < padNum; ++i) {
          padByte = padBytes.charCodeAt(i);
          if (padByte === 0) {
            ++numZeros;
          } else {
            eb.putByte(padByte);
          }
        }
        padNum = numZeros;
      }
    }
    eb.putByte(0);
    eb.putBytes(m);
    return eb;
  }
  function _decodePkcs1_v1_5(em, key, pub, ml) {
    var k = Math.ceil(key.n.bitLength() / 8);
    var eb = forge.util.createBuffer(em);
    var first = eb.getByte();
    var bt = eb.getByte();
    if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
      throw new Error("Encryption block is invalid.");
    }
    var padNum = 0;
    if (bt === 0) {
      padNum = k - 3 - ml;
      for (var i = 0; i < padNum; ++i) {
        if (eb.getByte() !== 0) {
          throw new Error("Encryption block is invalid.");
        }
      }
    } else if (bt === 1) {
      padNum = 0;
      while (eb.length() > 1) {
        if (eb.getByte() !== 255) {
          --eb.read;
          break;
        }
        ++padNum;
      }
    } else if (bt === 2) {
      padNum = 0;
      while (eb.length() > 1) {
        if (eb.getByte() === 0) {
          --eb.read;
          break;
        }
        ++padNum;
      }
    }
    var zero = eb.getByte();
    if (zero !== 0 || padNum !== k - 3 - eb.length()) {
      throw new Error("Encryption block is invalid.");
    }
    return eb.getBytes();
  }
  function _generateKeyPair(state, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    var opts = {
      algorithm: {
        name: options.algorithm || "PRIMEINC",
        options: {
          workers: options.workers || 2,
          workLoad: options.workLoad || 100,
          workerScript: options.workerScript
        }
      }
    };
    if ("prng" in options) {
      opts.prng = options.prng;
    }
    generate();
    function generate() {
      getPrime(state.pBits, function(err, num) {
        if (err) {
          return callback(err);
        }
        state.p = num;
        if (state.q !== null) {
          return finish(err, state.q);
        }
        getPrime(state.qBits, finish);
      });
    }
    function getPrime(bits, callback2) {
      forge.prime.generateProbablePrime(bits, opts, callback2);
    }
    function finish(err, num) {
      if (err) {
        return callback(err);
      }
      state.q = num;
      if (state.p.compareTo(state.q) < 0) {
        var tmp = state.p;
        state.p = state.q;
        state.q = tmp;
      }
      if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
        state.p = null;
        generate();
        return;
      }
      if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
        state.q = null;
        getPrime(state.qBits, finish);
        return;
      }
      state.p1 = state.p.subtract(BigInteger.ONE);
      state.q1 = state.q.subtract(BigInteger.ONE);
      state.phi = state.p1.multiply(state.q1);
      if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
        state.p = state.q = null;
        generate();
        return;
      }
      state.n = state.p.multiply(state.q);
      if (state.n.bitLength() !== state.bits) {
        state.q = null;
        getPrime(state.qBits, finish);
        return;
      }
      var d = state.e.modInverse(state.phi);
      state.keys = {
        privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
        publicKey: pki.rsa.setPublicKey(state.n, state.e)
      };
      callback(null, state.keys);
    }
  }
  function _bnToBytes(b) {
    var hex = b.toString(16);
    if (hex[0] >= "8") {
      hex = "00" + hex;
    }
    var bytes = forge.util.hexToBytes(hex);
    if (bytes.length > 1 && (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
      return bytes.substr(1);
    }
    return bytes;
  }
  function _getMillerRabinTests(bits) {
    if (bits <= 100)
      return 27;
    if (bits <= 150)
      return 18;
    if (bits <= 200)
      return 15;
    if (bits <= 250)
      return 12;
    if (bits <= 300)
      return 9;
    if (bits <= 350)
      return 8;
    if (bits <= 400)
      return 7;
    if (bits <= 500)
      return 6;
    if (bits <= 600)
      return 5;
    if (bits <= 800)
      return 4;
    if (bits <= 1250)
      return 3;
    return 2;
  }
  function _detectNodeCrypto(fn) {
    return forge.util.isNodejs && typeof _crypto[fn] === "function";
  }
  function _detectSubtleCrypto(fn) {
    return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn] === "function";
  }
  function _detectSubtleMsCrypto(fn) {
    return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn] === "function";
  }
  function _intToUint8Array(x) {
    var bytes = forge.util.hexToBytes(x.toString(16));
    var buffer = new Uint8Array(bytes.length);
    for (var i = 0; i < bytes.length; ++i) {
      buffer[i] = bytes.charCodeAt(i);
    }
    return buffer;
  }
});

// node_modules/node-forge/lib/pbe.js
var require_pbe = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_aes();
  require_asn1();
  require_des();
  require_md();
  require_oids();
  require_pbkdf2();
  require_pem();
  require_random();
  require_rc2();
  require_rsa();
  require_util();
  if (typeof BigInteger === "undefined") {
    BigInteger = forge.jsbn.BigInteger;
  }
  var BigInteger;
  var asn1 = forge.asn1;
  var pki = forge.pki = forge.pki || {};
  module2.exports = pki.pbe = forge.pbe = forge.pbe || {};
  var oids = pki.oids;
  var encryptedPrivateKeyValidator = {
    name: "EncryptedPrivateKeyInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "encryptionOid"
      }, {
        name: "AlgorithmIdentifier.parameters",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "encryptionParams"
      }]
    }, {
      name: "EncryptedPrivateKeyInfo.encryptedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: "encryptedData"
    }]
  };
  var PBES2AlgorithmsValidator = {
    name: "PBES2Algorithms",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "PBES2Algorithms.keyDerivationFunc",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc.oid",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "kdfOid"
      }, {
        name: "PBES2Algorithms.params",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.params.salt",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "kdfSalt"
        }, {
          name: "PBES2Algorithms.params.iterationCount",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "kdfIterationCount"
        }, {
          name: "PBES2Algorithms.params.keyLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          optional: true,
          capture: "keyLength"
        }, {
          name: "PBES2Algorithms.params.prf",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "PBES2Algorithms.params.prf.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "prfOid"
          }]
        }]
      }]
    }, {
      name: "PBES2Algorithms.encryptionScheme",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.encryptionScheme.oid",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "encOid"
      }, {
        name: "PBES2Algorithms.encryptionScheme.iv",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encIv"
      }]
    }]
  };
  var pkcs12PbeParamsValidator = {
    name: "pkcs-12PbeParams",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "pkcs-12PbeParams.salt",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: "salt"
    }, {
      name: "pkcs-12PbeParams.iterations",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "iterations"
    }]
  };
  pki.encryptPrivateKeyInfo = function(obj, password, options) {
    options = options || {};
    options.saltSize = options.saltSize || 8;
    options.count = options.count || 2048;
    options.algorithm = options.algorithm || "aes128";
    options.prfAlgorithm = options.prfAlgorithm || "sha1";
    var salt = forge.random.getBytesSync(options.saltSize);
    var count = options.count;
    var countBytes = asn1.integerToDer(count);
    var dkLen;
    var encryptionAlgorithm;
    var encryptedData;
    if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
      var ivLen, encOid, cipherFn;
      switch (options.algorithm) {
        case "aes128":
          dkLen = 16;
          ivLen = 16;
          encOid = oids["aes128-CBC"];
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes192":
          dkLen = 24;
          ivLen = 16;
          encOid = oids["aes192-CBC"];
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes256":
          dkLen = 32;
          ivLen = 16;
          encOid = oids["aes256-CBC"];
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "des":
          dkLen = 8;
          ivLen = 8;
          encOid = oids["desCBC"];
          cipherFn = forge.des.createEncryptionCipher;
          break;
        default:
          var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
          error.algorithm = options.algorithm;
          throw error;
      }
      var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
      var md = prfAlgorithmToMessageDigest(prfAlgorithm);
      var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
      var iv = forge.random.getBytesSync(ivLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(obj));
      cipher.finish();
      encryptedData = cipher.output.getBytes();
      var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
      encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()),
            params
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(encOid).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)
          ])
        ])
      ]);
    } else if (options.algorithm === "3des") {
      dkLen = 24;
      var saltBytes = new forge.util.ByteBuffer(salt);
      var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
      var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
      var cipher = forge.des.createEncryptionCipher(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(obj));
      cipher.finish();
      encryptedData = cipher.output.getBytes();
      encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())
        ])
      ]);
    } else {
      var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
      error.algorithm = options.algorithm;
      throw error;
    }
    var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      encryptionAlgorithm,
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)
    ]);
    return rval;
  };
  pki.decryptPrivateKeyInfo = function(obj, password) {
    var rval = null;
    var capture = {};
    var errors = [];
    if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
      var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      error.errors = errors;
      throw error;
    }
    var oid = asn1.derToOid(capture.encryptionOid);
    var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
    var encrypted = forge.util.createBuffer(capture.encryptedData);
    cipher.update(encrypted);
    if (cipher.finish()) {
      rval = asn1.fromDer(cipher.output);
    }
    return rval;
  };
  pki.encryptedPrivateKeyToPem = function(epki, maxline) {
    var msg = {
      type: "ENCRYPTED PRIVATE KEY",
      body: asn1.toDer(epki).getBytes()
    };
    return forge.pem.encode(msg, {maxline});
  };
  pki.encryptedPrivateKeyFromPem = function(pem) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "ENCRYPTED PRIVATE KEY") {
      var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
      error.headerType = msg.type;
      throw error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
    }
    return asn1.fromDer(msg.body);
  };
  pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
    options = options || {};
    if (!options.legacy) {
      var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
      rval = pki.encryptPrivateKeyInfo(rval, password, options);
      return pki.encryptedPrivateKeyToPem(rval);
    }
    var algorithm;
    var iv;
    var dkLen;
    var cipherFn;
    switch (options.algorithm) {
      case "aes128":
        algorithm = "AES-128-CBC";
        dkLen = 16;
        iv = forge.random.getBytesSync(16);
        cipherFn = forge.aes.createEncryptionCipher;
        break;
      case "aes192":
        algorithm = "AES-192-CBC";
        dkLen = 24;
        iv = forge.random.getBytesSync(16);
        cipherFn = forge.aes.createEncryptionCipher;
        break;
      case "aes256":
        algorithm = "AES-256-CBC";
        dkLen = 32;
        iv = forge.random.getBytesSync(16);
        cipherFn = forge.aes.createEncryptionCipher;
        break;
      case "3des":
        algorithm = "DES-EDE3-CBC";
        dkLen = 24;
        iv = forge.random.getBytesSync(8);
        cipherFn = forge.des.createEncryptionCipher;
        break;
      case "des":
        algorithm = "DES-CBC";
        dkLen = 8;
        iv = forge.random.getBytesSync(8);
        cipherFn = forge.des.createEncryptionCipher;
        break;
      default:
        var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
        error.algorithm = options.algorithm;
        throw error;
    }
    var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
    cipher.finish();
    var msg = {
      type: "RSA PRIVATE KEY",
      procType: {
        version: "4",
        type: "ENCRYPTED"
      },
      dekInfo: {
        algorithm,
        parameters: forge.util.bytesToHex(iv).toUpperCase()
      },
      body: cipher.output.getBytes()
    };
    return forge.pem.encode(msg);
  };
  pki.decryptRsaPrivateKey = function(pem, password) {
    var rval = null;
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
      var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
      error.headerType = error;
      throw error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      var dkLen;
      var cipherFn;
      switch (msg.dekInfo.algorithm) {
        case "DES-CBC":
          dkLen = 8;
          cipherFn = forge.des.createDecryptionCipher;
          break;
        case "DES-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge.des.createDecryptionCipher;
          break;
        case "AES-128-CBC":
          dkLen = 16;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "AES-192-CBC":
          dkLen = 24;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "AES-256-CBC":
          dkLen = 32;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "RC2-40-CBC":
          dkLen = 5;
          cipherFn = function(key) {
            return forge.rc2.createDecryptionCipher(key, 40);
          };
          break;
        case "RC2-64-CBC":
          dkLen = 8;
          cipherFn = function(key) {
            return forge.rc2.createDecryptionCipher(key, 64);
          };
          break;
        case "RC2-128-CBC":
          dkLen = 16;
          cipherFn = function(key) {
            return forge.rc2.createDecryptionCipher(key, 128);
          };
          break;
        default:
          var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
          error.algorithm = msg.dekInfo.algorithm;
          throw error;
      }
      var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
      var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(forge.util.createBuffer(msg.body));
      if (cipher.finish()) {
        rval = cipher.output.getBytes();
      } else {
        return rval;
      }
    } else {
      rval = msg.body;
    }
    if (msg.type === "ENCRYPTED PRIVATE KEY") {
      rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
    } else {
      rval = asn1.fromDer(rval);
    }
    if (rval !== null) {
      rval = pki.privateKeyFromAsn1(rval);
    }
    return rval;
  };
  pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
    var j, l;
    if (typeof md === "undefined" || md === null) {
      if (!("sha1" in forge.md)) {
        throw new Error('"sha1" hash algorithm unavailable.');
      }
      md = forge.md.sha1.create();
    }
    var u = md.digestLength;
    var v = md.blockLength;
    var result = new forge.util.ByteBuffer();
    var passBuf = new forge.util.ByteBuffer();
    if (password !== null && password !== void 0) {
      for (l = 0; l < password.length; l++) {
        passBuf.putInt16(password.charCodeAt(l));
      }
      passBuf.putInt16(0);
    }
    var p = passBuf.length();
    var s = salt.length();
    var D = new forge.util.ByteBuffer();
    D.fillWithByte(id, v);
    var Slen = v * Math.ceil(s / v);
    var S = new forge.util.ByteBuffer();
    for (l = 0; l < Slen; l++) {
      S.putByte(salt.at(l % s));
    }
    var Plen = v * Math.ceil(p / v);
    var P = new forge.util.ByteBuffer();
    for (l = 0; l < Plen; l++) {
      P.putByte(passBuf.at(l % p));
    }
    var I = S;
    I.putBuffer(P);
    var c = Math.ceil(n / u);
    for (var i = 1; i <= c; i++) {
      var buf = new forge.util.ByteBuffer();
      buf.putBytes(D.bytes());
      buf.putBytes(I.bytes());
      for (var round = 0; round < iter; round++) {
        md.start();
        md.update(buf.getBytes());
        buf = md.digest();
      }
      var B = new forge.util.ByteBuffer();
      for (l = 0; l < v; l++) {
        B.putByte(buf.at(l % u));
      }
      var k = Math.ceil(s / v) + Math.ceil(p / v);
      var Inew = new forge.util.ByteBuffer();
      for (j = 0; j < k; j++) {
        var chunk = new forge.util.ByteBuffer(I.getBytes(v));
        var x = 511;
        for (l = B.length() - 1; l >= 0; l--) {
          x = x >> 8;
          x += B.at(l) + chunk.at(l);
          chunk.setAt(l, x & 255);
        }
        Inew.putBuffer(chunk);
      }
      I = Inew;
      result.putBuffer(buf);
    }
    result.truncate(result.length() - n);
    return result;
  };
  pki.pbe.getCipher = function(oid, params, password) {
    switch (oid) {
      case pki.oids["pkcs5PBES2"]:
        return pki.pbe.getCipherForPBES2(oid, params, password);
      case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
        return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
      default:
        var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
        error.oid = oid;
        error.supportedOids = [
          "pkcs5PBES2",
          "pbeWithSHAAnd3-KeyTripleDES-CBC",
          "pbewithSHAAnd40BitRC2-CBC"
        ];
        throw error;
    }
  };
  pki.pbe.getCipherForPBES2 = function(oid, params, password) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
      var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      error.errors = errors;
      throw error;
    }
    oid = asn1.derToOid(capture.kdfOid);
    if (oid !== pki.oids["pkcs5PBKDF2"]) {
      var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
      error.oid = oid;
      error.supportedOids = ["pkcs5PBKDF2"];
      throw error;
    }
    oid = asn1.derToOid(capture.encOid);
    if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
      var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
      error.oid = oid;
      error.supportedOids = [
        "aes128-CBC",
        "aes192-CBC",
        "aes256-CBC",
        "des-EDE3-CBC",
        "desCBC"
      ];
      throw error;
    }
    var salt = capture.kdfSalt;
    var count = forge.util.createBuffer(capture.kdfIterationCount);
    count = count.getInt(count.length() << 3);
    var dkLen;
    var cipherFn;
    switch (pki.oids[oid]) {
      case "aes128-CBC":
        dkLen = 16;
        cipherFn = forge.aes.createDecryptionCipher;
        break;
      case "aes192-CBC":
        dkLen = 24;
        cipherFn = forge.aes.createDecryptionCipher;
        break;
      case "aes256-CBC":
        dkLen = 32;
        cipherFn = forge.aes.createDecryptionCipher;
        break;
      case "des-EDE3-CBC":
        dkLen = 24;
        cipherFn = forge.des.createDecryptionCipher;
        break;
      case "desCBC":
        dkLen = 8;
        cipherFn = forge.des.createDecryptionCipher;
        break;
    }
    var md = prfOidToMessageDigest(capture.prfOid);
    var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
    var iv = capture.encIv;
    var cipher = cipherFn(dk);
    cipher.start(iv);
    return cipher;
  };
  pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
      var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      error.errors = errors;
      throw error;
    }
    var salt = forge.util.createBuffer(capture.salt);
    var count = forge.util.createBuffer(capture.iterations);
    count = count.getInt(count.length() << 3);
    var dkLen, dIvLen, cipherFn;
    switch (oid) {
      case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        dkLen = 24;
        dIvLen = 8;
        cipherFn = forge.des.startDecrypting;
        break;
      case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
        dkLen = 5;
        dIvLen = 8;
        cipherFn = function(key2, iv2) {
          var cipher = forge.rc2.createDecryptionCipher(key2, 40);
          cipher.start(iv2, null);
          return cipher;
        };
        break;
      default:
        var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
        error.oid = oid;
        throw error;
    }
    var md = prfOidToMessageDigest(capture.prfOid);
    var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
    md.start();
    var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
    return cipherFn(key, iv);
  };
  pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
    if (typeof md === "undefined" || md === null) {
      if (!("md5" in forge.md)) {
        throw new Error('"md5" hash algorithm unavailable.');
      }
      md = forge.md.md5.create();
    }
    if (salt === null) {
      salt = "";
    }
    var digests = [hash(md, password + salt)];
    for (var length = 16, i = 1; length < dkLen; ++i, length += 16) {
      digests.push(hash(md, digests[i - 1] + password + salt));
    }
    return digests.join("").substr(0, dkLen);
  };
  function hash(md, bytes) {
    return md.start().update(bytes).digest().getBytes();
  }
  function prfOidToMessageDigest(prfOid) {
    var prfAlgorithm;
    if (!prfOid) {
      prfAlgorithm = "hmacWithSHA1";
    } else {
      prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
      if (!prfAlgorithm) {
        var error = new Error("Unsupported PRF OID.");
        error.oid = prfOid;
        error.supported = [
          "hmacWithSHA1",
          "hmacWithSHA224",
          "hmacWithSHA256",
          "hmacWithSHA384",
          "hmacWithSHA512"
        ];
        throw error;
      }
    }
    return prfAlgorithmToMessageDigest(prfAlgorithm);
  }
  function prfAlgorithmToMessageDigest(prfAlgorithm) {
    var factory = forge.md;
    switch (prfAlgorithm) {
      case "hmacWithSHA224":
        factory = forge.md.sha512;
      case "hmacWithSHA1":
      case "hmacWithSHA256":
      case "hmacWithSHA384":
      case "hmacWithSHA512":
        prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
        break;
      default:
        var error = new Error("Unsupported PRF algorithm.");
        error.algorithm = prfAlgorithm;
        error.supported = [
          "hmacWithSHA1",
          "hmacWithSHA224",
          "hmacWithSHA256",
          "hmacWithSHA384",
          "hmacWithSHA512"
        ];
        throw error;
    }
    if (!factory || !(prfAlgorithm in factory)) {
      throw new Error("Unknown hash algorithm: " + prfAlgorithm);
    }
    return factory[prfAlgorithm].create();
  }
  function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
    var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())
    ]);
    if (prfAlgorithm !== "hmacWithSHA1") {
      params.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(dkLen.toString(16))), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
    }
    return params;
  }
});

// node_modules/node-forge/lib/pkcs7asn1.js
var require_pkcs7asn1 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_asn1();
  require_util();
  var asn1 = forge.asn1;
  var p7v = module2.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
  forge.pkcs7 = forge.pkcs7 || {};
  forge.pkcs7.asn1 = p7v;
  var contentInfoValidator = {
    name: "ContentInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "ContentInfo.ContentType",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: "contentType"
    }, {
      name: "ContentInfo.content",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: true,
      optional: true,
      captureAsn1: "content"
    }]
  };
  p7v.contentInfoValidator = contentInfoValidator;
  var encryptedContentInfoValidator = {
    name: "EncryptedContentInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "EncryptedContentInfo.contentType",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: "contentType"
    }, {
      name: "EncryptedContentInfo.contentEncryptionAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "encAlgorithm"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
        tagClass: asn1.Class.UNIVERSAL,
        captureAsn1: "encParameter"
      }]
    }, {
      name: "EncryptedContentInfo.encryptedContent",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 0,
      capture: "encryptedContent",
      captureAsn1: "encryptedContentAsn1"
    }]
  };
  p7v.envelopedDataValidator = {
    name: "EnvelopedData",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "EnvelopedData.Version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "version"
    }, {
      name: "EnvelopedData.RecipientInfos",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SET,
      constructed: true,
      captureAsn1: "recipientInfos"
    }].concat(encryptedContentInfoValidator)
  };
  p7v.encryptedDataValidator = {
    name: "EncryptedData",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "EncryptedData.Version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "version"
    }].concat(encryptedContentInfoValidator)
  };
  var signerValidator = {
    name: "SignerInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "SignerInfo.version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false
    }, {
      name: "SignerInfo.issuerAndSerialNumber",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.issuerAndSerialNumber.issuer",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "issuer"
      }, {
        name: "SignerInfo.issuerAndSerialNumber.serialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "serial"
      }]
    }, {
      name: "SignerInfo.digestAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.digestAlgorithm.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "digestAlgorithm"
      }, {
        name: "SignerInfo.digestAlgorithm.parameter",
        tagClass: asn1.Class.UNIVERSAL,
        constructed: false,
        captureAsn1: "digestParameter",
        optional: true
      }]
    }, {
      name: "SignerInfo.authenticatedAttributes",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: true,
      optional: true,
      capture: "authenticatedAttributes"
    }, {
      name: "SignerInfo.digestEncryptionAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      capture: "signatureAlgorithm"
    }, {
      name: "SignerInfo.encryptedDigest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: "signature"
    }, {
      name: "SignerInfo.unauthenticatedAttributes",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 1,
      constructed: true,
      optional: true,
      capture: "unauthenticatedAttributes"
    }]
  };
  p7v.signedDataValidator = {
    name: "SignedData",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [
      {
        name: "SignedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      },
      {
        name: "SignedData.DigestAlgorithms",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: "digestAlgorithms"
      },
      contentInfoValidator,
      {
        name: "SignedData.Certificates",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        optional: true,
        captureAsn1: "certificates"
      },
      {
        name: "SignedData.CertificateRevocationLists",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        optional: true,
        captureAsn1: "crls"
      },
      {
        name: "SignedData.SignerInfos",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        capture: "signerInfos",
        optional: true,
        value: [signerValidator]
      }
    ]
  };
  p7v.recipientInfoValidator = {
    name: "RecipientInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "RecipientInfo.version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "version"
    }, {
      name: "RecipientInfo.issuerAndSerial",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.issuerAndSerial.issuer",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "issuer"
      }, {
        name: "RecipientInfo.issuerAndSerial.serialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "serial"
      }]
    }, {
      name: "RecipientInfo.keyEncryptionAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "encAlgorithm"
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
        tagClass: asn1.Class.UNIVERSAL,
        constructed: false,
        captureAsn1: "encParameter"
      }]
    }, {
      name: "RecipientInfo.encryptedKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: "encKey"
    }]
  };
});

// node_modules/node-forge/lib/mgf1.js
var require_mgf1 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util();
  forge.mgf = forge.mgf || {};
  var mgf1 = module2.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};
  mgf1.create = function(md) {
    var mgf = {
      generate: function(seed, maskLen) {
        var t = new forge.util.ByteBuffer();
        var len = Math.ceil(maskLen / md.digestLength);
        for (var i = 0; i < len; i++) {
          var c = new forge.util.ByteBuffer();
          c.putInt32(i);
          md.start();
          md.update(seed + c.getBytes());
          t.putBuffer(md.digest());
        }
        t.truncate(t.length() - maskLen);
        return t.getBytes();
      }
    };
    return mgf;
  };
});

// node_modules/node-forge/lib/mgf.js
var require_mgf = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_mgf1();
  module2.exports = forge.mgf = forge.mgf || {};
  forge.mgf.mgf1 = forge.mgf1;
});

// node_modules/node-forge/lib/pss.js
var require_pss = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_random();
  require_util();
  var pss = module2.exports = forge.pss = forge.pss || {};
  pss.create = function(options) {
    if (arguments.length === 3) {
      options = {
        md: arguments[0],
        mgf: arguments[1],
        saltLength: arguments[2]
      };
    }
    var hash = options.md;
    var mgf = options.mgf;
    var hLen = hash.digestLength;
    var salt_ = options.salt || null;
    if (typeof salt_ === "string") {
      salt_ = forge.util.createBuffer(salt_);
    }
    var sLen;
    if ("saltLength" in options) {
      sLen = options.saltLength;
    } else if (salt_ !== null) {
      sLen = salt_.length();
    } else {
      throw new Error("Salt length not specified or specific salt not given.");
    }
    if (salt_ !== null && salt_.length() !== sLen) {
      throw new Error("Given salt length does not match length of given salt.");
    }
    var prng = options.prng || forge.random;
    var pssobj = {};
    pssobj.encode = function(md, modBits) {
      var i;
      var emBits = modBits - 1;
      var emLen = Math.ceil(emBits / 8);
      var mHash = md.digest().getBytes();
      if (emLen < hLen + sLen + 2) {
        throw new Error("Message is too long to encrypt.");
      }
      var salt;
      if (salt_ === null) {
        salt = prng.getBytesSync(sLen);
      } else {
        salt = salt_.bytes();
      }
      var m_ = new forge.util.ByteBuffer();
      m_.fillWithByte(0, 8);
      m_.putBytes(mHash);
      m_.putBytes(salt);
      hash.start();
      hash.update(m_.getBytes());
      var h = hash.digest().getBytes();
      var ps = new forge.util.ByteBuffer();
      ps.fillWithByte(0, emLen - sLen - hLen - 2);
      ps.putByte(1);
      ps.putBytes(salt);
      var db2 = ps.getBytes();
      var maskLen = emLen - hLen - 1;
      var dbMask = mgf.generate(h, maskLen);
      var maskedDB = "";
      for (i = 0; i < maskLen; i++) {
        maskedDB += String.fromCharCode(db2.charCodeAt(i) ^ dbMask.charCodeAt(i));
      }
      var mask = 65280 >> 8 * emLen - emBits & 255;
      maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
      return maskedDB + h + String.fromCharCode(188);
    };
    pssobj.verify = function(mHash, em, modBits) {
      var i;
      var emBits = modBits - 1;
      var emLen = Math.ceil(emBits / 8);
      em = em.substr(-emLen);
      if (emLen < hLen + sLen + 2) {
        throw new Error("Inconsistent parameters to PSS signature verification.");
      }
      if (em.charCodeAt(emLen - 1) !== 188) {
        throw new Error("Encoded message does not end in 0xBC.");
      }
      var maskLen = emLen - hLen - 1;
      var maskedDB = em.substr(0, maskLen);
      var h = em.substr(maskLen, hLen);
      var mask = 65280 >> 8 * emLen - emBits & 255;
      if ((maskedDB.charCodeAt(0) & mask) !== 0) {
        throw new Error("Bits beyond keysize not zero as expected.");
      }
      var dbMask = mgf.generate(h, maskLen);
      var db2 = "";
      for (i = 0; i < maskLen; i++) {
        db2 += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
      }
      db2 = String.fromCharCode(db2.charCodeAt(0) & ~mask) + db2.substr(1);
      var checkLen = emLen - hLen - sLen - 2;
      for (i = 0; i < checkLen; i++) {
        if (db2.charCodeAt(i) !== 0) {
          throw new Error("Leftmost octets not zero as expected");
        }
      }
      if (db2.charCodeAt(checkLen) !== 1) {
        throw new Error("Inconsistent PSS signature, 0x01 marker not found");
      }
      var salt = db2.substr(-sLen);
      var m_ = new forge.util.ByteBuffer();
      m_.fillWithByte(0, 8);
      m_.putBytes(mHash);
      m_.putBytes(salt);
      hash.start();
      hash.update(m_.getBytes());
      var h_ = hash.digest().getBytes();
      return h === h_;
    };
    return pssobj;
  };
});

// node_modules/node-forge/lib/x509.js
var require_x509 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_aes();
  require_asn1();
  require_des();
  require_md();
  require_mgf();
  require_oids();
  require_pem();
  require_pss();
  require_rsa();
  require_util();
  var asn1 = forge.asn1;
  var pki = module2.exports = forge.pki = forge.pki || {};
  var oids = pki.oids;
  var _shortNames = {};
  _shortNames["CN"] = oids["commonName"];
  _shortNames["commonName"] = "CN";
  _shortNames["C"] = oids["countryName"];
  _shortNames["countryName"] = "C";
  _shortNames["L"] = oids["localityName"];
  _shortNames["localityName"] = "L";
  _shortNames["ST"] = oids["stateOrProvinceName"];
  _shortNames["stateOrProvinceName"] = "ST";
  _shortNames["O"] = oids["organizationName"];
  _shortNames["organizationName"] = "O";
  _shortNames["OU"] = oids["organizationalUnitName"];
  _shortNames["organizationalUnitName"] = "OU";
  _shortNames["E"] = oids["emailAddress"];
  _shortNames["emailAddress"] = "E";
  var publicKeyValidator = forge.pki.rsa.publicKeyValidator;
  var x509CertificateValidator = {
    name: "Certificate",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "Certificate.TBSCertificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "tbsCertificate",
      value: [
        {
          name: "Certificate.TBSCertificate.version",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          value: [{
            name: "Certificate.TBSCertificate.version.integer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certVersion"
          }]
        },
        {
          name: "Certificate.TBSCertificate.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "certSerialNumber"
        },
        {
          name: "Certificate.TBSCertificate.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "Certificate.TBSCertificate.signature.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "certinfoSignatureOid"
          }, {
            name: "Certificate.TBSCertificate.signature.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "certinfoSignatureParams"
          }]
        },
        {
          name: "Certificate.TBSCertificate.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certIssuer"
        },
        {
          name: "Certificate.TBSCertificate.validity",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "Certificate.TBSCertificate.validity.notBefore (utc)",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.UTCTIME,
            constructed: false,
            optional: true,
            capture: "certValidity1UTCTime"
          }, {
            name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.GENERALIZEDTIME,
            constructed: false,
            optional: true,
            capture: "certValidity2GeneralizedTime"
          }, {
            name: "Certificate.TBSCertificate.validity.notAfter (utc)",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.UTCTIME,
            constructed: false,
            optional: true,
            capture: "certValidity3UTCTime"
          }, {
            name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.GENERALIZEDTIME,
            constructed: false,
            optional: true,
            capture: "certValidity4GeneralizedTime"
          }]
        },
        {
          name: "Certificate.TBSCertificate.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certSubject"
        },
        publicKeyValidator,
        {
          name: "Certificate.TBSCertificate.issuerUniqueID",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          constructed: true,
          optional: true,
          value: [{
            name: "Certificate.TBSCertificate.issuerUniqueID.id",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: false,
            captureBitStringValue: "certIssuerUniqueId"
          }]
        },
        {
          name: "Certificate.TBSCertificate.subjectUniqueID",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 2,
          constructed: true,
          optional: true,
          value: [{
            name: "Certificate.TBSCertificate.subjectUniqueID.id",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: false,
            captureBitStringValue: "certSubjectUniqueId"
          }]
        },
        {
          name: "Certificate.TBSCertificate.extensions",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 3,
          constructed: true,
          captureAsn1: "certExtensions",
          optional: true
        }
      ]
    }, {
      name: "Certificate.signatureAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.signatureAlgorithm.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "certSignatureOid"
      }, {
        name: "Certificate.TBSCertificate.signature.parameters",
        tagClass: asn1.Class.UNIVERSAL,
        optional: true,
        captureAsn1: "certSignatureParams"
      }]
    }, {
      name: "Certificate.signatureValue",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.BITSTRING,
      constructed: false,
      captureBitStringValue: "certSignature"
    }]
  };
  var rsassaPssParameterValidator = {
    name: "rsapss",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "rsapss.hashAlgorithm",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Class.SEQUENCE,
        constructed: true,
        optional: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "hashOid"
        }]
      }]
    }, {
      name: "rsapss.maskGenAlgorithm",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 1,
      constructed: true,
      value: [{
        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Class.SEQUENCE,
        constructed: true,
        optional: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "maskGenOid"
        }, {
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "maskGenHashOid"
          }]
        }]
      }]
    }, {
      name: "rsapss.saltLength",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 2,
      optional: true,
      value: [{
        name: "rsapss.saltLength.saltLength",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Class.INTEGER,
        constructed: false,
        capture: "saltLength"
      }]
    }, {
      name: "rsapss.trailerField",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 3,
      optional: true,
      value: [{
        name: "rsapss.trailer.trailer",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Class.INTEGER,
        constructed: false,
        capture: "trailer"
      }]
    }]
  };
  var certificationRequestInfoValidator = {
    name: "CertificationRequestInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: "certificationRequestInfo",
    value: [
      {
        name: "CertificationRequestInfo.integer",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "certificationRequestInfoVersion"
      },
      {
        name: "CertificationRequestInfo.subject",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "certificationRequestInfoSubject"
      },
      publicKeyValidator,
      {
        name: "CertificationRequestInfo.attributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "certificationRequestInfoAttributes",
        value: [{
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "CertificationRequestInfo.attributes.type",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false
          }, {
            name: "CertificationRequestInfo.attributes.value",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SET,
            constructed: true
          }]
        }]
      }
    ]
  };
  var certificationRequestValidator = {
    name: "CertificationRequest",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: "csr",
    value: [
      certificationRequestInfoValidator,
      {
        name: "CertificationRequest.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "CertificationRequest.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "csrSignatureOid"
        }, {
          name: "CertificationRequest.signatureAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "csrSignatureParams"
        }]
      },
      {
        name: "CertificationRequest.signature",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "csrSignature"
      }
    ]
  };
  pki.RDNAttributesAsArray = function(rdn, md) {
    var rval = [];
    var set, attr, obj;
    for (var si = 0; si < rdn.value.length; ++si) {
      set = rdn.value[si];
      for (var i = 0; i < set.value.length; ++i) {
        obj = {};
        attr = set.value[i];
        obj.type = asn1.derToOid(attr.value[0].value);
        obj.value = attr.value[1].value;
        obj.valueTagClass = attr.value[1].type;
        if (obj.type in oids) {
          obj.name = oids[obj.type];
          if (obj.name in _shortNames) {
            obj.shortName = _shortNames[obj.name];
          }
        }
        if (md) {
          md.update(obj.type);
          md.update(obj.value);
        }
        rval.push(obj);
      }
    }
    return rval;
  };
  pki.CRIAttributesAsArray = function(attributes) {
    var rval = [];
    for (var si = 0; si < attributes.length; ++si) {
      var seq = attributes[si];
      var type = asn1.derToOid(seq.value[0].value);
      var values = seq.value[1].value;
      for (var vi = 0; vi < values.length; ++vi) {
        var obj = {};
        obj.type = type;
        obj.value = values[vi].value;
        obj.valueTagClass = values[vi].type;
        if (obj.type in oids) {
          obj.name = oids[obj.type];
          if (obj.name in _shortNames) {
            obj.shortName = _shortNames[obj.name];
          }
        }
        if (obj.type === oids.extensionRequest) {
          obj.extensions = [];
          for (var ei = 0; ei < obj.value.length; ++ei) {
            obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
          }
        }
        rval.push(obj);
      }
    }
    return rval;
  };
  function _getAttribute(obj, options) {
    if (typeof options === "string") {
      options = {shortName: options};
    }
    var rval = null;
    var attr;
    for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
      attr = obj.attributes[i];
      if (options.type && options.type === attr.type) {
        rval = attr;
      } else if (options.name && options.name === attr.name) {
        rval = attr;
      } else if (options.shortName && options.shortName === attr.shortName) {
        rval = attr;
      }
    }
    return rval;
  }
  var _readSignatureParameters = function(oid, obj, fillDefaults) {
    var params = {};
    if (oid !== oids["RSASSA-PSS"]) {
      return params;
    }
    if (fillDefaults) {
      params = {
        hash: {
          algorithmOid: oids["sha1"]
        },
        mgf: {
          algorithmOid: oids["mgf1"],
          hash: {
            algorithmOid: oids["sha1"]
          }
        },
        saltLength: 20
      };
    }
    var capture = {};
    var errors = [];
    if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
      var error = new Error("Cannot read RSASSA-PSS parameter block.");
      error.errors = errors;
      throw error;
    }
    if (capture.hashOid !== void 0) {
      params.hash = params.hash || {};
      params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
    }
    if (capture.maskGenOid !== void 0) {
      params.mgf = params.mgf || {};
      params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
      params.mgf.hash = params.mgf.hash || {};
      params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
    }
    if (capture.saltLength !== void 0) {
      params.saltLength = capture.saltLength.charCodeAt(0);
    }
    return params;
  };
  pki.certificateFromPem = function(pem, computeHash, strict) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
      var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
      error.headerType = msg.type;
      throw error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
    }
    var obj = asn1.fromDer(msg.body, strict);
    return pki.certificateFromAsn1(obj, computeHash);
  };
  pki.certificateToPem = function(cert, maxline) {
    var msg = {
      type: "CERTIFICATE",
      body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
    };
    return forge.pem.encode(msg, {maxline});
  };
  pki.publicKeyFromPem = function(pem) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
      var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
      error.headerType = msg.type;
      throw error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      throw new Error("Could not convert public key from PEM; PEM is encrypted.");
    }
    var obj = asn1.fromDer(msg.body);
    return pki.publicKeyFromAsn1(obj);
  };
  pki.publicKeyToPem = function(key, maxline) {
    var msg = {
      type: "PUBLIC KEY",
      body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
    };
    return forge.pem.encode(msg, {maxline});
  };
  pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
    var msg = {
      type: "RSA PUBLIC KEY",
      body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
    };
    return forge.pem.encode(msg, {maxline});
  };
  pki.getPublicKeyFingerprint = function(key, options) {
    options = options || {};
    var md = options.md || forge.md.sha1.create();
    var type = options.type || "RSAPublicKey";
    var bytes;
    switch (type) {
      case "RSAPublicKey":
        bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
        break;
      case "SubjectPublicKeyInfo":
        bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
        break;
      default:
        throw new Error('Unknown fingerprint type "' + options.type + '".');
    }
    md.start();
    md.update(bytes);
    var digest = md.digest();
    if (options.encoding === "hex") {
      var hex = digest.toHex();
      if (options.delimiter) {
        return hex.match(/.{2}/g).join(options.delimiter);
      }
      return hex;
    } else if (options.encoding === "binary") {
      return digest.getBytes();
    } else if (options.encoding) {
      throw new Error('Unknown encoding "' + options.encoding + '".');
    }
    return digest;
  };
  pki.certificationRequestFromPem = function(pem, computeHash, strict) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "CERTIFICATE REQUEST") {
      var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
      error.headerType = msg.type;
      throw error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
    }
    var obj = asn1.fromDer(msg.body, strict);
    return pki.certificationRequestFromAsn1(obj, computeHash);
  };
  pki.certificationRequestToPem = function(csr, maxline) {
    var msg = {
      type: "CERTIFICATE REQUEST",
      body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
    };
    return forge.pem.encode(msg, {maxline});
  };
  pki.createCertificate = function() {
    var cert = {};
    cert.version = 2;
    cert.serialNumber = "00";
    cert.signatureOid = null;
    cert.signature = null;
    cert.siginfo = {};
    cert.siginfo.algorithmOid = null;
    cert.validity = {};
    cert.validity.notBefore = new Date();
    cert.validity.notAfter = new Date();
    cert.issuer = {};
    cert.issuer.getField = function(sn) {
      return _getAttribute(cert.issuer, sn);
    };
    cert.issuer.addField = function(attr) {
      _fillMissingFields([attr]);
      cert.issuer.attributes.push(attr);
    };
    cert.issuer.attributes = [];
    cert.issuer.hash = null;
    cert.subject = {};
    cert.subject.getField = function(sn) {
      return _getAttribute(cert.subject, sn);
    };
    cert.subject.addField = function(attr) {
      _fillMissingFields([attr]);
      cert.subject.attributes.push(attr);
    };
    cert.subject.attributes = [];
    cert.subject.hash = null;
    cert.extensions = [];
    cert.publicKey = null;
    cert.md = null;
    cert.setSubject = function(attrs, uniqueId) {
      _fillMissingFields(attrs);
      cert.subject.attributes = attrs;
      delete cert.subject.uniqueId;
      if (uniqueId) {
        cert.subject.uniqueId = uniqueId;
      }
      cert.subject.hash = null;
    };
    cert.setIssuer = function(attrs, uniqueId) {
      _fillMissingFields(attrs);
      cert.issuer.attributes = attrs;
      delete cert.issuer.uniqueId;
      if (uniqueId) {
        cert.issuer.uniqueId = uniqueId;
      }
      cert.issuer.hash = null;
    };
    cert.setExtensions = function(exts) {
      for (var i = 0; i < exts.length; ++i) {
        _fillMissingExtensionFields(exts[i], {cert});
      }
      cert.extensions = exts;
    };
    cert.getExtension = function(options) {
      if (typeof options === "string") {
        options = {name: options};
      }
      var rval = null;
      var ext;
      for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
        ext = cert.extensions[i];
        if (options.id && ext.id === options.id) {
          rval = ext;
        } else if (options.name && ext.name === options.name) {
          rval = ext;
        }
      }
      return rval;
    };
    cert.sign = function(key, md) {
      cert.md = md || forge.md.sha1.create();
      var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
      if (!algorithmOid) {
        var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
        error.algorithm = cert.md.algorithm;
        throw error;
      }
      cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
      cert.tbsCertificate = pki.getTBSCertificate(cert);
      var bytes = asn1.toDer(cert.tbsCertificate);
      cert.md.update(bytes.getBytes());
      cert.signature = key.sign(cert.md);
    };
    cert.verify = function(child) {
      var rval = false;
      if (!cert.issued(child)) {
        var issuer = child.issuer;
        var subject = cert.subject;
        var error = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
        error.expectedIssuer = issuer.attributes;
        error.actualIssuer = subject.attributes;
        throw error;
      }
      var md = child.md;
      if (md === null) {
        if (child.signatureOid in oids) {
          var oid = oids[child.signatureOid];
          switch (oid) {
            case "sha1WithRSAEncryption":
              md = forge.md.sha1.create();
              break;
            case "md5WithRSAEncryption":
              md = forge.md.md5.create();
              break;
            case "sha256WithRSAEncryption":
              md = forge.md.sha256.create();
              break;
            case "sha384WithRSAEncryption":
              md = forge.md.sha384.create();
              break;
            case "sha512WithRSAEncryption":
              md = forge.md.sha512.create();
              break;
            case "RSASSA-PSS":
              md = forge.md.sha256.create();
              break;
          }
        }
        if (md === null) {
          var error = new Error("Could not compute certificate digest. Unknown signature OID.");
          error.signatureOid = child.signatureOid;
          throw error;
        }
        var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
        var bytes = asn1.toDer(tbsCertificate);
        md.update(bytes.getBytes());
      }
      if (md !== null) {
        var scheme;
        switch (child.signatureOid) {
          case oids.sha1WithRSAEncryption:
            scheme = void 0;
            break;
          case oids["RSASSA-PSS"]:
            var hash, mgf;
            hash = oids[child.signatureParameters.mgf.hash.algorithmOid];
            if (hash === void 0 || forge.md[hash] === void 0) {
              var error = new Error("Unsupported MGF hash function.");
              error.oid = child.signatureParameters.mgf.hash.algorithmOid;
              error.name = hash;
              throw error;
            }
            mgf = oids[child.signatureParameters.mgf.algorithmOid];
            if (mgf === void 0 || forge.mgf[mgf] === void 0) {
              var error = new Error("Unsupported MGF function.");
              error.oid = child.signatureParameters.mgf.algorithmOid;
              error.name = mgf;
              throw error;
            }
            mgf = forge.mgf[mgf].create(forge.md[hash].create());
            hash = oids[child.signatureParameters.hash.algorithmOid];
            if (hash === void 0 || forge.md[hash] === void 0) {
              throw {
                message: "Unsupported RSASSA-PSS hash function.",
                oid: child.signatureParameters.hash.algorithmOid,
                name: hash
              };
            }
            scheme = forge.pss.create(forge.md[hash].create(), mgf, child.signatureParameters.saltLength);
            break;
        }
        rval = cert.publicKey.verify(md.digest().getBytes(), child.signature, scheme);
      }
      return rval;
    };
    cert.isIssuer = function(parent) {
      var rval = false;
      var i = cert.issuer;
      var s = parent.subject;
      if (i.hash && s.hash) {
        rval = i.hash === s.hash;
      } else if (i.attributes.length === s.attributes.length) {
        rval = true;
        var iattr, sattr;
        for (var n = 0; rval && n < i.attributes.length; ++n) {
          iattr = i.attributes[n];
          sattr = s.attributes[n];
          if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
            rval = false;
          }
        }
      }
      return rval;
    };
    cert.issued = function(child) {
      return child.isIssuer(cert);
    };
    cert.generateSubjectKeyIdentifier = function() {
      return pki.getPublicKeyFingerprint(cert.publicKey, {type: "RSAPublicKey"});
    };
    cert.verifySubjectKeyIdentifier = function() {
      var oid = oids["subjectKeyIdentifier"];
      for (var i = 0; i < cert.extensions.length; ++i) {
        var ext = cert.extensions[i];
        if (ext.id === oid) {
          var ski = cert.generateSubjectKeyIdentifier().getBytes();
          return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
        }
      }
      return false;
    };
    return cert;
  };
  pki.certificateFromAsn1 = function(obj, computeHash) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
      var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
      error.errors = errors;
      throw error;
    }
    var oid = asn1.derToOid(capture.publicKeyOid);
    if (oid !== pki.oids.rsaEncryption) {
      throw new Error("Cannot read public key. OID is not RSA.");
    }
    var cert = pki.createCertificate();
    cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
    var serial = forge.util.createBuffer(capture.certSerialNumber);
    cert.serialNumber = serial.toHex();
    cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
    cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, true);
    cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
    cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, false);
    cert.signature = capture.certSignature;
    var validity = [];
    if (capture.certValidity1UTCTime !== void 0) {
      validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
    }
    if (capture.certValidity2GeneralizedTime !== void 0) {
      validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));
    }
    if (capture.certValidity3UTCTime !== void 0) {
      validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
    }
    if (capture.certValidity4GeneralizedTime !== void 0) {
      validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));
    }
    if (validity.length > 2) {
      throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
    }
    if (validity.length < 2) {
      throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
    }
    cert.validity.notBefore = validity[0];
    cert.validity.notAfter = validity[1];
    cert.tbsCertificate = capture.tbsCertificate;
    if (computeHash) {
      cert.md = null;
      if (cert.signatureOid in oids) {
        var oid = oids[cert.signatureOid];
        switch (oid) {
          case "sha1WithRSAEncryption":
            cert.md = forge.md.sha1.create();
            break;
          case "md5WithRSAEncryption":
            cert.md = forge.md.md5.create();
            break;
          case "sha256WithRSAEncryption":
            cert.md = forge.md.sha256.create();
            break;
          case "sha384WithRSAEncryption":
            cert.md = forge.md.sha384.create();
            break;
          case "sha512WithRSAEncryption":
            cert.md = forge.md.sha512.create();
            break;
          case "RSASSA-PSS":
            cert.md = forge.md.sha256.create();
            break;
        }
      }
      if (cert.md === null) {
        var error = new Error("Could not compute certificate digest. Unknown signature OID.");
        error.signatureOid = cert.signatureOid;
        throw error;
      }
      var bytes = asn1.toDer(cert.tbsCertificate);
      cert.md.update(bytes.getBytes());
    }
    var imd = forge.md.sha1.create();
    cert.issuer.getField = function(sn) {
      return _getAttribute(cert.issuer, sn);
    };
    cert.issuer.addField = function(attr) {
      _fillMissingFields([attr]);
      cert.issuer.attributes.push(attr);
    };
    cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer, imd);
    if (capture.certIssuerUniqueId) {
      cert.issuer.uniqueId = capture.certIssuerUniqueId;
    }
    cert.issuer.hash = imd.digest().toHex();
    var smd = forge.md.sha1.create();
    cert.subject.getField = function(sn) {
      return _getAttribute(cert.subject, sn);
    };
    cert.subject.addField = function(attr) {
      _fillMissingFields([attr]);
      cert.subject.attributes.push(attr);
    };
    cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject, smd);
    if (capture.certSubjectUniqueId) {
      cert.subject.uniqueId = capture.certSubjectUniqueId;
    }
    cert.subject.hash = smd.digest().toHex();
    if (capture.certExtensions) {
      cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
    } else {
      cert.extensions = [];
    }
    cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
    return cert;
  };
  pki.certificateExtensionsFromAsn1 = function(exts) {
    var rval = [];
    for (var i = 0; i < exts.value.length; ++i) {
      var extseq = exts.value[i];
      for (var ei = 0; ei < extseq.value.length; ++ei) {
        rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
      }
    }
    return rval;
  };
  pki.certificateExtensionFromAsn1 = function(ext) {
    var e = {};
    e.id = asn1.derToOid(ext.value[0].value);
    e.critical = false;
    if (ext.value[1].type === asn1.Type.BOOLEAN) {
      e.critical = ext.value[1].value.charCodeAt(0) !== 0;
      e.value = ext.value[2].value;
    } else {
      e.value = ext.value[1].value;
    }
    if (e.id in oids) {
      e.name = oids[e.id];
      if (e.name === "keyUsage") {
        var ev = asn1.fromDer(e.value);
        var b2 = 0;
        var b3 = 0;
        if (ev.value.length > 1) {
          b2 = ev.value.charCodeAt(1);
          b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
        }
        e.digitalSignature = (b2 & 128) === 128;
        e.nonRepudiation = (b2 & 64) === 64;
        e.keyEncipherment = (b2 & 32) === 32;
        e.dataEncipherment = (b2 & 16) === 16;
        e.keyAgreement = (b2 & 8) === 8;
        e.keyCertSign = (b2 & 4) === 4;
        e.cRLSign = (b2 & 2) === 2;
        e.encipherOnly = (b2 & 1) === 1;
        e.decipherOnly = (b3 & 128) === 128;
      } else if (e.name === "basicConstraints") {
        var ev = asn1.fromDer(e.value);
        if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
          e.cA = ev.value[0].value.charCodeAt(0) !== 0;
        } else {
          e.cA = false;
        }
        var value = null;
        if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
          value = ev.value[0].value;
        } else if (ev.value.length > 1) {
          value = ev.value[1].value;
        }
        if (value !== null) {
          e.pathLenConstraint = asn1.derToInteger(value);
        }
      } else if (e.name === "extKeyUsage") {
        var ev = asn1.fromDer(e.value);
        for (var vi = 0; vi < ev.value.length; ++vi) {
          var oid = asn1.derToOid(ev.value[vi].value);
          if (oid in oids) {
            e[oids[oid]] = true;
          } else {
            e[oid] = true;
          }
        }
      } else if (e.name === "nsCertType") {
        var ev = asn1.fromDer(e.value);
        var b2 = 0;
        if (ev.value.length > 1) {
          b2 = ev.value.charCodeAt(1);
        }
        e.client = (b2 & 128) === 128;
        e.server = (b2 & 64) === 64;
        e.email = (b2 & 32) === 32;
        e.objsign = (b2 & 16) === 16;
        e.reserved = (b2 & 8) === 8;
        e.sslCA = (b2 & 4) === 4;
        e.emailCA = (b2 & 2) === 2;
        e.objCA = (b2 & 1) === 1;
      } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
        e.altNames = [];
        var gn;
        var ev = asn1.fromDer(e.value);
        for (var n = 0; n < ev.value.length; ++n) {
          gn = ev.value[n];
          var altName = {
            type: gn.type,
            value: gn.value
          };
          e.altNames.push(altName);
          switch (gn.type) {
            case 1:
            case 2:
            case 6:
              break;
            case 7:
              altName.ip = forge.util.bytesToIP(gn.value);
              break;
            case 8:
              altName.oid = asn1.derToOid(gn.value);
              break;
            default:
          }
        }
      } else if (e.name === "subjectKeyIdentifier") {
        var ev = asn1.fromDer(e.value);
        e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
      }
    }
    return e;
  };
  pki.certificationRequestFromAsn1 = function(obj, computeHash) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
      var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
      error.errors = errors;
      throw error;
    }
    var oid = asn1.derToOid(capture.publicKeyOid);
    if (oid !== pki.oids.rsaEncryption) {
      throw new Error("Cannot read public key. OID is not RSA.");
    }
    var csr = pki.createCertificationRequest();
    csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
    csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
    csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, true);
    csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
    csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
    csr.signature = capture.csrSignature;
    csr.certificationRequestInfo = capture.certificationRequestInfo;
    if (computeHash) {
      csr.md = null;
      if (csr.signatureOid in oids) {
        var oid = oids[csr.signatureOid];
        switch (oid) {
          case "sha1WithRSAEncryption":
            csr.md = forge.md.sha1.create();
            break;
          case "md5WithRSAEncryption":
            csr.md = forge.md.md5.create();
            break;
          case "sha256WithRSAEncryption":
            csr.md = forge.md.sha256.create();
            break;
          case "sha384WithRSAEncryption":
            csr.md = forge.md.sha384.create();
            break;
          case "sha512WithRSAEncryption":
            csr.md = forge.md.sha512.create();
            break;
          case "RSASSA-PSS":
            csr.md = forge.md.sha256.create();
            break;
        }
      }
      if (csr.md === null) {
        var error = new Error("Could not compute certification request digest. Unknown signature OID.");
        error.signatureOid = csr.signatureOid;
        throw error;
      }
      var bytes = asn1.toDer(csr.certificationRequestInfo);
      csr.md.update(bytes.getBytes());
    }
    var smd = forge.md.sha1.create();
    csr.subject.getField = function(sn) {
      return _getAttribute(csr.subject, sn);
    };
    csr.subject.addField = function(attr) {
      _fillMissingFields([attr]);
      csr.subject.attributes.push(attr);
    };
    csr.subject.attributes = pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd);
    csr.subject.hash = smd.digest().toHex();
    csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
    csr.getAttribute = function(sn) {
      return _getAttribute(csr, sn);
    };
    csr.addAttribute = function(attr) {
      _fillMissingFields([attr]);
      csr.attributes.push(attr);
    };
    csr.attributes = pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []);
    return csr;
  };
  pki.createCertificationRequest = function() {
    var csr = {};
    csr.version = 0;
    csr.signatureOid = null;
    csr.signature = null;
    csr.siginfo = {};
    csr.siginfo.algorithmOid = null;
    csr.subject = {};
    csr.subject.getField = function(sn) {
      return _getAttribute(csr.subject, sn);
    };
    csr.subject.addField = function(attr) {
      _fillMissingFields([attr]);
      csr.subject.attributes.push(attr);
    };
    csr.subject.attributes = [];
    csr.subject.hash = null;
    csr.publicKey = null;
    csr.attributes = [];
    csr.getAttribute = function(sn) {
      return _getAttribute(csr, sn);
    };
    csr.addAttribute = function(attr) {
      _fillMissingFields([attr]);
      csr.attributes.push(attr);
    };
    csr.md = null;
    csr.setSubject = function(attrs) {
      _fillMissingFields(attrs);
      csr.subject.attributes = attrs;
      csr.subject.hash = null;
    };
    csr.setAttributes = function(attrs) {
      _fillMissingFields(attrs);
      csr.attributes = attrs;
    };
    csr.sign = function(key, md) {
      csr.md = md || forge.md.sha1.create();
      var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
      if (!algorithmOid) {
        var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
        error.algorithm = csr.md.algorithm;
        throw error;
      }
      csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
      csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
      var bytes = asn1.toDer(csr.certificationRequestInfo);
      csr.md.update(bytes.getBytes());
      csr.signature = key.sign(csr.md);
    };
    csr.verify = function() {
      var rval = false;
      var md = csr.md;
      if (md === null) {
        if (csr.signatureOid in oids) {
          var oid = oids[csr.signatureOid];
          switch (oid) {
            case "sha1WithRSAEncryption":
              md = forge.md.sha1.create();
              break;
            case "md5WithRSAEncryption":
              md = forge.md.md5.create();
              break;
            case "sha256WithRSAEncryption":
              md = forge.md.sha256.create();
              break;
            case "sha384WithRSAEncryption":
              md = forge.md.sha384.create();
              break;
            case "sha512WithRSAEncryption":
              md = forge.md.sha512.create();
              break;
            case "RSASSA-PSS":
              md = forge.md.sha256.create();
              break;
          }
        }
        if (md === null) {
          var error = new Error("Could not compute certification request digest. Unknown signature OID.");
          error.signatureOid = csr.signatureOid;
          throw error;
        }
        var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
        var bytes = asn1.toDer(cri);
        md.update(bytes.getBytes());
      }
      if (md !== null) {
        var scheme;
        switch (csr.signatureOid) {
          case oids.sha1WithRSAEncryption:
            break;
          case oids["RSASSA-PSS"]:
            var hash, mgf;
            hash = oids[csr.signatureParameters.mgf.hash.algorithmOid];
            if (hash === void 0 || forge.md[hash] === void 0) {
              var error = new Error("Unsupported MGF hash function.");
              error.oid = csr.signatureParameters.mgf.hash.algorithmOid;
              error.name = hash;
              throw error;
            }
            mgf = oids[csr.signatureParameters.mgf.algorithmOid];
            if (mgf === void 0 || forge.mgf[mgf] === void 0) {
              var error = new Error("Unsupported MGF function.");
              error.oid = csr.signatureParameters.mgf.algorithmOid;
              error.name = mgf;
              throw error;
            }
            mgf = forge.mgf[mgf].create(forge.md[hash].create());
            hash = oids[csr.signatureParameters.hash.algorithmOid];
            if (hash === void 0 || forge.md[hash] === void 0) {
              var error = new Error("Unsupported RSASSA-PSS hash function.");
              error.oid = csr.signatureParameters.hash.algorithmOid;
              error.name = hash;
              throw error;
            }
            scheme = forge.pss.create(forge.md[hash].create(), mgf, csr.signatureParameters.saltLength);
            break;
        }
        rval = csr.publicKey.verify(md.digest().getBytes(), csr.signature, scheme);
      }
      return rval;
    };
    return csr;
  };
  function _dnToAsn1(obj) {
    var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var attr, set;
    var attrs = obj.attributes;
    for (var i = 0; i < attrs.length; ++i) {
      attr = attrs[i];
      var value = attr.value;
      var valueTagClass = asn1.Type.PRINTABLESTRING;
      if ("valueTagClass" in attr) {
        valueTagClass = attr.valueTagClass;
        if (valueTagClass === asn1.Type.UTF8) {
          value = forge.util.encodeUtf8(value);
        }
      }
      set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
        ])
      ]);
      rval.value.push(set);
    }
    return rval;
  }
  function _fillMissingFields(attrs) {
    var attr;
    for (var i = 0; i < attrs.length; ++i) {
      attr = attrs[i];
      if (typeof attr.name === "undefined") {
        if (attr.type && attr.type in pki.oids) {
          attr.name = pki.oids[attr.type];
        } else if (attr.shortName && attr.shortName in _shortNames) {
          attr.name = pki.oids[_shortNames[attr.shortName]];
        }
      }
      if (typeof attr.type === "undefined") {
        if (attr.name && attr.name in pki.oids) {
          attr.type = pki.oids[attr.name];
        } else {
          var error = new Error("Attribute type not specified.");
          error.attribute = attr;
          throw error;
        }
      }
      if (typeof attr.shortName === "undefined") {
        if (attr.name && attr.name in _shortNames) {
          attr.shortName = _shortNames[attr.name];
        }
      }
      if (attr.type === oids.extensionRequest) {
        attr.valueConstructed = true;
        attr.valueTagClass = asn1.Type.SEQUENCE;
        if (!attr.value && attr.extensions) {
          attr.value = [];
          for (var ei = 0; ei < attr.extensions.length; ++ei) {
            attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));
          }
        }
      }
      if (typeof attr.value === "undefined") {
        var error = new Error("Attribute value not specified.");
        error.attribute = attr;
        throw error;
      }
    }
  }
  function _fillMissingExtensionFields(e, options) {
    options = options || {};
    if (typeof e.name === "undefined") {
      if (e.id && e.id in pki.oids) {
        e.name = pki.oids[e.id];
      }
    }
    if (typeof e.id === "undefined") {
      if (e.name && e.name in pki.oids) {
        e.id = pki.oids[e.name];
      } else {
        var error = new Error("Extension ID not specified.");
        error.extension = e;
        throw error;
      }
    }
    if (typeof e.value !== "undefined") {
      return e;
    }
    if (e.name === "keyUsage") {
      var unused = 0;
      var b2 = 0;
      var b3 = 0;
      if (e.digitalSignature) {
        b2 |= 128;
        unused = 7;
      }
      if (e.nonRepudiation) {
        b2 |= 64;
        unused = 6;
      }
      if (e.keyEncipherment) {
        b2 |= 32;
        unused = 5;
      }
      if (e.dataEncipherment) {
        b2 |= 16;
        unused = 4;
      }
      if (e.keyAgreement) {
        b2 |= 8;
        unused = 3;
      }
      if (e.keyCertSign) {
        b2 |= 4;
        unused = 2;
      }
      if (e.cRLSign) {
        b2 |= 2;
        unused = 1;
      }
      if (e.encipherOnly) {
        b2 |= 1;
        unused = 0;
      }
      if (e.decipherOnly) {
        b3 |= 128;
        unused = 7;
      }
      var value = String.fromCharCode(unused);
      if (b3 !== 0) {
        value += String.fromCharCode(b2) + String.fromCharCode(b3);
      } else if (b2 !== 0) {
        value += String.fromCharCode(b2);
      }
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
    } else if (e.name === "basicConstraints") {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      if (e.cA) {
        e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255)));
      }
      if ("pathLenConstraint" in e) {
        e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(e.pathLenConstraint).getBytes()));
      }
    } else if (e.name === "extKeyUsage") {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var seq = e.value.value;
      for (var key in e) {
        if (e[key] !== true) {
          continue;
        }
        if (key in oids) {
          seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[key]).getBytes()));
        } else if (key.indexOf(".") !== -1) {
          seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(key).getBytes()));
        }
      }
    } else if (e.name === "nsCertType") {
      var unused = 0;
      var b2 = 0;
      if (e.client) {
        b2 |= 128;
        unused = 7;
      }
      if (e.server) {
        b2 |= 64;
        unused = 6;
      }
      if (e.email) {
        b2 |= 32;
        unused = 5;
      }
      if (e.objsign) {
        b2 |= 16;
        unused = 4;
      }
      if (e.reserved) {
        b2 |= 8;
        unused = 3;
      }
      if (e.sslCA) {
        b2 |= 4;
        unused = 2;
      }
      if (e.emailCA) {
        b2 |= 2;
        unused = 1;
      }
      if (e.objCA) {
        b2 |= 1;
        unused = 0;
      }
      var value = String.fromCharCode(unused);
      if (b2 !== 0) {
        value += String.fromCharCode(b2);
      }
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
    } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var altName;
      for (var n = 0; n < e.altNames.length; ++n) {
        altName = e.altNames[n];
        var value = altName.value;
        if (altName.type === 7 && altName.ip) {
          value = forge.util.bytesFromIP(altName.ip);
          if (value === null) {
            var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
            error.extension = e;
            throw error;
          }
        } else if (altName.type === 8) {
          if (altName.oid) {
            value = asn1.oidToDer(asn1.oidToDer(altName.oid));
          } else {
            value = asn1.oidToDer(value);
          }
        }
        e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
      }
    } else if (e.name === "nsComment" && options.cert) {
      if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
        throw new Error('Invalid "nsComment" content.');
      }
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, false, e.comment);
    } else if (e.name === "subjectKeyIdentifier" && options.cert) {
      var ski = options.cert.generateSubjectKeyIdentifier();
      e.subjectKeyIdentifier = ski.toHex();
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());
    } else if (e.name === "authorityKeyIdentifier" && options.cert) {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var seq = e.value.value;
      if (e.keyIdentifier) {
        var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
        seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));
      }
      if (e.authorityCertIssuer) {
        var authorityCertIssuer = [
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
            _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
          ])
        ];
        seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));
      }
      if (e.serialNumber) {
        var serialNumber = forge.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
        seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));
      }
    } else if (e.name === "cRLDistributionPoints") {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var seq = e.value.value;
      var subSeq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var fullNameGeneralNames = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      var altName;
      for (var n = 0; n < e.altNames.length; ++n) {
        altName = e.altNames[n];
        var value = altName.value;
        if (altName.type === 7 && altName.ip) {
          value = forge.util.bytesFromIP(altName.ip);
          if (value === null) {
            var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
            error.extension = e;
            throw error;
          }
        } else if (altName.type === 8) {
          if (altName.oid) {
            value = asn1.oidToDer(asn1.oidToDer(altName.oid));
          } else {
            value = asn1.oidToDer(value);
          }
        }
        fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
      }
      subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));
      seq.push(subSeq);
    }
    if (typeof e.value === "undefined") {
      var error = new Error("Extension value not specified.");
      error.extension = e;
      throw error;
    }
    return e;
  }
  function _signatureParametersToAsn1(oid, params) {
    switch (oid) {
      case oids["RSASSA-PSS"]:
        var parts = [];
        if (params.hash.algorithmOid !== void 0) {
          parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.hash.algorithmOid).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ])
          ]));
        }
        if (params.mgf.algorithmOid !== void 0) {
          parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.algorithmOid).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ])
            ])
          ]));
        }
        if (params.saltLength !== void 0) {
          parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(params.saltLength).getBytes())
          ]));
        }
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
      default:
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
    }
  }
  function _CRIAttributesToAsn1(csr) {
    var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
    if (csr.attributes.length === 0) {
      return rval;
    }
    var attrs = csr.attributes;
    for (var i = 0; i < attrs.length; ++i) {
      var attr = attrs[i];
      var value = attr.value;
      var valueTagClass = asn1.Type.UTF8;
      if ("valueTagClass" in attr) {
        valueTagClass = attr.valueTagClass;
      }
      if (valueTagClass === asn1.Type.UTF8) {
        value = forge.util.encodeUtf8(value);
      }
      var valueConstructed = false;
      if ("valueConstructed" in attr) {
        valueConstructed = attr.valueConstructed;
      }
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)
        ])
      ]);
      rval.value.push(seq);
    }
    return rval;
  }
  var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
  var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
  function _dateToAsn1(date) {
    if (date >= jan_1_1950 && date < jan_1_2050) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
    } else {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
    }
  }
  pki.getTBSCertificate = function(cert) {
    var notBefore = _dateToAsn1(cert.validity.notBefore);
    var notAfter = _dateToAsn1(cert.validity.notAfter);
    var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(cert.version).getBytes())
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(cert.serialNumber)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),
        _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)
      ]),
      _dnToAsn1(cert.issuer),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        notBefore,
        notAfter
      ]),
      _dnToAsn1(cert.subject),
      pki.publicKeyToAsn1(cert.publicKey)
    ]);
    if (cert.issuer.uniqueId) {
      tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.issuer.uniqueId)
      ]));
    }
    if (cert.subject.uniqueId) {
      tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.subject.uniqueId)
      ]));
    }
    if (cert.extensions.length > 0) {
      tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
    }
    return tbs;
  };
  pki.getCertificationRequestInfo = function(csr) {
    var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(csr.version).getBytes()),
      _dnToAsn1(csr.subject),
      pki.publicKeyToAsn1(csr.publicKey),
      _CRIAttributesToAsn1(csr)
    ]);
    return cri;
  };
  pki.distinguishedNameToAsn1 = function(dn) {
    return _dnToAsn1(dn);
  };
  pki.certificateToAsn1 = function(cert) {
    var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      tbsCertificate,
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.signatureOid).getBytes()),
        _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.signature)
    ]);
  };
  pki.certificateExtensionsToAsn1 = function(exts) {
    var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
    var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    rval.value.push(seq);
    for (var i = 0; i < exts.length; ++i) {
      seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
    }
    return rval;
  };
  pki.certificateExtensionToAsn1 = function(ext) {
    var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ext.id).getBytes()));
    if (ext.critical) {
      extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255)));
    }
    var value = ext.value;
    if (typeof ext.value !== "string") {
      value = asn1.toDer(value).getBytes();
    }
    extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));
    return extseq;
  };
  pki.certificationRequestToAsn1 = function(csr) {
    var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      cri,
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(csr.signatureOid).getBytes()),
        _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + csr.signature)
    ]);
  };
  pki.createCaStore = function(certs) {
    var caStore = {
      certs: {}
    };
    caStore.getIssuer = function(cert2) {
      var rval = getBySubject(cert2.issuer);
      return rval;
    };
    caStore.addCertificate = function(cert2) {
      if (typeof cert2 === "string") {
        cert2 = forge.pki.certificateFromPem(cert2);
      }
      ensureSubjectHasHash(cert2.subject);
      if (!caStore.hasCertificate(cert2)) {
        if (cert2.subject.hash in caStore.certs) {
          var tmp = caStore.certs[cert2.subject.hash];
          if (!forge.util.isArray(tmp)) {
            tmp = [tmp];
          }
          tmp.push(cert2);
          caStore.certs[cert2.subject.hash] = tmp;
        } else {
          caStore.certs[cert2.subject.hash] = cert2;
        }
      }
    };
    caStore.hasCertificate = function(cert2) {
      if (typeof cert2 === "string") {
        cert2 = forge.pki.certificateFromPem(cert2);
      }
      var match = getBySubject(cert2.subject);
      if (!match) {
        return false;
      }
      if (!forge.util.isArray(match)) {
        match = [match];
      }
      var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
      for (var i2 = 0; i2 < match.length; ++i2) {
        var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
        if (der1 === der2) {
          return true;
        }
      }
      return false;
    };
    caStore.listAllCertificates = function() {
      var certList = [];
      for (var hash in caStore.certs) {
        if (caStore.certs.hasOwnProperty(hash)) {
          var value = caStore.certs[hash];
          if (!forge.util.isArray(value)) {
            certList.push(value);
          } else {
            for (var i2 = 0; i2 < value.length; ++i2) {
              certList.push(value[i2]);
            }
          }
        }
      }
      return certList;
    };
    caStore.removeCertificate = function(cert2) {
      var result;
      if (typeof cert2 === "string") {
        cert2 = forge.pki.certificateFromPem(cert2);
      }
      ensureSubjectHasHash(cert2.subject);
      if (!caStore.hasCertificate(cert2)) {
        return null;
      }
      var match = getBySubject(cert2.subject);
      if (!forge.util.isArray(match)) {
        result = caStore.certs[cert2.subject.hash];
        delete caStore.certs[cert2.subject.hash];
        return result;
      }
      var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
      for (var i2 = 0; i2 < match.length; ++i2) {
        var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
        if (der1 === der2) {
          result = match[i2];
          match.splice(i2, 1);
        }
      }
      if (match.length === 0) {
        delete caStore.certs[cert2.subject.hash];
      }
      return result;
    };
    function getBySubject(subject) {
      ensureSubjectHasHash(subject);
      return caStore.certs[subject.hash] || null;
    }
    function ensureSubjectHasHash(subject) {
      if (!subject.hash) {
        var md = forge.md.sha1.create();
        subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
        subject.hash = md.digest().toHex();
      }
    }
    if (certs) {
      for (var i = 0; i < certs.length; ++i) {
        var cert = certs[i];
        caStore.addCertificate(cert);
      }
    }
    return caStore;
  };
  pki.certificateError = {
    bad_certificate: "forge.pki.BadCertificate",
    unsupported_certificate: "forge.pki.UnsupportedCertificate",
    certificate_revoked: "forge.pki.CertificateRevoked",
    certificate_expired: "forge.pki.CertificateExpired",
    certificate_unknown: "forge.pki.CertificateUnknown",
    unknown_ca: "forge.pki.UnknownCertificateAuthority"
  };
  pki.verifyCertificateChain = function(caStore, chain, options) {
    if (typeof options === "function") {
      options = {verify: options};
    }
    options = options || {};
    chain = chain.slice(0);
    var certs = chain.slice(0);
    var validityCheckDate = options.validityCheckDate;
    if (typeof validityCheckDate === "undefined") {
      validityCheckDate = new Date();
    }
    var first = true;
    var error = null;
    var depth = 0;
    do {
      var cert = chain.shift();
      var parent = null;
      var selfSigned = false;
      if (validityCheckDate) {
        if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
          error = {
            message: "Certificate is not valid yet or has expired.",
            error: pki.certificateError.certificate_expired,
            notBefore: cert.validity.notBefore,
            notAfter: cert.validity.notAfter,
            now: validityCheckDate
          };
        }
      }
      if (error === null) {
        parent = chain[0] || caStore.getIssuer(cert);
        if (parent === null) {
          if (cert.isIssuer(cert)) {
            selfSigned = true;
            parent = cert;
          }
        }
        if (parent) {
          var parents = parent;
          if (!forge.util.isArray(parents)) {
            parents = [parents];
          }
          var verified = false;
          while (!verified && parents.length > 0) {
            parent = parents.shift();
            try {
              verified = parent.verify(cert);
            } catch (ex) {
            }
          }
          if (!verified) {
            error = {
              message: "Certificate signature is invalid.",
              error: pki.certificateError.bad_certificate
            };
          }
        }
        if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
          error = {
            message: "Certificate is not trusted.",
            error: pki.certificateError.unknown_ca
          };
        }
      }
      if (error === null && parent && !cert.isIssuer(parent)) {
        error = {
          message: "Certificate issuer is invalid.",
          error: pki.certificateError.bad_certificate
        };
      }
      if (error === null) {
        var se = {
          keyUsage: true,
          basicConstraints: true
        };
        for (var i = 0; error === null && i < cert.extensions.length; ++i) {
          var ext = cert.extensions[i];
          if (ext.critical && !(ext.name in se)) {
            error = {
              message: "Certificate has an unsupported critical extension.",
              error: pki.certificateError.unsupported_certificate
            };
          }
        }
      }
      if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {
        var bcExt = cert.getExtension("basicConstraints");
        var keyUsageExt = cert.getExtension("keyUsage");
        if (keyUsageExt !== null) {
          if (!keyUsageExt.keyCertSign || bcExt === null) {
            error = {
              message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
              error: pki.certificateError.bad_certificate
            };
          }
        }
        if (error === null && bcExt !== null && !bcExt.cA) {
          error = {
            message: "Certificate basicConstraints indicates the certificate is not a CA.",
            error: pki.certificateError.bad_certificate
          };
        }
        if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
          var pathLen = depth - 1;
          if (pathLen > bcExt.pathLenConstraint) {
            error = {
              message: "Certificate basicConstraints pathLenConstraint violated.",
              error: pki.certificateError.bad_certificate
            };
          }
        }
      }
      var vfd = error === null ? true : error.error;
      var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
      if (ret === true) {
        error = null;
      } else {
        if (vfd === true) {
          error = {
            message: "The application rejected the certificate.",
            error: pki.certificateError.bad_certificate
          };
        }
        if (ret || ret === 0) {
          if (typeof ret === "object" && !forge.util.isArray(ret)) {
            if (ret.message) {
              error.message = ret.message;
            }
            if (ret.error) {
              error.error = ret.error;
            }
          } else if (typeof ret === "string") {
            error.error = ret;
          }
        }
        throw error;
      }
      first = false;
      ++depth;
    } while (chain.length > 0);
    return true;
  };
});

// node_modules/node-forge/lib/pkcs12.js
var require_pkcs12 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_asn1();
  require_hmac();
  require_oids();
  require_pkcs7asn1();
  require_pbe();
  require_random();
  require_rsa();
  require_sha1();
  require_util();
  require_x509();
  var asn1 = forge.asn1;
  var pki = forge.pki;
  var p12 = module2.exports = forge.pkcs12 = forge.pkcs12 || {};
  var contentInfoValidator = {
    name: "ContentInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "ContentInfo.contentType",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: "contentType"
    }, {
      name: "ContentInfo.content",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      constructed: true,
      captureAsn1: "content"
    }]
  };
  var pfxValidator = {
    name: "PFX",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [
      {
        name: "PFX.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      },
      contentInfoValidator,
      {
        name: "PFX.macData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        optional: true,
        captureAsn1: "mac",
        value: [{
          name: "PFX.macData.mac",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PFX.macData.mac.digestAlgorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "PFX.macData.mac.digestAlgorithm.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "macAlgorithm"
            }, {
              name: "PFX.macData.mac.digestAlgorithm.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              captureAsn1: "macAlgorithmParameters"
            }]
          }, {
            name: "PFX.macData.mac.digest",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "macDigest"
          }]
        }, {
          name: "PFX.macData.macSalt",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "macSalt"
        }, {
          name: "PFX.macData.iterations",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          optional: true,
          capture: "macIterations"
        }]
      }
    ]
  };
  var safeBagValidator = {
    name: "SafeBag",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "SafeBag.bagId",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: "bagId"
    }, {
      name: "SafeBag.bagValue",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      constructed: true,
      captureAsn1: "bagValue"
    }, {
      name: "SafeBag.bagAttributes",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SET,
      constructed: true,
      optional: true,
      capture: "bagAttributes"
    }]
  };
  var attributeValidator = {
    name: "Attribute",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "Attribute.attrId",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: "oid"
    }, {
      name: "Attribute.attrValues",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SET,
      constructed: true,
      capture: "values"
    }]
  };
  var certBagValidator = {
    name: "CertBag",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "CertBag.certId",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: "certId"
    }, {
      name: "CertBag.certValue",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      constructed: true,
      value: [{
        name: "CertBag.certValue[0]",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Class.OCTETSTRING,
        constructed: false,
        capture: "cert"
      }]
    }]
  };
  function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
    var result = [];
    for (var i = 0; i < safeContents.length; i++) {
      for (var j = 0; j < safeContents[i].safeBags.length; j++) {
        var bag = safeContents[i].safeBags[j];
        if (bagType !== void 0 && bag.type !== bagType) {
          continue;
        }
        if (attrName === null) {
          result.push(bag);
          continue;
        }
        if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {
          result.push(bag);
        }
      }
    }
    return result;
  }
  p12.pkcs12FromAsn1 = function(obj, strict, password) {
    if (typeof strict === "string") {
      password = strict;
      strict = true;
    } else if (strict === void 0) {
      strict = true;
    }
    var capture = {};
    var errors = [];
    if (!asn1.validate(obj, pfxValidator, capture, errors)) {
      var error = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
      error.errors = error;
      throw error;
    }
    var pfx = {
      version: capture.version.charCodeAt(0),
      safeContents: [],
      getBags: function(filter) {
        var rval = {};
        var localKeyId;
        if ("localKeyId" in filter) {
          localKeyId = filter.localKeyId;
        } else if ("localKeyIdHex" in filter) {
          localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);
        }
        if (localKeyId === void 0 && !("friendlyName" in filter) && "bagType" in filter) {
          rval[filter.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter.bagType);
        }
        if (localKeyId !== void 0) {
          rval.localKeyId = _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, filter.bagType);
        }
        if ("friendlyName" in filter) {
          rval.friendlyName = _getBagsByAttribute(pfx.safeContents, "friendlyName", filter.friendlyName, filter.bagType);
        }
        return rval;
      },
      getBagsByFriendlyName: function(friendlyName, bagType) {
        return _getBagsByAttribute(pfx.safeContents, "friendlyName", friendlyName, bagType);
      },
      getBagsByLocalKeyId: function(localKeyId, bagType) {
        return _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, bagType);
      }
    };
    if (capture.version.charCodeAt(0) !== 3) {
      var error = new Error("PKCS#12 PFX of version other than 3 not supported.");
      error.version = capture.version.charCodeAt(0);
      throw error;
    }
    if (asn1.derToOid(capture.contentType) !== pki.oids.data) {
      var error = new Error("Only PKCS#12 PFX in password integrity mode supported.");
      error.oid = asn1.derToOid(capture.contentType);
      throw error;
    }
    var data = capture.content.value[0];
    if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
      throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
    }
    data = _decodePkcs7Data(data);
    if (capture.mac) {
      var md = null;
      var macKeyBytes = 0;
      var macAlgorithm = asn1.derToOid(capture.macAlgorithm);
      switch (macAlgorithm) {
        case pki.oids.sha1:
          md = forge.md.sha1.create();
          macKeyBytes = 20;
          break;
        case pki.oids.sha256:
          md = forge.md.sha256.create();
          macKeyBytes = 32;
          break;
        case pki.oids.sha384:
          md = forge.md.sha384.create();
          macKeyBytes = 48;
          break;
        case pki.oids.sha512:
          md = forge.md.sha512.create();
          macKeyBytes = 64;
          break;
        case pki.oids.md5:
          md = forge.md.md5.create();
          macKeyBytes = 16;
          break;
      }
      if (md === null) {
        throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
      }
      var macSalt = new forge.util.ByteBuffer(capture.macSalt);
      var macIterations = "macIterations" in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1;
      var macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md);
      var mac = forge.hmac.create();
      mac.start(md, macKey);
      mac.update(data.value);
      var macValue = mac.getMac();
      if (macValue.getBytes() !== capture.macDigest) {
        throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
      }
    }
    _decodeAuthenticatedSafe(pfx, data.value, strict, password);
    return pfx;
  };
  function _decodePkcs7Data(data) {
    if (data.composed || data.constructed) {
      var value = forge.util.createBuffer();
      for (var i = 0; i < data.value.length; ++i) {
        value.putBytes(data.value[i].value);
      }
      data.composed = data.constructed = false;
      data.value = value.getBytes();
    }
    return data;
  }
  function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
    authSafe = asn1.fromDer(authSafe, strict);
    if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {
      throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
    }
    for (var i = 0; i < authSafe.value.length; i++) {
      var contentInfo = authSafe.value[i];
      var capture = {};
      var errors = [];
      if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
        var error = new Error("Cannot read ContentInfo.");
        error.errors = errors;
        throw error;
      }
      var obj = {
        encrypted: false
      };
      var safeContents = null;
      var data = capture.content.value[0];
      switch (asn1.derToOid(capture.contentType)) {
        case pki.oids.data:
          if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
            throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
          }
          safeContents = _decodePkcs7Data(data).value;
          break;
        case pki.oids.encryptedData:
          safeContents = _decryptSafeContents(data, password);
          obj.encrypted = true;
          break;
        default:
          var error = new Error("Unsupported PKCS#12 contentType.");
          error.contentType = asn1.derToOid(capture.contentType);
          throw error;
      }
      obj.safeBags = _decodeSafeContents(safeContents, strict, password);
      pfx.safeContents.push(obj);
    }
  }
  function _decryptSafeContents(data, password) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {
      var error = new Error("Cannot read EncryptedContentInfo.");
      error.errors = errors;
      throw error;
    }
    var oid = asn1.derToOid(capture.contentType);
    if (oid !== pki.oids.data) {
      var error = new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.");
      error.oid = oid;
      throw error;
    }
    oid = asn1.derToOid(capture.encAlgorithm);
    var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);
    var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
    var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);
    cipher.update(encrypted);
    if (!cipher.finish()) {
      throw new Error("Failed to decrypt PKCS#12 SafeContents.");
    }
    return cipher.output.getBytes();
  }
  function _decodeSafeContents(safeContents, strict, password) {
    if (!strict && safeContents.length === 0) {
      return [];
    }
    safeContents = asn1.fromDer(safeContents, strict);
    if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {
      throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.");
    }
    var res = [];
    for (var i = 0; i < safeContents.value.length; i++) {
      var safeBag = safeContents.value[i];
      var capture = {};
      var errors = [];
      if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
        var error = new Error("Cannot read SafeBag.");
        error.errors = errors;
        throw error;
      }
      var bag = {
        type: asn1.derToOid(capture.bagId),
        attributes: _decodeBagAttributes(capture.bagAttributes)
      };
      res.push(bag);
      var validator, decoder;
      var bagAsn1 = capture.bagValue.value[0];
      switch (bag.type) {
        case pki.oids.pkcs8ShroudedKeyBag:
          bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);
          if (bagAsn1 === null) {
            throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?");
          }
        case pki.oids.keyBag:
          try {
            bag.key = pki.privateKeyFromAsn1(bagAsn1);
          } catch (e) {
            bag.key = null;
            bag.asn1 = bagAsn1;
          }
          continue;
        case pki.oids.certBag:
          validator = certBagValidator;
          decoder = function() {
            if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {
              var error2 = new Error("Unsupported certificate type, only X.509 supported.");
              error2.oid = asn1.derToOid(capture.certId);
              throw error2;
            }
            var certAsn1 = asn1.fromDer(capture.cert, strict);
            try {
              bag.cert = pki.certificateFromAsn1(certAsn1, true);
            } catch (e) {
              bag.cert = null;
              bag.asn1 = certAsn1;
            }
          };
          break;
        default:
          var error = new Error("Unsupported PKCS#12 SafeBag type.");
          error.oid = bag.type;
          throw error;
      }
      if (validator !== void 0 && !asn1.validate(bagAsn1, validator, capture, errors)) {
        var error = new Error("Cannot read PKCS#12 " + validator.name);
        error.errors = errors;
        throw error;
      }
      decoder();
    }
    return res;
  }
  function _decodeBagAttributes(attributes) {
    var decodedAttrs = {};
    if (attributes !== void 0) {
      for (var i = 0; i < attributes.length; ++i) {
        var capture = {};
        var errors = [];
        if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {
          var error = new Error("Cannot read PKCS#12 BagAttribute.");
          error.errors = errors;
          throw error;
        }
        var oid = asn1.derToOid(capture.oid);
        if (pki.oids[oid] === void 0) {
          continue;
        }
        decodedAttrs[pki.oids[oid]] = [];
        for (var j = 0; j < capture.values.length; ++j) {
          decodedAttrs[pki.oids[oid]].push(capture.values[j].value);
        }
      }
    }
    return decodedAttrs;
  }
  p12.toPkcs12Asn1 = function(key, cert, password, options) {
    options = options || {};
    options.saltSize = options.saltSize || 8;
    options.count = options.count || 2048;
    options.algorithm = options.algorithm || options.encAlgorithm || "aes128";
    if (!("useMac" in options)) {
      options.useMac = true;
    }
    if (!("localKeyId" in options)) {
      options.localKeyId = null;
    }
    if (!("generateLocalKeyId" in options)) {
      options.generateLocalKeyId = true;
    }
    var localKeyId = options.localKeyId;
    var bagAttrs;
    if (localKeyId !== null) {
      localKeyId = forge.util.hexToBytes(localKeyId);
    } else if (options.generateLocalKeyId) {
      if (cert) {
        var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;
        if (typeof pairedCert === "string") {
          pairedCert = pki.certificateFromPem(pairedCert);
        }
        var sha1 = forge.md.sha1.create();
        sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());
        localKeyId = sha1.digest().getBytes();
      } else {
        localKeyId = forge.random.getBytes(20);
      }
    }
    var attrs = [];
    if (localKeyId !== null) {
      attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.localKeyId).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, localKeyId)
        ])
      ]));
    }
    if ("friendlyName" in options) {
      attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.friendlyName).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false, options.friendlyName)
        ])
      ]));
    }
    if (attrs.length > 0) {
      bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
    }
    var contents = [];
    var chain = [];
    if (cert !== null) {
      if (forge.util.isArray(cert)) {
        chain = cert;
      } else {
        chain = [cert];
      }
    }
    var certSafeBags = [];
    for (var i = 0; i < chain.length; ++i) {
      cert = chain[i];
      if (typeof cert === "string") {
        cert = pki.certificateFromPem(cert);
      }
      var certBagAttrs = i === 0 ? bagAttrs : void 0;
      var certAsn1 = pki.certificateToAsn1(cert);
      var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.certBag).getBytes()),
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.x509Certificate).getBytes()),
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certAsn1).getBytes())
            ])
          ])
        ]),
        certBagAttrs
      ]);
      certSafeBags.push(certSafeBag);
    }
    if (certSafeBags.length > 0) {
      var certSafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);
      var certCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()),
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certSafeContents).getBytes())
        ])
      ]);
      contents.push(certCI);
    }
    var keyBag = null;
    if (key !== null) {
      var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));
      if (password === null) {
        keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.keyBag).getBytes()),
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            pkAsn1
          ]),
          bagAttrs
        ]);
      } else {
        keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            pki.encryptPrivateKeyInfo(pkAsn1, password, options)
          ]),
          bagAttrs
        ]);
      }
      var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);
      var keyCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()),
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(keySafeContents).getBytes())
        ])
      ]);
      contents.push(keyCI);
    }
    var safe = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);
    var macData;
    if (options.useMac) {
      var sha1 = forge.md.sha1.create();
      var macSalt = new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));
      var count = options.count;
      var key = p12.generateKey(password, macSalt, 3, count, 20);
      var mac = forge.hmac.create();
      mac.start(sha1, key);
      mac.update(asn1.toDer(safe).getBytes());
      var macValue = mac.getMac();
      macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.sha1).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macValue.getBytes())
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(count).getBytes())
      ]);
    }
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(3).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()),
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(safe).getBytes())
        ])
      ]),
      macData
    ]);
  };
  p12.generateKey = forge.pbe.generatePkcs12Key;
});

// node_modules/node-forge/lib/pki.js
var require_pki = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_asn1();
  require_oids();
  require_pbe();
  require_pem();
  require_pbkdf2();
  require_pkcs12();
  require_pss();
  require_rsa();
  require_util();
  require_x509();
  var asn1 = forge.asn1;
  var pki = module2.exports = forge.pki = forge.pki || {};
  pki.pemToDer = function(pem) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      throw new Error("Could not convert PEM to DER; PEM is encrypted.");
    }
    return forge.util.createBuffer(msg.body);
  };
  pki.privateKeyFromPem = function(pem) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
      var error = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
      error.headerType = msg.type;
      throw error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      throw new Error("Could not convert private key from PEM; PEM is encrypted.");
    }
    var obj = asn1.fromDer(msg.body);
    return pki.privateKeyFromAsn1(obj);
  };
  pki.privateKeyToPem = function(key, maxline) {
    var msg = {
      type: "RSA PRIVATE KEY",
      body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()
    };
    return forge.pem.encode(msg, {maxline});
  };
  pki.privateKeyInfoToPem = function(pki2, maxline) {
    var msg = {
      type: "PRIVATE KEY",
      body: asn1.toDer(pki2).getBytes()
    };
    return forge.pem.encode(msg, {maxline});
  };
});

// node_modules/node-forge/lib/tls.js
var require_tls = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_asn1();
  require_hmac();
  require_md5();
  require_pem();
  require_pki();
  require_random();
  require_sha1();
  require_util();
  var prf_TLS1 = function(secret, label, seed, length) {
    var rval = forge.util.createBuffer();
    var idx = secret.length >> 1;
    var slen = idx + (secret.length & 1);
    var s1 = secret.substr(0, slen);
    var s2 = secret.substr(idx, slen);
    var ai = forge.util.createBuffer();
    var hmac = forge.hmac.create();
    seed = label + seed;
    var md5itr = Math.ceil(length / 16);
    var sha1itr = Math.ceil(length / 20);
    hmac.start("MD5", s1);
    var md5bytes = forge.util.createBuffer();
    ai.putBytes(seed);
    for (var i = 0; i < md5itr; ++i) {
      hmac.start(null, null);
      hmac.update(ai.getBytes());
      ai.putBuffer(hmac.digest());
      hmac.start(null, null);
      hmac.update(ai.bytes() + seed);
      md5bytes.putBuffer(hmac.digest());
    }
    hmac.start("SHA1", s2);
    var sha1bytes = forge.util.createBuffer();
    ai.clear();
    ai.putBytes(seed);
    for (var i = 0; i < sha1itr; ++i) {
      hmac.start(null, null);
      hmac.update(ai.getBytes());
      ai.putBuffer(hmac.digest());
      hmac.start(null, null);
      hmac.update(ai.bytes() + seed);
      sha1bytes.putBuffer(hmac.digest());
    }
    rval.putBytes(forge.util.xorBytes(md5bytes.getBytes(), sha1bytes.getBytes(), length));
    return rval;
  };
  var hmac_sha1 = function(key2, seqNum, record) {
    var hmac = forge.hmac.create();
    hmac.start("SHA1", key2);
    var b = forge.util.createBuffer();
    b.putInt32(seqNum[0]);
    b.putInt32(seqNum[1]);
    b.putByte(record.type);
    b.putByte(record.version.major);
    b.putByte(record.version.minor);
    b.putInt16(record.length);
    b.putBytes(record.fragment.bytes());
    hmac.update(b.getBytes());
    return hmac.digest().getBytes();
  };
  var deflate = function(c, record, s) {
    var rval = false;
    try {
      var bytes = c.deflate(record.fragment.getBytes());
      record.fragment = forge.util.createBuffer(bytes);
      record.length = bytes.length;
      rval = true;
    } catch (ex) {
    }
    return rval;
  };
  var inflate = function(c, record, s) {
    var rval = false;
    try {
      var bytes = c.inflate(record.fragment.getBytes());
      record.fragment = forge.util.createBuffer(bytes);
      record.length = bytes.length;
      rval = true;
    } catch (ex) {
    }
    return rval;
  };
  var readVector = function(b, lenBytes) {
    var len = 0;
    switch (lenBytes) {
      case 1:
        len = b.getByte();
        break;
      case 2:
        len = b.getInt16();
        break;
      case 3:
        len = b.getInt24();
        break;
      case 4:
        len = b.getInt32();
        break;
    }
    return forge.util.createBuffer(b.getBytes(len));
  };
  var writeVector = function(b, lenBytes, v) {
    b.putInt(v.length(), lenBytes << 3);
    b.putBuffer(v);
  };
  var tls = {};
  tls.Versions = {
    TLS_1_0: {major: 3, minor: 1},
    TLS_1_1: {major: 3, minor: 2},
    TLS_1_2: {major: 3, minor: 3}
  };
  tls.SupportedVersions = [
    tls.Versions.TLS_1_1,
    tls.Versions.TLS_1_0
  ];
  tls.Version = tls.SupportedVersions[0];
  tls.MaxFragment = 16384 - 1024;
  tls.ConnectionEnd = {
    server: 0,
    client: 1
  };
  tls.PRFAlgorithm = {
    tls_prf_sha256: 0
  };
  tls.BulkCipherAlgorithm = {
    none: null,
    rc4: 0,
    des3: 1,
    aes: 2
  };
  tls.CipherType = {
    stream: 0,
    block: 1,
    aead: 2
  };
  tls.MACAlgorithm = {
    none: null,
    hmac_md5: 0,
    hmac_sha1: 1,
    hmac_sha256: 2,
    hmac_sha384: 3,
    hmac_sha512: 4
  };
  tls.CompressionMethod = {
    none: 0,
    deflate: 1
  };
  tls.ContentType = {
    change_cipher_spec: 20,
    alert: 21,
    handshake: 22,
    application_data: 23,
    heartbeat: 24
  };
  tls.HandshakeType = {
    hello_request: 0,
    client_hello: 1,
    server_hello: 2,
    certificate: 11,
    server_key_exchange: 12,
    certificate_request: 13,
    server_hello_done: 14,
    certificate_verify: 15,
    client_key_exchange: 16,
    finished: 20
  };
  tls.Alert = {};
  tls.Alert.Level = {
    warning: 1,
    fatal: 2
  };
  tls.Alert.Description = {
    close_notify: 0,
    unexpected_message: 10,
    bad_record_mac: 20,
    decryption_failed: 21,
    record_overflow: 22,
    decompression_failure: 30,
    handshake_failure: 40,
    bad_certificate: 42,
    unsupported_certificate: 43,
    certificate_revoked: 44,
    certificate_expired: 45,
    certificate_unknown: 46,
    illegal_parameter: 47,
    unknown_ca: 48,
    access_denied: 49,
    decode_error: 50,
    decrypt_error: 51,
    export_restriction: 60,
    protocol_version: 70,
    insufficient_security: 71,
    internal_error: 80,
    user_canceled: 90,
    no_renegotiation: 100
  };
  tls.HeartbeatMessageType = {
    heartbeat_request: 1,
    heartbeat_response: 2
  };
  tls.CipherSuites = {};
  tls.getCipherSuite = function(twoBytes) {
    var rval = null;
    for (var key2 in tls.CipherSuites) {
      var cs = tls.CipherSuites[key2];
      if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
        rval = cs;
        break;
      }
    }
    return rval;
  };
  tls.handleUnexpected = function(c, record) {
    var ignore = !c.open && c.entity === tls.ConnectionEnd.client;
    if (!ignore) {
      c.error(c, {
        message: "Unexpected message. Received TLS record out of order.",
        send: true,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.unexpected_message
        }
      });
    }
  };
  tls.handleHelloRequest = function(c, record, length) {
    if (!c.handshaking && c.handshakes > 0) {
      tls.queue(c, tls.createAlert(c, {
        level: tls.Alert.Level.warning,
        description: tls.Alert.Description.no_renegotiation
      }));
      tls.flush(c);
    }
    c.process();
  };
  tls.parseHelloMessage = function(c, record, length) {
    var msg = null;
    var client = c.entity === tls.ConnectionEnd.client;
    if (length < 38) {
      c.error(c, {
        message: client ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
        send: true,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.illegal_parameter
        }
      });
    } else {
      var b = record.fragment;
      var remaining = b.length();
      msg = {
        version: {
          major: b.getByte(),
          minor: b.getByte()
        },
        random: forge.util.createBuffer(b.getBytes(32)),
        session_id: readVector(b, 1),
        extensions: []
      };
      if (client) {
        msg.cipher_suite = b.getBytes(2);
        msg.compression_method = b.getByte();
      } else {
        msg.cipher_suites = readVector(b, 2);
        msg.compression_methods = readVector(b, 1);
      }
      remaining = length - (remaining - b.length());
      if (remaining > 0) {
        var exts = readVector(b, 2);
        while (exts.length() > 0) {
          msg.extensions.push({
            type: [exts.getByte(), exts.getByte()],
            data: readVector(exts, 2)
          });
        }
        if (!client) {
          for (var i = 0; i < msg.extensions.length; ++i) {
            var ext = msg.extensions[i];
            if (ext.type[0] === 0 && ext.type[1] === 0) {
              var snl = readVector(ext.data, 2);
              while (snl.length() > 0) {
                var snType = snl.getByte();
                if (snType !== 0) {
                  break;
                }
                c.session.extensions.server_name.serverNameList.push(readVector(snl, 2).getBytes());
              }
            }
          }
        }
      }
      if (c.session.version) {
        if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) {
          return c.error(c, {
            message: "TLS version change is disallowed during renegotiation.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.protocol_version
            }
          });
        }
      }
      if (client) {
        c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);
      } else {
        var tmp = forge.util.createBuffer(msg.cipher_suites.bytes());
        while (tmp.length() > 0) {
          c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));
          if (c.session.cipherSuite !== null) {
            break;
          }
        }
      }
      if (c.session.cipherSuite === null) {
        return c.error(c, {
          message: "No cipher suites in common.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.handshake_failure
          },
          cipherSuite: forge.util.bytesToHex(msg.cipher_suite)
        });
      }
      if (client) {
        c.session.compressionMethod = msg.compression_method;
      } else {
        c.session.compressionMethod = tls.CompressionMethod.none;
      }
    }
    return msg;
  };
  tls.createSecurityParameters = function(c, msg) {
    var client = c.entity === tls.ConnectionEnd.client;
    var msgRandom = msg.random.bytes();
    var cRandom = client ? c.session.sp.client_random : msgRandom;
    var sRandom = client ? msgRandom : tls.createRandom().getBytes();
    c.session.sp = {
      entity: c.entity,
      prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
      bulk_cipher_algorithm: null,
      cipher_type: null,
      enc_key_length: null,
      block_length: null,
      fixed_iv_length: null,
      record_iv_length: null,
      mac_algorithm: null,
      mac_length: null,
      mac_key_length: null,
      compression_algorithm: c.session.compressionMethod,
      pre_master_secret: null,
      master_secret: null,
      client_random: cRandom,
      server_random: sRandom
    };
  };
  tls.handleServerHello = function(c, record, length) {
    var msg = tls.parseHelloMessage(c, record, length);
    if (c.fail) {
      return;
    }
    if (msg.version.minor <= c.version.minor) {
      c.version.minor = msg.version.minor;
    } else {
      return c.error(c, {
        message: "Incompatible TLS version.",
        send: true,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.protocol_version
        }
      });
    }
    c.session.version = c.version;
    var sessionId = msg.session_id.bytes();
    if (sessionId.length > 0 && sessionId === c.session.id) {
      c.expect = SCC;
      c.session.resuming = true;
      c.session.sp.server_random = msg.random.bytes();
    } else {
      c.expect = SCE;
      c.session.resuming = false;
      tls.createSecurityParameters(c, msg);
    }
    c.session.id = sessionId;
    c.process();
  };
  tls.handleClientHello = function(c, record, length) {
    var msg = tls.parseHelloMessage(c, record, length);
    if (c.fail) {
      return;
    }
    var sessionId = msg.session_id.bytes();
    var session = null;
    if (c.sessionCache) {
      session = c.sessionCache.getSession(sessionId);
      if (session === null) {
        sessionId = "";
      } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
        session = null;
        sessionId = "";
      }
    }
    if (sessionId.length === 0) {
      sessionId = forge.random.getBytes(32);
    }
    c.session.id = sessionId;
    c.session.clientHelloVersion = msg.version;
    c.session.sp = {};
    if (session) {
      c.version = c.session.version = session.version;
      c.session.sp = session.sp;
    } else {
      var version;
      for (var i = 1; i < tls.SupportedVersions.length; ++i) {
        version = tls.SupportedVersions[i];
        if (version.minor <= msg.version.minor) {
          break;
        }
      }
      c.version = {major: version.major, minor: version.minor};
      c.session.version = c.version;
    }
    if (session !== null) {
      c.expect = CCC;
      c.session.resuming = true;
      c.session.sp.client_random = msg.random.bytes();
    } else {
      c.expect = c.verifyClient !== false ? CCE : CKE;
      c.session.resuming = false;
      tls.createSecurityParameters(c, msg);
    }
    c.open = true;
    tls.queue(c, tls.createRecord(c, {
      type: tls.ContentType.handshake,
      data: tls.createServerHello(c)
    }));
    if (c.session.resuming) {
      tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.change_cipher_spec,
        data: tls.createChangeCipherSpec()
      }));
      c.state.pending = tls.createConnectionState(c);
      c.state.current.write = c.state.pending.write;
      tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createFinished(c)
      }));
    } else {
      tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createCertificate(c)
      }));
      if (!c.fail) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createServerKeyExchange(c)
        }));
        if (c.verifyClient !== false) {
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createCertificateRequest(c)
          }));
        }
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createServerHelloDone(c)
        }));
      }
    }
    tls.flush(c);
    c.process();
  };
  tls.handleCertificate = function(c, record, length) {
    if (length < 3) {
      return c.error(c, {
        message: "Invalid Certificate message. Message too short.",
        send: true,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.illegal_parameter
        }
      });
    }
    var b = record.fragment;
    var msg = {
      certificate_list: readVector(b, 3)
    };
    var cert, asn1;
    var certs = [];
    try {
      while (msg.certificate_list.length() > 0) {
        cert = readVector(msg.certificate_list, 3);
        asn1 = forge.asn1.fromDer(cert);
        cert = forge.pki.certificateFromAsn1(asn1, true);
        certs.push(cert);
      }
    } catch (ex) {
      return c.error(c, {
        message: "Could not parse certificate list.",
        cause: ex,
        send: true,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.bad_certificate
        }
      });
    }
    var client = c.entity === tls.ConnectionEnd.client;
    if ((client || c.verifyClient === true) && certs.length === 0) {
      c.error(c, {
        message: client ? "No server certificate provided." : "No client certificate provided.",
        send: true,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.illegal_parameter
        }
      });
    } else if (certs.length === 0) {
      c.expect = client ? SKE : CKE;
    } else {
      if (client) {
        c.session.serverCertificate = certs[0];
      } else {
        c.session.clientCertificate = certs[0];
      }
      if (tls.verifyCertificateChain(c, certs)) {
        c.expect = client ? SKE : CKE;
      }
    }
    c.process();
  };
  tls.handleServerKeyExchange = function(c, record, length) {
    if (length > 0) {
      return c.error(c, {
        message: "Invalid key parameters. Only RSA is supported.",
        send: true,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.unsupported_certificate
        }
      });
    }
    c.expect = SCR;
    c.process();
  };
  tls.handleClientKeyExchange = function(c, record, length) {
    if (length < 48) {
      return c.error(c, {
        message: "Invalid key parameters. Only RSA is supported.",
        send: true,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.unsupported_certificate
        }
      });
    }
    var b = record.fragment;
    var msg = {
      enc_pre_master_secret: readVector(b, 2).getBytes()
    };
    var privateKey = null;
    if (c.getPrivateKey) {
      try {
        privateKey = c.getPrivateKey(c, c.session.serverCertificate);
        privateKey = forge.pki.privateKeyFromPem(privateKey);
      } catch (ex) {
        c.error(c, {
          message: "Could not get private key.",
          cause: ex,
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.internal_error
          }
        });
      }
    }
    if (privateKey === null) {
      return c.error(c, {
        message: "No private key set.",
        send: true,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.internal_error
        }
      });
    }
    try {
      var sp = c.session.sp;
      sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
      var version = c.session.clientHelloVersion;
      if (version.major !== sp.pre_master_secret.charCodeAt(0) || version.minor !== sp.pre_master_secret.charCodeAt(1)) {
        throw new Error("TLS version rollback attack detected.");
      }
    } catch (ex) {
      sp.pre_master_secret = forge.random.getBytes(48);
    }
    c.expect = CCC;
    if (c.session.clientCertificate !== null) {
      c.expect = CCV;
    }
    c.process();
  };
  tls.handleCertificateRequest = function(c, record, length) {
    if (length < 3) {
      return c.error(c, {
        message: "Invalid CertificateRequest. Message too short.",
        send: true,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.illegal_parameter
        }
      });
    }
    var b = record.fragment;
    var msg = {
      certificate_types: readVector(b, 1),
      certificate_authorities: readVector(b, 2)
    };
    c.session.certificateRequest = msg;
    c.expect = SHD;
    c.process();
  };
  tls.handleCertificateVerify = function(c, record, length) {
    if (length < 2) {
      return c.error(c, {
        message: "Invalid CertificateVerify. Message too short.",
        send: true,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.illegal_parameter
        }
      });
    }
    var b = record.fragment;
    b.read -= 4;
    var msgBytes = b.bytes();
    b.read += 4;
    var msg = {
      signature: readVector(b, 2).getBytes()
    };
    var verify = forge.util.createBuffer();
    verify.putBuffer(c.session.md5.digest());
    verify.putBuffer(c.session.sha1.digest());
    verify = verify.getBytes();
    try {
      var cert = c.session.clientCertificate;
      if (!cert.publicKey.verify(verify, msg.signature, "NONE")) {
        throw new Error("CertificateVerify signature does not match.");
      }
      c.session.md5.update(msgBytes);
      c.session.sha1.update(msgBytes);
    } catch (ex) {
      return c.error(c, {
        message: "Bad signature in CertificateVerify.",
        send: true,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.handshake_failure
        }
      });
    }
    c.expect = CCC;
    c.process();
  };
  tls.handleServerHelloDone = function(c, record, length) {
    if (length > 0) {
      return c.error(c, {
        message: "Invalid ServerHelloDone message. Invalid length.",
        send: true,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.record_overflow
        }
      });
    }
    if (c.serverCertificate === null) {
      var error = {
        message: "No server certificate provided. Not enough security.",
        send: true,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.insufficient_security
        }
      };
      var depth = 0;
      var ret = c.verify(c, error.alert.description, depth, []);
      if (ret !== true) {
        if (ret || ret === 0) {
          if (typeof ret === "object" && !forge.util.isArray(ret)) {
            if (ret.message) {
              error.message = ret.message;
            }
            if (ret.alert) {
              error.alert.description = ret.alert;
            }
          } else if (typeof ret === "number") {
            error.alert.description = ret;
          }
        }
        return c.error(c, error);
      }
    }
    if (c.session.certificateRequest !== null) {
      record = tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createCertificate(c)
      });
      tls.queue(c, record);
    }
    record = tls.createRecord(c, {
      type: tls.ContentType.handshake,
      data: tls.createClientKeyExchange(c)
    });
    tls.queue(c, record);
    c.expect = SER;
    var callback = function(c2, signature) {
      if (c2.session.certificateRequest !== null && c2.session.clientCertificate !== null) {
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.handshake,
          data: tls.createCertificateVerify(c2, signature)
        }));
      }
      tls.queue(c2, tls.createRecord(c2, {
        type: tls.ContentType.change_cipher_spec,
        data: tls.createChangeCipherSpec()
      }));
      c2.state.pending = tls.createConnectionState(c2);
      c2.state.current.write = c2.state.pending.write;
      tls.queue(c2, tls.createRecord(c2, {
        type: tls.ContentType.handshake,
        data: tls.createFinished(c2)
      }));
      c2.expect = SCC;
      tls.flush(c2);
      c2.process();
    };
    if (c.session.certificateRequest === null || c.session.clientCertificate === null) {
      return callback(c, null);
    }
    tls.getClientSignature(c, callback);
  };
  tls.handleChangeCipherSpec = function(c, record) {
    if (record.fragment.getByte() !== 1) {
      return c.error(c, {
        message: "Invalid ChangeCipherSpec message received.",
        send: true,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.illegal_parameter
        }
      });
    }
    var client = c.entity === tls.ConnectionEnd.client;
    if (c.session.resuming && client || !c.session.resuming && !client) {
      c.state.pending = tls.createConnectionState(c);
    }
    c.state.current.read = c.state.pending.read;
    if (!c.session.resuming && client || c.session.resuming && !client) {
      c.state.pending = null;
    }
    c.expect = client ? SFI : CFI;
    c.process();
  };
  tls.handleFinished = function(c, record, length) {
    var b = record.fragment;
    b.read -= 4;
    var msgBytes = b.bytes();
    b.read += 4;
    var vd = record.fragment.getBytes();
    b = forge.util.createBuffer();
    b.putBuffer(c.session.md5.digest());
    b.putBuffer(c.session.sha1.digest());
    var client = c.entity === tls.ConnectionEnd.client;
    var label = client ? "server finished" : "client finished";
    var sp = c.session.sp;
    var vdl = 12;
    var prf = prf_TLS1;
    b = prf(sp.master_secret, label, b.getBytes(), vdl);
    if (b.getBytes() !== vd) {
      return c.error(c, {
        message: "Invalid verify_data in Finished message.",
        send: true,
        alert: {
          level: tls.Alert.Level.fatal,
          description: tls.Alert.Description.decrypt_error
        }
      });
    }
    c.session.md5.update(msgBytes);
    c.session.sha1.update(msgBytes);
    if (c.session.resuming && client || !c.session.resuming && !client) {
      tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.change_cipher_spec,
        data: tls.createChangeCipherSpec()
      }));
      c.state.current.write = c.state.pending.write;
      c.state.pending = null;
      tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createFinished(c)
      }));
    }
    c.expect = client ? SAD : CAD;
    c.handshaking = false;
    ++c.handshakes;
    c.peerCertificate = client ? c.session.serverCertificate : c.session.clientCertificate;
    tls.flush(c);
    c.isConnected = true;
    c.connected(c);
    c.process();
  };
  tls.handleAlert = function(c, record) {
    var b = record.fragment;
    var alert = {
      level: b.getByte(),
      description: b.getByte()
    };
    var msg;
    switch (alert.description) {
      case tls.Alert.Description.close_notify:
        msg = "Connection closed.";
        break;
      case tls.Alert.Description.unexpected_message:
        msg = "Unexpected message.";
        break;
      case tls.Alert.Description.bad_record_mac:
        msg = "Bad record MAC.";
        break;
      case tls.Alert.Description.decryption_failed:
        msg = "Decryption failed.";
        break;
      case tls.Alert.Description.record_overflow:
        msg = "Record overflow.";
        break;
      case tls.Alert.Description.decompression_failure:
        msg = "Decompression failed.";
        break;
      case tls.Alert.Description.handshake_failure:
        msg = "Handshake failure.";
        break;
      case tls.Alert.Description.bad_certificate:
        msg = "Bad certificate.";
        break;
      case tls.Alert.Description.unsupported_certificate:
        msg = "Unsupported certificate.";
        break;
      case tls.Alert.Description.certificate_revoked:
        msg = "Certificate revoked.";
        break;
      case tls.Alert.Description.certificate_expired:
        msg = "Certificate expired.";
        break;
      case tls.Alert.Description.certificate_unknown:
        msg = "Certificate unknown.";
        break;
      case tls.Alert.Description.illegal_parameter:
        msg = "Illegal parameter.";
        break;
      case tls.Alert.Description.unknown_ca:
        msg = "Unknown certificate authority.";
        break;
      case tls.Alert.Description.access_denied:
        msg = "Access denied.";
        break;
      case tls.Alert.Description.decode_error:
        msg = "Decode error.";
        break;
      case tls.Alert.Description.decrypt_error:
        msg = "Decrypt error.";
        break;
      case tls.Alert.Description.export_restriction:
        msg = "Export restriction.";
        break;
      case tls.Alert.Description.protocol_version:
        msg = "Unsupported protocol version.";
        break;
      case tls.Alert.Description.insufficient_security:
        msg = "Insufficient security.";
        break;
      case tls.Alert.Description.internal_error:
        msg = "Internal error.";
        break;
      case tls.Alert.Description.user_canceled:
        msg = "User canceled.";
        break;
      case tls.Alert.Description.no_renegotiation:
        msg = "Renegotiation not supported.";
        break;
      default:
        msg = "Unknown error.";
        break;
    }
    if (alert.description === tls.Alert.Description.close_notify) {
      return c.close();
    }
    c.error(c, {
      message: msg,
      send: false,
      origin: c.entity === tls.ConnectionEnd.client ? "server" : "client",
      alert
    });
    c.process();
  };
  tls.handleHandshake = function(c, record) {
    var b = record.fragment;
    var type = b.getByte();
    var length = b.getInt24();
    if (length > b.length()) {
      c.fragmented = record;
      record.fragment = forge.util.createBuffer();
      b.read -= 4;
      return c.process();
    }
    c.fragmented = null;
    b.read -= 4;
    var bytes = b.bytes(length + 4);
    b.read += 4;
    if (type in hsTable[c.entity][c.expect]) {
      if (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {
        c.handshaking = true;
        c.session = {
          version: null,
          extensions: {
            server_name: {
              serverNameList: []
            }
          },
          cipherSuite: null,
          compressionMethod: null,
          serverCertificate: null,
          clientCertificate: null,
          md5: forge.md.md5.create(),
          sha1: forge.md.sha1.create()
        };
      }
      if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {
        c.session.md5.update(bytes);
        c.session.sha1.update(bytes);
      }
      hsTable[c.entity][c.expect][type](c, record, length);
    } else {
      tls.handleUnexpected(c, record);
    }
  };
  tls.handleApplicationData = function(c, record) {
    c.data.putBuffer(record.fragment);
    c.dataReady(c);
    c.process();
  };
  tls.handleHeartbeat = function(c, record) {
    var b = record.fragment;
    var type = b.getByte();
    var length = b.getInt16();
    var payload = b.getBytes(length);
    if (type === tls.HeartbeatMessageType.heartbeat_request) {
      if (c.handshaking || length > payload.length) {
        return c.process();
      }
      tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.heartbeat,
        data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_response, payload)
      }));
      tls.flush(c);
    } else if (type === tls.HeartbeatMessageType.heartbeat_response) {
      if (payload !== c.expectedHeartbeatPayload) {
        return c.process();
      }
      if (c.heartbeatReceived) {
        c.heartbeatReceived(c, forge.util.createBuffer(payload));
      }
    }
    c.process();
  };
  var SHE = 0;
  var SCE = 1;
  var SKE = 2;
  var SCR = 3;
  var SHD = 4;
  var SCC = 5;
  var SFI = 6;
  var SAD = 7;
  var SER = 8;
  var CHE = 0;
  var CCE = 1;
  var CKE = 2;
  var CCV = 3;
  var CCC = 4;
  var CFI = 5;
  var CAD = 6;
  var __ = tls.handleUnexpected;
  var R0 = tls.handleChangeCipherSpec;
  var R1 = tls.handleAlert;
  var R2 = tls.handleHandshake;
  var R3 = tls.handleApplicationData;
  var R4 = tls.handleHeartbeat;
  var ctTable = [];
  ctTable[tls.ConnectionEnd.client] = [
    [__, R1, R2, __, R4],
    [__, R1, R2, __, R4],
    [__, R1, R2, __, R4],
    [__, R1, R2, __, R4],
    [__, R1, R2, __, R4],
    [R0, R1, __, __, R4],
    [__, R1, R2, __, R4],
    [__, R1, R2, R3, R4],
    [__, R1, R2, __, R4]
  ];
  ctTable[tls.ConnectionEnd.server] = [
    [__, R1, R2, __, R4],
    [__, R1, R2, __, R4],
    [__, R1, R2, __, R4],
    [__, R1, R2, __, R4],
    [R0, R1, __, __, R4],
    [__, R1, R2, __, R4],
    [__, R1, R2, R3, R4],
    [__, R1, R2, __, R4]
  ];
  var H0 = tls.handleHelloRequest;
  var H1 = tls.handleServerHello;
  var H2 = tls.handleCertificate;
  var H3 = tls.handleServerKeyExchange;
  var H4 = tls.handleCertificateRequest;
  var H5 = tls.handleServerHelloDone;
  var H6 = tls.handleFinished;
  var hsTable = [];
  hsTable[tls.ConnectionEnd.client] = [
    [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
    [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __],
    [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],
    [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],
    [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],
    [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
    [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
    [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
    [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
  ];
  var H7 = tls.handleClientHello;
  var H8 = tls.handleClientKeyExchange;
  var H9 = tls.handleCertificateVerify;
  hsTable[tls.ConnectionEnd.server] = [
    [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
    [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __],
    [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],
    [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],
    [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
    [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
    [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
    [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
  ];
  tls.generateKeys = function(c, sp) {
    var prf = prf_TLS1;
    var random = sp.client_random + sp.server_random;
    if (!c.session.resuming) {
      sp.master_secret = prf(sp.pre_master_secret, "master secret", random, 48).bytes();
      sp.pre_master_secret = null;
    }
    random = sp.server_random + sp.client_random;
    var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
    var tls10 = c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor;
    if (tls10) {
      length += 2 * sp.fixed_iv_length;
    }
    var km = prf(sp.master_secret, "key expansion", random, length);
    var rval = {
      client_write_MAC_key: km.getBytes(sp.mac_key_length),
      server_write_MAC_key: km.getBytes(sp.mac_key_length),
      client_write_key: km.getBytes(sp.enc_key_length),
      server_write_key: km.getBytes(sp.enc_key_length)
    };
    if (tls10) {
      rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
      rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
    }
    return rval;
  };
  tls.createConnectionState = function(c) {
    var client = c.entity === tls.ConnectionEnd.client;
    var createMode = function() {
      var mode = {
        sequenceNumber: [0, 0],
        macKey: null,
        macLength: 0,
        macFunction: null,
        cipherState: null,
        cipherFunction: function(record) {
          return true;
        },
        compressionState: null,
        compressFunction: function(record) {
          return true;
        },
        updateSequenceNumber: function() {
          if (mode.sequenceNumber[1] === 4294967295) {
            mode.sequenceNumber[1] = 0;
            ++mode.sequenceNumber[0];
          } else {
            ++mode.sequenceNumber[1];
          }
        }
      };
      return mode;
    };
    var state = {
      read: createMode(),
      write: createMode()
    };
    state.read.update = function(c2, record) {
      if (!state.read.cipherFunction(record, state.read)) {
        c2.error(c2, {
          message: "Could not decrypt record or bad MAC.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.bad_record_mac
          }
        });
      } else if (!state.read.compressFunction(c2, record, state.read)) {
        c2.error(c2, {
          message: "Could not decompress record.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.decompression_failure
          }
        });
      }
      return !c2.fail;
    };
    state.write.update = function(c2, record) {
      if (!state.write.compressFunction(c2, record, state.write)) {
        c2.error(c2, {
          message: "Could not compress record.",
          send: false,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.internal_error
          }
        });
      } else if (!state.write.cipherFunction(record, state.write)) {
        c2.error(c2, {
          message: "Could not encrypt record.",
          send: false,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.internal_error
          }
        });
      }
      return !c2.fail;
    };
    if (c.session) {
      var sp = c.session.sp;
      c.session.cipherSuite.initSecurityParameters(sp);
      sp.keys = tls.generateKeys(c, sp);
      state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
      state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
      c.session.cipherSuite.initConnectionState(state, c, sp);
      switch (sp.compression_algorithm) {
        case tls.CompressionMethod.none:
          break;
        case tls.CompressionMethod.deflate:
          state.read.compressFunction = inflate;
          state.write.compressFunction = deflate;
          break;
        default:
          throw new Error("Unsupported compression algorithm.");
      }
    }
    return state;
  };
  tls.createRandom = function() {
    var d = new Date();
    var utc = +d + d.getTimezoneOffset() * 6e4;
    var rval = forge.util.createBuffer();
    rval.putInt32(utc);
    rval.putBytes(forge.random.getBytes(28));
    return rval;
  };
  tls.createRecord = function(c, options) {
    if (!options.data) {
      return null;
    }
    var record = {
      type: options.type,
      version: {
        major: c.version.major,
        minor: c.version.minor
      },
      length: options.data.length(),
      fragment: options.data
    };
    return record;
  };
  tls.createAlert = function(c, alert) {
    var b = forge.util.createBuffer();
    b.putByte(alert.level);
    b.putByte(alert.description);
    return tls.createRecord(c, {
      type: tls.ContentType.alert,
      data: b
    });
  };
  tls.createClientHello = function(c) {
    c.session.clientHelloVersion = {
      major: c.version.major,
      minor: c.version.minor
    };
    var cipherSuites = forge.util.createBuffer();
    for (var i = 0; i < c.cipherSuites.length; ++i) {
      var cs = c.cipherSuites[i];
      cipherSuites.putByte(cs.id[0]);
      cipherSuites.putByte(cs.id[1]);
    }
    var cSuites = cipherSuites.length();
    var compressionMethods = forge.util.createBuffer();
    compressionMethods.putByte(tls.CompressionMethod.none);
    var cMethods = compressionMethods.length();
    var extensions = forge.util.createBuffer();
    if (c.virtualHost) {
      var ext = forge.util.createBuffer();
      ext.putByte(0);
      ext.putByte(0);
      var serverName = forge.util.createBuffer();
      serverName.putByte(0);
      writeVector(serverName, 2, forge.util.createBuffer(c.virtualHost));
      var snList = forge.util.createBuffer();
      writeVector(snList, 2, serverName);
      writeVector(ext, 2, snList);
      extensions.putBuffer(ext);
    }
    var extLength = extensions.length();
    if (extLength > 0) {
      extLength += 2;
    }
    var sessionId = c.session.id;
    var length = sessionId.length + 1 + 2 + 4 + 28 + 2 + cSuites + 1 + cMethods + extLength;
    var rval = forge.util.createBuffer();
    rval.putByte(tls.HandshakeType.client_hello);
    rval.putInt24(length);
    rval.putByte(c.version.major);
    rval.putByte(c.version.minor);
    rval.putBytes(c.session.sp.client_random);
    writeVector(rval, 1, forge.util.createBuffer(sessionId));
    writeVector(rval, 2, cipherSuites);
    writeVector(rval, 1, compressionMethods);
    if (extLength > 0) {
      writeVector(rval, 2, extensions);
    }
    return rval;
  };
  tls.createServerHello = function(c) {
    var sessionId = c.session.id;
    var length = sessionId.length + 1 + 2 + 4 + 28 + 2 + 1;
    var rval = forge.util.createBuffer();
    rval.putByte(tls.HandshakeType.server_hello);
    rval.putInt24(length);
    rval.putByte(c.version.major);
    rval.putByte(c.version.minor);
    rval.putBytes(c.session.sp.server_random);
    writeVector(rval, 1, forge.util.createBuffer(sessionId));
    rval.putByte(c.session.cipherSuite.id[0]);
    rval.putByte(c.session.cipherSuite.id[1]);
    rval.putByte(c.session.compressionMethod);
    return rval;
  };
  tls.createCertificate = function(c) {
    var client = c.entity === tls.ConnectionEnd.client;
    var cert = null;
    if (c.getCertificate) {
      var hint;
      if (client) {
        hint = c.session.certificateRequest;
      } else {
        hint = c.session.extensions.server_name.serverNameList;
      }
      cert = c.getCertificate(c, hint);
    }
    var certList = forge.util.createBuffer();
    if (cert !== null) {
      try {
        if (!forge.util.isArray(cert)) {
          cert = [cert];
        }
        var asn1 = null;
        for (var i = 0; i < cert.length; ++i) {
          var msg = forge.pem.decode(cert[i])[0];
          if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
            var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
          }
          var der = forge.util.createBuffer(msg.body);
          if (asn1 === null) {
            asn1 = forge.asn1.fromDer(der.bytes(), false);
          }
          var certBuffer = forge.util.createBuffer();
          writeVector(certBuffer, 3, der);
          certList.putBuffer(certBuffer);
        }
        cert = forge.pki.certificateFromAsn1(asn1);
        if (client) {
          c.session.clientCertificate = cert;
        } else {
          c.session.serverCertificate = cert;
        }
      } catch (ex) {
        return c.error(c, {
          message: "Could not send certificate list.",
          cause: ex,
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.bad_certificate
          }
        });
      }
    }
    var length = 3 + certList.length();
    var rval = forge.util.createBuffer();
    rval.putByte(tls.HandshakeType.certificate);
    rval.putInt24(length);
    writeVector(rval, 3, certList);
    return rval;
  };
  tls.createClientKeyExchange = function(c) {
    var b = forge.util.createBuffer();
    b.putByte(c.session.clientHelloVersion.major);
    b.putByte(c.session.clientHelloVersion.minor);
    b.putBytes(forge.random.getBytes(46));
    var sp = c.session.sp;
    sp.pre_master_secret = b.getBytes();
    var key2 = c.session.serverCertificate.publicKey;
    b = key2.encrypt(sp.pre_master_secret);
    var length = b.length + 2;
    var rval = forge.util.createBuffer();
    rval.putByte(tls.HandshakeType.client_key_exchange);
    rval.putInt24(length);
    rval.putInt16(b.length);
    rval.putBytes(b);
    return rval;
  };
  tls.createServerKeyExchange = function(c) {
    var length = 0;
    var rval = forge.util.createBuffer();
    if (length > 0) {
      rval.putByte(tls.HandshakeType.server_key_exchange);
      rval.putInt24(length);
    }
    return rval;
  };
  tls.getClientSignature = function(c, callback) {
    var b = forge.util.createBuffer();
    b.putBuffer(c.session.md5.digest());
    b.putBuffer(c.session.sha1.digest());
    b = b.getBytes();
    c.getSignature = c.getSignature || function(c2, b2, callback2) {
      var privateKey = null;
      if (c2.getPrivateKey) {
        try {
          privateKey = c2.getPrivateKey(c2, c2.session.clientCertificate);
          privateKey = forge.pki.privateKeyFromPem(privateKey);
        } catch (ex) {
          c2.error(c2, {
            message: "Could not get private key.",
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
      }
      if (privateKey === null) {
        c2.error(c2, {
          message: "No private key set.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.internal_error
          }
        });
      } else {
        b2 = privateKey.sign(b2, null);
      }
      callback2(c2, b2);
    };
    c.getSignature(c, b, callback);
  };
  tls.createCertificateVerify = function(c, signature) {
    var length = signature.length + 2;
    var rval = forge.util.createBuffer();
    rval.putByte(tls.HandshakeType.certificate_verify);
    rval.putInt24(length);
    rval.putInt16(signature.length);
    rval.putBytes(signature);
    return rval;
  };
  tls.createCertificateRequest = function(c) {
    var certTypes = forge.util.createBuffer();
    certTypes.putByte(1);
    var cAs = forge.util.createBuffer();
    for (var key2 in c.caStore.certs) {
      var cert = c.caStore.certs[key2];
      var dn = forge.pki.distinguishedNameToAsn1(cert.subject);
      var byteBuffer = forge.asn1.toDer(dn);
      cAs.putInt16(byteBuffer.length());
      cAs.putBuffer(byteBuffer);
    }
    var length = 1 + certTypes.length() + 2 + cAs.length();
    var rval = forge.util.createBuffer();
    rval.putByte(tls.HandshakeType.certificate_request);
    rval.putInt24(length);
    writeVector(rval, 1, certTypes);
    writeVector(rval, 2, cAs);
    return rval;
  };
  tls.createServerHelloDone = function(c) {
    var rval = forge.util.createBuffer();
    rval.putByte(tls.HandshakeType.server_hello_done);
    rval.putInt24(0);
    return rval;
  };
  tls.createChangeCipherSpec = function() {
    var rval = forge.util.createBuffer();
    rval.putByte(1);
    return rval;
  };
  tls.createFinished = function(c) {
    var b = forge.util.createBuffer();
    b.putBuffer(c.session.md5.digest());
    b.putBuffer(c.session.sha1.digest());
    var client = c.entity === tls.ConnectionEnd.client;
    var sp = c.session.sp;
    var vdl = 12;
    var prf = prf_TLS1;
    var label = client ? "client finished" : "server finished";
    b = prf(sp.master_secret, label, b.getBytes(), vdl);
    var rval = forge.util.createBuffer();
    rval.putByte(tls.HandshakeType.finished);
    rval.putInt24(b.length());
    rval.putBuffer(b);
    return rval;
  };
  tls.createHeartbeat = function(type, payload, payloadLength) {
    if (typeof payloadLength === "undefined") {
      payloadLength = payload.length;
    }
    var rval = forge.util.createBuffer();
    rval.putByte(type);
    rval.putInt16(payloadLength);
    rval.putBytes(payload);
    var plaintextLength = rval.length();
    var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
    rval.putBytes(forge.random.getBytes(paddingLength));
    return rval;
  };
  tls.queue = function(c, record) {
    if (!record) {
      return;
    }
    if (record.fragment.length() === 0) {
      if (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec) {
        return;
      }
    }
    if (record.type === tls.ContentType.handshake) {
      var bytes = record.fragment.bytes();
      c.session.md5.update(bytes);
      c.session.sha1.update(bytes);
      bytes = null;
    }
    var records;
    if (record.fragment.length() <= tls.MaxFragment) {
      records = [record];
    } else {
      records = [];
      var data = record.fragment.bytes();
      while (data.length > tls.MaxFragment) {
        records.push(tls.createRecord(c, {
          type: record.type,
          data: forge.util.createBuffer(data.slice(0, tls.MaxFragment))
        }));
        data = data.slice(tls.MaxFragment);
      }
      if (data.length > 0) {
        records.push(tls.createRecord(c, {
          type: record.type,
          data: forge.util.createBuffer(data)
        }));
      }
    }
    for (var i = 0; i < records.length && !c.fail; ++i) {
      var rec = records[i];
      var s = c.state.current.write;
      if (s.update(c, rec)) {
        c.records.push(rec);
      }
    }
  };
  tls.flush = function(c) {
    for (var i = 0; i < c.records.length; ++i) {
      var record = c.records[i];
      c.tlsData.putByte(record.type);
      c.tlsData.putByte(record.version.major);
      c.tlsData.putByte(record.version.minor);
      c.tlsData.putInt16(record.fragment.length());
      c.tlsData.putBuffer(c.records[i].fragment);
    }
    c.records = [];
    return c.tlsDataReady(c);
  };
  var _certErrorToAlertDesc = function(error) {
    switch (error) {
      case true:
        return true;
      case forge.pki.certificateError.bad_certificate:
        return tls.Alert.Description.bad_certificate;
      case forge.pki.certificateError.unsupported_certificate:
        return tls.Alert.Description.unsupported_certificate;
      case forge.pki.certificateError.certificate_revoked:
        return tls.Alert.Description.certificate_revoked;
      case forge.pki.certificateError.certificate_expired:
        return tls.Alert.Description.certificate_expired;
      case forge.pki.certificateError.certificate_unknown:
        return tls.Alert.Description.certificate_unknown;
      case forge.pki.certificateError.unknown_ca:
        return tls.Alert.Description.unknown_ca;
      default:
        return tls.Alert.Description.bad_certificate;
    }
  };
  var _alertDescToCertError = function(desc) {
    switch (desc) {
      case true:
        return true;
      case tls.Alert.Description.bad_certificate:
        return forge.pki.certificateError.bad_certificate;
      case tls.Alert.Description.unsupported_certificate:
        return forge.pki.certificateError.unsupported_certificate;
      case tls.Alert.Description.certificate_revoked:
        return forge.pki.certificateError.certificate_revoked;
      case tls.Alert.Description.certificate_expired:
        return forge.pki.certificateError.certificate_expired;
      case tls.Alert.Description.certificate_unknown:
        return forge.pki.certificateError.certificate_unknown;
      case tls.Alert.Description.unknown_ca:
        return forge.pki.certificateError.unknown_ca;
      default:
        return forge.pki.certificateError.bad_certificate;
    }
  };
  tls.verifyCertificateChain = function(c, chain) {
    try {
      var options = {};
      for (var key2 in c.verifyOptions) {
        options[key2] = c.verifyOptions[key2];
      }
      options.verify = function(vfd, depth, chain2) {
        var desc = _certErrorToAlertDesc(vfd);
        var ret = c.verify(c, vfd, depth, chain2);
        if (ret !== true) {
          if (typeof ret === "object" && !forge.util.isArray(ret)) {
            var error = new Error("The application rejected the certificate.");
            error.send = true;
            error.alert = {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.bad_certificate
            };
            if (ret.message) {
              error.message = ret.message;
            }
            if (ret.alert) {
              error.alert.description = ret.alert;
            }
            throw error;
          }
          if (ret !== vfd) {
            ret = _alertDescToCertError(ret);
          }
        }
        return ret;
      };
      forge.pki.verifyCertificateChain(c.caStore, chain, options);
    } catch (ex) {
      var err = ex;
      if (typeof err !== "object" || forge.util.isArray(err)) {
        err = {
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: _certErrorToAlertDesc(ex)
          }
        };
      }
      if (!("send" in err)) {
        err.send = true;
      }
      if (!("alert" in err)) {
        err.alert = {
          level: tls.Alert.Level.fatal,
          description: _certErrorToAlertDesc(err.error)
        };
      }
      c.error(c, err);
    }
    return !c.fail;
  };
  tls.createSessionCache = function(cache, capacity) {
    var rval = null;
    if (cache && cache.getSession && cache.setSession && cache.order) {
      rval = cache;
    } else {
      rval = {};
      rval.cache = cache || {};
      rval.capacity = Math.max(capacity || 100, 1);
      rval.order = [];
      for (var key2 in cache) {
        if (rval.order.length <= capacity) {
          rval.order.push(key2);
        } else {
          delete cache[key2];
        }
      }
      rval.getSession = function(sessionId) {
        var session = null;
        var key3 = null;
        if (sessionId) {
          key3 = forge.util.bytesToHex(sessionId);
        } else if (rval.order.length > 0) {
          key3 = rval.order[0];
        }
        if (key3 !== null && key3 in rval.cache) {
          session = rval.cache[key3];
          delete rval.cache[key3];
          for (var i in rval.order) {
            if (rval.order[i] === key3) {
              rval.order.splice(i, 1);
              break;
            }
          }
        }
        return session;
      };
      rval.setSession = function(sessionId, session) {
        if (rval.order.length === rval.capacity) {
          var key3 = rval.order.shift();
          delete rval.cache[key3];
        }
        var key3 = forge.util.bytesToHex(sessionId);
        rval.order.push(key3);
        rval.cache[key3] = session;
      };
    }
    return rval;
  };
  tls.createConnection = function(options) {
    var caStore = null;
    if (options.caStore) {
      if (forge.util.isArray(options.caStore)) {
        caStore = forge.pki.createCaStore(options.caStore);
      } else {
        caStore = options.caStore;
      }
    } else {
      caStore = forge.pki.createCaStore();
    }
    var cipherSuites = options.cipherSuites || null;
    if (cipherSuites === null) {
      cipherSuites = [];
      for (var key2 in tls.CipherSuites) {
        cipherSuites.push(tls.CipherSuites[key2]);
      }
    }
    var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;
    var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;
    var c = {
      version: {major: tls.Version.major, minor: tls.Version.minor},
      entity,
      sessionId: options.sessionId,
      caStore,
      sessionCache,
      cipherSuites,
      connected: options.connected,
      virtualHost: options.virtualHost || null,
      verifyClient: options.verifyClient || false,
      verify: options.verify || function(cn, vfd, dpth, cts) {
        return vfd;
      },
      verifyOptions: options.verifyOptions || {},
      getCertificate: options.getCertificate || null,
      getPrivateKey: options.getPrivateKey || null,
      getSignature: options.getSignature || null,
      input: forge.util.createBuffer(),
      tlsData: forge.util.createBuffer(),
      data: forge.util.createBuffer(),
      tlsDataReady: options.tlsDataReady,
      dataReady: options.dataReady,
      heartbeatReceived: options.heartbeatReceived,
      closed: options.closed,
      error: function(c2, ex) {
        ex.origin = ex.origin || (c2.entity === tls.ConnectionEnd.client ? "client" : "server");
        if (ex.send) {
          tls.queue(c2, tls.createAlert(c2, ex.alert));
          tls.flush(c2);
        }
        var fatal = ex.fatal !== false;
        if (fatal) {
          c2.fail = true;
        }
        options.error(c2, ex);
        if (fatal) {
          c2.close(false);
        }
      },
      deflate: options.deflate || null,
      inflate: options.inflate || null
    };
    c.reset = function(clearFail) {
      c.version = {major: tls.Version.major, minor: tls.Version.minor};
      c.record = null;
      c.session = null;
      c.peerCertificate = null;
      c.state = {
        pending: null,
        current: null
      };
      c.expect = c.entity === tls.ConnectionEnd.client ? SHE : CHE;
      c.fragmented = null;
      c.records = [];
      c.open = false;
      c.handshakes = 0;
      c.handshaking = false;
      c.isConnected = false;
      c.fail = !(clearFail || typeof clearFail === "undefined");
      c.input.clear();
      c.tlsData.clear();
      c.data.clear();
      c.state.current = tls.createConnectionState(c);
    };
    c.reset();
    var _update = function(c2, record) {
      var aligned = record.type - tls.ContentType.change_cipher_spec;
      var handlers = ctTable[c2.entity][c2.expect];
      if (aligned in handlers) {
        handlers[aligned](c2, record);
      } else {
        tls.handleUnexpected(c2, record);
      }
    };
    var _readRecordHeader = function(c2) {
      var rval = 0;
      var b = c2.input;
      var len = b.length();
      if (len < 5) {
        rval = 5 - len;
      } else {
        c2.record = {
          type: b.getByte(),
          version: {
            major: b.getByte(),
            minor: b.getByte()
          },
          length: b.getInt16(),
          fragment: forge.util.createBuffer(),
          ready: false
        };
        var compatibleVersion = c2.record.version.major === c2.version.major;
        if (compatibleVersion && c2.session && c2.session.version) {
          compatibleVersion = c2.record.version.minor === c2.version.minor;
        }
        if (!compatibleVersion) {
          c2.error(c2, {
            message: "Incompatible TLS version.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.protocol_version
            }
          });
        }
      }
      return rval;
    };
    var _readRecord = function(c2) {
      var rval = 0;
      var b = c2.input;
      var len = b.length();
      if (len < c2.record.length) {
        rval = c2.record.length - len;
      } else {
        c2.record.fragment.putBytes(b.getBytes(c2.record.length));
        b.compact();
        var s = c2.state.current.read;
        if (s.update(c2, c2.record)) {
          if (c2.fragmented !== null) {
            if (c2.fragmented.type === c2.record.type) {
              c2.fragmented.fragment.putBuffer(c2.record.fragment);
              c2.record = c2.fragmented;
            } else {
              c2.error(c2, {
                message: "Invalid fragmented record.",
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.unexpected_message
                }
              });
            }
          }
          c2.record.ready = true;
        }
      }
      return rval;
    };
    c.handshake = function(sessionId) {
      if (c.entity !== tls.ConnectionEnd.client) {
        c.error(c, {
          message: "Cannot initiate handshake as a server.",
          fatal: false
        });
      } else if (c.handshaking) {
        c.error(c, {
          message: "Handshake already in progress.",
          fatal: false
        });
      } else {
        if (c.fail && !c.open && c.handshakes === 0) {
          c.fail = false;
        }
        c.handshaking = true;
        sessionId = sessionId || "";
        var session = null;
        if (sessionId.length > 0) {
          if (c.sessionCache) {
            session = c.sessionCache.getSession(sessionId);
          }
          if (session === null) {
            sessionId = "";
          }
        }
        if (sessionId.length === 0 && c.sessionCache) {
          session = c.sessionCache.getSession();
          if (session !== null) {
            sessionId = session.id;
          }
        }
        c.session = {
          id: sessionId,
          version: null,
          cipherSuite: null,
          compressionMethod: null,
          serverCertificate: null,
          certificateRequest: null,
          clientCertificate: null,
          sp: {},
          md5: forge.md.md5.create(),
          sha1: forge.md.sha1.create()
        };
        if (session) {
          c.version = session.version;
          c.session.sp = session.sp;
        }
        c.session.sp.client_random = tls.createRandom().getBytes();
        c.open = true;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createClientHello(c)
        }));
        tls.flush(c);
      }
    };
    c.process = function(data) {
      var rval = 0;
      if (data) {
        c.input.putBytes(data);
      }
      if (!c.fail) {
        if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) {
          c.record = null;
        }
        if (c.record === null) {
          rval = _readRecordHeader(c);
        }
        if (!c.fail && c.record !== null && !c.record.ready) {
          rval = _readRecord(c);
        }
        if (!c.fail && c.record !== null && c.record.ready) {
          _update(c, c.record);
        }
      }
      return rval;
    };
    c.prepare = function(data) {
      tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.application_data,
        data: forge.util.createBuffer(data)
      }));
      return tls.flush(c);
    };
    c.prepareHeartbeatRequest = function(payload, payloadLength) {
      if (payload instanceof forge.util.ByteBuffer) {
        payload = payload.bytes();
      }
      if (typeof payloadLength === "undefined") {
        payloadLength = payload.length;
      }
      c.expectedHeartbeatPayload = payload;
      tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.heartbeat,
        data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_request, payload, payloadLength)
      }));
      return tls.flush(c);
    };
    c.close = function(clearFail) {
      if (!c.fail && c.sessionCache && c.session) {
        var session = {
          id: c.session.id,
          version: c.session.version,
          sp: c.session.sp
        };
        session.sp.keys = null;
        c.sessionCache.setSession(session.id, session);
      }
      if (c.open) {
        c.open = false;
        c.input.clear();
        if (c.isConnected || c.handshaking) {
          c.isConnected = c.handshaking = false;
          tls.queue(c, tls.createAlert(c, {
            level: tls.Alert.Level.warning,
            description: tls.Alert.Description.close_notify
          }));
          tls.flush(c);
        }
        c.closed(c);
      }
      c.reset(clearFail);
    };
    return c;
  };
  module2.exports = forge.tls = forge.tls || {};
  for (var key in tls) {
    if (typeof tls[key] !== "function") {
      forge.tls[key] = tls[key];
    }
  }
  forge.tls.prf_tls1 = prf_TLS1;
  forge.tls.hmac_sha1 = hmac_sha1;
  forge.tls.createSessionCache = tls.createSessionCache;
  forge.tls.createConnection = tls.createConnection;
});

// node_modules/node-forge/lib/aesCipherSuites.js
var require_aesCipherSuites = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_aes();
  require_tls();
  var tls = module2.exports = forge.tls;
  tls.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
    id: [0, 47],
    name: "TLS_RSA_WITH_AES_128_CBC_SHA",
    initSecurityParameters: function(sp) {
      sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
      sp.cipher_type = tls.CipherType.block;
      sp.enc_key_length = 16;
      sp.block_length = 16;
      sp.fixed_iv_length = 16;
      sp.record_iv_length = 16;
      sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
      sp.mac_length = 20;
      sp.mac_key_length = 20;
    },
    initConnectionState
  };
  tls.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
    id: [0, 53],
    name: "TLS_RSA_WITH_AES_256_CBC_SHA",
    initSecurityParameters: function(sp) {
      sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
      sp.cipher_type = tls.CipherType.block;
      sp.enc_key_length = 32;
      sp.block_length = 16;
      sp.fixed_iv_length = 16;
      sp.record_iv_length = 16;
      sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
      sp.mac_length = 20;
      sp.mac_key_length = 20;
    },
    initConnectionState
  };
  function initConnectionState(state, c, sp) {
    var client = c.entity === forge.tls.ConnectionEnd.client;
    state.read.cipherState = {
      init: false,
      cipher: forge.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key),
      iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
    };
    state.write.cipherState = {
      init: false,
      cipher: forge.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key),
      iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
    };
    state.read.cipherFunction = decrypt_aes_cbc_sha1;
    state.write.cipherFunction = encrypt_aes_cbc_sha1;
    state.read.macLength = state.write.macLength = sp.mac_length;
    state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
  }
  function encrypt_aes_cbc_sha1(record, s) {
    var rval = false;
    var mac = s.macFunction(s.macKey, s.sequenceNumber, record);
    record.fragment.putBytes(mac);
    s.updateSequenceNumber();
    var iv;
    if (record.version.minor === tls.Versions.TLS_1_0.minor) {
      iv = s.cipherState.init ? null : s.cipherState.iv;
    } else {
      iv = forge.random.getBytesSync(16);
    }
    s.cipherState.init = true;
    var cipher = s.cipherState.cipher;
    cipher.start({iv});
    if (record.version.minor >= tls.Versions.TLS_1_1.minor) {
      cipher.output.putBytes(iv);
    }
    cipher.update(record.fragment);
    if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
      record.fragment = cipher.output;
      record.length = record.fragment.length();
      rval = true;
    }
    return rval;
  }
  function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
    if (!decrypt) {
      var padding = blockSize - input.length() % blockSize;
      input.fillWithByte(padding - 1, padding);
    }
    return true;
  }
  function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
    var rval = true;
    if (decrypt) {
      var len = output.length();
      var paddingLength = output.last();
      for (var i = len - 1 - paddingLength; i < len - 1; ++i) {
        rval = rval && output.at(i) == paddingLength;
      }
      if (rval) {
        output.truncate(paddingLength + 1);
      }
    }
    return rval;
  }
  function decrypt_aes_cbc_sha1(record, s) {
    var rval = false;
    var iv;
    if (record.version.minor === tls.Versions.TLS_1_0.minor) {
      iv = s.cipherState.init ? null : s.cipherState.iv;
    } else {
      iv = record.fragment.getBytes(16);
    }
    s.cipherState.init = true;
    var cipher = s.cipherState.cipher;
    cipher.start({iv});
    cipher.update(record.fragment);
    rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
    var macLen = s.macLength;
    var mac = forge.random.getBytesSync(macLen);
    var len = cipher.output.length();
    if (len >= macLen) {
      record.fragment = cipher.output.getBytes(len - macLen);
      mac = cipher.output.getBytes(macLen);
    } else {
      record.fragment = cipher.output.getBytes();
    }
    record.fragment = forge.util.createBuffer(record.fragment);
    record.length = record.fragment.length();
    var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);
    s.updateSequenceNumber();
    rval = compareMacs(s.macKey, mac, mac2) && rval;
    return rval;
  }
  function compareMacs(key, mac1, mac2) {
    var hmac = forge.hmac.create();
    hmac.start("SHA1", key);
    hmac.update(mac1);
    mac1 = hmac.digest().getBytes();
    hmac.start(null, null);
    hmac.update(mac2);
    mac2 = hmac.digest().getBytes();
    return mac1 === mac2;
  }
});

// node_modules/node-forge/lib/debug.js
var require_debug = __commonJS((exports2, module2) => {
  var forge = require_forge();
  module2.exports = forge.debug = forge.debug || {};
  forge.debug.storage = {};
  forge.debug.get = function(cat, name) {
    var rval;
    if (typeof cat === "undefined") {
      rval = forge.debug.storage;
    } else if (cat in forge.debug.storage) {
      if (typeof name === "undefined") {
        rval = forge.debug.storage[cat];
      } else {
        rval = forge.debug.storage[cat][name];
      }
    }
    return rval;
  };
  forge.debug.set = function(cat, name, data) {
    if (!(cat in forge.debug.storage)) {
      forge.debug.storage[cat] = {};
    }
    forge.debug.storage[cat][name] = data;
  };
  forge.debug.clear = function(cat, name) {
    if (typeof cat === "undefined") {
      forge.debug.storage = {};
    } else if (cat in forge.debug.storage) {
      if (typeof name === "undefined") {
        delete forge.debug.storage[cat];
      } else {
        delete forge.debug.storage[cat][name];
      }
    }
  };
});

// node_modules/node-forge/lib/sha512.js
var require_sha512 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_md();
  require_util();
  var sha512 = module2.exports = forge.sha512 = forge.sha512 || {};
  forge.md.sha512 = forge.md.algorithms.sha512 = sha512;
  var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
  sha384.create = function() {
    return sha512.create("SHA-384");
  };
  forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
  forge.sha512.sha256 = forge.sha512.sha256 || {
    create: function() {
      return sha512.create("SHA-512/256");
    }
  };
  forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
  forge.sha512.sha224 = forge.sha512.sha224 || {
    create: function() {
      return sha512.create("SHA-512/224");
    }
  };
  forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
  sha512.create = function(algorithm) {
    if (!_initialized) {
      _init();
    }
    if (typeof algorithm === "undefined") {
      algorithm = "SHA-512";
    }
    if (!(algorithm in _states)) {
      throw new Error("Invalid SHA-512 algorithm: " + algorithm);
    }
    var _state = _states[algorithm];
    var _h = null;
    var _input = forge.util.createBuffer();
    var _w = new Array(80);
    for (var wi = 0; wi < 80; ++wi) {
      _w[wi] = new Array(2);
    }
    var digestLength = 64;
    switch (algorithm) {
      case "SHA-384":
        digestLength = 48;
        break;
      case "SHA-512/256":
        digestLength = 32;
        break;
      case "SHA-512/224":
        digestLength = 28;
        break;
    }
    var md = {
      algorithm: algorithm.replace("-", "").toLowerCase(),
      blockLength: 128,
      digestLength,
      messageLength: 0,
      fullMessageLength: null,
      messageLengthSize: 16
    };
    md.start = function() {
      md.messageLength = 0;
      md.fullMessageLength = md.messageLength128 = [];
      var int32s = md.messageLengthSize / 4;
      for (var i = 0; i < int32s; ++i) {
        md.fullMessageLength.push(0);
      }
      _input = forge.util.createBuffer();
      _h = new Array(_state.length);
      for (var i = 0; i < _state.length; ++i) {
        _h[i] = _state[i].slice(0);
      }
      return md;
    };
    md.start();
    md.update = function(msg, encoding) {
      if (encoding === "utf8") {
        msg = forge.util.encodeUtf8(msg);
      }
      var len = msg.length;
      md.messageLength += len;
      len = [len / 4294967296 >>> 0, len >>> 0];
      for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
        md.fullMessageLength[i] += len[1];
        len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
        md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
        len[0] = len[1] / 4294967296 >>> 0;
      }
      _input.putBytes(msg);
      _update(_h, _w, _input);
      if (_input.read > 2048 || _input.length() === 0) {
        _input.compact();
      }
      return md;
    };
    md.digest = function() {
      var finalBlock = forge.util.createBuffer();
      finalBlock.putBytes(_input.bytes());
      var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
      var overflow = remaining & md.blockLength - 1;
      finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
      var next, carry;
      var bits = md.fullMessageLength[0] * 8;
      for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
        next = md.fullMessageLength[i + 1] * 8;
        carry = next / 4294967296 >>> 0;
        bits += carry;
        finalBlock.putInt32(bits >>> 0);
        bits = next >>> 0;
      }
      finalBlock.putInt32(bits);
      var h = new Array(_h.length);
      for (var i = 0; i < _h.length; ++i) {
        h[i] = _h[i].slice(0);
      }
      _update(h, _w, finalBlock);
      var rval = forge.util.createBuffer();
      var hlen;
      if (algorithm === "SHA-512") {
        hlen = h.length;
      } else if (algorithm === "SHA-384") {
        hlen = h.length - 2;
      } else {
        hlen = h.length - 4;
      }
      for (var i = 0; i < hlen; ++i) {
        rval.putInt32(h[i][0]);
        if (i !== hlen - 1 || algorithm !== "SHA-512/224") {
          rval.putInt32(h[i][1]);
        }
      }
      return rval;
    };
    return md;
  };
  var _padding = null;
  var _initialized = false;
  var _k = null;
  var _states = null;
  function _init() {
    _padding = String.fromCharCode(128);
    _padding += forge.util.fillString(String.fromCharCode(0), 128);
    _k = [
      [1116352408, 3609767458],
      [1899447441, 602891725],
      [3049323471, 3964484399],
      [3921009573, 2173295548],
      [961987163, 4081628472],
      [1508970993, 3053834265],
      [2453635748, 2937671579],
      [2870763221, 3664609560],
      [3624381080, 2734883394],
      [310598401, 1164996542],
      [607225278, 1323610764],
      [1426881987, 3590304994],
      [1925078388, 4068182383],
      [2162078206, 991336113],
      [2614888103, 633803317],
      [3248222580, 3479774868],
      [3835390401, 2666613458],
      [4022224774, 944711139],
      [264347078, 2341262773],
      [604807628, 2007800933],
      [770255983, 1495990901],
      [1249150122, 1856431235],
      [1555081692, 3175218132],
      [1996064986, 2198950837],
      [2554220882, 3999719339],
      [2821834349, 766784016],
      [2952996808, 2566594879],
      [3210313671, 3203337956],
      [3336571891, 1034457026],
      [3584528711, 2466948901],
      [113926993, 3758326383],
      [338241895, 168717936],
      [666307205, 1188179964],
      [773529912, 1546045734],
      [1294757372, 1522805485],
      [1396182291, 2643833823],
      [1695183700, 2343527390],
      [1986661051, 1014477480],
      [2177026350, 1206759142],
      [2456956037, 344077627],
      [2730485921, 1290863460],
      [2820302411, 3158454273],
      [3259730800, 3505952657],
      [3345764771, 106217008],
      [3516065817, 3606008344],
      [3600352804, 1432725776],
      [4094571909, 1467031594],
      [275423344, 851169720],
      [430227734, 3100823752],
      [506948616, 1363258195],
      [659060556, 3750685593],
      [883997877, 3785050280],
      [958139571, 3318307427],
      [1322822218, 3812723403],
      [1537002063, 2003034995],
      [1747873779, 3602036899],
      [1955562222, 1575990012],
      [2024104815, 1125592928],
      [2227730452, 2716904306],
      [2361852424, 442776044],
      [2428436474, 593698344],
      [2756734187, 3733110249],
      [3204031479, 2999351573],
      [3329325298, 3815920427],
      [3391569614, 3928383900],
      [3515267271, 566280711],
      [3940187606, 3454069534],
      [4118630271, 4000239992],
      [116418474, 1914138554],
      [174292421, 2731055270],
      [289380356, 3203993006],
      [460393269, 320620315],
      [685471733, 587496836],
      [852142971, 1086792851],
      [1017036298, 365543100],
      [1126000580, 2618297676],
      [1288033470, 3409855158],
      [1501505948, 4234509866],
      [1607167915, 987167468],
      [1816402316, 1246189591]
    ];
    _states = {};
    _states["SHA-512"] = [
      [1779033703, 4089235720],
      [3144134277, 2227873595],
      [1013904242, 4271175723],
      [2773480762, 1595750129],
      [1359893119, 2917565137],
      [2600822924, 725511199],
      [528734635, 4215389547],
      [1541459225, 327033209]
    ];
    _states["SHA-384"] = [
      [3418070365, 3238371032],
      [1654270250, 914150663],
      [2438529370, 812702999],
      [355462360, 4144912697],
      [1731405415, 4290775857],
      [2394180231, 1750603025],
      [3675008525, 1694076839],
      [1203062813, 3204075428]
    ];
    _states["SHA-512/256"] = [
      [573645204, 4230739756],
      [2673172387, 3360449730],
      [596883563, 1867755857],
      [2520282905, 1497426621],
      [2519219938, 2827943907],
      [3193839141, 1401305490],
      [721525244, 746961066],
      [246885852, 2177182882]
    ];
    _states["SHA-512/224"] = [
      [2352822216, 424955298],
      [1944164710, 2312950998],
      [502970286, 855612546],
      [1738396948, 1479516111],
      [258812777, 2077511080],
      [2011393907, 79989058],
      [1067287976, 1780299464],
      [286451373, 2446758561]
    ];
    _initialized = true;
  }
  function _update(s, w, bytes) {
    var t1_hi, t1_lo;
    var t2_hi, t2_lo;
    var s0_hi, s0_lo;
    var s1_hi, s1_lo;
    var ch_hi, ch_lo;
    var maj_hi, maj_lo;
    var a_hi, a_lo;
    var b_hi, b_lo;
    var c_hi, c_lo;
    var d_hi, d_lo;
    var e_hi, e_lo;
    var f_hi, f_lo;
    var g_hi, g_lo;
    var h_hi, h_lo;
    var i, hi, lo, w2, w7, w15, w16;
    var len = bytes.length();
    while (len >= 128) {
      for (i = 0; i < 16; ++i) {
        w[i][0] = bytes.getInt32() >>> 0;
        w[i][1] = bytes.getInt32() >>> 0;
      }
      for (; i < 80; ++i) {
        w2 = w[i - 2];
        hi = w2[0];
        lo = w2[1];
        t1_hi = ((hi >>> 19 | lo << 13) ^ (lo >>> 29 | hi << 3) ^ hi >>> 6) >>> 0;
        t1_lo = ((hi << 13 | lo >>> 19) ^ (lo << 3 | hi >>> 29) ^ (hi << 26 | lo >>> 6)) >>> 0;
        w15 = w[i - 15];
        hi = w15[0];
        lo = w15[1];
        t2_hi = ((hi >>> 1 | lo << 31) ^ (hi >>> 8 | lo << 24) ^ hi >>> 7) >>> 0;
        t2_lo = ((hi << 31 | lo >>> 1) ^ (hi << 24 | lo >>> 8) ^ (hi << 25 | lo >>> 7)) >>> 0;
        w7 = w[i - 7];
        w16 = w[i - 16];
        lo = t1_lo + w7[1] + t2_lo + w16[1];
        w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
        w[i][1] = lo >>> 0;
      }
      a_hi = s[0][0];
      a_lo = s[0][1];
      b_hi = s[1][0];
      b_lo = s[1][1];
      c_hi = s[2][0];
      c_lo = s[2][1];
      d_hi = s[3][0];
      d_lo = s[3][1];
      e_hi = s[4][0];
      e_lo = s[4][1];
      f_hi = s[5][0];
      f_lo = s[5][1];
      g_hi = s[6][0];
      g_lo = s[6][1];
      h_hi = s[7][0];
      h_lo = s[7][1];
      for (i = 0; i < 80; ++i) {
        s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ (e_hi >>> 18 | e_lo << 14) ^ (e_lo >>> 9 | e_hi << 23)) >>> 0;
        s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ (e_hi << 14 | e_lo >>> 18) ^ (e_lo << 23 | e_hi >>> 9)) >>> 0;
        ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
        ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
        s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ (a_lo >>> 2 | a_hi << 30) ^ (a_lo >>> 7 | a_hi << 25)) >>> 0;
        s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ (a_lo << 30 | a_hi >>> 2) ^ (a_lo << 25 | a_hi >>> 7)) >>> 0;
        maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
        maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
        lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];
        t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0;
        t1_lo = lo >>> 0;
        lo = s0_lo + maj_lo;
        t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
        t2_lo = lo >>> 0;
        h_hi = g_hi;
        h_lo = g_lo;
        g_hi = f_hi;
        g_lo = f_lo;
        f_hi = e_hi;
        f_lo = e_lo;
        lo = d_lo + t1_lo;
        e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
        e_lo = lo >>> 0;
        d_hi = c_hi;
        d_lo = c_lo;
        c_hi = b_hi;
        c_lo = b_lo;
        b_hi = a_hi;
        b_lo = a_lo;
        lo = t1_lo + t2_lo;
        a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
        a_lo = lo >>> 0;
      }
      lo = s[0][1] + a_lo;
      s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
      s[0][1] = lo >>> 0;
      lo = s[1][1] + b_lo;
      s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
      s[1][1] = lo >>> 0;
      lo = s[2][1] + c_lo;
      s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
      s[2][1] = lo >>> 0;
      lo = s[3][1] + d_lo;
      s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
      s[3][1] = lo >>> 0;
      lo = s[4][1] + e_lo;
      s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
      s[4][1] = lo >>> 0;
      lo = s[5][1] + f_lo;
      s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
      s[5][1] = lo >>> 0;
      lo = s[6][1] + g_lo;
      s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
      s[6][1] = lo >>> 0;
      lo = s[7][1] + h_lo;
      s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
      s[7][1] = lo >>> 0;
      len -= 128;
    }
  }
});

// node_modules/node-forge/lib/asn1-validator.js
var require_asn1_validator = __commonJS((exports2) => {
  var forge = require_forge();
  require_asn1();
  var asn1 = forge.asn1;
  exports2.privateKeyValidator = {
    name: "PrivateKeyInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "PrivateKeyInfo.version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyVersion"
    }, {
      name: "PrivateKeyInfo.privateKeyAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "privateKeyOid"
      }]
    }, {
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: "privateKey"
    }]
  };
  exports2.publicKeyValidator = {
    name: "SubjectPublicKeyInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: "subjectPublicKeyInfo",
    value: [
      {
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      },
      {
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        composed: true,
        captureBitStringValue: "ed25519PublicKey"
      }
    ]
  };
});

// node_modules/node-forge/lib/ed25519.js
var require_ed25519 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_jsbn();
  require_random();
  require_sha512();
  require_util();
  var asn1Validator = require_asn1_validator();
  var publicKeyValidator = asn1Validator.publicKeyValidator;
  var privateKeyValidator = asn1Validator.privateKeyValidator;
  if (typeof BigInteger === "undefined") {
    BigInteger = forge.jsbn.BigInteger;
  }
  var BigInteger;
  var ByteBuffer = forge.util.ByteBuffer;
  var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
  forge.pki = forge.pki || {};
  module2.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};
  var ed25519 = forge.ed25519;
  ed25519.constants = {};
  ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
  ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
  ed25519.constants.SEED_BYTE_LENGTH = 32;
  ed25519.constants.SIGN_BYTE_LENGTH = 64;
  ed25519.constants.HASH_BYTE_LENGTH = 64;
  ed25519.generateKeyPair = function(options) {
    options = options || {};
    var seed = options.seed;
    if (seed === void 0) {
      seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
    } else if (typeof seed === "string") {
      if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
        throw new TypeError('"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length.");
      }
    } else if (!(seed instanceof Uint8Array)) {
      throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.');
    }
    seed = messageToNativeBuffer({message: seed, encoding: "binary"});
    var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
    var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
    for (var i = 0; i < 32; ++i) {
      sk[i] = seed[i];
    }
    crypto_sign_keypair(pk, sk);
    return {publicKey: pk, privateKey: sk};
  };
  ed25519.privateKeyFromAsn1 = function(obj) {
    var capture = {};
    var errors = [];
    var valid = forge.asn1.validate(obj, privateKeyValidator, capture, errors);
    if (!valid) {
      var error = new Error("Invalid Key.");
      error.errors = errors;
      throw error;
    }
    var oid = forge.asn1.derToOid(capture.privateKeyOid);
    var ed25519Oid = forge.oids.EdDSA25519;
    if (oid !== ed25519Oid) {
      throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
    }
    var privateKey = capture.privateKey;
    var privateKeyBytes = messageToNativeBuffer({
      message: forge.asn1.fromDer(privateKey).value,
      encoding: "binary"
    });
    return {privateKeyBytes};
  };
  ed25519.publicKeyFromAsn1 = function(obj) {
    var capture = {};
    var errors = [];
    var valid = forge.asn1.validate(obj, publicKeyValidator, capture, errors);
    if (!valid) {
      var error = new Error("Invalid Key.");
      error.errors = errors;
      throw error;
    }
    var oid = forge.asn1.derToOid(capture.publicKeyOid);
    var ed25519Oid = forge.oids.EdDSA25519;
    if (oid !== ed25519Oid) {
      throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
    }
    var publicKeyBytes = capture.ed25519PublicKey;
    if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
      throw new Error("Key length is invalid.");
    }
    return messageToNativeBuffer({
      message: publicKeyBytes,
      encoding: "binary"
    });
  };
  ed25519.publicKeyFromPrivateKey = function(options) {
    options = options || {};
    var privateKey = messageToNativeBuffer({
      message: options.privateKey,
      encoding: "binary"
    });
    if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
      throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
    }
    var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
    for (var i = 0; i < pk.length; ++i) {
      pk[i] = privateKey[32 + i];
    }
    return pk;
  };
  ed25519.sign = function(options) {
    options = options || {};
    var msg = messageToNativeBuffer(options);
    var privateKey = messageToNativeBuffer({
      message: options.privateKey,
      encoding: "binary"
    });
    if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
      var keyPair = ed25519.generateKeyPair({seed: privateKey});
      privateKey = keyPair.privateKey;
    } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
      throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
    }
    var signedMsg = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
    crypto_sign(signedMsg, msg, msg.length, privateKey);
    var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
    for (var i = 0; i < sig.length; ++i) {
      sig[i] = signedMsg[i];
    }
    return sig;
  };
  ed25519.verify = function(options) {
    options = options || {};
    var msg = messageToNativeBuffer(options);
    if (options.signature === void 0) {
      throw new TypeError('"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.');
    }
    var sig = messageToNativeBuffer({
      message: options.signature,
      encoding: "binary"
    });
    if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
      throw new TypeError('"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH);
    }
    var publicKey = messageToNativeBuffer({
      message: options.publicKey,
      encoding: "binary"
    });
    if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
      throw new TypeError('"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
    }
    var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
    var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
    var i;
    for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) {
      sm[i] = sig[i];
    }
    for (i = 0; i < msg.length; ++i) {
      sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];
    }
    return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
  };
  function messageToNativeBuffer(options) {
    var message = options.message;
    if (message instanceof Uint8Array || message instanceof NativeBuffer) {
      return message;
    }
    var encoding = options.encoding;
    if (message === void 0) {
      if (options.md) {
        message = options.md.digest().getBytes();
        encoding = "binary";
      } else {
        throw new TypeError('"options.message" or "options.md" not specified.');
      }
    }
    if (typeof message === "string" && !encoding) {
      throw new TypeError('"options.encoding" must be "binary" or "utf8".');
    }
    if (typeof message === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.from(message, encoding);
      }
      message = new ByteBuffer(message, encoding);
    } else if (!(message instanceof ByteBuffer)) {
      throw new TypeError('"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.');
    }
    var buffer = new NativeBuffer(message.length());
    for (var i = 0; i < buffer.length; ++i) {
      buffer[i] = message.at(i);
    }
    return buffer;
  }
  var gf0 = gf();
  var gf1 = gf([1]);
  var D = gf([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]);
  var D2 = gf([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]);
  var X = gf([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]);
  var Y = gf([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]);
  var L = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  var I = gf([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function sha512(msg, msgLen) {
    var md = forge.md.sha512.create();
    var buffer = new ByteBuffer(msg);
    md.update(buffer.getBytes(msgLen), "binary");
    var hash = md.digest().getBytes();
    if (typeof Buffer !== "undefined") {
      return Buffer.from(hash, "binary");
    }
    var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
    for (var i = 0; i < 64; ++i) {
      out[i] = hash.charCodeAt(i);
    }
    return out;
  }
  function crypto_sign_keypair(pk, sk) {
    var p = [gf(), gf(), gf(), gf()];
    var i;
    var d = sha512(sk, 32);
    d[0] &= 248;
    d[31] &= 127;
    d[31] |= 64;
    scalarbase(p, d);
    pack(pk, p);
    for (i = 0; i < 32; ++i) {
      sk[i + 32] = pk[i];
    }
    return 0;
  }
  function crypto_sign(sm, m, n, sk) {
    var i, j, x = new Float64Array(64);
    var p = [gf(), gf(), gf(), gf()];
    var d = sha512(sk, 32);
    d[0] &= 248;
    d[31] &= 127;
    d[31] |= 64;
    var smlen = n + 64;
    for (i = 0; i < n; ++i) {
      sm[64 + i] = m[i];
    }
    for (i = 0; i < 32; ++i) {
      sm[32 + i] = d[32 + i];
    }
    var r = sha512(sm.subarray(32), n + 32);
    reduce(r);
    scalarbase(p, r);
    pack(sm, p);
    for (i = 32; i < 64; ++i) {
      sm[i] = sk[i];
    }
    var h = sha512(sm, n + 64);
    reduce(h);
    for (i = 32; i < 64; ++i) {
      x[i] = 0;
    }
    for (i = 0; i < 32; ++i) {
      x[i] = r[i];
    }
    for (i = 0; i < 32; ++i) {
      for (j = 0; j < 32; j++) {
        x[i + j] += h[i] * d[j];
      }
    }
    modL(sm.subarray(32), x);
    return smlen;
  }
  function crypto_sign_open(m, sm, n, pk) {
    var i, mlen;
    var t = new NativeBuffer(32);
    var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
    mlen = -1;
    if (n < 64) {
      return -1;
    }
    if (unpackneg(q, pk)) {
      return -1;
    }
    for (i = 0; i < n; ++i) {
      m[i] = sm[i];
    }
    for (i = 0; i < 32; ++i) {
      m[i + 32] = pk[i];
    }
    var h = sha512(m, n);
    reduce(h);
    scalarmult(p, q, h);
    scalarbase(q, sm.subarray(32));
    add(p, q);
    pack(t, p);
    n -= 64;
    if (crypto_verify_32(sm, 0, t, 0)) {
      for (i = 0; i < n; ++i) {
        m[i] = 0;
      }
      return -1;
    }
    for (i = 0; i < n; ++i) {
      m[i] = sm[i + 64];
    }
    mlen = n;
    return mlen;
  }
  function modL(r, x) {
    var carry, i, j, k;
    for (i = 63; i >= 32; --i) {
      carry = 0;
      for (j = i - 32, k = i - 12; j < k; ++j) {
        x[j] += carry - 16 * x[i] * L[j - (i - 32)];
        carry = x[j] + 128 >> 8;
        x[j] -= carry * 256;
      }
      x[j] += carry;
      x[i] = 0;
    }
    carry = 0;
    for (j = 0; j < 32; ++j) {
      x[j] += carry - (x[31] >> 4) * L[j];
      carry = x[j] >> 8;
      x[j] &= 255;
    }
    for (j = 0; j < 32; ++j) {
      x[j] -= carry * L[j];
    }
    for (i = 0; i < 32; ++i) {
      x[i + 1] += x[i] >> 8;
      r[i] = x[i] & 255;
    }
  }
  function reduce(r) {
    var x = new Float64Array(64);
    for (var i = 0; i < 64; ++i) {
      x[i] = r[i];
      r[i] = 0;
    }
    modL(r, x);
  }
  function add(p, q) {
    var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
    Z(a, p[1], p[0]);
    Z(t, q[1], q[0]);
    M(a, a, t);
    A(b, p[0], p[1]);
    A(t, q[0], q[1]);
    M(b, b, t);
    M(c, p[3], q[3]);
    M(c, c, D2);
    M(d, p[2], q[2]);
    A(d, d, d);
    Z(e, b, a);
    Z(f, d, c);
    A(g, d, c);
    A(h, b, a);
    M(p[0], e, f);
    M(p[1], h, g);
    M(p[2], g, f);
    M(p[3], e, h);
  }
  function cswap(p, q, b) {
    for (var i = 0; i < 4; ++i) {
      sel25519(p[i], q[i], b);
    }
  }
  function pack(r, p) {
    var tx = gf(), ty = gf(), zi = gf();
    inv25519(zi, p[2]);
    M(tx, p[0], zi);
    M(ty, p[1], zi);
    pack25519(r, ty);
    r[31] ^= par25519(tx) << 7;
  }
  function pack25519(o, n) {
    var i, j, b;
    var m = gf(), t = gf();
    for (i = 0; i < 16; ++i) {
      t[i] = n[i];
    }
    car25519(t);
    car25519(t);
    car25519(t);
    for (j = 0; j < 2; ++j) {
      m[0] = t[0] - 65517;
      for (i = 1; i < 15; ++i) {
        m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
        m[i - 1] &= 65535;
      }
      m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
      b = m[15] >> 16 & 1;
      m[14] &= 65535;
      sel25519(t, m, 1 - b);
    }
    for (i = 0; i < 16; i++) {
      o[2 * i] = t[i] & 255;
      o[2 * i + 1] = t[i] >> 8;
    }
  }
  function unpackneg(r, p) {
    var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
    set25519(r[2], gf1);
    unpack25519(r[1], p);
    S(num, r[1]);
    M(den, num, D);
    Z(num, num, r[2]);
    A(den, r[2], den);
    S(den2, den);
    S(den4, den2);
    M(den6, den4, den2);
    M(t, den6, num);
    M(t, t, den);
    pow2523(t, t);
    M(t, t, num);
    M(t, t, den);
    M(t, t, den);
    M(r[0], t, den);
    S(chk, r[0]);
    M(chk, chk, den);
    if (neq25519(chk, num)) {
      M(r[0], r[0], I);
    }
    S(chk, r[0]);
    M(chk, chk, den);
    if (neq25519(chk, num)) {
      return -1;
    }
    if (par25519(r[0]) === p[31] >> 7) {
      Z(r[0], gf0, r[0]);
    }
    M(r[3], r[0], r[1]);
    return 0;
  }
  function unpack25519(o, n) {
    var i;
    for (i = 0; i < 16; ++i) {
      o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    }
    o[15] &= 32767;
  }
  function pow2523(o, i) {
    var c = gf();
    var a;
    for (a = 0; a < 16; ++a) {
      c[a] = i[a];
    }
    for (a = 250; a >= 0; --a) {
      S(c, c);
      if (a !== 1) {
        M(c, c, i);
      }
    }
    for (a = 0; a < 16; ++a) {
      o[a] = c[a];
    }
  }
  function neq25519(a, b) {
    var c = new NativeBuffer(32);
    var d = new NativeBuffer(32);
    pack25519(c, a);
    pack25519(d, b);
    return crypto_verify_32(c, 0, d, 0);
  }
  function crypto_verify_32(x, xi, y, yi) {
    return vn(x, xi, y, yi, 32);
  }
  function vn(x, xi, y, yi, n) {
    var i, d = 0;
    for (i = 0; i < n; ++i) {
      d |= x[xi + i] ^ y[yi + i];
    }
    return (1 & d - 1 >>> 8) - 1;
  }
  function par25519(a) {
    var d = new NativeBuffer(32);
    pack25519(d, a);
    return d[0] & 1;
  }
  function scalarmult(p, q, s) {
    var b, i;
    set25519(p[0], gf0);
    set25519(p[1], gf1);
    set25519(p[2], gf1);
    set25519(p[3], gf0);
    for (i = 255; i >= 0; --i) {
      b = s[i / 8 | 0] >> (i & 7) & 1;
      cswap(p, q, b);
      add(q, p);
      add(p, p);
      cswap(p, q, b);
    }
  }
  function scalarbase(p, s) {
    var q = [gf(), gf(), gf(), gf()];
    set25519(q[0], X);
    set25519(q[1], Y);
    set25519(q[2], gf1);
    M(q[3], X, Y);
    scalarmult(p, q, s);
  }
  function set25519(r, a) {
    var i;
    for (i = 0; i < 16; i++) {
      r[i] = a[i] | 0;
    }
  }
  function inv25519(o, i) {
    var c = gf();
    var a;
    for (a = 0; a < 16; ++a) {
      c[a] = i[a];
    }
    for (a = 253; a >= 0; --a) {
      S(c, c);
      if (a !== 2 && a !== 4) {
        M(c, c, i);
      }
    }
    for (a = 0; a < 16; ++a) {
      o[a] = c[a];
    }
  }
  function car25519(o) {
    var i, v, c = 1;
    for (i = 0; i < 16; ++i) {
      v = o[i] + c + 65535;
      c = Math.floor(v / 65536);
      o[i] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
  }
  function sel25519(p, q, b) {
    var t, c = ~(b - 1);
    for (var i = 0; i < 16; ++i) {
      t = c & (p[i] ^ q[i]);
      p[i] ^= t;
      q[i] ^= t;
    }
  }
  function gf(init) {
    var i, r = new Float64Array(16);
    if (init) {
      for (i = 0; i < init.length; ++i) {
        r[i] = init[i];
      }
    }
    return r;
  }
  function A(o, a, b) {
    for (var i = 0; i < 16; ++i) {
      o[i] = a[i] + b[i];
    }
  }
  function Z(o, a, b) {
    for (var i = 0; i < 16; ++i) {
      o[i] = a[i] - b[i];
    }
  }
  function S(o, a) {
    M(o, a, a);
  }
  function M(o, a, b) {
    var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
  }
});

// node_modules/node-forge/lib/kem.js
var require_kem = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util();
  require_random();
  require_jsbn();
  module2.exports = forge.kem = forge.kem || {};
  var BigInteger = forge.jsbn.BigInteger;
  forge.kem.rsa = {};
  forge.kem.rsa.create = function(kdf, options) {
    options = options || {};
    var prng = options.prng || forge.random;
    var kem = {};
    kem.encrypt = function(publicKey, keyLength) {
      var byteLength = Math.ceil(publicKey.n.bitLength() / 8);
      var r;
      do {
        r = new BigInteger(forge.util.bytesToHex(prng.getBytesSync(byteLength)), 16).mod(publicKey.n);
      } while (r.compareTo(BigInteger.ONE) <= 0);
      r = forge.util.hexToBytes(r.toString(16));
      var zeros = byteLength - r.length;
      if (zeros > 0) {
        r = forge.util.fillString(String.fromCharCode(0), zeros) + r;
      }
      var encapsulation = publicKey.encrypt(r, "NONE");
      var key = kdf.generate(r, keyLength);
      return {encapsulation, key};
    };
    kem.decrypt = function(privateKey, encapsulation, keyLength) {
      var r = privateKey.decrypt(encapsulation, "NONE");
      return kdf.generate(r, keyLength);
    };
    return kem;
  };
  forge.kem.kdf1 = function(md, digestLength) {
    _createKDF(this, md, 0, digestLength || md.digestLength);
  };
  forge.kem.kdf2 = function(md, digestLength) {
    _createKDF(this, md, 1, digestLength || md.digestLength);
  };
  function _createKDF(kdf, md, counterStart, digestLength) {
    kdf.generate = function(x, length) {
      var key = new forge.util.ByteBuffer();
      var k = Math.ceil(length / digestLength) + counterStart;
      var c = new forge.util.ByteBuffer();
      for (var i = counterStart; i < k; ++i) {
        c.putInt32(i);
        md.start();
        md.update(x + c.getBytes());
        var hash = md.digest();
        key.putBytes(hash.getBytes(digestLength));
      }
      key.truncate(key.length() - length);
      return key.getBytes();
    };
  }
});

// node_modules/node-forge/lib/log.js
var require_log = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util();
  module2.exports = forge.log = forge.log || {};
  forge.log.levels = [
    "none",
    "error",
    "warning",
    "info",
    "debug",
    "verbose",
    "max"
  ];
  var sLevelInfo = {};
  var sLoggers = [];
  var sConsoleLogger = null;
  forge.log.LEVEL_LOCKED = 1 << 1;
  forge.log.NO_LEVEL_CHECK = 1 << 2;
  forge.log.INTERPOLATE = 1 << 3;
  for (var i = 0; i < forge.log.levels.length; ++i) {
    level = forge.log.levels[i];
    sLevelInfo[level] = {
      index: i,
      name: level.toUpperCase()
    };
  }
  var level;
  forge.log.logMessage = function(message) {
    var messageLevelIndex = sLevelInfo[message.level].index;
    for (var i2 = 0; i2 < sLoggers.length; ++i2) {
      var logger2 = sLoggers[i2];
      if (logger2.flags & forge.log.NO_LEVEL_CHECK) {
        logger2.f(message);
      } else {
        var loggerLevelIndex = sLevelInfo[logger2.level].index;
        if (messageLevelIndex <= loggerLevelIndex) {
          logger2.f(logger2, message);
        }
      }
    }
  };
  forge.log.prepareStandard = function(message) {
    if (!("standard" in message)) {
      message.standard = sLevelInfo[message.level].name + " [" + message.category + "] " + message.message;
    }
  };
  forge.log.prepareFull = function(message) {
    if (!("full" in message)) {
      var args = [message.message];
      args = args.concat([]);
      message.full = forge.util.format.apply(this, args);
    }
  };
  forge.log.prepareStandardFull = function(message) {
    if (!("standardFull" in message)) {
      forge.log.prepareStandard(message);
      message.standardFull = message.standard;
    }
  };
  if (true) {
    levels = ["error", "warning", "info", "debug", "verbose"];
    for (i = 0; i < levels.length; ++i) {
      (function(level2) {
        forge.log[level2] = function(category, message) {
          var args = Array.prototype.slice.call(arguments).slice(2);
          var msg = {
            timestamp: new Date(),
            level: level2,
            category,
            message,
            arguments: args
          };
          forge.log.logMessage(msg);
        };
      })(levels[i]);
    }
  }
  var levels;
  var i;
  forge.log.makeLogger = function(logFunction) {
    var logger2 = {
      flags: 0,
      f: logFunction
    };
    forge.log.setLevel(logger2, "none");
    return logger2;
  };
  forge.log.setLevel = function(logger2, level2) {
    var rval = false;
    if (logger2 && !(logger2.flags & forge.log.LEVEL_LOCKED)) {
      for (var i2 = 0; i2 < forge.log.levels.length; ++i2) {
        var aValidLevel = forge.log.levels[i2];
        if (level2 == aValidLevel) {
          logger2.level = level2;
          rval = true;
          break;
        }
      }
    }
    return rval;
  };
  forge.log.lock = function(logger2, lock2) {
    if (typeof lock2 === "undefined" || lock2) {
      logger2.flags |= forge.log.LEVEL_LOCKED;
    } else {
      logger2.flags &= ~forge.log.LEVEL_LOCKED;
    }
  };
  forge.log.addLogger = function(logger2) {
    sLoggers.push(logger2);
  };
  if (typeof console !== "undefined" && "log" in console) {
    if (console.error && console.warn && console.info && console.debug) {
      levelHandlers = {
        error: console.error,
        warning: console.warn,
        info: console.info,
        debug: console.debug,
        verbose: console.debug
      };
      f = function(logger2, message) {
        forge.log.prepareStandard(message);
        var handler = levelHandlers[message.level];
        var args = [message.standard];
        args = args.concat(message["arguments"].slice());
        handler.apply(console, args);
      };
      logger = forge.log.makeLogger(f);
    } else {
      f = function(logger2, message) {
        forge.log.prepareStandardFull(message);
        console.log(message.standardFull);
      };
      logger = forge.log.makeLogger(f);
    }
    forge.log.setLevel(logger, "debug");
    forge.log.addLogger(logger);
    sConsoleLogger = logger;
  } else {
    console = {
      log: function() {
      }
    };
  }
  var logger;
  var levelHandlers;
  var f;
  if (sConsoleLogger !== null) {
    query = forge.util.getQueryVariables();
    if ("console.level" in query) {
      forge.log.setLevel(sConsoleLogger, query["console.level"].slice(-1)[0]);
    }
    if ("console.lock" in query) {
      lock = query["console.lock"].slice(-1)[0];
      if (lock == "true") {
        forge.log.lock(sConsoleLogger);
      }
    }
  }
  var query;
  var lock;
  forge.log.consoleLogger = sConsoleLogger;
});

// node_modules/node-forge/lib/md.all.js
var require_md_all = __commonJS((exports2, module2) => {
  module2.exports = require_md();
  require_md5();
  require_sha1();
  require_sha256();
  require_sha512();
});

// node_modules/node-forge/lib/pkcs7.js
var require_pkcs7 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_aes();
  require_asn1();
  require_des();
  require_oids();
  require_pem();
  require_pkcs7asn1();
  require_random();
  require_util();
  require_x509();
  var asn1 = forge.asn1;
  var p7 = module2.exports = forge.pkcs7 = forge.pkcs7 || {};
  p7.messageFromPem = function(pem) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "PKCS7") {
      var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
      error.headerType = msg.type;
      throw error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
    }
    var obj = asn1.fromDer(msg.body);
    return p7.messageFromAsn1(obj);
  };
  p7.messageToPem = function(msg, maxline) {
    var pemObj = {
      type: "PKCS7",
      body: asn1.toDer(msg.toAsn1()).getBytes()
    };
    return forge.pem.encode(pemObj, {maxline});
  };
  p7.messageFromAsn1 = function(obj) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
      var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
      error.errors = errors;
      throw error;
    }
    var contentType = asn1.derToOid(capture.contentType);
    var msg;
    switch (contentType) {
      case forge.pki.oids.envelopedData:
        msg = p7.createEnvelopedData();
        break;
      case forge.pki.oids.encryptedData:
        msg = p7.createEncryptedData();
        break;
      case forge.pki.oids.signedData:
        msg = p7.createSignedData();
        break;
      default:
        throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
    }
    msg.fromAsn1(capture.content.value[0]);
    return msg;
  };
  p7.createSignedData = function() {
    var msg = null;
    msg = {
      type: forge.pki.oids.signedData,
      version: 1,
      certificates: [],
      crls: [],
      signers: [],
      digestAlgorithmIdentifiers: [],
      contentInfo: null,
      signerInfos: [],
      fromAsn1: function(obj) {
        _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
        msg.certificates = [];
        msg.crls = [];
        msg.digestAlgorithmIdentifiers = [];
        msg.contentInfo = null;
        msg.signerInfos = [];
        if (msg.rawCapture.certificates) {
          var certs = msg.rawCapture.certificates.value;
          for (var i = 0; i < certs.length; ++i) {
            msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));
          }
        }
      },
      toAsn1: function() {
        if (!msg.contentInfo) {
          msg.sign();
        }
        var certs = [];
        for (var i = 0; i < msg.certificates.length; ++i) {
          certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));
        }
        var crls = [];
        var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.digestAlgorithmIdentifiers),
            msg.contentInfo
          ])
        ]);
        if (certs.length > 0) {
          signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));
        }
        if (crls.length > 0) {
          signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));
        }
        signedData.value[0].value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.signerInfos));
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()),
          signedData
        ]);
      },
      addSigner: function(signer) {
        var issuer = signer.issuer;
        var serialNumber = signer.serialNumber;
        if (signer.certificate) {
          var cert = signer.certificate;
          if (typeof cert === "string") {
            cert = forge.pki.certificateFromPem(cert);
          }
          issuer = cert.issuer.attributes;
          serialNumber = cert.serialNumber;
        }
        var key = signer.key;
        if (!key) {
          throw new Error("Could not add PKCS#7 signer; no private key specified.");
        }
        if (typeof key === "string") {
          key = forge.pki.privateKeyFromPem(key);
        }
        var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;
        switch (digestAlgorithm) {
          case forge.pki.oids.sha1:
          case forge.pki.oids.sha256:
          case forge.pki.oids.sha384:
          case forge.pki.oids.sha512:
          case forge.pki.oids.md5:
            break;
          default:
            throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm);
        }
        var authenticatedAttributes = signer.authenticatedAttributes || [];
        if (authenticatedAttributes.length > 0) {
          var contentType = false;
          var messageDigest = false;
          for (var i = 0; i < authenticatedAttributes.length; ++i) {
            var attr = authenticatedAttributes[i];
            if (!contentType && attr.type === forge.pki.oids.contentType) {
              contentType = true;
              if (messageDigest) {
                break;
              }
              continue;
            }
            if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {
              messageDigest = true;
              if (contentType) {
                break;
              }
              continue;
            }
          }
          if (!contentType || !messageDigest) {
            throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
          }
        }
        msg.signers.push({
          key,
          version: 1,
          issuer,
          serialNumber,
          digestAlgorithm,
          signatureAlgorithm: forge.pki.oids.rsaEncryption,
          signature: null,
          authenticatedAttributes,
          unauthenticatedAttributes: []
        });
      },
      sign: function(options) {
        options = options || {};
        if (typeof msg.content !== "object" || msg.contentInfo === null) {
          msg.contentInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes())
          ]);
          if ("content" in msg) {
            var content;
            if (msg.content instanceof forge.util.ByteBuffer) {
              content = msg.content.bytes();
            } else if (typeof msg.content === "string") {
              content = forge.util.encodeUtf8(msg.content);
            }
            if (options.detached) {
              msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
            } else {
              msg.contentInfo.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content)
              ]));
            }
          }
        }
        if (msg.signers.length === 0) {
          return;
        }
        var mds = addDigestAlgorithmIds();
        addSignerInfos(mds);
      },
      verify: function() {
        throw new Error("PKCS#7 signature verification not yet implemented.");
      },
      addCertificate: function(cert) {
        if (typeof cert === "string") {
          cert = forge.pki.certificateFromPem(cert);
        }
        msg.certificates.push(cert);
      },
      addCertificateRevokationList: function(crl) {
        throw new Error("PKCS#7 CRL support not yet implemented.");
      }
    };
    return msg;
    function addDigestAlgorithmIds() {
      var mds = {};
      for (var i = 0; i < msg.signers.length; ++i) {
        var signer = msg.signers[i];
        var oid = signer.digestAlgorithm;
        if (!(oid in mds)) {
          mds[oid] = forge.md[forge.pki.oids[oid]].create();
        }
        if (signer.authenticatedAttributes.length === 0) {
          signer.md = mds[oid];
        } else {
          signer.md = forge.md[forge.pki.oids[oid]].create();
        }
      }
      msg.digestAlgorithmIdentifiers = [];
      for (var oid in mds) {
        msg.digestAlgorithmIdentifiers.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oid).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]));
      }
      return mds;
    }
    function addSignerInfos(mds) {
      var content;
      if (msg.detachedContent) {
        content = msg.detachedContent;
      } else {
        content = msg.contentInfo.value[1];
        content = content.value[0];
      }
      if (!content) {
        throw new Error("Could not sign PKCS#7 message; there is no content to sign.");
      }
      var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
      var bytes = asn1.toDer(content);
      bytes.getByte();
      asn1.getBerValueLength(bytes);
      bytes = bytes.getBytes();
      for (var oid in mds) {
        mds[oid].start().update(bytes);
      }
      var signingTime = new Date();
      for (var i = 0; i < msg.signers.length; ++i) {
        var signer = msg.signers[i];
        if (signer.authenticatedAttributes.length === 0) {
          if (contentType !== forge.pki.oids.data) {
            throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.");
          }
        } else {
          signer.authenticatedAttributesAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
          var attrsAsn1 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, []);
          for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
            var attr = signer.authenticatedAttributes[ai];
            if (attr.type === forge.pki.oids.messageDigest) {
              attr.value = mds[signer.digestAlgorithm].digest();
            } else if (attr.type === forge.pki.oids.signingTime) {
              if (!attr.value) {
                attr.value = signingTime;
              }
            }
            attrsAsn1.value.push(_attributeToAsn1(attr));
            signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
          }
          bytes = asn1.toDer(attrsAsn1).getBytes();
          signer.md.start().update(bytes);
        }
        signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
      }
      msg.signerInfos = _signersToAsn1(msg.signers);
    }
  };
  p7.createEncryptedData = function() {
    var msg = null;
    msg = {
      type: forge.pki.oids.encryptedData,
      version: 0,
      encryptedContent: {
        algorithm: forge.pki.oids["aes256-CBC"]
      },
      fromAsn1: function(obj) {
        _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
      },
      decrypt: function(key) {
        if (key !== void 0) {
          msg.encryptedContent.key = key;
        }
        _decryptContent(msg);
      }
    };
    return msg;
  };
  p7.createEnvelopedData = function() {
    var msg = null;
    msg = {
      type: forge.pki.oids.envelopedData,
      version: 0,
      recipients: [],
      encryptedContent: {
        algorithm: forge.pki.oids["aes256-CBC"]
      },
      fromAsn1: function(obj) {
        var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
        msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
      },
      toAsn1: function() {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()),
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, _recipientsToAsn1(msg.recipients)),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, _encryptedContentToAsn1(msg.encryptedContent))
            ])
          ])
        ]);
      },
      findRecipient: function(cert) {
        var sAttr = cert.issuer.attributes;
        for (var i = 0; i < msg.recipients.length; ++i) {
          var r = msg.recipients[i];
          var rAttr = r.issuer;
          if (r.serialNumber !== cert.serialNumber) {
            continue;
          }
          if (rAttr.length !== sAttr.length) {
            continue;
          }
          var match = true;
          for (var j = 0; j < sAttr.length; ++j) {
            if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
              match = false;
              break;
            }
          }
          if (match) {
            return r;
          }
        }
        return null;
      },
      decrypt: function(recipient, privKey) {
        if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
          switch (recipient.encryptedContent.algorithm) {
            case forge.pki.oids.rsaEncryption:
            case forge.pki.oids.desCBC:
              var key = privKey.decrypt(recipient.encryptedContent.content);
              msg.encryptedContent.key = forge.util.createBuffer(key);
              break;
            default:
              throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
          }
        }
        _decryptContent(msg);
      },
      addRecipient: function(cert) {
        msg.recipients.push({
          version: 0,
          issuer: cert.issuer.attributes,
          serialNumber: cert.serialNumber,
          encryptedContent: {
            algorithm: forge.pki.oids.rsaEncryption,
            key: cert.publicKey
          }
        });
      },
      encrypt: function(key, cipher) {
        if (msg.encryptedContent.content === void 0) {
          cipher = cipher || msg.encryptedContent.algorithm;
          key = key || msg.encryptedContent.key;
          var keyLen, ivLen, ciphFn;
          switch (cipher) {
            case forge.pki.oids["aes128-CBC"]:
              keyLen = 16;
              ivLen = 16;
              ciphFn = forge.aes.createEncryptionCipher;
              break;
            case forge.pki.oids["aes192-CBC"]:
              keyLen = 24;
              ivLen = 16;
              ciphFn = forge.aes.createEncryptionCipher;
              break;
            case forge.pki.oids["aes256-CBC"]:
              keyLen = 32;
              ivLen = 16;
              ciphFn = forge.aes.createEncryptionCipher;
              break;
            case forge.pki.oids["des-EDE3-CBC"]:
              keyLen = 24;
              ivLen = 8;
              ciphFn = forge.des.createEncryptionCipher;
              break;
            default:
              throw new Error("Unsupported symmetric cipher, OID " + cipher);
          }
          if (key === void 0) {
            key = forge.util.createBuffer(forge.random.getBytes(keyLen));
          } else if (key.length() != keyLen) {
            throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
          }
          msg.encryptedContent.algorithm = cipher;
          msg.encryptedContent.key = key;
          msg.encryptedContent.parameter = forge.util.createBuffer(forge.random.getBytes(ivLen));
          var ciph = ciphFn(key);
          ciph.start(msg.encryptedContent.parameter.copy());
          ciph.update(msg.content);
          if (!ciph.finish()) {
            throw new Error("Symmetric encryption failed.");
          }
          msg.encryptedContent.content = ciph.output;
        }
        for (var i = 0; i < msg.recipients.length; ++i) {
          var recipient = msg.recipients[i];
          if (recipient.encryptedContent.content !== void 0) {
            continue;
          }
          switch (recipient.encryptedContent.algorithm) {
            case forge.pki.oids.rsaEncryption:
              recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(msg.encryptedContent.key.data);
              break;
            default:
              throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
          }
        }
      }
    };
    return msg;
  };
  function _recipientFromAsn1(obj) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
      var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
      error.errors = errors;
      throw error;
    }
    return {
      version: capture.version.charCodeAt(0),
      issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
      serialNumber: forge.util.createBuffer(capture.serial).toHex(),
      encryptedContent: {
        algorithm: asn1.derToOid(capture.encAlgorithm),
        parameter: capture.encParameter.value,
        content: capture.encKey
      }
    };
  }
  function _recipientToAsn1(obj) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        forge.pki.distinguishedNameToAsn1({attributes: obj.issuer}),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.encryptedContent.content)
    ]);
  }
  function _recipientsFromAsn1(infos) {
    var ret = [];
    for (var i = 0; i < infos.length; ++i) {
      ret.push(_recipientFromAsn1(infos[i]));
    }
    return ret;
  }
  function _recipientsToAsn1(recipients) {
    var ret = [];
    for (var i = 0; i < recipients.length; ++i) {
      ret.push(_recipientToAsn1(recipients[i]));
    }
    return ret;
  }
  function _signerToAsn1(obj) {
    var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        forge.pki.distinguishedNameToAsn1({attributes: obj.issuer}),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.digestAlgorithm).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ])
    ]);
    if (obj.authenticatedAttributesAsn1) {
      rval.value.push(obj.authenticatedAttributesAsn1);
    }
    rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.signatureAlgorithm).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
    ]));
    rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature));
    if (obj.unauthenticatedAttributes.length > 0) {
      var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
      for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
        var attr = obj.unauthenticatedAttributes[i];
        attrsAsn1.values.push(_attributeToAsn1(attr));
      }
      rval.value.push(attrsAsn1);
    }
    return rval;
  }
  function _signersToAsn1(signers) {
    var ret = [];
    for (var i = 0; i < signers.length; ++i) {
      ret.push(_signerToAsn1(signers[i]));
    }
    return ret;
  }
  function _attributeToAsn1(attr) {
    var value;
    if (attr.type === forge.pki.oids.contentType) {
      value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.value).getBytes());
    } else if (attr.type === forge.pki.oids.messageDigest) {
      value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, attr.value.bytes());
    } else if (attr.type === forge.pki.oids.signingTime) {
      var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
      var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
      var date = attr.value;
      if (typeof date === "string") {
        var timestamp = Date.parse(date);
        if (!isNaN(timestamp)) {
          date = new Date(timestamp);
        } else if (date.length === 13) {
          date = asn1.utcTimeToDate(date);
        } else {
          date = asn1.generalizedTimeToDate(date);
        }
      }
      if (date >= jan_1_1950 && date < jan_1_2050) {
        value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
      } else {
        value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
      }
    }
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
        value
      ])
    ]);
  }
  function _encryptedContentToAsn1(ec) {
    return [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ec.algorithm).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.parameter.getBytes())
      ]),
      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.content.getBytes())
      ])
    ];
  }
  function _fromAsn1(msg, obj, validator) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(obj, validator, capture, errors)) {
      var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
      error.errors = error;
      throw error;
    }
    var contentType = asn1.derToOid(capture.contentType);
    if (contentType !== forge.pki.oids.data) {
      throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
    }
    if (capture.encryptedContent) {
      var content = "";
      if (forge.util.isArray(capture.encryptedContent)) {
        for (var i = 0; i < capture.encryptedContent.length; ++i) {
          if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
            throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
          }
          content += capture.encryptedContent[i].value;
        }
      } else {
        content = capture.encryptedContent;
      }
      msg.encryptedContent = {
        algorithm: asn1.derToOid(capture.encAlgorithm),
        parameter: forge.util.createBuffer(capture.encParameter.value),
        content: forge.util.createBuffer(content)
      };
    }
    if (capture.content) {
      var content = "";
      if (forge.util.isArray(capture.content)) {
        for (var i = 0; i < capture.content.length; ++i) {
          if (capture.content[i].type !== asn1.Type.OCTETSTRING) {
            throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
          }
          content += capture.content[i].value;
        }
      } else {
        content = capture.content;
      }
      msg.content = forge.util.createBuffer(content);
    }
    msg.version = capture.version.charCodeAt(0);
    msg.rawCapture = capture;
    return capture;
  }
  function _decryptContent(msg) {
    if (msg.encryptedContent.key === void 0) {
      throw new Error("Symmetric key not available.");
    }
    if (msg.content === void 0) {
      var ciph;
      switch (msg.encryptedContent.algorithm) {
        case forge.pki.oids["aes128-CBC"]:
        case forge.pki.oids["aes192-CBC"]:
        case forge.pki.oids["aes256-CBC"]:
          ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
          break;
        case forge.pki.oids["desCBC"]:
        case forge.pki.oids["des-EDE3-CBC"]:
          ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
          break;
        default:
          throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
      }
      ciph.start(msg.encryptedContent.parameter);
      ciph.update(msg.encryptedContent.content);
      if (!ciph.finish()) {
        throw new Error("Symmetric decryption failed.");
      }
      msg.content = ciph.output;
    }
  }
});

// node_modules/node-forge/lib/ssh.js
var require_ssh = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_aes();
  require_hmac();
  require_md5();
  require_sha1();
  require_util();
  var ssh = module2.exports = forge.ssh = forge.ssh || {};
  ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {
    comment = comment || "";
    passphrase = passphrase || "";
    var algorithm = "ssh-rsa";
    var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
    var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
    ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
    ppk += "Comment: " + comment + "\r\n";
    var pubbuffer = forge.util.createBuffer();
    _addStringToBuffer(pubbuffer, algorithm);
    _addBigIntegerToBuffer(pubbuffer, privateKey.e);
    _addBigIntegerToBuffer(pubbuffer, privateKey.n);
    var pub = forge.util.encode64(pubbuffer.bytes(), 64);
    var length = Math.floor(pub.length / 66) + 1;
    ppk += "Public-Lines: " + length + "\r\n";
    ppk += pub;
    var privbuffer = forge.util.createBuffer();
    _addBigIntegerToBuffer(privbuffer, privateKey.d);
    _addBigIntegerToBuffer(privbuffer, privateKey.p);
    _addBigIntegerToBuffer(privbuffer, privateKey.q);
    _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
    var priv;
    if (!passphrase) {
      priv = forge.util.encode64(privbuffer.bytes(), 64);
    } else {
      var encLen = privbuffer.length() + 16 - 1;
      encLen -= encLen % 16;
      var padding = _sha1(privbuffer.bytes());
      padding.truncate(padding.length() - encLen + privbuffer.length());
      privbuffer.putBuffer(padding);
      var aeskey = forge.util.createBuffer();
      aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
      aeskey.putBuffer(_sha1("\0\0\0", passphrase));
      var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
      cipher.start(forge.util.createBuffer().fillWithByte(0, 16));
      cipher.update(privbuffer.copy());
      cipher.finish();
      var encrypted = cipher.output;
      encrypted.truncate(16);
      priv = forge.util.encode64(encrypted.bytes(), 64);
    }
    length = Math.floor(priv.length / 66) + 1;
    ppk += "\r\nPrivate-Lines: " + length + "\r\n";
    ppk += priv;
    var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
    var macbuffer = forge.util.createBuffer();
    _addStringToBuffer(macbuffer, algorithm);
    _addStringToBuffer(macbuffer, encryptionAlgorithm);
    _addStringToBuffer(macbuffer, comment);
    macbuffer.putInt32(pubbuffer.length());
    macbuffer.putBuffer(pubbuffer);
    macbuffer.putInt32(privbuffer.length());
    macbuffer.putBuffer(privbuffer);
    var hmac = forge.hmac.create();
    hmac.start("sha1", mackey);
    hmac.update(macbuffer.bytes());
    ppk += "\r\nPrivate-MAC: " + hmac.digest().toHex() + "\r\n";
    return ppk;
  };
  ssh.publicKeyToOpenSSH = function(key, comment) {
    var type = "ssh-rsa";
    comment = comment || "";
    var buffer = forge.util.createBuffer();
    _addStringToBuffer(buffer, type);
    _addBigIntegerToBuffer(buffer, key.e);
    _addBigIntegerToBuffer(buffer, key.n);
    return type + " " + forge.util.encode64(buffer.bytes()) + " " + comment;
  };
  ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
    if (!passphrase) {
      return forge.pki.privateKeyToPem(privateKey);
    }
    return forge.pki.encryptRsaPrivateKey(privateKey, passphrase, {legacy: true, algorithm: "aes128"});
  };
  ssh.getPublicKeyFingerprint = function(key, options) {
    options = options || {};
    var md = options.md || forge.md.md5.create();
    var type = "ssh-rsa";
    var buffer = forge.util.createBuffer();
    _addStringToBuffer(buffer, type);
    _addBigIntegerToBuffer(buffer, key.e);
    _addBigIntegerToBuffer(buffer, key.n);
    md.start();
    md.update(buffer.getBytes());
    var digest = md.digest();
    if (options.encoding === "hex") {
      var hex = digest.toHex();
      if (options.delimiter) {
        return hex.match(/.{2}/g).join(options.delimiter);
      }
      return hex;
    } else if (options.encoding === "binary") {
      return digest.getBytes();
    } else if (options.encoding) {
      throw new Error('Unknown encoding "' + options.encoding + '".');
    }
    return digest;
  };
  function _addBigIntegerToBuffer(buffer, val) {
    var hexVal = val.toString(16);
    if (hexVal[0] >= "8") {
      hexVal = "00" + hexVal;
    }
    var bytes = forge.util.hexToBytes(hexVal);
    buffer.putInt32(bytes.length);
    buffer.putBytes(bytes);
  }
  function _addStringToBuffer(buffer, val) {
    buffer.putInt32(val.length);
    buffer.putString(val);
  }
  function _sha1() {
    var sha = forge.md.sha1.create();
    var num = arguments.length;
    for (var i = 0; i < num; ++i) {
      sha.update(arguments[i]);
    }
    return sha.digest();
  }
});

// node_modules/node-forge/lib/task.js
var require_task = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_debug();
  require_log();
  require_util();
  var cat = "forge.task";
  var sVL = 0;
  var sTasks = {};
  var sNextTaskId = 0;
  forge.debug.set(cat, "tasks", sTasks);
  var sTaskQueues = {};
  forge.debug.set(cat, "queues", sTaskQueues);
  var sNoTaskName = "?";
  var sMaxRecursions = 30;
  var sTimeSlice = 20;
  var READY = "ready";
  var RUNNING = "running";
  var BLOCKED = "blocked";
  var SLEEPING = "sleeping";
  var DONE = "done";
  var ERROR = "error";
  var STOP = "stop";
  var START = "start";
  var BLOCK = "block";
  var UNBLOCK = "unblock";
  var SLEEP = "sleep";
  var WAKEUP = "wakeup";
  var CANCEL = "cancel";
  var FAIL = "fail";
  var sStateTable = {};
  sStateTable[READY] = {};
  sStateTable[READY][STOP] = READY;
  sStateTable[READY][START] = RUNNING;
  sStateTable[READY][CANCEL] = DONE;
  sStateTable[READY][FAIL] = ERROR;
  sStateTable[RUNNING] = {};
  sStateTable[RUNNING][STOP] = READY;
  sStateTable[RUNNING][START] = RUNNING;
  sStateTable[RUNNING][BLOCK] = BLOCKED;
  sStateTable[RUNNING][UNBLOCK] = RUNNING;
  sStateTable[RUNNING][SLEEP] = SLEEPING;
  sStateTable[RUNNING][WAKEUP] = RUNNING;
  sStateTable[RUNNING][CANCEL] = DONE;
  sStateTable[RUNNING][FAIL] = ERROR;
  sStateTable[BLOCKED] = {};
  sStateTable[BLOCKED][STOP] = BLOCKED;
  sStateTable[BLOCKED][START] = BLOCKED;
  sStateTable[BLOCKED][BLOCK] = BLOCKED;
  sStateTable[BLOCKED][UNBLOCK] = BLOCKED;
  sStateTable[BLOCKED][SLEEP] = BLOCKED;
  sStateTable[BLOCKED][WAKEUP] = BLOCKED;
  sStateTable[BLOCKED][CANCEL] = DONE;
  sStateTable[BLOCKED][FAIL] = ERROR;
  sStateTable[SLEEPING] = {};
  sStateTable[SLEEPING][STOP] = SLEEPING;
  sStateTable[SLEEPING][START] = SLEEPING;
  sStateTable[SLEEPING][BLOCK] = SLEEPING;
  sStateTable[SLEEPING][UNBLOCK] = SLEEPING;
  sStateTable[SLEEPING][SLEEP] = SLEEPING;
  sStateTable[SLEEPING][WAKEUP] = SLEEPING;
  sStateTable[SLEEPING][CANCEL] = DONE;
  sStateTable[SLEEPING][FAIL] = ERROR;
  sStateTable[DONE] = {};
  sStateTable[DONE][STOP] = DONE;
  sStateTable[DONE][START] = DONE;
  sStateTable[DONE][BLOCK] = DONE;
  sStateTable[DONE][UNBLOCK] = DONE;
  sStateTable[DONE][SLEEP] = DONE;
  sStateTable[DONE][WAKEUP] = DONE;
  sStateTable[DONE][CANCEL] = DONE;
  sStateTable[DONE][FAIL] = ERROR;
  sStateTable[ERROR] = {};
  sStateTable[ERROR][STOP] = ERROR;
  sStateTable[ERROR][START] = ERROR;
  sStateTable[ERROR][BLOCK] = ERROR;
  sStateTable[ERROR][UNBLOCK] = ERROR;
  sStateTable[ERROR][SLEEP] = ERROR;
  sStateTable[ERROR][WAKEUP] = ERROR;
  sStateTable[ERROR][CANCEL] = ERROR;
  sStateTable[ERROR][FAIL] = ERROR;
  var Task = function(options) {
    this.id = -1;
    this.name = options.name || sNoTaskName;
    this.parent = options.parent || null;
    this.run = options.run;
    this.subtasks = [];
    this.error = false;
    this.state = READY;
    this.blocks = 0;
    this.timeoutId = null;
    this.swapTime = null;
    this.userData = null;
    this.id = sNextTaskId++;
    sTasks[this.id] = this;
    if (sVL >= 1) {
      forge.log.verbose(cat, "[%s][%s] init", this.id, this.name, this);
    }
  };
  Task.prototype.debug = function(msg) {
    msg = msg || "";
    forge.log.debug(cat, msg, "[%s][%s] task:", this.id, this.name, this, "subtasks:", this.subtasks.length, "queue:", sTaskQueues);
  };
  Task.prototype.next = function(name, subrun) {
    if (typeof name === "function") {
      subrun = name;
      name = this.name;
    }
    var subtask = new Task({
      run: subrun,
      name,
      parent: this
    });
    subtask.state = RUNNING;
    subtask.type = this.type;
    subtask.successCallback = this.successCallback || null;
    subtask.failureCallback = this.failureCallback || null;
    this.subtasks.push(subtask);
    return this;
  };
  Task.prototype.parallel = function(name, subrun) {
    if (forge.util.isArray(name)) {
      subrun = name;
      name = this.name;
    }
    return this.next(name, function(task) {
      var ptask = task;
      ptask.block(subrun.length);
      var startParallelTask = function(pname2, pi2) {
        forge.task.start({
          type: pname2,
          run: function(task2) {
            subrun[pi2](task2);
          },
          success: function(task2) {
            ptask.unblock();
          },
          failure: function(task2) {
            ptask.unblock();
          }
        });
      };
      for (var i = 0; i < subrun.length; i++) {
        var pname = name + "__parallel-" + task.id + "-" + i;
        var pi = i;
        startParallelTask(pname, pi);
      }
    });
  };
  Task.prototype.stop = function() {
    this.state = sStateTable[this.state][STOP];
  };
  Task.prototype.start = function() {
    this.error = false;
    this.state = sStateTable[this.state][START];
    if (this.state === RUNNING) {
      this.start = new Date();
      this.run(this);
      runNext(this, 0);
    }
  };
  Task.prototype.block = function(n) {
    n = typeof n === "undefined" ? 1 : n;
    this.blocks += n;
    if (this.blocks > 0) {
      this.state = sStateTable[this.state][BLOCK];
    }
  };
  Task.prototype.unblock = function(n) {
    n = typeof n === "undefined" ? 1 : n;
    this.blocks -= n;
    if (this.blocks === 0 && this.state !== DONE) {
      this.state = RUNNING;
      runNext(this, 0);
    }
    return this.blocks;
  };
  Task.prototype.sleep = function(n) {
    n = typeof n === "undefined" ? 0 : n;
    this.state = sStateTable[this.state][SLEEP];
    var self2 = this;
    this.timeoutId = setTimeout(function() {
      self2.timeoutId = null;
      self2.state = RUNNING;
      runNext(self2, 0);
    }, n);
  };
  Task.prototype.wait = function(cond) {
    cond.wait(this);
  };
  Task.prototype.wakeup = function() {
    if (this.state === SLEEPING) {
      cancelTimeout(this.timeoutId);
      this.timeoutId = null;
      this.state = RUNNING;
      runNext(this, 0);
    }
  };
  Task.prototype.cancel = function() {
    this.state = sStateTable[this.state][CANCEL];
    this.permitsNeeded = 0;
    if (this.timeoutId !== null) {
      cancelTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    this.subtasks = [];
  };
  Task.prototype.fail = function(next) {
    this.error = true;
    finish(this, true);
    if (next) {
      next.error = this.error;
      next.swapTime = this.swapTime;
      next.userData = this.userData;
      runNext(next, 0);
    } else {
      if (this.parent !== null) {
        var parent = this.parent;
        while (parent.parent !== null) {
          parent.error = this.error;
          parent.swapTime = this.swapTime;
          parent.userData = this.userData;
          parent = parent.parent;
        }
        finish(parent, true);
      }
      if (this.failureCallback) {
        this.failureCallback(this);
      }
    }
  };
  var start = function(task) {
    task.error = false;
    task.state = sStateTable[task.state][START];
    setTimeout(function() {
      if (task.state === RUNNING) {
        task.swapTime = +new Date();
        task.run(task);
        runNext(task, 0);
      }
    }, 0);
  };
  var runNext = function(task, recurse) {
    var swap = recurse > sMaxRecursions || +new Date() - task.swapTime > sTimeSlice;
    var doNext = function(recurse2) {
      recurse2++;
      if (task.state === RUNNING) {
        if (swap) {
          task.swapTime = +new Date();
        }
        if (task.subtasks.length > 0) {
          var subtask = task.subtasks.shift();
          subtask.error = task.error;
          subtask.swapTime = task.swapTime;
          subtask.userData = task.userData;
          subtask.run(subtask);
          if (!subtask.error) {
            runNext(subtask, recurse2);
          }
        } else {
          finish(task);
          if (!task.error) {
            if (task.parent !== null) {
              task.parent.error = task.error;
              task.parent.swapTime = task.swapTime;
              task.parent.userData = task.userData;
              runNext(task.parent, recurse2);
            }
          }
        }
      }
    };
    if (swap) {
      setTimeout(doNext, 0);
    } else {
      doNext(recurse);
    }
  };
  var finish = function(task, suppressCallbacks) {
    task.state = DONE;
    delete sTasks[task.id];
    if (sVL >= 1) {
      forge.log.verbose(cat, "[%s][%s] finish", task.id, task.name, task);
    }
    if (task.parent === null) {
      if (!(task.type in sTaskQueues)) {
        forge.log.error(cat, "[%s][%s] task queue missing [%s]", task.id, task.name, task.type);
      } else if (sTaskQueues[task.type].length === 0) {
        forge.log.error(cat, "[%s][%s] task queue empty [%s]", task.id, task.name, task.type);
      } else if (sTaskQueues[task.type][0] !== task) {
        forge.log.error(cat, "[%s][%s] task not first in queue [%s]", task.id, task.name, task.type);
      } else {
        sTaskQueues[task.type].shift();
        if (sTaskQueues[task.type].length === 0) {
          if (sVL >= 1) {
            forge.log.verbose(cat, "[%s][%s] delete queue [%s]", task.id, task.name, task.type);
          }
          delete sTaskQueues[task.type];
        } else {
          if (sVL >= 1) {
            forge.log.verbose(cat, "[%s][%s] queue start next [%s] remain:%s", task.id, task.name, task.type, sTaskQueues[task.type].length);
          }
          sTaskQueues[task.type][0].start();
        }
      }
      if (!suppressCallbacks) {
        if (task.error && task.failureCallback) {
          task.failureCallback(task);
        } else if (!task.error && task.successCallback) {
          task.successCallback(task);
        }
      }
    }
  };
  module2.exports = forge.task = forge.task || {};
  forge.task.start = function(options) {
    var task = new Task({
      run: options.run,
      name: options.name || sNoTaskName
    });
    task.type = options.type;
    task.successCallback = options.success || null;
    task.failureCallback = options.failure || null;
    if (!(task.type in sTaskQueues)) {
      if (sVL >= 1) {
        forge.log.verbose(cat, "[%s][%s] create queue [%s]", task.id, task.name, task.type);
      }
      sTaskQueues[task.type] = [task];
      start(task);
    } else {
      sTaskQueues[options.type].push(task);
    }
  };
  forge.task.cancel = function(type) {
    if (type in sTaskQueues) {
      sTaskQueues[type] = [sTaskQueues[type][0]];
    }
  };
  forge.task.createCondition = function() {
    var cond = {
      tasks: {}
    };
    cond.wait = function(task) {
      if (!(task.id in cond.tasks)) {
        task.block();
        cond.tasks[task.id] = task;
      }
    };
    cond.notify = function() {
      var tmp = cond.tasks;
      cond.tasks = {};
      for (var id in tmp) {
        tmp[id].unblock();
      }
    };
    return cond;
  };
});

// node_modules/node-forge/lib/index.js
var require_lib3 = __commonJS((exports2, module2) => {
  module2.exports = require_forge();
  require_aes();
  require_aesCipherSuites();
  require_asn1();
  require_cipher();
  require_debug();
  require_des();
  require_ed25519();
  require_hmac();
  require_kem();
  require_log();
  require_md_all();
  require_mgf1();
  require_pbkdf2();
  require_pem();
  require_pkcs1();
  require_pkcs12();
  require_pkcs7();
  require_pki();
  require_prime();
  require_prng();
  require_pss();
  require_random();
  require_rc2();
  require_ssh();
  require_task();
  require_tls();
  require_util();
});

// node_modules/google-p12-pem/build/src/index.js
var require_src5 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getPem = void 0;
  var fs = require("fs");
  var forge = require_lib3();
  var util_1 = require("util");
  var readFile = util_1.promisify(fs.readFile);
  function getPem(filename, callback) {
    if (callback) {
      getPemAsync(filename).then((pem) => callback(null, pem)).catch((err) => callback(err, null));
    } else {
      return getPemAsync(filename);
    }
  }
  exports2.getPem = getPem;
  function getPemAsync(filename) {
    return readFile(filename, {encoding: "base64"}).then((keyp12) => {
      return convertToPem(keyp12);
    });
  }
  function convertToPem(p12base64) {
    const p12Der = forge.util.decode64(p12base64);
    const p12Asn1 = forge.asn1.fromDer(p12Der);
    const p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, "notasecret");
    const bags = p12.getBags({friendlyName: "privatekey"});
    if (bags.friendlyName) {
      const privateKey = bags.friendlyName[0].key;
      const pem = forge.pki.privateKeyToPem(privateKey);
      return pem.replace(/\r\n/g, "\n");
    } else {
      throw new Error("Unable to get friendly name.");
    }
  }
});

// node_modules/gtoken/build/src/index.js
var require_src6 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.GoogleToken = void 0;
  var fs = require("fs");
  var gaxios_1 = require_src3();
  var jws = require_jws();
  var path = require("path");
  var util_1 = require("util");
  var readFile = fs.readFile ? util_1.promisify(fs.readFile) : async () => {
    throw new ErrorWithCode("use key rather than keyFile.", "MISSING_CREDENTIALS");
  };
  var GOOGLE_TOKEN_URL = "https://www.googleapis.com/oauth2/v4/token";
  var GOOGLE_REVOKE_TOKEN_URL = "https://accounts.google.com/o/oauth2/revoke?token=";
  var ErrorWithCode = class extends Error {
    constructor(message, code) {
      super(message);
      this.code = code;
    }
  };
  var getPem;
  var GoogleToken = class {
    constructor(options) {
      this.configure(options);
    }
    get accessToken() {
      return this.rawToken ? this.rawToken.access_token : void 0;
    }
    get idToken() {
      return this.rawToken ? this.rawToken.id_token : void 0;
    }
    get tokenType() {
      return this.rawToken ? this.rawToken.token_type : void 0;
    }
    get refreshToken() {
      return this.rawToken ? this.rawToken.refresh_token : void 0;
    }
    hasExpired() {
      const now = new Date().getTime();
      if (this.rawToken && this.expiresAt) {
        return now >= this.expiresAt;
      } else {
        return true;
      }
    }
    isTokenExpiring() {
      var _a;
      const now = new Date().getTime();
      const eagerRefreshThresholdMillis = (_a = this.eagerRefreshThresholdMillis) !== null && _a !== void 0 ? _a : 0;
      if (this.rawToken && this.expiresAt) {
        return this.expiresAt <= now + eagerRefreshThresholdMillis;
      } else {
        return true;
      }
    }
    getToken(callback, opts = {}) {
      if (typeof callback === "object") {
        opts = callback;
        callback = void 0;
      }
      opts = Object.assign({
        forceRefresh: false
      }, opts);
      if (callback) {
        const cb = callback;
        this.getTokenAsync(opts).then((t) => cb(null, t), callback);
        return;
      }
      return this.getTokenAsync(opts);
    }
    async getCredentials(keyFile) {
      const ext = path.extname(keyFile);
      switch (ext) {
        case ".json": {
          const key = await readFile(keyFile, "utf8");
          const body = JSON.parse(key);
          const privateKey = body.private_key;
          const clientEmail = body.client_email;
          if (!privateKey || !clientEmail) {
            throw new ErrorWithCode("private_key and client_email are required.", "MISSING_CREDENTIALS");
          }
          return {privateKey, clientEmail};
        }
        case ".der":
        case ".crt":
        case ".pem": {
          const privateKey = await readFile(keyFile, "utf8");
          return {privateKey};
        }
        case ".p12":
        case ".pfx": {
          if (!getPem) {
            getPem = (await Promise.resolve().then(() => require_src5())).getPem;
          }
          const privateKey = await getPem(keyFile);
          return {privateKey};
        }
        default:
          throw new ErrorWithCode("Unknown certificate type. Type is determined based on file extension. Current supported extensions are *.json, *.pem, and *.p12.", "UNKNOWN_CERTIFICATE_TYPE");
      }
    }
    async getTokenAsync(opts) {
      if (this.inFlightRequest && !opts.forceRefresh) {
        return this.inFlightRequest;
      }
      try {
        return await (this.inFlightRequest = this.getTokenAsyncInner(opts));
      } finally {
        this.inFlightRequest = void 0;
      }
    }
    async getTokenAsyncInner(opts) {
      if (this.isTokenExpiring() === false && opts.forceRefresh === false) {
        return Promise.resolve(this.rawToken);
      }
      if (!this.key && !this.keyFile) {
        throw new Error("No key or keyFile set.");
      }
      if (!this.key && this.keyFile) {
        const creds = await this.getCredentials(this.keyFile);
        this.key = creds.privateKey;
        this.iss = creds.clientEmail || this.iss;
        if (!creds.clientEmail) {
          this.ensureEmail();
        }
      }
      return this.requestToken();
    }
    ensureEmail() {
      if (!this.iss) {
        throw new ErrorWithCode("email is required.", "MISSING_CREDENTIALS");
      }
    }
    revokeToken(callback) {
      if (callback) {
        this.revokeTokenAsync().then(() => callback(), callback);
        return;
      }
      return this.revokeTokenAsync();
    }
    async revokeTokenAsync() {
      if (!this.accessToken) {
        throw new Error("No token to revoke.");
      }
      const url = GOOGLE_REVOKE_TOKEN_URL + this.accessToken;
      await gaxios_1.request({url});
      this.configure({
        email: this.iss,
        sub: this.sub,
        key: this.key,
        keyFile: this.keyFile,
        scope: this.scope,
        additionalClaims: this.additionalClaims
      });
    }
    configure(options = {}) {
      this.keyFile = options.keyFile;
      this.key = options.key;
      this.rawToken = void 0;
      this.iss = options.email || options.iss;
      this.sub = options.sub;
      this.additionalClaims = options.additionalClaims;
      if (typeof options.scope === "object") {
        this.scope = options.scope.join(" ");
      } else {
        this.scope = options.scope;
      }
      this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;
    }
    async requestToken() {
      const iat = Math.floor(new Date().getTime() / 1e3);
      const additionalClaims = this.additionalClaims || {};
      const payload = Object.assign({
        iss: this.iss,
        scope: this.scope,
        aud: GOOGLE_TOKEN_URL,
        exp: iat + 3600,
        iat,
        sub: this.sub
      }, additionalClaims);
      const signedJWT = jws.sign({
        header: {alg: "RS256"},
        payload,
        secret: this.key
      });
      try {
        const r = await gaxios_1.request({
          method: "POST",
          url: GOOGLE_TOKEN_URL,
          data: {
            grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
            assertion: signedJWT
          },
          headers: {"Content-Type": "application/x-www-form-urlencoded"},
          responseType: "json"
        });
        this.rawToken = r.data;
        this.expiresAt = r.data.expires_in === null || r.data.expires_in === void 0 ? void 0 : (iat + r.data.expires_in) * 1e3;
        return this.rawToken;
      } catch (e) {
        this.rawToken = void 0;
        this.tokenExpires = void 0;
        const body = e.response && e.response.data ? e.response.data : {};
        if (body.error) {
          const desc = body.error_description ? `: ${body.error_description}` : "";
          e.message = `${body.error}${desc}`;
        }
        throw e;
      }
    }
  };
  exports2.GoogleToken = GoogleToken;
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head; walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  function Yallist(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist();
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length; i < l; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  }
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return void 0;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return void 0;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
      walker = walker.next;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
      walker = walker.prev;
    }
    if (i === n && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.head; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for (var walker = this.tail; walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (; walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (; walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0; walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0; i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  function insert(self2, node, value) {
    var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  }
  function push(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  }
  function unshift(self2, item) {
    self2.head = new Node(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  }
  function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }
  try {
    require_iterator()(Yallist);
  } catch (er) {
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS((exports2, module2) => {
  "use strict";
  var Yallist = require_yallist();
  var MAX = Symbol("max");
  var LENGTH = Symbol("length");
  var LENGTH_CALCULATOR = Symbol("lengthCalculator");
  var ALLOW_STALE = Symbol("allowStale");
  var MAX_AGE = Symbol("maxAge");
  var DISPOSE = Symbol("dispose");
  var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
  var LRU_LIST = Symbol("lruList");
  var CACHE = Symbol("cache");
  var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
  var naiveLength = () => 1;
  var LRUCache = class {
    constructor(options) {
      if (typeof options === "number")
        options = {max: options};
      if (!options)
        options = {};
      if (options.max && (typeof options.max !== "number" || options.max < 0))
        throw new TypeError("max must be a non-negative number");
      const max = this[MAX] = options.max || Infinity;
      const lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }
    set max(mL) {
      if (typeof mL !== "number" || mL < 0)
        throw new TypeError("max must be a non-negative number");
      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
      if (typeof lC !== "function")
        lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail; walker !== null; ) {
        const prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
    forEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head; walker !== null; ) {
        const next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k) => k.key);
    }
    values() {
      return this[LRU_LIST].toArray().map((k) => k.value);
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
      }
      this[CACHE] = new Map();
      this[LRU_LIST] = new Yallist();
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter((h) => h);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      const now = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        const node = this[CACHE].get(key);
        const item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      const hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key, value);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
    has(key) {
      if (!this[CACHE].has(key))
        return false;
      const hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
    get(key) {
      return get(this, key, true);
    }
    peek(key) {
      return get(this, key, false);
    }
    pop() {
      const node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    }
    del(key) {
      del(this, this[CACHE].get(key));
    }
    load(arr) {
      this.reset();
      const now = Date.now();
      for (let l = arr.length - 1; l >= 0; l--) {
        const hit = arr[l];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          const maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value, key) => get(this, key, false));
    }
  };
  var get = (self2, key, doUse) => {
    const node = self2[CACHE].get(key);
    if (node) {
      const hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          return void 0;
      } else {
        if (doUse) {
          if (self2[UPDATE_AGE_ON_GET])
            node.value.now = Date.now();
          self2[LRU_LIST].unshiftNode(node);
        }
      }
      return hit.value;
    }
  };
  var isStale = (self2, hit) => {
    if (!hit || !hit.maxAge && !self2[MAX_AGE])
      return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
  };
  var trim = (self2) => {
    if (self2[LENGTH] > self2[MAX]) {
      for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
        const prev = walker.prev;
        del(self2, walker);
        walker = prev;
      }
    }
  };
  var del = (self2, node) => {
    if (node) {
      const hit = node.value;
      if (self2[DISPOSE])
        self2[DISPOSE](hit.key, hit.value);
      self2[LENGTH] -= hit.length;
      self2[CACHE].delete(hit.key);
      self2[LRU_LIST].removeNode(node);
    }
  };
  var Entry = class {
    constructor(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  };
  var forEachStep = (self2, fn, node, thisp) => {
    let hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        hit = void 0;
    }
    if (hit)
      fn.call(thisp, hit.value, hit.key, self2);
  };
  module2.exports = LRUCache;
});

// node_modules/google-auth-library/build/src/auth/jwtaccess.js
var require_jwtaccess = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.JWTAccess = void 0;
  var jws = require_jws();
  var LRU = require_lru_cache();
  var DEFAULT_HEADER = {
    alg: "RS256",
    typ: "JWT"
  };
  var JWTAccess = class {
    constructor(email, key, keyId, eagerRefreshThresholdMillis) {
      this.cache = new LRU({
        max: 500,
        maxAge: 60 * 60 * 1e3
      });
      this.email = email;
      this.key = key;
      this.keyId = keyId;
      this.eagerRefreshThresholdMillis = eagerRefreshThresholdMillis !== null && eagerRefreshThresholdMillis !== void 0 ? eagerRefreshThresholdMillis : 5 * 60 * 1e3;
    }
    getRequestHeaders(url, additionalClaims) {
      const cachedToken = this.cache.get(url);
      const now = Date.now();
      if (cachedToken && cachedToken.expiration - now > this.eagerRefreshThresholdMillis) {
        return cachedToken.headers;
      }
      const iat = Math.floor(Date.now() / 1e3);
      const exp = JWTAccess.getExpirationTime(iat);
      const defaultClaims = {
        iss: this.email,
        sub: this.email,
        aud: url,
        exp,
        iat
      };
      if (additionalClaims) {
        for (const claim in defaultClaims) {
          if (additionalClaims[claim]) {
            throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);
          }
        }
      }
      const header = this.keyId ? __objSpread(__objSpread({}, DEFAULT_HEADER), {kid: this.keyId}) : DEFAULT_HEADER;
      const payload = Object.assign(defaultClaims, additionalClaims);
      const signedJWT = jws.sign({header, payload, secret: this.key});
      const headers = {Authorization: `Bearer ${signedJWT}`};
      this.cache.set(url, {
        expiration: exp * 1e3,
        headers
      });
      return headers;
    }
    static getExpirationTime(iat) {
      const exp = iat + 3600;
      return exp;
    }
    fromJSON(json) {
      if (!json) {
        throw new Error("Must pass in a JSON object containing the service account auth settings.");
      }
      if (!json.client_email) {
        throw new Error("The incoming JSON object does not contain a client_email field");
      }
      if (!json.private_key) {
        throw new Error("The incoming JSON object does not contain a private_key field");
      }
      this.email = json.client_email;
      this.key = json.private_key;
      this.keyId = json.private_key_id;
      this.projectId = json.project_id;
    }
    fromStream(inputStream, callback) {
      if (callback) {
        this.fromStreamAsync(inputStream).then(() => callback(), callback);
      } else {
        return this.fromStreamAsync(inputStream);
      }
    }
    fromStreamAsync(inputStream) {
      return new Promise((resolve, reject) => {
        if (!inputStream) {
          reject(new Error("Must pass in a stream containing the service account auth settings."));
        }
        let s = "";
        inputStream.setEncoding("utf8").on("data", (chunk) => s += chunk).on("error", reject).on("end", () => {
          try {
            const data = JSON.parse(s);
            this.fromJSON(data);
            resolve();
          } catch (err) {
            reject(err);
          }
        });
      });
    }
  };
  exports2.JWTAccess = JWTAccess;
});

// node_modules/google-auth-library/build/src/auth/jwtclient.js
var require_jwtclient = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.JWT = void 0;
  var gtoken_1 = require_src6();
  var jwtaccess_1 = require_jwtaccess();
  var oauth2client_1 = require_oauth2client();
  var JWT = class extends oauth2client_1.OAuth2Client {
    constructor(optionsOrEmail, keyFile, key, scopes, subject, keyId) {
      const opts = optionsOrEmail && typeof optionsOrEmail === "object" ? optionsOrEmail : {email: optionsOrEmail, keyFile, key, keyId, scopes, subject};
      super({
        eagerRefreshThresholdMillis: opts.eagerRefreshThresholdMillis,
        forceRefreshOnFailure: opts.forceRefreshOnFailure
      });
      this.email = opts.email;
      this.keyFile = opts.keyFile;
      this.key = opts.key;
      this.keyId = opts.keyId;
      this.scopes = opts.scopes;
      this.subject = opts.subject;
      this.additionalClaims = opts.additionalClaims;
      this.credentials = {refresh_token: "jwt-placeholder", expiry_date: 1};
    }
    createScoped(scopes) {
      return new JWT({
        email: this.email,
        keyFile: this.keyFile,
        key: this.key,
        keyId: this.keyId,
        scopes,
        subject: this.subject,
        additionalClaims: this.additionalClaims
      });
    }
    async getRequestMetadataAsync(url) {
      if (!this.apiKey && !this.hasUserScopes() && url) {
        if (this.additionalClaims && this.additionalClaims.target_audience) {
          const {tokens} = await this.refreshToken();
          return {
            headers: this.addSharedMetadataHeaders({
              Authorization: `Bearer ${tokens.id_token}`
            })
          };
        } else {
          if (!this.access) {
            this.access = new jwtaccess_1.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis);
          }
          const headers = await this.access.getRequestHeaders(url, this.additionalClaims);
          return {headers: this.addSharedMetadataHeaders(headers)};
        }
      } else if (this.hasAnyScopes() || this.apiKey) {
        return super.getRequestMetadataAsync(url);
      } else {
        return {headers: {}};
      }
    }
    async fetchIdToken(targetAudience) {
      const gtoken = new gtoken_1.GoogleToken({
        iss: this.email,
        sub: this.subject,
        scope: this.scopes || this.defaultScopes,
        keyFile: this.keyFile,
        key: this.key,
        additionalClaims: {target_audience: targetAudience}
      });
      await gtoken.getToken({
        forceRefresh: true
      });
      if (!gtoken.idToken) {
        throw new Error("Unknown error: Failed to fetch ID token");
      }
      return gtoken.idToken;
    }
    hasUserScopes() {
      if (!this.scopes) {
        return false;
      }
      return this.scopes.length > 0;
    }
    hasAnyScopes() {
      if (this.scopes && this.scopes.length > 0)
        return true;
      if (this.defaultScopes && this.defaultScopes.length > 0)
        return true;
      return false;
    }
    authorize(callback) {
      if (callback) {
        this.authorizeAsync().then((r) => callback(null, r), callback);
      } else {
        return this.authorizeAsync();
      }
    }
    async authorizeAsync() {
      const result = await this.refreshToken();
      if (!result) {
        throw new Error("No result returned");
      }
      this.credentials = result.tokens;
      this.credentials.refresh_token = "jwt-placeholder";
      this.key = this.gtoken.key;
      this.email = this.gtoken.iss;
      return result.tokens;
    }
    async refreshTokenNoCache(refreshToken) {
      const gtoken = this.createGToken();
      const token = await gtoken.getToken({
        forceRefresh: this.isTokenExpiring()
      });
      const tokens = {
        access_token: token.access_token,
        token_type: "Bearer",
        expiry_date: gtoken.expiresAt,
        id_token: gtoken.idToken
      };
      this.emit("tokens", tokens);
      return {res: null, tokens};
    }
    createGToken() {
      if (!this.gtoken) {
        this.gtoken = new gtoken_1.GoogleToken({
          iss: this.email,
          sub: this.subject,
          scope: this.scopes || this.defaultScopes,
          keyFile: this.keyFile,
          key: this.key,
          additionalClaims: this.additionalClaims
        });
      }
      return this.gtoken;
    }
    fromJSON(json) {
      if (!json) {
        throw new Error("Must pass in a JSON object containing the service account auth settings.");
      }
      if (!json.client_email) {
        throw new Error("The incoming JSON object does not contain a client_email field");
      }
      if (!json.private_key) {
        throw new Error("The incoming JSON object does not contain a private_key field");
      }
      this.email = json.client_email;
      this.key = json.private_key;
      this.keyId = json.private_key_id;
      this.projectId = json.project_id;
      this.quotaProjectId = json.quota_project_id;
    }
    fromStream(inputStream, callback) {
      if (callback) {
        this.fromStreamAsync(inputStream).then(() => callback(), callback);
      } else {
        return this.fromStreamAsync(inputStream);
      }
    }
    fromStreamAsync(inputStream) {
      return new Promise((resolve, reject) => {
        if (!inputStream) {
          throw new Error("Must pass in a stream containing the service account auth settings.");
        }
        let s = "";
        inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => s += chunk).on("end", () => {
          try {
            const data = JSON.parse(s);
            this.fromJSON(data);
            resolve();
          } catch (e) {
            reject(e);
          }
        });
      });
    }
    fromAPIKey(apiKey) {
      if (typeof apiKey !== "string") {
        throw new Error("Must provide an API Key string.");
      }
      this.apiKey = apiKey;
    }
    async getCredentials() {
      if (this.key) {
        return {private_key: this.key, client_email: this.email};
      } else if (this.keyFile) {
        const gtoken = this.createGToken();
        const creds = await gtoken.getCredentials(this.keyFile);
        return {private_key: creds.privateKey, client_email: creds.clientEmail};
      }
      throw new Error("A key or a keyFile must be provided to getCredentials.");
    }
  };
  exports2.JWT = JWT;
});

// node_modules/google-auth-library/build/src/auth/refreshclient.js
var require_refreshclient = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.UserRefreshClient = void 0;
  var oauth2client_1 = require_oauth2client();
  var UserRefreshClient = class extends oauth2client_1.OAuth2Client {
    constructor(optionsOrClientId, clientSecret, refreshToken, eagerRefreshThresholdMillis, forceRefreshOnFailure) {
      const opts = optionsOrClientId && typeof optionsOrClientId === "object" ? optionsOrClientId : {
        clientId: optionsOrClientId,
        clientSecret,
        refreshToken,
        eagerRefreshThresholdMillis,
        forceRefreshOnFailure
      };
      super({
        clientId: opts.clientId,
        clientSecret: opts.clientSecret,
        eagerRefreshThresholdMillis: opts.eagerRefreshThresholdMillis,
        forceRefreshOnFailure: opts.forceRefreshOnFailure
      });
      this._refreshToken = opts.refreshToken;
      this.credentials.refresh_token = opts.refreshToken;
    }
    async refreshTokenNoCache(refreshToken) {
      return super.refreshTokenNoCache(this._refreshToken);
    }
    fromJSON(json) {
      if (!json) {
        throw new Error("Must pass in a JSON object containing the user refresh token");
      }
      if (json.type !== "authorized_user") {
        throw new Error('The incoming JSON object does not have the "authorized_user" type');
      }
      if (!json.client_id) {
        throw new Error("The incoming JSON object does not contain a client_id field");
      }
      if (!json.client_secret) {
        throw new Error("The incoming JSON object does not contain a client_secret field");
      }
      if (!json.refresh_token) {
        throw new Error("The incoming JSON object does not contain a refresh_token field");
      }
      this._clientId = json.client_id;
      this._clientSecret = json.client_secret;
      this._refreshToken = json.refresh_token;
      this.credentials.refresh_token = json.refresh_token;
      this.quotaProjectId = json.quota_project_id;
    }
    fromStream(inputStream, callback) {
      if (callback) {
        this.fromStreamAsync(inputStream).then(() => callback(), callback);
      } else {
        return this.fromStreamAsync(inputStream);
      }
    }
    async fromStreamAsync(inputStream) {
      return new Promise((resolve, reject) => {
        if (!inputStream) {
          return reject(new Error("Must pass in a stream containing the user refresh token."));
        }
        let s = "";
        inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => s += chunk).on("end", () => {
          try {
            const data = JSON.parse(s);
            this.fromJSON(data);
            return resolve();
          } catch (err) {
            return reject(err);
          }
        });
      });
    }
  };
  exports2.UserRefreshClient = UserRefreshClient;
});

// node_modules/google-auth-library/build/src/auth/googleauth.js
var require_googleauth = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.GoogleAuth = exports2.CLOUD_SDK_CLIENT_ID = void 0;
  var child_process_1 = require("child_process");
  var fs = require("fs");
  var gcpMetadata = require_src4();
  var os = require("os");
  var path = require("path");
  var crypto_1 = require_crypto3();
  var transporters_1 = require_transporters();
  var computeclient_1 = require_computeclient();
  var idtokenclient_1 = require_idtokenclient();
  var envDetect_1 = require_envDetect();
  var jwtclient_1 = require_jwtclient();
  var refreshclient_1 = require_refreshclient();
  exports2.CLOUD_SDK_CLIENT_ID = "764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com";
  var GoogleAuth = class {
    constructor(opts) {
      this.checkIsGCE = void 0;
      this.jsonContent = null;
      this.cachedCredential = null;
      opts = opts || {};
      this._cachedProjectId = opts.projectId || null;
      this.keyFilename = opts.keyFilename || opts.keyFile;
      this.scopes = opts.scopes;
      this.jsonContent = opts.credentials || null;
      this.clientOptions = opts.clientOptions;
    }
    get isGCE() {
      return this.checkIsGCE;
    }
    getProjectId(callback) {
      if (callback) {
        this.getProjectIdAsync().then((r) => callback(null, r), callback);
      } else {
        return this.getProjectIdAsync();
      }
    }
    getProjectIdAsync() {
      if (this._cachedProjectId) {
        return Promise.resolve(this._cachedProjectId);
      }
      if (!this._getDefaultProjectIdPromise) {
        this._getDefaultProjectIdPromise = new Promise(async (resolve, reject) => {
          try {
            const projectId = this.getProductionProjectId() || await this.getFileProjectId() || await this.getDefaultServiceProjectId() || await this.getGCEProjectId();
            this._cachedProjectId = projectId;
            if (!projectId) {
              throw new Error("Unable to detect a Project Id in the current environment. \nTo learn more about authentication and Google APIs, visit: \nhttps://cloud.google.com/docs/authentication/getting-started");
            }
            resolve(projectId);
          } catch (e) {
            reject(e);
          }
        });
      }
      return this._getDefaultProjectIdPromise;
    }
    getApplicationDefault(optionsOrCallback = {}, callback) {
      let options;
      if (typeof optionsOrCallback === "function") {
        callback = optionsOrCallback;
      } else {
        options = optionsOrCallback;
      }
      if (callback) {
        this.getApplicationDefaultAsync(options).then((r) => callback(null, r.credential, r.projectId), callback);
      } else {
        return this.getApplicationDefaultAsync(options);
      }
    }
    async getApplicationDefaultAsync(options = {}) {
      if (this.cachedCredential) {
        return {
          credential: this.cachedCredential,
          projectId: await this.getProjectIdAsync()
        };
      }
      let credential;
      let projectId;
      credential = await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);
      if (credential) {
        if (credential instanceof jwtclient_1.JWT) {
          credential.defaultScopes = this.defaultScopes;
          credential.scopes = this.scopes;
        }
        this.cachedCredential = credential;
        projectId = await this.getProjectId();
        return {credential, projectId};
      }
      credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);
      if (credential) {
        if (credential instanceof jwtclient_1.JWT) {
          credential.defaultScopes = this.defaultScopes;
          credential.scopes = this.scopes;
        }
        this.cachedCredential = credential;
        projectId = await this.getProjectId();
        return {credential, projectId};
      }
      let isGCE;
      try {
        isGCE = await this._checkIsGCE();
      } catch (e) {
        e.message = `Unexpected error determining execution environment: ${e.message}`;
        throw e;
      }
      if (!isGCE) {
        throw new Error("Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.");
      }
      options.scopes = this.scopes || this.defaultScopes;
      this.cachedCredential = new computeclient_1.Compute(options);
      projectId = await this.getProjectId();
      return {projectId, credential: this.cachedCredential};
    }
    async _checkIsGCE() {
      if (this.checkIsGCE === void 0) {
        this.checkIsGCE = await gcpMetadata.isAvailable();
      }
      return this.checkIsGCE;
    }
    async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {
      const credentialsPath = process.env["GOOGLE_APPLICATION_CREDENTIALS"] || process.env["google_application_credentials"];
      if (!credentialsPath || credentialsPath.length === 0) {
        return null;
      }
      try {
        return this._getApplicationCredentialsFromFilePath(credentialsPath, options);
      } catch (e) {
        e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;
        throw e;
      }
    }
    async _tryGetApplicationCredentialsFromWellKnownFile(options) {
      let location = null;
      if (this._isWindows()) {
        location = process.env["APPDATA"];
      } else {
        const home = process.env["HOME"];
        if (home) {
          location = path.join(home, ".config");
        }
      }
      if (location) {
        location = path.join(location, "gcloud", "application_default_credentials.json");
        if (!fs.existsSync(location)) {
          location = null;
        }
      }
      if (!location) {
        return null;
      }
      const client = await this._getApplicationCredentialsFromFilePath(location, options);
      return client;
    }
    async _getApplicationCredentialsFromFilePath(filePath, options = {}) {
      if (!filePath || filePath.length === 0) {
        throw new Error("The file path is invalid.");
      }
      try {
        filePath = fs.realpathSync(filePath);
        if (!fs.lstatSync(filePath).isFile()) {
          throw new Error();
        }
      } catch (err) {
        err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;
        throw err;
      }
      const readStream = fs.createReadStream(filePath);
      return this.fromStream(readStream, options);
    }
    fromJSON(json, options) {
      let client;
      if (!json) {
        throw new Error("Must pass in a JSON object containing the Google auth settings.");
      }
      options = options || {};
      if (json.type === "authorized_user") {
        client = new refreshclient_1.UserRefreshClient(options);
      } else {
        options.scopes = this.scopes;
        client = new jwtclient_1.JWT(options);
        client.defaultScopes = this.defaultScopes;
      }
      client.fromJSON(json);
      return client;
    }
    _cacheClientFromJSON(json, options) {
      let client;
      options = options || {};
      if (json.type === "authorized_user") {
        client = new refreshclient_1.UserRefreshClient(options);
      } else {
        options.scopes = this.scopes;
        client = new jwtclient_1.JWT(options);
        client.defaultScopes = this.defaultScopes;
      }
      client.fromJSON(json);
      this.jsonContent = json;
      this.cachedCredential = client;
      return this.cachedCredential;
    }
    fromStream(inputStream, optionsOrCallback = {}, callback) {
      let options = {};
      if (typeof optionsOrCallback === "function") {
        callback = optionsOrCallback;
      } else {
        options = optionsOrCallback;
      }
      if (callback) {
        this.fromStreamAsync(inputStream, options).then((r) => callback(null, r), callback);
      } else {
        return this.fromStreamAsync(inputStream, options);
      }
    }
    fromStreamAsync(inputStream, options) {
      return new Promise((resolve, reject) => {
        if (!inputStream) {
          throw new Error("Must pass in a stream containing the Google auth settings.");
        }
        let s = "";
        inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => s += chunk).on("end", () => {
          try {
            try {
              const data = JSON.parse(s);
              const r = this._cacheClientFromJSON(data, options);
              return resolve(r);
            } catch (err) {
              if (!this.keyFilename)
                throw err;
              const client = new jwtclient_1.JWT(__objSpread(__objSpread({}, this.clientOptions), {
                keyFile: this.keyFilename
              }));
              this.cachedCredential = client;
              return resolve(client);
            }
          } catch (err) {
            return reject(err);
          }
        });
      });
    }
    fromAPIKey(apiKey, options) {
      options = options || {};
      const client = new jwtclient_1.JWT(options);
      client.fromAPIKey(apiKey);
      return client;
    }
    _isWindows() {
      const sys = os.platform();
      if (sys && sys.length >= 3) {
        if (sys.substring(0, 3).toLowerCase() === "win") {
          return true;
        }
      }
      return false;
    }
    async getDefaultServiceProjectId() {
      return new Promise((resolve) => {
        child_process_1.exec("gcloud config config-helper --format json", (err, stdout) => {
          if (!err && stdout) {
            try {
              const projectId = JSON.parse(stdout).configuration.properties.core.project;
              resolve(projectId);
              return;
            } catch (e) {
            }
          }
          resolve(null);
        });
      });
    }
    getProductionProjectId() {
      return process.env["GCLOUD_PROJECT"] || process.env["GOOGLE_CLOUD_PROJECT"] || process.env["gcloud_project"] || process.env["google_cloud_project"];
    }
    async getFileProjectId() {
      if (this.cachedCredential) {
        return this.cachedCredential.projectId;
      }
      if (this.keyFilename) {
        const creds = await this.getClient();
        if (creds && creds.projectId) {
          return creds.projectId;
        }
      }
      const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();
      if (r) {
        return r.projectId;
      } else {
        return null;
      }
    }
    async getGCEProjectId() {
      try {
        const r = await gcpMetadata.project("project-id");
        return r;
      } catch (e) {
        return null;
      }
    }
    getCredentials(callback) {
      if (callback) {
        this.getCredentialsAsync().then((r) => callback(null, r), callback);
      } else {
        return this.getCredentialsAsync();
      }
    }
    async getCredentialsAsync() {
      await this.getClient();
      if (this.jsonContent) {
        const credential = {
          client_email: this.jsonContent.client_email,
          private_key: this.jsonContent.private_key
        };
        return credential;
      }
      const isGCE = await this._checkIsGCE();
      if (!isGCE) {
        throw new Error("Unknown error.");
      }
      const data = await gcpMetadata.instance({
        property: "service-accounts/",
        params: {recursive: "true"}
      });
      if (!data || !data.default || !data.default.email) {
        throw new Error("Failure from metadata server.");
      }
      return {client_email: data.default.email};
    }
    async getClient(options) {
      if (options) {
        throw new Error("Passing options to getClient is forbidden in v5.0.0. Use new GoogleAuth(opts) instead.");
      }
      if (!this.cachedCredential) {
        if (this.jsonContent) {
          this._cacheClientFromJSON(this.jsonContent, this.clientOptions);
        } else if (this.keyFilename) {
          const filePath = path.resolve(this.keyFilename);
          const stream = fs.createReadStream(filePath);
          await this.fromStreamAsync(stream, this.clientOptions);
        } else {
          await this.getApplicationDefaultAsync(this.clientOptions);
        }
      }
      return this.cachedCredential;
    }
    async getIdTokenClient(targetAudience) {
      const client = await this.getClient();
      if (!("fetchIdToken" in client)) {
        throw new Error("Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.");
      }
      return new idtokenclient_1.IdTokenClient({targetAudience, idTokenProvider: client});
    }
    async getAccessToken() {
      const client = await this.getClient();
      return (await client.getAccessToken()).token;
    }
    async getRequestHeaders(url) {
      const client = await this.getClient();
      return client.getRequestHeaders(url);
    }
    async authorizeRequest(opts) {
      opts = opts || {};
      const url = opts.url || opts.uri;
      const client = await this.getClient();
      const headers = await client.getRequestHeaders(url);
      opts.headers = Object.assign(opts.headers || {}, headers);
      return opts;
    }
    async request(opts) {
      const client = await this.getClient();
      return client.request(opts);
    }
    getEnv() {
      return envDetect_1.getEnv();
    }
    async sign(data) {
      const client = await this.getClient();
      const crypto2 = crypto_1.createCrypto();
      if (client instanceof jwtclient_1.JWT && client.key) {
        const sign = await crypto2.sign(client.key, data);
        return sign;
      }
      const projectId = await this.getProjectId();
      if (!projectId) {
        throw new Error("Cannot sign data without a project ID.");
      }
      const creds = await this.getCredentials();
      if (!creds.client_email) {
        throw new Error("Cannot sign data without `client_email`.");
      }
      const url = `https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${creds.client_email}:signBlob`;
      const res = await this.request({
        method: "POST",
        url,
        data: {
          payload: crypto2.encodeBase64StringUtf8(data)
        }
      });
      return res.data.signedBlob;
    }
  };
  exports2.GoogleAuth = GoogleAuth;
  GoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;
});

// node_modules/google-auth-library/build/src/auth/iam.js
var require_iam = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.IAMAuth = void 0;
  var IAMAuth = class {
    constructor(selector, token) {
      this.selector = selector;
      this.token = token;
      this.selector = selector;
      this.token = token;
    }
    getRequestHeaders() {
      return {
        "x-goog-iam-authority-selector": this.selector,
        "x-goog-iam-authorization-token": this.token
      };
    }
  };
  exports2.IAMAuth = IAMAuth;
});

// node_modules/google-auth-library/build/src/index.js
var require_src7 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.GoogleAuth = exports2.auth = void 0;
  var googleauth_1 = require_googleauth();
  Object.defineProperty(exports2, "GoogleAuth", {enumerable: true, get: function() {
    return googleauth_1.GoogleAuth;
  }});
  var computeclient_1 = require_computeclient();
  Object.defineProperty(exports2, "Compute", {enumerable: true, get: function() {
    return computeclient_1.Compute;
  }});
  var envDetect_1 = require_envDetect();
  Object.defineProperty(exports2, "GCPEnv", {enumerable: true, get: function() {
    return envDetect_1.GCPEnv;
  }});
  var iam_1 = require_iam();
  Object.defineProperty(exports2, "IAMAuth", {enumerable: true, get: function() {
    return iam_1.IAMAuth;
  }});
  var idtokenclient_1 = require_idtokenclient();
  Object.defineProperty(exports2, "IdTokenClient", {enumerable: true, get: function() {
    return idtokenclient_1.IdTokenClient;
  }});
  var jwtaccess_1 = require_jwtaccess();
  Object.defineProperty(exports2, "JWTAccess", {enumerable: true, get: function() {
    return jwtaccess_1.JWTAccess;
  }});
  var jwtclient_1 = require_jwtclient();
  Object.defineProperty(exports2, "JWT", {enumerable: true, get: function() {
    return jwtclient_1.JWT;
  }});
  var oauth2client_1 = require_oauth2client();
  Object.defineProperty(exports2, "CodeChallengeMethod", {enumerable: true, get: function() {
    return oauth2client_1.CodeChallengeMethod;
  }});
  Object.defineProperty(exports2, "OAuth2Client", {enumerable: true, get: function() {
    return oauth2client_1.OAuth2Client;
  }});
  var loginticket_1 = require_loginticket();
  Object.defineProperty(exports2, "LoginTicket", {enumerable: true, get: function() {
    return loginticket_1.LoginTicket;
  }});
  var refreshclient_1 = require_refreshclient();
  Object.defineProperty(exports2, "UserRefreshClient", {enumerable: true, get: function() {
    return refreshclient_1.UserRefreshClient;
  }});
  var transporters_1 = require_transporters();
  Object.defineProperty(exports2, "DefaultTransporter", {enumerable: true, get: function() {
    return transporters_1.DefaultTransporter;
  }});
  var auth = new googleauth_1.GoogleAuth();
  exports2.auth = auth;
});

// node_modules/@grpc/grpc-js/build/src/channel-credentials.js
var require_channel_credentials = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createGoogleDefaultCredentials = exports2.ChannelCredentials = void 0;
  var tls_1 = require("tls");
  var call_credentials_1 = require_call_credentials();
  var tls_helpers_1 = require_tls_helpers();
  function verifyIsBufferOrNull(obj, friendlyName) {
    if (obj && !(obj instanceof Buffer)) {
      throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);
    }
  }
  function bufferOrNullEqual(buf1, buf2) {
    if (buf1 === null && buf2 === null) {
      return true;
    } else {
      return buf1 !== null && buf2 !== null && buf1.equals(buf2);
    }
  }
  var ChannelCredentials = class {
    constructor(callCredentials) {
      this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();
    }
    _getCallCredentials() {
      return this.callCredentials;
    }
    static createSsl(rootCerts, privateKey, certChain, verifyOptions) {
      verifyIsBufferOrNull(rootCerts, "Root certificate");
      verifyIsBufferOrNull(privateKey, "Private key");
      verifyIsBufferOrNull(certChain, "Certificate chain");
      if (privateKey && !certChain) {
        throw new Error("Private key must be given with accompanying certificate chain");
      }
      if (!privateKey && certChain) {
        throw new Error("Certificate chain must be given with accompanying private key");
      }
      return new SecureChannelCredentialsImpl(rootCerts || tls_helpers_1.getDefaultRootsData(), privateKey || null, certChain || null, verifyOptions || {});
    }
    static createInsecure() {
      return new InsecureChannelCredentialsImpl();
    }
  };
  exports2.ChannelCredentials = ChannelCredentials;
  var InsecureChannelCredentialsImpl = class extends ChannelCredentials {
    constructor(callCredentials) {
      super(callCredentials);
    }
    compose(callCredentials) {
      throw new Error("Cannot compose insecure credentials");
    }
    _getConnectionOptions() {
      return null;
    }
    _isSecure() {
      return false;
    }
    _equals(other) {
      return other instanceof InsecureChannelCredentialsImpl;
    }
  };
  var SecureChannelCredentialsImpl = class extends ChannelCredentials {
    constructor(rootCerts, privateKey, certChain, verifyOptions) {
      super();
      this.rootCerts = rootCerts;
      this.privateKey = privateKey;
      this.certChain = certChain;
      this.verifyOptions = verifyOptions;
      const secureContext = tls_1.createSecureContext({
        ca: rootCerts || void 0,
        key: privateKey || void 0,
        cert: certChain || void 0,
        ciphers: tls_helpers_1.CIPHER_SUITES
      });
      this.connectionOptions = {secureContext};
      if (verifyOptions && verifyOptions.checkServerIdentity) {
        this.connectionOptions.checkServerIdentity = (host, cert) => {
          return verifyOptions.checkServerIdentity(host, {raw: cert.raw});
        };
      }
    }
    compose(callCredentials) {
      const combinedCallCredentials = this.callCredentials.compose(callCredentials);
      return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
    }
    _getConnectionOptions() {
      return Object.assign({}, this.connectionOptions);
    }
    _isSecure() {
      return true;
    }
    _equals(other) {
      if (this === other) {
        return true;
      }
      if (other instanceof SecureChannelCredentialsImpl) {
        if (!bufferOrNullEqual(this.rootCerts, other.rootCerts)) {
          return false;
        }
        if (!bufferOrNullEqual(this.privateKey, other.privateKey)) {
          return false;
        }
        if (!bufferOrNullEqual(this.certChain, other.certChain)) {
          return false;
        }
        return this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;
      } else {
        return false;
      }
    }
  };
  var ComposedChannelCredentialsImpl = class extends ChannelCredentials {
    constructor(channelCredentials, callCreds) {
      super(callCreds);
      this.channelCredentials = channelCredentials;
    }
    compose(callCredentials) {
      const combinedCallCredentials = this.callCredentials.compose(callCredentials);
      return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);
    }
    _getConnectionOptions() {
      return this.channelCredentials._getConnectionOptions();
    }
    _isSecure() {
      return true;
    }
    _equals(other) {
      if (this === other) {
        return true;
      }
      if (other instanceof ComposedChannelCredentialsImpl) {
        return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);
      } else {
        return false;
      }
    }
  };
  function createGoogleDefaultCredentials() {
    const GoogleAuth = require_src7().GoogleAuth;
    const sslCreds = ChannelCredentials.createSsl();
    const googleAuthCreds = call_credentials_1.CallCredentials.createFromGoogleCredential(new GoogleAuth());
    return sslCreds.compose(googleAuthCreds);
  }
  exports2.createGoogleDefaultCredentials = createGoogleDefaultCredentials;
});

// node_modules/@grpc/grpc-js/build/src/picker.js
var require_picker = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.QueuePicker = exports2.UnavailablePicker = exports2.PickResultType = void 0;
  var metadata_1 = require_metadata();
  var constants_1 = require_constants();
  var PickResultType;
  (function(PickResultType2) {
    PickResultType2[PickResultType2["COMPLETE"] = 0] = "COMPLETE";
    PickResultType2[PickResultType2["QUEUE"] = 1] = "QUEUE";
    PickResultType2[PickResultType2["TRANSIENT_FAILURE"] = 2] = "TRANSIENT_FAILURE";
    PickResultType2[PickResultType2["DROP"] = 3] = "DROP";
  })(PickResultType = exports2.PickResultType || (exports2.PickResultType = {}));
  var UnavailablePicker = class {
    constructor(status) {
      if (status !== void 0) {
        this.status = status;
      } else {
        this.status = {
          code: constants_1.Status.UNAVAILABLE,
          details: "No connection established",
          metadata: new metadata_1.Metadata()
        };
      }
    }
    pick(pickArgs) {
      return {
        pickResultType: PickResultType.TRANSIENT_FAILURE,
        subchannel: null,
        status: this.status,
        extraFilterFactory: null,
        onCallStarted: null
      };
    }
  };
  exports2.UnavailablePicker = UnavailablePicker;
  var QueuePicker = class {
    constructor(loadBalancer) {
      this.loadBalancer = loadBalancer;
      this.calledExitIdle = false;
    }
    pick(pickArgs) {
      if (!this.calledExitIdle) {
        process.nextTick(() => {
          this.loadBalancer.exitIdle();
        });
        this.calledExitIdle = true;
      }
      return {
        pickResultType: PickResultType.QUEUE,
        subchannel: null,
        status: null,
        extraFilterFactory: null,
        onCallStarted: null
      };
    }
  };
  exports2.QueuePicker = QueuePicker;
});

// node_modules/@grpc/grpc-js/build/src/backoff-timeout.js
var require_backoff_timeout = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.BackoffTimeout = void 0;
  var INITIAL_BACKOFF_MS = 1e3;
  var BACKOFF_MULTIPLIER = 1.6;
  var MAX_BACKOFF_MS = 12e4;
  var BACKOFF_JITTER = 0.2;
  function uniformRandom(min, max) {
    return Math.random() * (max - min) + min;
  }
  var BackoffTimeout = class {
    constructor(callback, options) {
      this.callback = callback;
      this.initialDelay = INITIAL_BACKOFF_MS;
      this.multiplier = BACKOFF_MULTIPLIER;
      this.maxDelay = MAX_BACKOFF_MS;
      this.jitter = BACKOFF_JITTER;
      this.running = false;
      this.hasRef = true;
      if (options) {
        if (options.initialDelay) {
          this.initialDelay = options.initialDelay;
        }
        if (options.multiplier) {
          this.multiplier = options.multiplier;
        }
        if (options.jitter) {
          this.jitter = options.jitter;
        }
        if (options.maxDelay) {
          this.maxDelay = options.maxDelay;
        }
      }
      this.nextDelay = this.initialDelay;
      this.timerId = setTimeout(() => {
      }, 0);
      clearTimeout(this.timerId);
    }
    runOnce() {
      var _a, _b;
      this.running = true;
      this.timerId = setTimeout(() => {
        this.callback();
        this.running = false;
      }, this.nextDelay);
      if (!this.hasRef) {
        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
      const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);
      const jitterMagnitude = nextBackoff * this.jitter;
      this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);
    }
    stop() {
      clearTimeout(this.timerId);
      this.running = false;
    }
    reset() {
      this.nextDelay = this.initialDelay;
    }
    isRunning() {
      return this.running;
    }
    ref() {
      var _a, _b;
      this.hasRef = true;
      (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    unref() {
      var _a, _b;
      this.hasRef = false;
      (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
  };
  exports2.BackoffTimeout = BackoffTimeout;
});

// node_modules/@grpc/grpc-js/build/src/service-config.js
var require_service_config = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.extractAndSelectServiceConfig = exports2.validateServiceConfig = void 0;
  var os = require("os");
  var load_balancer_1 = require_load_balancer();
  var TIMEOUT_REGEX = /^\d+(\.\d{1,9})?s$/;
  var CLIENT_LANGUAGE_STRING = "node";
  function validateName(obj) {
    if (!("service" in obj) || typeof obj.service !== "string") {
      throw new Error("Invalid method config name: invalid service");
    }
    const result = {
      service: obj.service
    };
    if ("method" in obj) {
      if (typeof obj.method === "string") {
        result.method = obj.method;
      } else {
        throw new Error("Invalid method config name: invalid method");
      }
    }
    return result;
  }
  function validateMethodConfig(obj) {
    const result = {
      name: []
    };
    if (!("name" in obj) || !Array.isArray(obj.name)) {
      throw new Error("Invalid method config: invalid name array");
    }
    for (const name of obj.name) {
      result.name.push(validateName(name));
    }
    if ("waitForReady" in obj) {
      if (typeof obj.waitForReady !== "boolean") {
        throw new Error("Invalid method config: invalid waitForReady");
      }
      result.waitForReady = obj.waitForReady;
    }
    if ("timeout" in obj) {
      if (!(typeof obj.timeout === "string") || !TIMEOUT_REGEX.test(obj.timeout)) {
        throw new Error("Invalid method config: invalid timeout");
      }
      result.timeout = obj.timeout;
    }
    if ("maxRequestBytes" in obj) {
      if (typeof obj.maxRequestBytes !== "number") {
        throw new Error("Invalid method config: invalid maxRequestBytes");
      }
      result.maxRequestBytes = obj.maxRequestBytes;
    }
    if ("maxResponseBytes" in obj) {
      if (typeof obj.maxResponseBytes !== "number") {
        throw new Error("Invalid method config: invalid maxRequestBytes");
      }
      result.maxResponseBytes = obj.maxResponseBytes;
    }
    return result;
  }
  function validateServiceConfig(obj) {
    const result = {
      loadBalancingConfig: [],
      methodConfig: []
    };
    if ("loadBalancingPolicy" in obj) {
      if (typeof obj.loadBalancingPolicy === "string") {
        result.loadBalancingPolicy = obj.loadBalancingPolicy;
      } else {
        throw new Error("Invalid service config: invalid loadBalancingPolicy");
      }
    }
    if ("loadBalancingConfig" in obj) {
      if (Array.isArray(obj.loadBalancingConfig)) {
        for (const config of obj.loadBalancingConfig) {
          result.loadBalancingConfig.push(load_balancer_1.validateLoadBalancingConfig(config));
        }
      } else {
        throw new Error("Invalid service config: invalid loadBalancingConfig");
      }
    }
    if ("methodConfig" in obj) {
      if (Array.isArray(obj.methodConfig)) {
        for (const methodConfig of obj.methodConfig) {
          result.methodConfig.push(validateMethodConfig(methodConfig));
        }
      }
    }
    const seenMethodNames = [];
    for (const methodConfig of result.methodConfig) {
      for (const name of methodConfig.name) {
        for (const seenName of seenMethodNames) {
          if (name.service === seenName.service && name.method === seenName.method) {
            throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);
          }
        }
        seenMethodNames.push(name);
      }
    }
    return result;
  }
  exports2.validateServiceConfig = validateServiceConfig;
  function validateCanaryConfig(obj) {
    if (!("serviceConfig" in obj)) {
      throw new Error("Invalid service config choice: missing service config");
    }
    const result = {
      serviceConfig: validateServiceConfig(obj.serviceConfig)
    };
    if ("clientLanguage" in obj) {
      if (Array.isArray(obj.clientLanguage)) {
        result.clientLanguage = [];
        for (const lang of obj.clientLanguage) {
          if (typeof lang === "string") {
            result.clientLanguage.push(lang);
          } else {
            throw new Error("Invalid service config choice: invalid clientLanguage");
          }
        }
      } else {
        throw new Error("Invalid service config choice: invalid clientLanguage");
      }
    }
    if ("clientHostname" in obj) {
      if (Array.isArray(obj.clientHostname)) {
        result.clientHostname = [];
        for (const lang of obj.clientHostname) {
          if (typeof lang === "string") {
            result.clientHostname.push(lang);
          } else {
            throw new Error("Invalid service config choice: invalid clientHostname");
          }
        }
      } else {
        throw new Error("Invalid service config choice: invalid clientHostname");
      }
    }
    if ("percentage" in obj) {
      if (typeof obj.percentage === "number" && 0 <= obj.percentage && obj.percentage <= 100) {
        result.percentage = obj.percentage;
      } else {
        throw new Error("Invalid service config choice: invalid percentage");
      }
    }
    const allowedFields = [
      "clientLanguage",
      "percentage",
      "clientHostname",
      "serviceConfig"
    ];
    for (const field in obj) {
      if (!allowedFields.includes(field)) {
        throw new Error(`Invalid service config choice: unexpected field ${field}`);
      }
    }
    return result;
  }
  function validateAndSelectCanaryConfig(obj, percentage) {
    if (!Array.isArray(obj)) {
      throw new Error("Invalid service config list");
    }
    for (const config of obj) {
      const validatedConfig = validateCanaryConfig(config);
      if (typeof validatedConfig.percentage === "number" && percentage > validatedConfig.percentage) {
        continue;
      }
      if (Array.isArray(validatedConfig.clientHostname)) {
        let hostnameMatched = false;
        for (const hostname of validatedConfig.clientHostname) {
          if (hostname === os.hostname()) {
            hostnameMatched = true;
          }
        }
        if (!hostnameMatched) {
          continue;
        }
      }
      if (Array.isArray(validatedConfig.clientLanguage)) {
        let languageMatched = false;
        for (const language of validatedConfig.clientLanguage) {
          if (language === CLIENT_LANGUAGE_STRING) {
            languageMatched = true;
          }
        }
        if (!languageMatched) {
          continue;
        }
      }
      return validatedConfig.serviceConfig;
    }
    throw new Error("No matching service config found");
  }
  function extractAndSelectServiceConfig(txtRecord, percentage) {
    for (const record of txtRecord) {
      if (record.length > 0 && record[0].startsWith("grpc_config=")) {
        const recordString = record.join("").substring("grpc_config=".length);
        const recordJson = JSON.parse(recordString);
        return validateAndSelectCanaryConfig(recordJson, percentage);
      }
    }
    return null;
  }
  exports2.extractAndSelectServiceConfig = extractAndSelectServiceConfig;
});

// node_modules/@grpc/grpc-js/build/src/uri-parser.js
var require_uri_parser = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.uriToString = exports2.splitHostPort = exports2.parseUri = void 0;
  var URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\/\/([^/]*)\/)?(.+)$/;
  function parseUri(uriString) {
    const parsedUri = URI_REGEX.exec(uriString);
    if (parsedUri === null) {
      return null;
    }
    return {
      scheme: parsedUri[1],
      authority: parsedUri[2],
      path: parsedUri[3]
    };
  }
  exports2.parseUri = parseUri;
  var NUMBER_REGEX = /^\d+$/;
  function splitHostPort(path) {
    if (path.startsWith("[")) {
      const hostEnd = path.indexOf("]");
      if (hostEnd === -1) {
        return null;
      }
      const host = path.substring(1, hostEnd);
      if (host.indexOf(":") === -1) {
        return null;
      }
      if (path.length > hostEnd + 1) {
        if (path[hostEnd + 1] === ":") {
          const portString = path.substring(hostEnd + 2);
          if (NUMBER_REGEX.test(portString)) {
            return {
              host,
              port: +portString
            };
          } else {
            return null;
          }
        } else {
          return null;
        }
      } else {
        return {
          host
        };
      }
    } else {
      const splitPath = path.split(":");
      if (splitPath.length === 2) {
        if (NUMBER_REGEX.test(splitPath[1])) {
          return {
            host: splitPath[0],
            port: +splitPath[1]
          };
        } else {
          return null;
        }
      } else {
        return {
          host: path
        };
      }
    }
  }
  exports2.splitHostPort = splitHostPort;
  function uriToString(uri) {
    let result = "";
    if (uri.scheme !== void 0) {
      result += uri.scheme + ":";
    }
    if (uri.authority !== void 0) {
      result += "//" + uri.authority + "/";
    }
    result += uri.path;
    return result;
  }
  exports2.uriToString = uriToString;
});

// node_modules/@grpc/grpc-js/build/src/resolver-dns.js
var require_resolver_dns = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.setup = void 0;
  var resolver_1 = require_resolver();
  var dns = require("dns");
  var util = require("util");
  var service_config_1 = require_service_config();
  var constants_1 = require_constants();
  var metadata_1 = require_metadata();
  var logging = require_logging();
  var constants_2 = require_constants();
  var uri_parser_1 = require_uri_parser();
  var net_1 = require("net");
  var TRACER_NAME = "dns_resolver";
  function trace(text) {
    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
  }
  var DEFAULT_PORT = 443;
  var resolveTxtPromise = util.promisify(dns.resolveTxt);
  var dnsLookupPromise = util.promisify(dns.lookup);
  function mergeArrays(...arrays) {
    const result = [];
    for (let i = 0; i < Math.max.apply(null, arrays.map((array) => array.length)); i++) {
      for (const array of arrays) {
        if (i < array.length) {
          result.push(array[i]);
        }
      }
    }
    return result;
  }
  var DnsResolver = class {
    constructor(target, listener, channelOptions) {
      var _a, _b;
      this.target = target;
      this.listener = listener;
      this.pendingLookupPromise = null;
      this.pendingTxtPromise = null;
      this.latestLookupResult = null;
      this.latestServiceConfig = null;
      this.latestServiceConfigError = null;
      trace("Resolver constructed for target " + uri_parser_1.uriToString(target));
      const hostPort = uri_parser_1.splitHostPort(target.path);
      if (hostPort === null) {
        this.ipResult = null;
        this.dnsHostname = null;
        this.port = null;
      } else {
        if (net_1.isIPv4(hostPort.host) || net_1.isIPv6(hostPort.host)) {
          this.ipResult = [
            {
              host: hostPort.host,
              port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT
            }
          ];
          this.dnsHostname = null;
          this.port = null;
        } else {
          this.ipResult = null;
          this.dnsHostname = hostPort.host;
          this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : DEFAULT_PORT;
        }
      }
      this.percentage = Math.random() * 100;
      this.defaultResolutionError = {
        code: constants_1.Status.UNAVAILABLE,
        details: `Name resolution failed for target ${uri_parser_1.uriToString(this.target)}`,
        metadata: new metadata_1.Metadata()
      };
    }
    startResolution() {
      if (this.ipResult !== null) {
        trace("Returning IP address for target " + uri_parser_1.uriToString(this.target));
        setImmediate(() => {
          this.listener.onSuccessfulResolution(this.ipResult, null, null, {});
        });
        return;
      }
      if (this.dnsHostname === null) {
        setImmediate(() => {
          this.listener.onError({
            code: constants_1.Status.UNAVAILABLE,
            details: `Failed to parse DNS address ${uri_parser_1.uriToString(this.target)}`,
            metadata: new metadata_1.Metadata()
          });
        });
      } else {
        this.latestLookupResult = null;
        const hostname = this.dnsHostname;
        this.pendingLookupPromise = dnsLookupPromise(hostname, {all: true});
        this.pendingLookupPromise.then((addressList) => {
          this.pendingLookupPromise = null;
          const ip4Addresses = addressList.filter((addr) => addr.family === 4);
          const ip6Addresses = addressList.filter((addr) => addr.family === 6);
          this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map((addr) => ({host: addr.address, port: +this.port}));
          const allAddressesString = "[" + this.latestLookupResult.map((addr) => addr.host + ":" + addr.port).join(",") + "]";
          trace("Resolved addresses for target " + uri_parser_1.uriToString(this.target) + ": " + allAddressesString);
          if (this.latestLookupResult.length === 0) {
            this.listener.onError(this.defaultResolutionError);
            return;
          }
          this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, {});
        }, (err) => {
          trace("Resolution error for target " + uri_parser_1.uriToString(this.target) + ": " + err.message);
          this.pendingLookupPromise = null;
          this.listener.onError(this.defaultResolutionError);
        });
        if (this.pendingTxtPromise === null) {
          this.pendingTxtPromise = resolveTxtPromise(hostname);
          this.pendingTxtPromise.then((txtRecord) => {
            this.pendingTxtPromise = null;
            try {
              this.latestServiceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, this.percentage);
            } catch (err) {
              this.latestServiceConfigError = {
                code: constants_1.Status.UNAVAILABLE,
                details: "Parsing service config failed",
                metadata: new metadata_1.Metadata()
              };
            }
            if (this.latestLookupResult !== null) {
              this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, {});
            }
          }, (err) => {
          });
        }
      }
    }
    updateResolution() {
      trace("Resolution update requested for target " + uri_parser_1.uriToString(this.target));
      if (this.pendingLookupPromise === null) {
        this.startResolution();
      }
    }
    destroy() {
    }
    static getDefaultAuthority(target) {
      return target.path;
    }
  };
  function setup() {
    resolver_1.registerResolver("dns", DnsResolver);
    resolver_1.registerDefaultScheme("dns");
  }
  exports2.setup = setup;
});

// node_modules/@grpc/grpc-js/build/src/resolver-uds.js
var require_resolver_uds = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.setup = void 0;
  var resolver_1 = require_resolver();
  var UdsResolver = class {
    constructor(target, listener, channelOptions) {
      this.listener = listener;
      this.addresses = [];
      let path;
      if (target.authority === "") {
        path = "/" + target.path;
      } else {
        path = target.path;
      }
      this.addresses = [{path}];
    }
    updateResolution() {
      process.nextTick(this.listener.onSuccessfulResolution, this.addresses, null, null, {});
    }
    destroy() {
    }
    static getDefaultAuthority(target) {
      return "localhost";
    }
  };
  function setup() {
    resolver_1.registerResolver("unix", UdsResolver);
  }
  exports2.setup = setup;
});

// node_modules/@grpc/grpc-js/build/src/resolver.js
var require_resolver = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.registerAll = exports2.mapUriDefaultScheme = exports2.getDefaultAuthority = exports2.createResolver = exports2.registerDefaultScheme = exports2.registerResolver = void 0;
  var resolver_dns = require_resolver_dns();
  var resolver_uds = require_resolver_uds();
  var uri_parser_1 = require_uri_parser();
  var registeredResolvers = {};
  var defaultScheme = null;
  function registerResolver(scheme, resolverClass) {
    registeredResolvers[scheme] = resolverClass;
  }
  exports2.registerResolver = registerResolver;
  function registerDefaultScheme(scheme) {
    defaultScheme = scheme;
  }
  exports2.registerDefaultScheme = registerDefaultScheme;
  function createResolver(target, listener, options) {
    if (target.scheme !== void 0 && target.scheme in registeredResolvers) {
      return new registeredResolvers[target.scheme](target, listener, options);
    } else {
      throw new Error(`No resolver could be created for target ${uri_parser_1.uriToString(target)}`);
    }
  }
  exports2.createResolver = createResolver;
  function getDefaultAuthority(target) {
    if (target.scheme !== void 0 && target.scheme in registeredResolvers) {
      return registeredResolvers[target.scheme].getDefaultAuthority(target);
    } else {
      throw new Error(`Invalid target ${uri_parser_1.uriToString(target)}`);
    }
  }
  exports2.getDefaultAuthority = getDefaultAuthority;
  function mapUriDefaultScheme(target) {
    if (target.scheme === void 0 || !(target.scheme in registeredResolvers)) {
      if (defaultScheme !== null) {
        return {
          scheme: defaultScheme,
          authority: void 0,
          path: uri_parser_1.uriToString(target)
        };
      } else {
        return null;
      }
    }
    return target;
  }
  exports2.mapUriDefaultScheme = mapUriDefaultScheme;
  function registerAll() {
    resolver_dns.setup();
    resolver_uds.setup();
  }
  exports2.registerAll = registerAll;
});

// node_modules/@grpc/grpc-js/build/src/http_proxy.js
var require_http_proxy = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getProxiedConnection = exports2.mapProxyName = void 0;
  var logging_1 = require_logging();
  var constants_1 = require_constants();
  var resolver_1 = require_resolver();
  var http = require("http");
  var tls = require("tls");
  var logging = require_logging();
  var subchannel_1 = require_subchannel();
  var uri_parser_1 = require_uri_parser();
  var url_1 = require("url");
  var TRACER_NAME = "proxy";
  function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
  }
  function getProxyInfo() {
    let proxyEnv = "";
    let envVar = "";
    if (process.env.grpc_proxy) {
      envVar = "grpc_proxy";
      proxyEnv = process.env.grpc_proxy;
    } else if (process.env.https_proxy) {
      envVar = "https_proxy";
      proxyEnv = process.env.https_proxy;
    } else if (process.env.http_proxy) {
      envVar = "http_proxy";
      proxyEnv = process.env.http_proxy;
    } else {
      return {};
    }
    let proxyUrl;
    try {
      proxyUrl = new url_1.URL(proxyEnv);
    } catch (e) {
      logging_1.log(constants_1.LogVerbosity.ERROR, `cannot parse value of "${envVar}" env var`);
      return {};
    }
    if (proxyUrl.protocol !== "http:") {
      logging_1.log(constants_1.LogVerbosity.ERROR, `"${proxyUrl.protocol}" scheme not supported in proxy URI`);
      return {};
    }
    let userCred = null;
    if (proxyUrl.username) {
      if (proxyUrl.password) {
        logging_1.log(constants_1.LogVerbosity.INFO, "userinfo found in proxy URI");
        userCred = `${proxyUrl.username}:${proxyUrl.password}`;
      } else {
        userCred = proxyUrl.username;
      }
    }
    const hostname = proxyUrl.hostname;
    let port = proxyUrl.port;
    if (port === "") {
      port = "80";
    }
    const result = {
      address: `${hostname}:${port}`
    };
    if (userCred) {
      result.creds = userCred;
    }
    trace("Proxy server " + result.address + " set by environment variable " + envVar);
    return result;
  }
  function getNoProxyHostList() {
    let noProxyStr = process.env.no_grpc_proxy;
    let envVar = "no_grpc_proxy";
    if (!noProxyStr) {
      noProxyStr = process.env.no_proxy;
      envVar = "no_proxy";
    }
    if (noProxyStr) {
      trace("No proxy server list set by environment variable " + envVar);
      return noProxyStr.split(",");
    } else {
      return [];
    }
  }
  function mapProxyName(target, options) {
    var _a;
    const noProxyResult = {
      target,
      extraOptions: {}
    };
    if (((_a = options["grpc.enable_http_proxy"]) !== null && _a !== void 0 ? _a : 1) === 0) {
      return noProxyResult;
    }
    const proxyInfo = getProxyInfo();
    if (!proxyInfo.address) {
      return noProxyResult;
    }
    const hostPort = uri_parser_1.splitHostPort(target.path);
    if (!hostPort) {
      return noProxyResult;
    }
    const serverHost = hostPort.host;
    for (const host of getNoProxyHostList()) {
      if (host === serverHost) {
        trace("Not using proxy for target in no_proxy list: " + uri_parser_1.uriToString(target));
        return noProxyResult;
      }
    }
    const extraOptions = {
      "grpc.http_connect_target": uri_parser_1.uriToString(target)
    };
    if (proxyInfo.creds) {
      extraOptions["grpc.http_connect_creds"] = proxyInfo.creds;
    }
    return {
      target: {
        scheme: "dns",
        path: proxyInfo.address
      },
      extraOptions
    };
  }
  exports2.mapProxyName = mapProxyName;
  function getProxiedConnection(address, channelOptions, connectionOptions) {
    if (!("grpc.http_connect_target" in channelOptions)) {
      return Promise.resolve({});
    }
    const realTarget = channelOptions["grpc.http_connect_target"];
    const parsedTarget = uri_parser_1.parseUri(realTarget);
    if (parsedTarget === null) {
      return Promise.resolve({});
    }
    const options = {
      method: "CONNECT",
      path: parsedTarget.path
    };
    if (subchannel_1.isTcpSubchannelAddress(address)) {
      options.host = address.host;
      options.port = address.port;
    } else {
      options.socketPath = address.path;
    }
    if ("grpc.http_connect_creds" in channelOptions) {
      options.headers = {
        "Proxy-Authorization": "Basic " + Buffer.from(channelOptions["grpc.http_connect_creds"]).toString("base64")
      };
    }
    const proxyAddressString = subchannel_1.subchannelAddressToString(address);
    trace("Using proxy " + proxyAddressString + " to connect to " + options.path);
    return new Promise((resolve, reject) => {
      const request = http.request(options);
      request.once("connect", (res, socket, head) => {
        var _a;
        request.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode === 200) {
          trace("Successfully connected to " + options.path + " through proxy " + proxyAddressString);
          if ("secureContext" in connectionOptions) {
            const targetPath = resolver_1.getDefaultAuthority(parsedTarget);
            const hostPort = uri_parser_1.splitHostPort(targetPath);
            const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;
            const cts = tls.connect(Object.assign({host: remoteHost, servername: remoteHost, socket}, connectionOptions), () => {
              trace("Successfully established a TLS connection to " + options.path + " through proxy " + proxyAddressString);
              resolve({socket: cts, realTarget: parsedTarget});
            });
            cts.on("error", () => {
              reject();
            });
          } else {
            resolve({
              socket,
              realTarget: parsedTarget
            });
          }
        } else {
          logging_1.log(constants_1.LogVerbosity.ERROR, "Failed to connect to " + options.path + " through proxy " + proxyAddressString + " with status " + res.statusCode);
          reject();
        }
      });
      request.once("error", (err) => {
        request.removeAllListeners();
        logging_1.log(constants_1.LogVerbosity.ERROR, "Failed to connect to proxy " + proxyAddressString + " with error " + err.message);
        reject();
      });
      request.end();
    });
  }
  exports2.getProxiedConnection = getProxiedConnection;
});

// node_modules/@grpc/grpc-js/package.json
var require_package2 = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "@grpc/grpc-js",
    version: "1.2.12",
    description: "gRPC Library for Node - pure JS implementation",
    homepage: "https://grpc.io/",
    repository: "https://github.com/grpc/grpc-node/tree/master/packages/grpc-js",
    main: "build/src/index.js",
    engines: {
      node: "^8.13.0 || >=10.10.0"
    },
    keywords: [],
    author: {
      name: "Google Inc."
    },
    types: "build/src/index.d.ts",
    license: "Apache-2.0",
    devDependencies: {
      "@grpc/proto-loader": "^0.5.5",
      "@types/gulp": "^4.0.6",
      "@types/gulp-mocha": "0.0.32",
      "@types/lodash": "^4.14.108",
      "@types/mocha": "^5.2.6",
      "@types/ncp": "^2.0.1",
      "@types/pify": "^3.0.2",
      "@types/semver": "^6.0.1",
      "@types/yargs": "^15.0.5",
      "clang-format": "^1.0.55",
      execa: "^2.0.3",
      gts: "^2.0.0",
      gulp: "^4.0.2",
      "gulp-mocha": "^6.0.0",
      lodash: "^4.17.4",
      "mocha-jenkins-reporter": "^0.4.1",
      ncp: "^2.0.0",
      pify: "^4.0.1",
      rimraf: "^3.0.2",
      "ts-node": "^8.3.0",
      typescript: "^3.7.2",
      yargs: "^15.4.1"
    },
    contributors: [
      {
        name: "Google Inc."
      }
    ],
    scripts: {
      build: "npm run compile",
      clean: `node -e 'require("rimraf")("./build", () => {})'`,
      compile: "tsc -p .",
      format: 'clang-format -i -style="{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}" src/*.ts test/*.ts',
      lint: "npm run check",
      prepare: "npm run compile",
      test: "gulp test",
      check: "gts check src/**/*.ts",
      fix: "gts fix src/*.ts",
      pretest: "npm run compile",
      posttest: "npm run check"
    },
    dependencies: {
      "@types/node": ">=12.12.47",
      "google-auth-library": "^6.1.1",
      semver: "^6.2.0"
    },
    files: [
      "src/**/*.ts",
      "build/src/*.{js,d.ts,js.map}",
      "LICENSE",
      "deps/envoy-api/envoy/api/v2/**/*.proto",
      "deps/envoy-api/envoy/config/**/*.proto",
      "deps/envoy-api/envoy/service/**/*.proto",
      "deps/envoy-api/envoy/type/**/*.proto",
      "deps/udpa/udpa/**/*.proto",
      "deps/googleapis/google/api/*.proto",
      "deps/googleapis/google/rpc/*.proto",
      "deps/protoc-gen-validate/validate/**/*.proto"
    ]
  };
});

// node_modules/@grpc/grpc-js/build/src/subchannel.js
var require_subchannel = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Subchannel = exports2.subchannelAddressToString = exports2.subchannelAddressEqual = exports2.isTcpSubchannelAddress = void 0;
  var http2 = require("http2");
  var tls_1 = require("tls");
  var channel_1 = require_channel();
  var backoff_timeout_1 = require_backoff_timeout();
  var resolver_1 = require_resolver();
  var logging = require_logging();
  var constants_1 = require_constants();
  var http_proxy_1 = require_http_proxy();
  var net = require("net");
  var uri_parser_1 = require_uri_parser();
  var clientVersion = require_package2().version;
  var TRACER_NAME = "subchannel";
  function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
  }
  function refTrace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, "subchannel_refcount", text);
  }
  var KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
  var KEEPALIVE_TIMEOUT_MS = 2e4;
  var {HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT} = http2.constants;
  var tooManyPingsData = Buffer.from("too_many_pings", "ascii");
  function isTcpSubchannelAddress(address) {
    return "port" in address;
  }
  exports2.isTcpSubchannelAddress = isTcpSubchannelAddress;
  function subchannelAddressEqual(address1, address2) {
    if (isTcpSubchannelAddress(address1)) {
      return isTcpSubchannelAddress(address2) && address1.host === address2.host && address1.port === address2.port;
    } else {
      return !isTcpSubchannelAddress(address2) && address1.path === address2.path;
    }
  }
  exports2.subchannelAddressEqual = subchannelAddressEqual;
  function subchannelAddressToString(address) {
    if (isTcpSubchannelAddress(address)) {
      return address.host + ":" + address.port;
    } else {
      return address.path;
    }
  }
  exports2.subchannelAddressToString = subchannelAddressToString;
  var Subchannel = class {
    constructor(channelTarget, subchannelAddress, options, credentials) {
      this.channelTarget = channelTarget;
      this.subchannelAddress = subchannelAddress;
      this.options = options;
      this.credentials = credentials;
      this.connectivityState = channel_1.ConnectivityState.IDLE;
      this.session = null;
      this.continueConnecting = false;
      this.stateListeners = [];
      this.disconnectListeners = [];
      this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;
      this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;
      this.keepaliveWithoutCalls = false;
      this.callRefcount = 0;
      this.refcount = 0;
      this.userAgent = [
        options["grpc.primary_user_agent"],
        `grpc-node-js/${clientVersion}`,
        options["grpc.secondary_user_agent"]
      ].filter((e) => e).join(" ");
      if ("grpc.keepalive_time_ms" in options) {
        this.keepaliveTimeMs = options["grpc.keepalive_time_ms"];
      }
      if ("grpc.keepalive_timeout_ms" in options) {
        this.keepaliveTimeoutMs = options["grpc.keepalive_timeout_ms"];
      }
      if ("grpc.keepalive_permit_without_calls" in options) {
        this.keepaliveWithoutCalls = options["grpc.keepalive_permit_without_calls"] === 1;
      } else {
        this.keepaliveWithoutCalls = false;
      }
      this.keepaliveIntervalId = setTimeout(() => {
      }, 0);
      clearTimeout(this.keepaliveIntervalId);
      this.keepaliveTimeoutId = setTimeout(() => {
      }, 0);
      clearTimeout(this.keepaliveTimeoutId);
      const backoffOptions = {
        initialDelay: options["grpc.initial_reconnect_backoff_ms"],
        maxDelay: options["grpc.max_reconnect_backoff_ms"]
      };
      this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
        this.handleBackoffTimer();
      }, backoffOptions);
      this.subchannelAddressString = subchannelAddressToString(subchannelAddress);
    }
    handleBackoffTimer() {
      if (this.continueConnecting) {
        this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE], channel_1.ConnectivityState.CONNECTING);
      } else {
        this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE], channel_1.ConnectivityState.IDLE);
      }
    }
    startBackoff() {
      this.backoffTimeout.runOnce();
    }
    stopBackoff() {
      this.backoffTimeout.stop();
      this.backoffTimeout.reset();
    }
    sendPing() {
      logging.trace(constants_1.LogVerbosity.DEBUG, "keepalive", "Sending ping to " + this.subchannelAddressString);
      this.keepaliveTimeoutId = setTimeout(() => {
        this.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);
      }, this.keepaliveTimeoutMs);
      this.session.ping((err, duration, payload) => {
        clearTimeout(this.keepaliveTimeoutId);
      });
    }
    startKeepalivePings() {
      this.keepaliveIntervalId = setInterval(() => {
        this.sendPing();
      }, this.keepaliveTimeMs);
    }
    stopKeepalivePings() {
      clearInterval(this.keepaliveIntervalId);
      clearTimeout(this.keepaliveTimeoutId);
    }
    createSession(proxyConnectionResult) {
      var _a, _b, _c;
      const targetAuthority = resolver_1.getDefaultAuthority((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);
      let connectionOptions = this.credentials._getConnectionOptions() || {};
      connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;
      let addressScheme = "http://";
      if ("secureContext" in connectionOptions) {
        addressScheme = "https://";
        if (this.options["grpc.ssl_target_name_override"]) {
          const sslTargetNameOverride = this.options["grpc.ssl_target_name_override"];
          connectionOptions.checkServerIdentity = (host, cert) => {
            return tls_1.checkServerIdentity(sslTargetNameOverride, cert);
          };
          connectionOptions.servername = sslTargetNameOverride;
        } else {
          const authorityHostname = (_c = (_b = uri_parser_1.splitHostPort(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : "localhost";
          connectionOptions.servername = authorityHostname;
        }
        if (proxyConnectionResult.socket) {
          connectionOptions.createConnection = (authority, option) => {
            return proxyConnectionResult.socket;
          };
        }
      } else {
        connectionOptions.createConnection = (authority, option) => {
          if (proxyConnectionResult.socket) {
            return proxyConnectionResult.socket;
          } else {
            return net.connect(this.subchannelAddress);
          }
        };
      }
      connectionOptions = Object.assign(Object.assign({}, connectionOptions), this.subchannelAddress);
      const session = http2.connect(addressScheme + targetAuthority, connectionOptions);
      this.session = session;
      session.unref();
      session.once("connect", () => {
        if (this.session === session) {
          this.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.READY);
        }
      });
      session.once("close", () => {
        if (this.session === session) {
          this.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.TRANSIENT_FAILURE);
          this.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);
        }
      });
      session.once("goaway", (errorCode, lastStreamID, opaqueData) => {
        if (this.session === session) {
          if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {
            this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);
            logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${uri_parser_1.uriToString(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTimeMs} ms`);
          }
          trace(this.subchannelAddressString + " connection closed by GOAWAY with code " + errorCode);
          this.transitionToState([channel_1.ConnectivityState.CONNECTING, channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);
        }
      });
      session.once("error", (error) => {
        trace(this.subchannelAddressString + " connection closed with error " + error.message);
      });
    }
    startConnectingInternal() {
      var _a, _b;
      const connectionOptions = this.credentials._getConnectionOptions() || {};
      if ("secureContext" in connectionOptions) {
        connectionOptions.ALPNProtocols = ["h2"];
        if (this.options["grpc.ssl_target_name_override"]) {
          const sslTargetNameOverride = this.options["grpc.ssl_target_name_override"];
          connectionOptions.checkServerIdentity = (host, cert) => {
            return tls_1.checkServerIdentity(sslTargetNameOverride, cert);
          };
          connectionOptions.servername = sslTargetNameOverride;
        } else {
          if ("grpc.http_connect_target" in this.options) {
            const targetPath = resolver_1.getDefaultAuthority((_a = uri_parser_1.parseUri(this.options["grpc.http_connect_target"])) !== null && _a !== void 0 ? _a : {
              path: "localhost"
            });
            const hostPort = uri_parser_1.splitHostPort(targetPath);
            connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;
          }
        }
      }
      http_proxy_1.getProxiedConnection(this.subchannelAddress, this.options, connectionOptions).then((result) => {
        this.createSession(result);
      }, (reason) => {
        this.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.TRANSIENT_FAILURE);
      });
    }
    transitionToState(oldStates, newState) {
      if (oldStates.indexOf(this.connectivityState) === -1) {
        return false;
      }
      trace(this.subchannelAddressString + " " + channel_1.ConnectivityState[this.connectivityState] + " -> " + channel_1.ConnectivityState[newState]);
      const previousState = this.connectivityState;
      this.connectivityState = newState;
      switch (newState) {
        case channel_1.ConnectivityState.READY:
          this.stopBackoff();
          this.session.socket.once("close", () => {
            for (const listener of this.disconnectListeners) {
              listener();
            }
          });
          if (this.keepaliveWithoutCalls) {
            this.startKeepalivePings();
          }
          break;
        case channel_1.ConnectivityState.CONNECTING:
          this.startBackoff();
          this.startConnectingInternal();
          this.continueConnecting = false;
          break;
        case channel_1.ConnectivityState.TRANSIENT_FAILURE:
          if (this.session) {
            this.session.close();
          }
          this.session = null;
          this.stopKeepalivePings();
          if (!this.backoffTimeout.isRunning()) {
            process.nextTick(() => {
              this.handleBackoffTimer();
            });
          }
          break;
        case channel_1.ConnectivityState.IDLE:
          if (this.session) {
            this.session.close();
          }
          this.session = null;
          this.stopKeepalivePings();
          break;
        default:
          throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);
      }
      for (const listener of [...this.stateListeners]) {
        listener(this, previousState, newState);
      }
      return true;
    }
    checkBothRefcounts() {
      if (this.callRefcount === 0 && this.refcount === 0) {
        this.transitionToState([
          channel_1.ConnectivityState.CONNECTING,
          channel_1.ConnectivityState.IDLE,
          channel_1.ConnectivityState.READY
        ], channel_1.ConnectivityState.TRANSIENT_FAILURE);
      }
    }
    callRef() {
      refTrace(this.subchannelAddressString + " callRefcount " + this.callRefcount + " -> " + (this.callRefcount + 1));
      if (this.callRefcount === 0) {
        if (this.session) {
          this.session.ref();
        }
        this.backoffTimeout.ref();
        if (!this.keepaliveWithoutCalls) {
          this.startKeepalivePings();
        }
      }
      this.callRefcount += 1;
    }
    callUnref() {
      refTrace(this.subchannelAddressString + " callRefcount " + this.callRefcount + " -> " + (this.callRefcount - 1));
      this.callRefcount -= 1;
      if (this.callRefcount === 0) {
        if (this.session) {
          this.session.unref();
        }
        this.backoffTimeout.unref();
        if (!this.keepaliveWithoutCalls) {
          this.stopKeepalivePings();
        }
        this.checkBothRefcounts();
      }
    }
    ref() {
      refTrace(this.subchannelAddressString + " refcount " + this.refcount + " -> " + (this.refcount + 1));
      this.refcount += 1;
    }
    unref() {
      refTrace(this.subchannelAddressString + " refcount " + this.refcount + " -> " + (this.refcount - 1));
      this.refcount -= 1;
      this.checkBothRefcounts();
    }
    unrefIfOneRef() {
      if (this.refcount === 1) {
        this.unref();
        return true;
      }
      return false;
    }
    startCallStream(metadata, callStream, extraFilterFactory) {
      const headers = metadata.toHttp2Headers();
      headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();
      headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;
      headers[HTTP2_HEADER_CONTENT_TYPE] = "application/grpc";
      headers[HTTP2_HEADER_METHOD] = "POST";
      headers[HTTP2_HEADER_PATH] = callStream.getMethod();
      headers[HTTP2_HEADER_TE] = "trailers";
      let http2Stream;
      try {
        http2Stream = this.session.request(headers);
      } catch (e) {
        this.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.TRANSIENT_FAILURE);
        throw e;
      }
      let headersString = "";
      for (const header of Object.keys(headers)) {
        headersString += "		" + header + ": " + headers[header] + "\n";
      }
      logging.trace(constants_1.LogVerbosity.DEBUG, "call_stream", "Starting stream on subchannel " + this.subchannelAddressString + " with headers\n" + headersString);
      callStream.attachHttp2Stream(http2Stream, this, extraFilterFactory);
    }
    startConnecting() {
      if (!this.transitionToState([channel_1.ConnectivityState.IDLE], channel_1.ConnectivityState.CONNECTING)) {
        if (this.connectivityState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
          this.continueConnecting = true;
        }
      }
    }
    getConnectivityState() {
      return this.connectivityState;
    }
    addConnectivityStateListener(listener) {
      this.stateListeners.push(listener);
    }
    removeConnectivityStateListener(listener) {
      const listenerIndex = this.stateListeners.indexOf(listener);
      if (listenerIndex > -1) {
        this.stateListeners.splice(listenerIndex, 1);
      }
    }
    addDisconnectListener(listener) {
      this.disconnectListeners.push(listener);
    }
    removeDisconnectListener(listener) {
      const listenerIndex = this.disconnectListeners.indexOf(listener);
      if (listenerIndex > -1) {
        this.disconnectListeners.splice(listenerIndex, 1);
      }
    }
    resetBackoff() {
      this.backoffTimeout.reset();
      this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE], channel_1.ConnectivityState.CONNECTING);
    }
    getAddress() {
      return this.subchannelAddressString;
    }
  };
  exports2.Subchannel = Subchannel;
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js
var require_load_balancer_pick_first = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.setup = exports2.PickFirstLoadBalancer = exports2.PickFirstLoadBalancingConfig = void 0;
  var load_balancer_1 = require_load_balancer();
  var channel_1 = require_channel();
  var picker_1 = require_picker();
  var subchannel_1 = require_subchannel();
  var logging = require_logging();
  var constants_1 = require_constants();
  var TRACER_NAME = "pick_first";
  function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
  }
  var TYPE_NAME = "pick_first";
  var CONNECTION_DELAY_INTERVAL_MS = 250;
  var PickFirstLoadBalancingConfig = class {
    getLoadBalancerName() {
      return TYPE_NAME;
    }
    constructor() {
    }
    toJsonObject() {
      return {
        [TYPE_NAME]: {}
      };
    }
    static createFromJson(obj) {
      return new PickFirstLoadBalancingConfig();
    }
  };
  exports2.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;
  var PickFirstPicker = class {
    constructor(subchannel) {
      this.subchannel = subchannel;
    }
    pick(pickArgs) {
      return {
        pickResultType: picker_1.PickResultType.COMPLETE,
        subchannel: this.subchannel,
        status: null,
        extraFilterFactory: null,
        onCallStarted: null
      };
    }
  };
  var PickFirstLoadBalancer = class {
    constructor(channelControlHelper) {
      this.channelControlHelper = channelControlHelper;
      this.latestAddressList = [];
      this.subchannels = [];
      this.currentState = channel_1.ConnectivityState.IDLE;
      this.currentSubchannelIndex = 0;
      this.currentPick = null;
      this.triedAllSubchannels = false;
      this.subchannelStateCounts = {
        [channel_1.ConnectivityState.CONNECTING]: 0,
        [channel_1.ConnectivityState.IDLE]: 0,
        [channel_1.ConnectivityState.READY]: 0,
        [channel_1.ConnectivityState.SHUTDOWN]: 0,
        [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0
      };
      this.subchannelStateListener = (subchannel, previousState, newState) => {
        this.subchannelStateCounts[previousState] -= 1;
        this.subchannelStateCounts[newState] += 1;
        if (subchannel === this.subchannels[this.currentSubchannelIndex] && newState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
          this.startNextSubchannelConnecting();
        }
        if (newState === channel_1.ConnectivityState.READY) {
          this.pickSubchannel(subchannel);
          return;
        } else {
          if (this.triedAllSubchannels && this.subchannelStateCounts[channel_1.ConnectivityState.IDLE] === this.subchannels.length) {
            this.resetSubchannelList();
            this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
            return;
          }
          if (this.currentPick === null) {
            if (this.triedAllSubchannels) {
              let newLBState;
              if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {
                newLBState = channel_1.ConnectivityState.CONNECTING;
              } else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {
                newLBState = channel_1.ConnectivityState.TRANSIENT_FAILURE;
              } else {
                newLBState = channel_1.ConnectivityState.IDLE;
              }
              if (newLBState !== this.currentState) {
                if (newLBState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
                  this.updateState(newLBState, new picker_1.UnavailablePicker());
                } else {
                  this.updateState(newLBState, new picker_1.QueuePicker(this));
                }
              }
            } else {
              this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
            }
          }
        }
      };
      this.pickedSubchannelStateListener = (subchannel, previousState, newState) => {
        if (newState !== channel_1.ConnectivityState.READY) {
          this.currentPick = null;
          subchannel.unref();
          subchannel.removeConnectivityStateListener(this.pickedSubchannelStateListener);
          if (this.subchannels.length > 0) {
            if (this.triedAllSubchannels) {
              let newLBState;
              if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {
                newLBState = channel_1.ConnectivityState.CONNECTING;
              } else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {
                newLBState = channel_1.ConnectivityState.TRANSIENT_FAILURE;
              } else {
                newLBState = channel_1.ConnectivityState.IDLE;
              }
              if (newLBState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
                this.updateState(newLBState, new picker_1.UnavailablePicker());
              } else {
                this.updateState(newLBState, new picker_1.QueuePicker(this));
              }
            } else {
              this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
            }
          } else {
            this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
          }
        }
      };
      this.connectionDelayTimeout = setTimeout(() => {
      }, 0);
      clearTimeout(this.connectionDelayTimeout);
    }
    startNextSubchannelConnecting() {
      if (this.triedAllSubchannels) {
        return;
      }
      for (const [index, subchannel] of this.subchannels.entries()) {
        if (index > this.currentSubchannelIndex) {
          const subchannelState = subchannel.getConnectivityState();
          if (subchannelState === channel_1.ConnectivityState.IDLE || subchannelState === channel_1.ConnectivityState.CONNECTING) {
            this.startConnecting(index);
            return;
          }
        }
      }
      this.triedAllSubchannels = true;
    }
    startConnecting(subchannelIndex) {
      clearTimeout(this.connectionDelayTimeout);
      this.currentSubchannelIndex = subchannelIndex;
      if (this.subchannels[subchannelIndex].getConnectivityState() === channel_1.ConnectivityState.IDLE) {
        trace("Start connecting to subchannel with address " + this.subchannels[subchannelIndex].getAddress());
        process.nextTick(() => {
          this.subchannels[subchannelIndex].startConnecting();
        });
      }
      this.connectionDelayTimeout = setTimeout(() => {
        this.startNextSubchannelConnecting();
      }, CONNECTION_DELAY_INTERVAL_MS);
    }
    pickSubchannel(subchannel) {
      trace("Pick subchannel with address " + subchannel.getAddress());
      if (this.currentPick !== null) {
        this.currentPick.unref();
        this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);
      }
      this.currentPick = subchannel;
      this.updateState(channel_1.ConnectivityState.READY, new PickFirstPicker(subchannel));
      subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);
      subchannel.ref();
      this.resetSubchannelList();
      clearTimeout(this.connectionDelayTimeout);
    }
    updateState(newState, picker) {
      trace(channel_1.ConnectivityState[this.currentState] + " -> " + channel_1.ConnectivityState[newState]);
      this.currentState = newState;
      this.channelControlHelper.updateState(newState, picker);
    }
    resetSubchannelList() {
      for (const subchannel of this.subchannels) {
        subchannel.removeConnectivityStateListener(this.subchannelStateListener);
        subchannel.unref();
      }
      this.currentSubchannelIndex = 0;
      this.subchannelStateCounts = {
        [channel_1.ConnectivityState.CONNECTING]: 0,
        [channel_1.ConnectivityState.IDLE]: 0,
        [channel_1.ConnectivityState.READY]: 0,
        [channel_1.ConnectivityState.SHUTDOWN]: 0,
        [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0
      };
      this.subchannels = [];
      this.triedAllSubchannels = false;
    }
    connectToAddressList() {
      this.resetSubchannelList();
      trace("Connect to address list " + this.latestAddressList.map((address) => subchannel_1.subchannelAddressToString(address)));
      this.subchannels = this.latestAddressList.map((address) => this.channelControlHelper.createSubchannel(address, {}));
      for (const subchannel of this.subchannels) {
        subchannel.ref();
      }
      for (const subchannel of this.subchannels) {
        subchannel.addConnectivityStateListener(this.subchannelStateListener);
        this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;
        if (subchannel.getConnectivityState() === channel_1.ConnectivityState.READY) {
          this.pickSubchannel(subchannel);
          this.resetSubchannelList();
          return;
        }
      }
      for (const [index, subchannel] of this.subchannels.entries()) {
        const subchannelState = subchannel.getConnectivityState();
        if (subchannelState === channel_1.ConnectivityState.IDLE || subchannelState === channel_1.ConnectivityState.CONNECTING) {
          this.startConnecting(index);
          if (this.currentPick === null) {
            this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
          }
          return;
        }
      }
      if (this.currentPick === null) {
        this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());
      }
    }
    updateAddressList(addressList, lbConfig) {
      if (this.subchannels.length === 0 || !this.latestAddressList.every((value, index) => addressList[index] === value)) {
        this.latestAddressList = addressList;
        this.connectToAddressList();
      }
    }
    exitIdle() {
      for (const subchannel of this.subchannels) {
        subchannel.startConnecting();
      }
      if (this.currentState === channel_1.ConnectivityState.IDLE) {
        if (this.latestAddressList.length > 0) {
          this.connectToAddressList();
        }
      }
      if (this.currentState === channel_1.ConnectivityState.IDLE || this.triedAllSubchannels) {
        this.channelControlHelper.requestReresolution();
      }
    }
    resetBackoff() {
    }
    destroy() {
      this.resetSubchannelList();
      if (this.currentPick !== null) {
        this.currentPick.unref();
        this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);
      }
    }
    getTypeName() {
      return TYPE_NAME;
    }
  };
  exports2.PickFirstLoadBalancer = PickFirstLoadBalancer;
  function setup() {
    load_balancer_1.registerLoadBalancerType(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);
  }
  exports2.setup = setup;
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js
var require_load_balancer_round_robin = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.setup = exports2.RoundRobinLoadBalancer = void 0;
  var load_balancer_1 = require_load_balancer();
  var channel_1 = require_channel();
  var picker_1 = require_picker();
  var subchannel_1 = require_subchannel();
  var logging = require_logging();
  var constants_1 = require_constants();
  var TRACER_NAME = "round_robin";
  function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
  }
  var TYPE_NAME = "round_robin";
  var RoundRobinLoadBalancingConfig = class {
    getLoadBalancerName() {
      return TYPE_NAME;
    }
    constructor() {
    }
    toJsonObject() {
      return {
        [TYPE_NAME]: {}
      };
    }
    static createFromJson(obj) {
      return new RoundRobinLoadBalancingConfig();
    }
  };
  var RoundRobinPicker = class {
    constructor(subchannelList, nextIndex = 0) {
      this.subchannelList = subchannelList;
      this.nextIndex = nextIndex;
    }
    pick(pickArgs) {
      const pickedSubchannel = this.subchannelList[this.nextIndex];
      this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;
      return {
        pickResultType: picker_1.PickResultType.COMPLETE,
        subchannel: pickedSubchannel,
        status: null,
        extraFilterFactory: null,
        onCallStarted: null
      };
    }
    peekNextSubchannel() {
      return this.subchannelList[this.nextIndex];
    }
  };
  var RoundRobinLoadBalancer = class {
    constructor(channelControlHelper) {
      this.channelControlHelper = channelControlHelper;
      this.subchannels = [];
      this.currentState = channel_1.ConnectivityState.IDLE;
      this.currentReadyPicker = null;
      this.subchannelStateCounts = {
        [channel_1.ConnectivityState.CONNECTING]: 0,
        [channel_1.ConnectivityState.IDLE]: 0,
        [channel_1.ConnectivityState.READY]: 0,
        [channel_1.ConnectivityState.SHUTDOWN]: 0,
        [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0
      };
      this.subchannelStateListener = (subchannel, previousState, newState) => {
        this.subchannelStateCounts[previousState] -= 1;
        this.subchannelStateCounts[newState] += 1;
        this.calculateAndUpdateState();
        if (newState === channel_1.ConnectivityState.TRANSIENT_FAILURE || newState === channel_1.ConnectivityState.IDLE) {
          this.channelControlHelper.requestReresolution();
          subchannel.startConnecting();
        }
      };
    }
    calculateAndUpdateState() {
      if (this.subchannelStateCounts[channel_1.ConnectivityState.READY] > 0) {
        const readySubchannels = this.subchannels.filter((subchannel) => subchannel.getConnectivityState() === channel_1.ConnectivityState.READY);
        let index = 0;
        if (this.currentReadyPicker !== null) {
          index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());
          if (index < 0) {
            index = 0;
          }
        }
        this.updateState(channel_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));
      } else if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {
        this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
      } else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {
        this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());
      } else {
        this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
      }
    }
    updateState(newState, picker) {
      trace(channel_1.ConnectivityState[this.currentState] + " -> " + channel_1.ConnectivityState[newState]);
      if (newState === channel_1.ConnectivityState.READY) {
        this.currentReadyPicker = picker;
      } else {
        this.currentReadyPicker = null;
      }
      this.currentState = newState;
      this.channelControlHelper.updateState(newState, picker);
    }
    resetSubchannelList() {
      for (const subchannel of this.subchannels) {
        subchannel.removeConnectivityStateListener(this.subchannelStateListener);
        subchannel.unref();
      }
      this.subchannelStateCounts = {
        [channel_1.ConnectivityState.CONNECTING]: 0,
        [channel_1.ConnectivityState.IDLE]: 0,
        [channel_1.ConnectivityState.READY]: 0,
        [channel_1.ConnectivityState.SHUTDOWN]: 0,
        [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0
      };
      this.subchannels = [];
    }
    updateAddressList(addressList, lbConfig) {
      this.resetSubchannelList();
      trace("Connect to address list " + addressList.map((address) => subchannel_1.subchannelAddressToString(address)));
      this.subchannels = addressList.map((address) => this.channelControlHelper.createSubchannel(address, {}));
      for (const subchannel of this.subchannels) {
        subchannel.ref();
        subchannel.addConnectivityStateListener(this.subchannelStateListener);
        const subchannelState = subchannel.getConnectivityState();
        this.subchannelStateCounts[subchannelState] += 1;
        if (subchannelState === channel_1.ConnectivityState.IDLE || subchannelState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
          subchannel.startConnecting();
        }
      }
      this.calculateAndUpdateState();
    }
    exitIdle() {
      for (const subchannel of this.subchannels) {
        subchannel.startConnecting();
      }
    }
    resetBackoff() {
    }
    destroy() {
      this.resetSubchannelList();
    }
    getTypeName() {
      return TYPE_NAME;
    }
  };
  exports2.RoundRobinLoadBalancer = RoundRobinLoadBalancer;
  function setup() {
    load_balancer_1.registerLoadBalancerType(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);
  }
  exports2.setup = setup;
});

// node_modules/@grpc/grpc-js/build/src/load-balancer.js
var require_load_balancer = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.registerAll = exports2.validateLoadBalancingConfig = exports2.getFirstUsableConfig = exports2.isLoadBalancerNameRegistered = exports2.createLoadBalancer = exports2.registerLoadBalancerType = void 0;
  var load_balancer_pick_first = require_load_balancer_pick_first();
  var load_balancer_round_robin = require_load_balancer_round_robin();
  var registeredLoadBalancerTypes = {};
  function registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {
    registeredLoadBalancerTypes[typeName] = {
      LoadBalancer: loadBalancerType,
      LoadBalancingConfig: loadBalancingConfigType
    };
  }
  exports2.registerLoadBalancerType = registerLoadBalancerType;
  function createLoadBalancer(config, channelControlHelper) {
    const typeName = config.getLoadBalancerName();
    if (typeName in registeredLoadBalancerTypes) {
      return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);
    } else {
      return null;
    }
  }
  exports2.createLoadBalancer = createLoadBalancer;
  function isLoadBalancerNameRegistered(typeName) {
    return typeName in registeredLoadBalancerTypes;
  }
  exports2.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;
  function getFirstUsableConfig(configs, defaultPickFirst = false) {
    for (const config of configs) {
      if (config.getLoadBalancerName() in registeredLoadBalancerTypes) {
        return config;
      }
    }
    if (defaultPickFirst) {
      return new load_balancer_pick_first.PickFirstLoadBalancingConfig();
    } else {
      return null;
    }
  }
  exports2.getFirstUsableConfig = getFirstUsableConfig;
  function validateLoadBalancingConfig(obj) {
    if (!(obj !== null && typeof obj === "object")) {
      throw new Error("Load balancing config must be an object");
    }
    const keys = Object.keys(obj);
    if (keys.length !== 1) {
      throw new Error("Provided load balancing config has multiple conflicting entries");
    }
    const typeName = keys[0];
    if (typeName in registeredLoadBalancerTypes) {
      return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(obj[typeName]);
    } else {
      throw new Error(`Unrecognized load balancing config name ${typeName}`);
    }
  }
  exports2.validateLoadBalancingConfig = validateLoadBalancingConfig;
  function registerAll() {
    load_balancer_pick_first.setup();
    load_balancer_round_robin.setup();
  }
  exports2.registerAll = registerAll;
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js
var require_load_balancer_child_handler = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ChildLoadBalancerHandler = void 0;
  var load_balancer_1 = require_load_balancer();
  var channel_1 = require_channel();
  var TYPE_NAME = "child_load_balancer_helper";
  var ChildLoadBalancerHandler = class {
    constructor(channelControlHelper) {
      this.channelControlHelper = channelControlHelper;
      this.currentChild = null;
      this.pendingChild = null;
      this.ChildPolicyHelper = class {
        constructor(parent) {
          this.parent = parent;
          this.child = null;
        }
        createSubchannel(subchannelAddress, subchannelArgs) {
          return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
        }
        updateState(connectivityState, picker) {
          var _a;
          if (this.calledByPendingChild()) {
            if (connectivityState !== channel_1.ConnectivityState.READY) {
              return;
            }
            (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();
            this.parent.currentChild = this.parent.pendingChild;
            this.parent.pendingChild = null;
          } else if (!this.calledByCurrentChild()) {
            return;
          }
          this.parent.channelControlHelper.updateState(connectivityState, picker);
        }
        requestReresolution() {
          var _a;
          const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;
          if (this.child === latestChild) {
            this.parent.channelControlHelper.requestReresolution();
          }
        }
        setChild(newChild) {
          this.child = newChild;
        }
        calledByPendingChild() {
          return this.child === this.parent.pendingChild;
        }
        calledByCurrentChild() {
          return this.child === this.parent.currentChild;
        }
      };
    }
    updateAddressList(addressList, lbConfig, attributes) {
      let childToUpdate;
      if (this.currentChild === null || this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()) {
        const newHelper = new this.ChildPolicyHelper(this);
        const newChild = load_balancer_1.createLoadBalancer(lbConfig, newHelper);
        newHelper.setChild(newChild);
        if (this.currentChild === null) {
          this.currentChild = newChild;
          childToUpdate = this.currentChild;
        } else {
          if (this.pendingChild) {
            this.pendingChild.destroy();
          }
          this.pendingChild = newChild;
          childToUpdate = this.pendingChild;
        }
      } else {
        if (this.pendingChild === null) {
          childToUpdate = this.currentChild;
        } else {
          childToUpdate = this.pendingChild;
        }
      }
      childToUpdate.updateAddressList(addressList, lbConfig, attributes);
    }
    exitIdle() {
      if (this.currentChild) {
        this.currentChild.resetBackoff();
        if (this.pendingChild) {
          this.pendingChild.resetBackoff();
        }
      }
    }
    resetBackoff() {
      if (this.currentChild) {
        this.currentChild.resetBackoff();
        if (this.pendingChild) {
          this.pendingChild.resetBackoff();
        }
      }
    }
    destroy() {
      if (this.currentChild) {
        this.currentChild.destroy();
        this.currentChild = null;
      }
      if (this.pendingChild) {
        this.pendingChild.destroy();
        this.pendingChild = null;
      }
    }
    getTypeName() {
      return TYPE_NAME;
    }
  };
  exports2.ChildLoadBalancerHandler = ChildLoadBalancerHandler;
});

// node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js
var require_resolving_load_balancer = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ResolvingLoadBalancer = void 0;
  var load_balancer_1 = require_load_balancer();
  var service_config_1 = require_service_config();
  var channel_1 = require_channel();
  var resolver_1 = require_resolver();
  var picker_1 = require_picker();
  var backoff_timeout_1 = require_backoff_timeout();
  var constants_1 = require_constants();
  var metadata_1 = require_metadata();
  var logging = require_logging();
  var constants_2 = require_constants();
  var uri_parser_1 = require_uri_parser();
  var load_balancer_child_handler_1 = require_load_balancer_child_handler();
  var TRACER_NAME = "resolving_load_balancer";
  function trace(text) {
    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
  }
  var ResolvingLoadBalancer = class {
    constructor(target, channelControlHelper, channelOptions) {
      this.target = target;
      this.channelControlHelper = channelControlHelper;
      this.channelOptions = channelOptions;
      this.latestChildState = channel_1.ConnectivityState.IDLE;
      this.latestChildPicker = new picker_1.QueuePicker(this);
      this.currentState = channel_1.ConnectivityState.IDLE;
      this.previousServiceConfig = null;
      this.continueResolving = false;
      if (channelOptions["grpc.service_config"]) {
        this.defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(channelOptions["grpc.service_config"]));
      } else {
        this.defaultServiceConfig = {
          loadBalancingConfig: [],
          methodConfig: []
        };
      }
      this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
      this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({
        createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),
        requestReresolution: () => {
          if (this.backoffTimeout.isRunning()) {
            this.continueResolving = true;
          } else {
            this.updateResolution();
          }
        },
        updateState: (newState, picker) => {
          this.latestChildState = newState;
          this.latestChildPicker = picker;
          this.updateState(newState, picker);
        }
      });
      this.innerResolver = resolver_1.createResolver(target, {
        onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, attributes) => {
          var _a;
          let workingServiceConfig = null;
          if (serviceConfig === null) {
            if (serviceConfigError === null) {
              this.previousServiceConfig = null;
              workingServiceConfig = this.defaultServiceConfig;
            } else {
              if (this.previousServiceConfig === null) {
                this.handleResolutionFailure(serviceConfigError);
              } else {
                workingServiceConfig = this.previousServiceConfig;
              }
            }
          } else {
            workingServiceConfig = serviceConfig;
            this.previousServiceConfig = serviceConfig;
          }
          const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];
          const loadBalancingConfig = load_balancer_1.getFirstUsableConfig(workingConfigList, true);
          if (loadBalancingConfig === null) {
            this.handleResolutionFailure({
              code: constants_1.Status.UNAVAILABLE,
              details: "All load balancer options in service config are not compatible",
              metadata: new metadata_1.Metadata()
            });
            return;
          }
          this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);
        },
        onError: (error) => {
          this.handleResolutionFailure(error);
        }
      }, channelOptions);
      this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
        if (this.continueResolving) {
          this.updateResolution();
          this.continueResolving = false;
        } else {
          this.updateState(this.latestChildState, this.latestChildPicker);
        }
      });
      this.backoffTimeout.unref();
    }
    updateResolution() {
      this.innerResolver.updateResolution();
      if (this.currentState === channel_1.ConnectivityState.IDLE) {
        this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
      }
    }
    updateState(connectivityState, picker) {
      trace(uri_parser_1.uriToString(this.target) + " " + channel_1.ConnectivityState[this.currentState] + " -> " + channel_1.ConnectivityState[connectivityState]);
      if (connectivityState === channel_1.ConnectivityState.IDLE) {
        picker = new picker_1.QueuePicker(this);
      }
      this.currentState = connectivityState;
      this.channelControlHelper.updateState(connectivityState, picker);
    }
    handleResolutionFailure(error) {
      if (this.latestChildState === channel_1.ConnectivityState.IDLE) {
        this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));
      }
      this.backoffTimeout.runOnce();
    }
    exitIdle() {
      this.childLoadBalancer.exitIdle();
      if (this.currentState === channel_1.ConnectivityState.IDLE) {
        if (this.backoffTimeout.isRunning()) {
          this.continueResolving = true;
        } else {
          this.updateResolution();
        }
        this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
      }
    }
    updateAddressList(addressList, lbConfig) {
      throw new Error("updateAddressList not supported on ResolvingLoadBalancer");
    }
    resetBackoff() {
      this.backoffTimeout.reset();
      this.childLoadBalancer.resetBackoff();
    }
    destroy() {
      this.childLoadBalancer.destroy();
      this.innerResolver.destroy();
      this.updateState(channel_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());
    }
    getTypeName() {
      return "resolving_load_balancer";
    }
  };
  exports2.ResolvingLoadBalancer = ResolvingLoadBalancer;
});

// node_modules/@grpc/grpc-js/build/src/channel-options.js
var require_channel_options = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.channelOptionsEqual = exports2.recognizedOptions = void 0;
  exports2.recognizedOptions = {
    "grpc.ssl_target_name_override": true,
    "grpc.primary_user_agent": true,
    "grpc.secondary_user_agent": true,
    "grpc.default_authority": true,
    "grpc.keepalive_time_ms": true,
    "grpc.keepalive_timeout_ms": true,
    "grpc.keepalive_permit_without_calls": true,
    "grpc.service_config": true,
    "grpc.max_concurrent_streams": true,
    "grpc.initial_reconnect_backoff_ms": true,
    "grpc.max_reconnect_backoff_ms": true,
    "grpc.use_local_subchannel_pool": true,
    "grpc.max_send_message_length": true,
    "grpc.max_receive_message_length": true,
    "grpc.enable_http_proxy": true
  };
  function channelOptionsEqual(options1, options2) {
    const keys1 = Object.keys(options1).sort();
    const keys2 = Object.keys(options2).sort();
    if (keys1.length !== keys2.length) {
      return false;
    }
    for (let i = 0; i < keys1.length; i += 1) {
      if (keys1[i] !== keys2[i]) {
        return false;
      }
      if (options1[keys1[i]] !== options2[keys2[i]]) {
        return false;
      }
    }
    return true;
  }
  exports2.channelOptionsEqual = channelOptionsEqual;
});

// node_modules/@grpc/grpc-js/build/src/subchannel-pool.js
var require_subchannel_pool = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getSubchannelPool = exports2.SubchannelPool = void 0;
  var channel_options_1 = require_channel_options();
  var subchannel_1 = require_subchannel();
  var uri_parser_1 = require_uri_parser();
  var REF_CHECK_INTERVAL = 1e4;
  var SubchannelPool = class {
    constructor(global2) {
      this.global = global2;
      this.pool = Object.create(null);
      this.cleanupTimer = null;
    }
    unrefUnusedSubchannels() {
      let allSubchannelsUnrefed = true;
      for (const channelTarget in this.pool) {
        const subchannelObjArray = this.pool[channelTarget];
        const refedSubchannels = subchannelObjArray.filter((value) => !value.subchannel.unrefIfOneRef());
        if (refedSubchannels.length > 0) {
          allSubchannelsUnrefed = false;
        }
        this.pool[channelTarget] = refedSubchannels;
      }
      if (allSubchannelsUnrefed && this.cleanupTimer !== null) {
        clearInterval(this.cleanupTimer);
        this.cleanupTimer = null;
      }
    }
    ensureCleanupTask() {
      var _a, _b;
      if (this.global && this.cleanupTimer === null) {
        this.cleanupTimer = setInterval(() => {
          this.unrefUnusedSubchannels();
        }, REF_CHECK_INTERVAL);
        (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
    }
    getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {
      this.ensureCleanupTask();
      const channelTarget = uri_parser_1.uriToString(channelTargetUri);
      if (channelTarget in this.pool) {
        const subchannelObjArray = this.pool[channelTarget];
        for (const subchannelObj of subchannelObjArray) {
          if (subchannel_1.subchannelAddressEqual(subchannelTarget, subchannelObj.subchannelAddress) && channel_options_1.channelOptionsEqual(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {
            return subchannelObj.subchannel;
          }
        }
      }
      const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials);
      if (!(channelTarget in this.pool)) {
        this.pool[channelTarget] = [];
      }
      this.pool[channelTarget].push({
        subchannelAddress: subchannelTarget,
        channelArguments,
        channelCredentials,
        subchannel
      });
      if (this.global) {
        subchannel.ref();
      }
      return subchannel;
    }
  };
  exports2.SubchannelPool = SubchannelPool;
  var globalSubchannelPool = new SubchannelPool(true);
  function getSubchannelPool(global2) {
    if (global2) {
      return globalSubchannelPool;
    } else {
      return new SubchannelPool(false);
    }
  }
  exports2.getSubchannelPool = getSubchannelPool;
});

// node_modules/@grpc/grpc-js/build/src/filter.js
var require_filter = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.BaseFilter = void 0;
  var BaseFilter = class {
    async sendMetadata(metadata) {
      return metadata;
    }
    receiveMetadata(metadata) {
      return metadata;
    }
    async sendMessage(message) {
      return message;
    }
    async receiveMessage(message) {
      return message;
    }
    receiveTrailers(status) {
      return status;
    }
  };
  exports2.BaseFilter = BaseFilter;
});

// node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js
var require_call_credentials_filter = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.CallCredentialsFilterFactory = exports2.CallCredentialsFilter = void 0;
  var filter_1 = require_filter();
  var constants_1 = require_constants();
  var uri_parser_1 = require_uri_parser();
  var CallCredentialsFilter = class extends filter_1.BaseFilter {
    constructor(channel, stream) {
      var _a, _b;
      super();
      this.channel = channel;
      this.stream = stream;
      this.channel = channel;
      this.stream = stream;
      const splitPath = stream.getMethod().split("/");
      let serviceName = "";
      if (splitPath.length >= 2) {
        serviceName = splitPath[1];
      }
      const hostname = (_b = (_a = uri_parser_1.splitHostPort(stream.getHost())) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : "localhost";
      this.serviceUrl = `https://${hostname}/${serviceName}`;
    }
    async sendMetadata(metadata) {
      const credentials = this.stream.getCredentials();
      const credsMetadata = credentials.generateMetadata({
        service_url: this.serviceUrl
      });
      const resultMetadata = await metadata;
      try {
        resultMetadata.merge(await credsMetadata);
      } catch (error) {
        this.stream.cancelWithStatus(constants_1.Status.UNAUTHENTICATED, `Failed to retrieve auth metadata with error: ${error.message}`);
        return Promise.reject("Failed to retrieve auth metadata");
      }
      if (resultMetadata.get("authorization").length > 1) {
        this.stream.cancelWithStatus(constants_1.Status.INTERNAL, '"authorization" metadata cannot have multiple values');
        return Promise.reject('"authorization" metadata cannot have multiple values');
      }
      return resultMetadata;
    }
  };
  exports2.CallCredentialsFilter = CallCredentialsFilter;
  var CallCredentialsFilterFactory = class {
    constructor(channel) {
      this.channel = channel;
      this.channel = channel;
    }
    createFilter(callStream) {
      return new CallCredentialsFilter(this.channel, callStream);
    }
  };
  exports2.CallCredentialsFilterFactory = CallCredentialsFilterFactory;
});

// node_modules/@grpc/grpc-js/build/src/deadline-filter.js
var require_deadline_filter = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.DeadlineFilterFactory = exports2.DeadlineFilter = void 0;
  var constants_1 = require_constants();
  var filter_1 = require_filter();
  var units = [
    ["m", 1],
    ["S", 1e3],
    ["M", 60 * 1e3],
    ["H", 60 * 60 * 1e3]
  ];
  function getDeadline(deadline) {
    const now = new Date().getTime();
    const timeoutMs = Math.max(deadline - now, 0);
    for (const [unit, factor] of units) {
      const amount = timeoutMs / factor;
      if (amount < 1e8) {
        return String(Math.ceil(amount)) + unit;
      }
    }
    throw new Error("Deadline is too far in the future");
  }
  var DeadlineFilter = class extends filter_1.BaseFilter {
    constructor(channel, callStream) {
      var _a, _b;
      super();
      this.channel = channel;
      this.callStream = callStream;
      this.timer = null;
      const callDeadline = callStream.getDeadline();
      if (callDeadline instanceof Date) {
        this.deadline = callDeadline.getTime();
      } else {
        this.deadline = callDeadline;
      }
      const now = new Date().getTime();
      let timeout = this.deadline - now;
      if (timeout <= 0) {
        process.nextTick(() => {
          callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, "Deadline exceeded");
        });
      } else if (this.deadline !== Infinity) {
        this.timer = setTimeout(() => {
          callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, "Deadline exceeded");
        }, timeout);
        (_b = (_a = this.timer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
    }
    async sendMetadata(metadata) {
      if (this.deadline === Infinity) {
        return metadata;
      }
      const finalMetadata = await metadata;
      const timeoutString = getDeadline(this.deadline);
      finalMetadata.set("grpc-timeout", timeoutString);
      return finalMetadata;
    }
    receiveTrailers(status) {
      if (this.timer) {
        clearTimeout(this.timer);
      }
      return status;
    }
  };
  exports2.DeadlineFilter = DeadlineFilter;
  var DeadlineFilterFactory = class {
    constructor(channel) {
      this.channel = channel;
    }
    createFilter(callStream) {
      return new DeadlineFilter(this.channel, callStream);
    }
  };
  exports2.DeadlineFilterFactory = DeadlineFilterFactory;
});

// node_modules/@grpc/grpc-js/build/src/compression-filter.js
var require_compression_filter = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.CompressionFilterFactory = exports2.CompressionFilter = void 0;
  var zlib = require("zlib");
  var filter_1 = require_filter();
  var CompressionHandler = class {
    async writeMessage(message, compress) {
      let messageBuffer = message;
      if (compress) {
        messageBuffer = await this.compressMessage(messageBuffer);
      }
      const output = Buffer.allocUnsafe(messageBuffer.length + 5);
      output.writeUInt8(compress ? 1 : 0, 0);
      output.writeUInt32BE(messageBuffer.length, 1);
      messageBuffer.copy(output, 5);
      return output;
    }
    async readMessage(data) {
      const compressed = data.readUInt8(0) === 1;
      let messageBuffer = data.slice(5);
      if (compressed) {
        messageBuffer = await this.decompressMessage(messageBuffer);
      }
      return messageBuffer;
    }
  };
  var IdentityHandler = class extends CompressionHandler {
    async compressMessage(message) {
      return message;
    }
    async writeMessage(message, compress) {
      const output = Buffer.allocUnsafe(message.length + 5);
      output.writeUInt8(0, 0);
      output.writeUInt32BE(message.length, 1);
      message.copy(output, 5);
      return output;
    }
    decompressMessage(message) {
      return Promise.reject(new Error('Received compressed message but "grpc-encoding" header was identity'));
    }
  };
  var DeflateHandler = class extends CompressionHandler {
    compressMessage(message) {
      return new Promise((resolve, reject) => {
        zlib.deflate(message, (err, output) => {
          if (err) {
            reject(err);
          } else {
            resolve(output);
          }
        });
      });
    }
    decompressMessage(message) {
      return new Promise((resolve, reject) => {
        zlib.inflate(message, (err, output) => {
          if (err) {
            reject(err);
          } else {
            resolve(output);
          }
        });
      });
    }
  };
  var GzipHandler = class extends CompressionHandler {
    compressMessage(message) {
      return new Promise((resolve, reject) => {
        zlib.gzip(message, (err, output) => {
          if (err) {
            reject(err);
          } else {
            resolve(output);
          }
        });
      });
    }
    decompressMessage(message) {
      return new Promise((resolve, reject) => {
        zlib.unzip(message, (err, output) => {
          if (err) {
            reject(err);
          } else {
            resolve(output);
          }
        });
      });
    }
  };
  var UnknownHandler = class extends CompressionHandler {
    constructor(compressionName) {
      super();
      this.compressionName = compressionName;
    }
    compressMessage(message) {
      return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));
    }
    decompressMessage(message) {
      return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));
    }
  };
  function getCompressionHandler(compressionName) {
    switch (compressionName) {
      case "identity":
        return new IdentityHandler();
      case "deflate":
        return new DeflateHandler();
      case "gzip":
        return new GzipHandler();
      default:
        return new UnknownHandler(compressionName);
    }
  }
  var CompressionFilter = class extends filter_1.BaseFilter {
    constructor() {
      super(...arguments);
      this.sendCompression = new IdentityHandler();
      this.receiveCompression = new IdentityHandler();
    }
    async sendMetadata(metadata) {
      const headers = await metadata;
      headers.set("grpc-accept-encoding", "identity,deflate,gzip");
      headers.set("accept-encoding", "identity");
      return headers;
    }
    receiveMetadata(metadata) {
      const receiveEncoding = metadata.get("grpc-encoding");
      if (receiveEncoding.length > 0) {
        const encoding = receiveEncoding[0];
        if (typeof encoding === "string") {
          this.receiveCompression = getCompressionHandler(encoding);
        }
      }
      metadata.remove("grpc-encoding");
      metadata.remove("grpc-accept-encoding");
      return metadata;
    }
    async sendMessage(message) {
      const resolvedMessage = await message;
      const compress = resolvedMessage.flags === void 0 ? false : (resolvedMessage.flags & 2) === 0;
      return {
        message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),
        flags: resolvedMessage.flags
      };
    }
    async receiveMessage(message) {
      return this.receiveCompression.readMessage(await message);
    }
  };
  exports2.CompressionFilter = CompressionFilter;
  var CompressionFilterFactory = class {
    constructor(channel) {
      this.channel = channel;
    }
    createFilter(callStream) {
      return new CompressionFilter();
    }
  };
  exports2.CompressionFilterFactory = CompressionFilterFactory;
});

// node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js
var require_max_message_size_filter = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.MaxMessageSizeFilterFactory = exports2.MaxMessageSizeFilter = void 0;
  var filter_1 = require_filter();
  var constants_1 = require_constants();
  var MaxMessageSizeFilter = class extends filter_1.BaseFilter {
    constructor(options, callStream) {
      super();
      this.options = options;
      this.callStream = callStream;
      this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
      this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
      if ("grpc.max_send_message_length" in options) {
        this.maxSendMessageSize = options["grpc.max_send_message_length"];
      }
      if ("grpc.max_receive_message_length" in options) {
        this.maxReceiveMessageSize = options["grpc.max_receive_message_length"];
      }
    }
    async sendMessage(message) {
      if (this.maxSendMessageSize === -1) {
        return message;
      } else {
        const concreteMessage = await message;
        if (concreteMessage.message.length > this.maxSendMessageSize) {
          this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`);
          return Promise.reject("Message too large");
        } else {
          return concreteMessage;
        }
      }
    }
    async receiveMessage(message) {
      if (this.maxReceiveMessageSize === -1) {
        return message;
      } else {
        const concreteMessage = await message;
        if (concreteMessage.length > this.maxReceiveMessageSize) {
          this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`);
          return Promise.reject("Message too large");
        } else {
          return concreteMessage;
        }
      }
    }
  };
  exports2.MaxMessageSizeFilter = MaxMessageSizeFilter;
  var MaxMessageSizeFilterFactory = class {
    constructor(options) {
      this.options = options;
    }
    createFilter(callStream) {
      return new MaxMessageSizeFilter(this.options, callStream);
    }
  };
  exports2.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory;
});

// node_modules/@grpc/grpc-js/build/src/channel.js
var require_channel = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ChannelImplementation = exports2.ConnectivityState = void 0;
  var call_stream_1 = require_call_stream();
  var channel_credentials_1 = require_channel_credentials();
  var resolving_load_balancer_1 = require_resolving_load_balancer();
  var subchannel_pool_1 = require_subchannel_pool();
  var picker_1 = require_picker();
  var constants_1 = require_constants();
  var filter_stack_1 = require_filter_stack();
  var call_credentials_filter_1 = require_call_credentials_filter();
  var deadline_filter_1 = require_deadline_filter();
  var compression_filter_1 = require_compression_filter();
  var resolver_1 = require_resolver();
  var logging_1 = require_logging();
  var max_message_size_filter_1 = require_max_message_size_filter();
  var http_proxy_1 = require_http_proxy();
  var uri_parser_1 = require_uri_parser();
  var ConnectivityState;
  (function(ConnectivityState2) {
    ConnectivityState2[ConnectivityState2["IDLE"] = 0] = "IDLE";
    ConnectivityState2[ConnectivityState2["CONNECTING"] = 1] = "CONNECTING";
    ConnectivityState2[ConnectivityState2["READY"] = 2] = "READY";
    ConnectivityState2[ConnectivityState2["TRANSIENT_FAILURE"] = 3] = "TRANSIENT_FAILURE";
    ConnectivityState2[ConnectivityState2["SHUTDOWN"] = 4] = "SHUTDOWN";
  })(ConnectivityState = exports2.ConnectivityState || (exports2.ConnectivityState = {}));
  var MAX_TIMEOUT_TIME = 2147483647;
  var nextCallNumber = 0;
  function getNewCallNumber() {
    const callNumber = nextCallNumber;
    nextCallNumber += 1;
    if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {
      nextCallNumber = 0;
    }
    return callNumber;
  }
  var ChannelImplementation = class {
    constructor(target, credentials, options) {
      var _a, _b, _c;
      this.credentials = credentials;
      this.options = options;
      this.connectivityState = ConnectivityState.IDLE;
      this.currentPicker = new picker_1.UnavailablePicker();
      this.pickQueue = [];
      this.connectivityStateWatchers = [];
      if (typeof target !== "string") {
        throw new TypeError("Channel target must be a string");
      }
      if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
        throw new TypeError("Channel credentials must be a ChannelCredentials object");
      }
      if (options) {
        if (typeof options !== "object" || !Object.values(options).every((value) => typeof value === "string" || typeof value === "number" || typeof value === "undefined")) {
          throw new TypeError("Channel options must be an object with string or number values");
        }
      }
      const originalTargetUri = uri_parser_1.parseUri(target);
      if (originalTargetUri === null) {
        throw new Error(`Could not parse target name "${target}"`);
      }
      const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);
      if (defaultSchemeMapResult === null) {
        throw new Error(`Could not find a default scheme for target name "${target}"`);
      }
      this.callRefTimer = setInterval(() => {
      }, MAX_TIMEOUT_TIME);
      (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
      if (this.options["grpc.default_authority"]) {
        this.defaultAuthority = this.options["grpc.default_authority"];
      } else {
        this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);
      }
      const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);
      this.target = proxyMapResult.target;
      this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);
      this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options["grpc.use_local_subchannel_pool"]) !== null && _c !== void 0 ? _c : 0) === 0);
      const channelControlHelper = {
        createSubchannel: (subchannelAddress, subchannelArgs) => {
          return this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);
        },
        updateState: (connectivityState, picker) => {
          var _a2, _b2;
          this.currentPicker = picker;
          const queueCopy = this.pickQueue.slice();
          (_b2 = (_a2 = this.callRefTimer).unref) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
          this.pickQueue = [];
          for (const {callStream, callMetadata} of queueCopy) {
            this.tryPick(callStream, callMetadata);
          }
          this.updateState(connectivityState);
        },
        requestReresolution: () => {
          throw new Error("Resolving load balancer should never call requestReresolution");
        }
      };
      this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options);
      this.filterStackFactory = new filter_stack_1.FilterStackFactory([
        new call_credentials_filter_1.CallCredentialsFilterFactory(this),
        new deadline_filter_1.DeadlineFilterFactory(this),
        new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),
        new compression_filter_1.CompressionFilterFactory(this)
      ]);
    }
    pushPick(callStream, callMetadata) {
      var _a, _b;
      (_b = (_a = this.callRefTimer).ref) === null || _b === void 0 ? void 0 : _b.call(_a);
      this.pickQueue.push({callStream, callMetadata});
    }
    tryPick(callStream, callMetadata) {
      var _a, _b, _c;
      const pickResult = this.currentPicker.pick({metadata: callMetadata});
      logging_1.trace(constants_1.LogVerbosity.DEBUG, "channel", "Pick result: " + picker_1.PickResultType[pickResult.pickResultType] + " subchannel: " + ((_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) + " status: " + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.code) + " " + ((_c = pickResult.status) === null || _c === void 0 ? void 0 : _c.details));
      switch (pickResult.pickResultType) {
        case picker_1.PickResultType.COMPLETE:
          if (pickResult.subchannel === null) {
            callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, "Request dropped by load balancing policy");
          } else {
            if (pickResult.subchannel.getConnectivityState() !== ConnectivityState.READY) {
              logging_1.log(constants_1.LogVerbosity.ERROR, "Error: COMPLETE pick result subchannel " + pickResult.subchannel.getAddress() + " has state " + ConnectivityState[pickResult.subchannel.getConnectivityState()]);
              this.pushPick(callStream, callMetadata);
              break;
            }
            callStream.filterStack.sendMetadata(Promise.resolve(callMetadata.clone())).then((finalMetadata) => {
              var _a2, _b2;
              const subchannelState = pickResult.subchannel.getConnectivityState();
              if (subchannelState === ConnectivityState.READY) {
                try {
                  pickResult.subchannel.startCallStream(finalMetadata, callStream, (_a2 = pickResult.extraFilterFactory) !== null && _a2 !== void 0 ? _a2 : void 0);
                  (_b2 = pickResult.onCallStarted) === null || _b2 === void 0 ? void 0 : _b2.call(pickResult);
                } catch (error) {
                  if (error.code === "ERR_HTTP2_GOAWAY_SESSION") {
                    logging_1.trace(constants_1.LogVerbosity.INFO, "channel", "Failed to start call on picked subchannel " + pickResult.subchannel.getAddress() + " with error " + error.message + ". Retrying pick");
                    this.tryPick(callStream, callMetadata);
                  } else {
                    logging_1.trace(constants_1.LogVerbosity.INFO, "channel", "Failed to start call on picked subchanel " + pickResult.subchannel.getAddress() + " with error " + error.message + ". Ending call");
                    callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error.message}`);
                  }
                }
              } else {
                logging_1.trace(constants_1.LogVerbosity.INFO, "channel", "Picked subchannel " + pickResult.subchannel.getAddress() + " has state " + ConnectivityState[subchannelState] + " after metadata filters. Retrying pick");
                this.tryPick(callStream, callMetadata);
              }
            }, (error) => {
              callStream.cancelWithStatus(typeof error.code === "number" ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);
            });
          }
          break;
        case picker_1.PickResultType.QUEUE:
          this.pushPick(callStream, callMetadata);
          break;
        case picker_1.PickResultType.TRANSIENT_FAILURE:
          if (callMetadata.getOptions().waitForReady) {
            this.pushPick(callStream, callMetadata);
          } else {
            callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);
          }
          break;
        case picker_1.PickResultType.DROP:
          callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);
          break;
        default:
          throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);
      }
    }
    removeConnectivityStateWatcher(watcherObject) {
      const watcherIndex = this.connectivityStateWatchers.findIndex((value) => value === watcherObject);
      if (watcherIndex >= 0) {
        this.connectivityStateWatchers.splice(watcherIndex, 1);
      }
    }
    updateState(newState) {
      logging_1.trace(constants_1.LogVerbosity.DEBUG, "connectivity_state", uri_parser_1.uriToString(this.target) + " " + ConnectivityState[this.connectivityState] + " -> " + ConnectivityState[newState]);
      this.connectivityState = newState;
      const watchersCopy = this.connectivityStateWatchers.slice();
      for (const watcherObject of watchersCopy) {
        if (newState !== watcherObject.currentState) {
          if (watcherObject.timer) {
            clearTimeout(watcherObject.timer);
          }
          this.removeConnectivityStateWatcher(watcherObject);
          watcherObject.callback();
        }
      }
    }
    _startCallStream(stream, metadata) {
      this.tryPick(stream, metadata.clone());
    }
    close() {
      this.resolvingLoadBalancer.destroy();
      this.updateState(ConnectivityState.SHUTDOWN);
      clearInterval(this.callRefTimer);
      this.subchannelPool.unrefUnusedSubchannels();
    }
    getTarget() {
      return uri_parser_1.uriToString(this.target);
    }
    getConnectivityState(tryToConnect) {
      const connectivityState = this.connectivityState;
      if (tryToConnect) {
        this.resolvingLoadBalancer.exitIdle();
      }
      return connectivityState;
    }
    watchConnectivityState(currentState, deadline, callback) {
      if (this.connectivityState === ConnectivityState.SHUTDOWN) {
        throw new Error("Channel has been shut down");
      }
      let timer = null;
      if (deadline !== Infinity) {
        const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);
        const now = new Date();
        if (deadline === -Infinity || deadlineDate <= now) {
          process.nextTick(callback, new Error("Deadline passed without connectivity state change"));
          return;
        }
        timer = setTimeout(() => {
          this.removeConnectivityStateWatcher(watcherObject);
          callback(new Error("Deadline passed without connectivity state change"));
        }, deadlineDate.getTime() - now.getTime());
      }
      const watcherObject = {
        currentState,
        callback,
        timer
      };
      this.connectivityStateWatchers.push(watcherObject);
    }
    createCall(method, deadline, host, parentCall, propagateFlags) {
      if (typeof method !== "string") {
        throw new TypeError("Channel#createCall: method must be a string");
      }
      if (!(typeof deadline === "number" || deadline instanceof Date)) {
        throw new TypeError("Channel#createCall: deadline must be a number or Date");
      }
      if (this.connectivityState === ConnectivityState.SHUTDOWN) {
        throw new Error("Channel has been shut down");
      }
      const callNumber = getNewCallNumber();
      logging_1.trace(constants_1.LogVerbosity.DEBUG, "channel", uri_parser_1.uriToString(this.target) + " createCall [" + callNumber + '] method="' + method + '", deadline=' + deadline);
      const finalOptions = {
        deadline,
        flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,
        host: host !== null && host !== void 0 ? host : this.defaultAuthority,
        parentCall
      };
      const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);
      return stream;
    }
  };
  exports2.ChannelImplementation = ChannelImplementation;
});

// node_modules/@grpc/grpc-js/build/src/call.js
var require_call = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ClientDuplexStreamImpl = exports2.ClientWritableStreamImpl = exports2.ClientReadableStreamImpl = exports2.ClientUnaryCallImpl = exports2.callErrorFromStatus = void 0;
  var events_1 = require("events");
  var stream_1 = require("stream");
  var constants_1 = require_constants();
  function callErrorFromStatus(status) {
    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;
    return Object.assign(new Error(message), status);
  }
  exports2.callErrorFromStatus = callErrorFromStatus;
  var ClientUnaryCallImpl = class extends events_1.EventEmitter {
    constructor() {
      super();
    }
    cancel() {
      var _a;
      (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
    }
    getPeer() {
      var _a, _b;
      return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
    }
  };
  exports2.ClientUnaryCallImpl = ClientUnaryCallImpl;
  var ClientReadableStreamImpl = class extends stream_1.Readable {
    constructor(deserialize) {
      super({objectMode: true});
      this.deserialize = deserialize;
    }
    cancel() {
      var _a;
      (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
    }
    getPeer() {
      var _a, _b;
      return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
    }
    _read(_size) {
      var _a;
      (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
    }
  };
  exports2.ClientReadableStreamImpl = ClientReadableStreamImpl;
  var ClientWritableStreamImpl = class extends stream_1.Writable {
    constructor(serialize) {
      super({objectMode: true});
      this.serialize = serialize;
    }
    cancel() {
      var _a;
      (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
    }
    getPeer() {
      var _a, _b;
      return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
    }
    _write(chunk, encoding, cb) {
      var _a;
      const context = {
        callback: cb
      };
      const flags = Number(encoding);
      if (!Number.isNaN(flags)) {
        context.flags = flags;
      }
      (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
    }
    _final(cb) {
      var _a;
      (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
      cb();
    }
  };
  exports2.ClientWritableStreamImpl = ClientWritableStreamImpl;
  var ClientDuplexStreamImpl = class extends stream_1.Duplex {
    constructor(serialize, deserialize) {
      super({objectMode: true});
      this.serialize = serialize;
      this.deserialize = deserialize;
    }
    cancel() {
      var _a;
      (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
    }
    getPeer() {
      var _a, _b;
      return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
    }
    _read(_size) {
      var _a;
      (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
    }
    _write(chunk, encoding, cb) {
      var _a;
      const context = {
        callback: cb
      };
      const flags = Number(encoding);
      if (!Number.isNaN(flags)) {
        context.flags = flags;
      }
      (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
    }
    _final(cb) {
      var _a;
      (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
      cb();
    }
  };
  exports2.ClientDuplexStreamImpl = ClientDuplexStreamImpl;
});

// node_modules/@grpc/grpc-js/build/src/client-interceptors.js
var require_client_interceptors = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getInterceptingCall = exports2.InterceptingCall = exports2.RequesterBuilder = exports2.ListenerBuilder = exports2.InterceptorConfigurationError = void 0;
  var metadata_1 = require_metadata();
  var call_stream_1 = require_call_stream();
  var constants_1 = require_constants();
  var InterceptorConfigurationError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "InterceptorConfigurationError";
      Error.captureStackTrace(this, InterceptorConfigurationError);
    }
  };
  exports2.InterceptorConfigurationError = InterceptorConfigurationError;
  var ListenerBuilder = class {
    constructor() {
      this.metadata = void 0;
      this.message = void 0;
      this.status = void 0;
    }
    withOnReceiveMetadata(onReceiveMetadata) {
      this.metadata = onReceiveMetadata;
      return this;
    }
    withOnReceiveMessage(onReceiveMessage) {
      this.message = onReceiveMessage;
      return this;
    }
    withOnReceiveStatus(onReceiveStatus) {
      this.status = onReceiveStatus;
      return this;
    }
    build() {
      return {
        onReceiveMetadata: this.metadata,
        onReceiveMessage: this.message,
        onReceiveStatus: this.status
      };
    }
  };
  exports2.ListenerBuilder = ListenerBuilder;
  var RequesterBuilder = class {
    constructor() {
      this.start = void 0;
      this.message = void 0;
      this.halfClose = void 0;
      this.cancel = void 0;
    }
    withStart(start) {
      this.start = start;
      return this;
    }
    withSendMessage(sendMessage) {
      this.message = sendMessage;
      return this;
    }
    withHalfClose(halfClose) {
      this.halfClose = halfClose;
      return this;
    }
    withCancel(cancel) {
      this.cancel = cancel;
      return this;
    }
    build() {
      return {
        start: this.start,
        sendMessage: this.message,
        halfClose: this.halfClose,
        cancel: this.cancel
      };
    }
  };
  exports2.RequesterBuilder = RequesterBuilder;
  var defaultListener = {
    onReceiveMetadata: (metadata, next) => {
      next(metadata);
    },
    onReceiveMessage: (message, next) => {
      next(message);
    },
    onReceiveStatus: (status, next) => {
      next(status);
    }
  };
  var defaultRequester = {
    start: (metadata, listener, next) => {
      next(metadata, listener);
    },
    sendMessage: (message, next) => {
      next(message);
    },
    halfClose: (next) => {
      next();
    },
    cancel: (next) => {
      next();
    }
  };
  var InterceptingCall = class {
    constructor(nextCall, requester) {
      var _a, _b, _c, _d;
      this.nextCall = nextCall;
      this.processingMessage = false;
      this.pendingHalfClose = false;
      if (requester) {
        this.requester = {
          start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,
          sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,
          halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,
          cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel
        };
      } else {
        this.requester = defaultRequester;
      }
    }
    cancelWithStatus(status, details) {
      this.requester.cancel(() => {
        this.nextCall.cancelWithStatus(status, details);
      });
    }
    getPeer() {
      return this.nextCall.getPeer();
    }
    start(metadata, interceptingListener) {
      var _a, _b, _c, _d, _e, _f;
      const fullInterceptingListener = {
        onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata2) => {
        },
        onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message) => {
        },
        onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status) => {
        }
      };
      this.requester.start(metadata, fullInterceptingListener, (md, listener) => {
        var _a2, _b2, _c2;
        let finalInterceptingListener;
        if (call_stream_1.isInterceptingListener(listener)) {
          finalInterceptingListener = listener;
        } else {
          const fullListener = {
            onReceiveMetadata: (_a2 = listener.onReceiveMetadata) !== null && _a2 !== void 0 ? _a2 : defaultListener.onReceiveMetadata,
            onReceiveMessage: (_b2 = listener.onReceiveMessage) !== null && _b2 !== void 0 ? _b2 : defaultListener.onReceiveMessage,
            onReceiveStatus: (_c2 = listener.onReceiveStatus) !== null && _c2 !== void 0 ? _c2 : defaultListener.onReceiveStatus
          };
          finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);
        }
        this.nextCall.start(md, finalInterceptingListener);
      });
    }
    sendMessageWithContext(context, message) {
      this.processingMessage = true;
      this.requester.sendMessage(message, (finalMessage) => {
        this.processingMessage = false;
        this.nextCall.sendMessageWithContext(context, finalMessage);
        if (this.pendingHalfClose) {
          this.nextCall.halfClose();
        }
      });
    }
    sendMessage(message) {
      this.sendMessageWithContext({}, message);
    }
    startRead() {
      this.nextCall.startRead();
    }
    halfClose() {
      this.requester.halfClose(() => {
        if (this.processingMessage) {
          this.pendingHalfClose = true;
        } else {
          this.nextCall.halfClose();
        }
      });
    }
    setCredentials(credentials) {
      this.nextCall.setCredentials(credentials);
    }
  };
  exports2.InterceptingCall = InterceptingCall;
  function getCall(channel, path, options) {
    var _a, _b;
    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;
    const host = options.host;
    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;
    const propagateFlags = options.propagate_flags;
    const credentials = options.credentials;
    const call = channel.createCall(path, deadline, host, parent, propagateFlags);
    if (credentials) {
      call.setCredentials(credentials);
    }
    return call;
  }
  var BaseInterceptingCall = class {
    constructor(call, methodDefinition) {
      this.call = call;
      this.methodDefinition = methodDefinition;
    }
    cancelWithStatus(status, details) {
      this.call.cancelWithStatus(status, details);
    }
    getPeer() {
      return this.call.getPeer();
    }
    setCredentials(credentials) {
      this.call.setCredentials(credentials);
    }
    sendMessageWithContext(context, message) {
      let serialized;
      try {
        serialized = this.methodDefinition.requestSerialize(message);
      } catch (e) {
        this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${e.message}`);
        return;
      }
      this.call.sendMessageWithContext(context, serialized);
    }
    sendMessage(message) {
      this.sendMessageWithContext({}, message);
    }
    start(metadata, interceptingListener) {
      let readError = null;
      this.call.start(metadata, {
        onReceiveMetadata: (metadata2) => {
          var _a;
          (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata2);
        },
        onReceiveMessage: (message) => {
          var _a;
          let deserialized;
          try {
            deserialized = this.methodDefinition.responseDeserialize(message);
          } catch (e) {
            readError = {
              code: constants_1.Status.INTERNAL,
              details: `Response message parsing error: ${e.message}`,
              metadata: new metadata_1.Metadata()
            };
            this.call.cancelWithStatus(readError.code, readError.details);
            return;
          }
          (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);
        },
        onReceiveStatus: (status) => {
          var _a, _b;
          if (readError) {
            (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);
          } else {
            (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);
          }
        }
      });
    }
    startRead() {
      this.call.startRead();
    }
    halfClose() {
      this.call.halfClose();
    }
  };
  var BaseUnaryInterceptingCall = class extends BaseInterceptingCall {
    constructor(call, methodDefinition) {
      super(call, methodDefinition);
    }
    start(metadata, listener) {
      var _a, _b;
      let receivedMessage = false;
      const wrapperListener = {
        onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata2) => {
        },
        onReceiveMessage: (message) => {
          var _a2;
          receivedMessage = true;
          (_a2 = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a2 === void 0 ? void 0 : _a2.call(listener, message);
        },
        onReceiveStatus: (status) => {
          var _a2, _b2;
          if (!receivedMessage) {
            (_a2 = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a2 === void 0 ? void 0 : _a2.call(listener, null);
          }
          (_b2 = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b2 === void 0 ? void 0 : _b2.call(listener, status);
        }
      };
      super.start(metadata, wrapperListener);
      this.call.startRead();
    }
  };
  var BaseStreamingInterceptingCall = class extends BaseInterceptingCall {
  };
  function getBottomInterceptingCall(channel, options, methodDefinition) {
    const call = getCall(channel, methodDefinition.path, options);
    if (methodDefinition.responseStream) {
      return new BaseStreamingInterceptingCall(call, methodDefinition);
    } else {
      return new BaseUnaryInterceptingCall(call, methodDefinition);
    }
  }
  function getInterceptingCall(interceptorArgs, methodDefinition, options, channel) {
    if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {
      throw new InterceptorConfigurationError("Both interceptors and interceptor_providers were passed as options to the client constructor. Only one of these is allowed.");
    }
    if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {
      throw new InterceptorConfigurationError("Both interceptors and interceptor_providers were passed as call options. Only one of these is allowed.");
    }
    let interceptors = [];
    if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {
      interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider) => provider(methodDefinition))).filter((interceptor) => interceptor);
    } else {
      interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider) => provider(methodDefinition))).filter((interceptor) => interceptor);
    }
    const interceptorOptions = Object.assign({}, options, {
      method_definition: methodDefinition
    });
    const getCall2 = interceptors.reduceRight((nextCall, nextInterceptor) => {
      return (currentOptions) => nextInterceptor(currentOptions, nextCall);
    }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));
    return getCall2(interceptorOptions);
  }
  exports2.getInterceptingCall = getInterceptingCall;
});

// node_modules/@grpc/grpc-js/build/src/client.js
var require_client = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Client = void 0;
  var call_1 = require_call();
  var channel_1 = require_channel();
  var constants_1 = require_constants();
  var metadata_1 = require_metadata();
  var client_interceptors_1 = require_client_interceptors();
  var CHANNEL_SYMBOL = Symbol();
  var INTERCEPTOR_SYMBOL = Symbol();
  var INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
  var CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();
  var Client = class {
    constructor(address, credentials, options = {}) {
      var _a, _b;
      options = Object.assign({}, options);
      this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];
      delete options.interceptors;
      this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];
      delete options.interceptor_providers;
      if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {
        throw new Error("Both interceptors and interceptor_providers were passed as options to the client constructor. Only one of these is allowed.");
      }
      this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;
      delete options.callInvocationTransformer;
      if (options.channelOverride) {
        this[CHANNEL_SYMBOL] = options.channelOverride;
      } else if (options.channelFactoryOverride) {
        const channelFactoryOverride = options.channelFactoryOverride;
        delete options.channelFactoryOverride;
        this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);
      } else {
        this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);
      }
    }
    close() {
      this[CHANNEL_SYMBOL].close();
    }
    getChannel() {
      return this[CHANNEL_SYMBOL];
    }
    waitForReady(deadline, callback) {
      const checkState = (err) => {
        if (err) {
          callback(new Error("Failed to connect before the deadline"));
          return;
        }
        let newState;
        try {
          newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
        } catch (e) {
          callback(new Error("The channel has been closed"));
          return;
        }
        if (newState === channel_1.ConnectivityState.READY) {
          callback();
        } else {
          try {
            this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);
          } catch (e) {
            callback(new Error("The channel has been closed"));
          }
        }
      };
      setImmediate(checkState);
    }
    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {
      if (arg1 instanceof Function) {
        return {metadata: new metadata_1.Metadata(), options: {}, callback: arg1};
      } else if (arg2 instanceof Function) {
        if (arg1 instanceof metadata_1.Metadata) {
          return {metadata: arg1, options: {}, callback: arg2};
        } else {
          return {metadata: new metadata_1.Metadata(), options: arg1, callback: arg2};
        }
      } else {
        if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && arg3 instanceof Function)) {
          throw new Error("Incorrect arguments passed");
        }
        return {metadata: arg1, options: arg2, callback: arg3};
      }
    }
    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {
      var _a, _b;
      const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
      const methodDefinition = {
        path: method,
        requestStream: false,
        responseStream: false,
        requestSerialize: serialize,
        responseDeserialize: deserialize
      };
      let callProperties = {
        argument,
        metadata: checkedArguments.metadata,
        call: new call_1.ClientUnaryCallImpl(),
        channel: this[CHANNEL_SYMBOL],
        methodDefinition,
        callOptions: checkedArguments.options,
        callback: checkedArguments.callback
      };
      if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
        callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
      }
      const emitter = callProperties.call;
      const interceptorArgs = {
        clientInterceptors: this[INTERCEPTOR_SYMBOL],
        clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
        callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
        callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
      };
      const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
      emitter.call = call;
      if (callProperties.callOptions.credentials) {
        call.setCredentials(callProperties.callOptions.credentials);
      }
      let responseMessage = null;
      let receivedStatus = false;
      call.start(callProperties.metadata, {
        onReceiveMetadata: (metadata2) => {
          emitter.emit("metadata", metadata2);
        },
        onReceiveMessage(message) {
          if (responseMessage !== null) {
            call.cancelWithStatus(constants_1.Status.INTERNAL, "Too many responses received");
          }
          responseMessage = message;
        },
        onReceiveStatus(status) {
          if (receivedStatus) {
            return;
          }
          receivedStatus = true;
          if (status.code === constants_1.Status.OK) {
            callProperties.callback(null, responseMessage);
          } else {
            callProperties.callback(call_1.callErrorFromStatus(status));
          }
          emitter.emit("status", status);
        }
      });
      call.sendMessage(argument);
      call.halfClose();
      return emitter;
    }
    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {
      var _a, _b;
      const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
      const methodDefinition = {
        path: method,
        requestStream: true,
        responseStream: false,
        requestSerialize: serialize,
        responseDeserialize: deserialize
      };
      let callProperties = {
        metadata: checkedArguments.metadata,
        call: new call_1.ClientWritableStreamImpl(serialize),
        channel: this[CHANNEL_SYMBOL],
        methodDefinition,
        callOptions: checkedArguments.options,
        callback: checkedArguments.callback
      };
      if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
        callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
      }
      const emitter = callProperties.call;
      const interceptorArgs = {
        clientInterceptors: this[INTERCEPTOR_SYMBOL],
        clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
        callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
        callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
      };
      const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
      emitter.call = call;
      if (callProperties.callOptions.credentials) {
        call.setCredentials(callProperties.callOptions.credentials);
      }
      let responseMessage = null;
      let receivedStatus = false;
      call.start(callProperties.metadata, {
        onReceiveMetadata: (metadata2) => {
          emitter.emit("metadata", metadata2);
        },
        onReceiveMessage(message) {
          if (responseMessage !== null) {
            call.cancelWithStatus(constants_1.Status.INTERNAL, "Too many responses received");
          }
          responseMessage = message;
        },
        onReceiveStatus(status) {
          if (receivedStatus) {
            return;
          }
          receivedStatus = true;
          if (status.code === constants_1.Status.OK) {
            callProperties.callback(null, responseMessage);
          } else {
            callProperties.callback(call_1.callErrorFromStatus(status));
          }
          emitter.emit("status", status);
        }
      });
      return emitter;
    }
    checkMetadataAndOptions(arg1, arg2) {
      let metadata;
      let options;
      if (arg1 instanceof metadata_1.Metadata) {
        metadata = arg1;
        if (arg2) {
          options = arg2;
        } else {
          options = {};
        }
      } else {
        if (arg1) {
          options = arg1;
        } else {
          options = {};
        }
        metadata = new metadata_1.Metadata();
      }
      return {metadata, options};
    }
    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {
      var _a, _b;
      const checkedArguments = this.checkMetadataAndOptions(metadata, options);
      const methodDefinition = {
        path: method,
        requestStream: false,
        responseStream: true,
        requestSerialize: serialize,
        responseDeserialize: deserialize
      };
      let callProperties = {
        argument,
        metadata: checkedArguments.metadata,
        call: new call_1.ClientReadableStreamImpl(deserialize),
        channel: this[CHANNEL_SYMBOL],
        methodDefinition,
        callOptions: checkedArguments.options
      };
      if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
        callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
      }
      const stream = callProperties.call;
      const interceptorArgs = {
        clientInterceptors: this[INTERCEPTOR_SYMBOL],
        clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
        callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
        callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
      };
      const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
      stream.call = call;
      if (callProperties.callOptions.credentials) {
        call.setCredentials(callProperties.callOptions.credentials);
      }
      let receivedStatus = false;
      call.start(callProperties.metadata, {
        onReceiveMetadata(metadata2) {
          stream.emit("metadata", metadata2);
        },
        onReceiveMessage(message) {
          stream.push(message);
        },
        onReceiveStatus(status) {
          if (receivedStatus) {
            return;
          }
          receivedStatus = true;
          stream.push(null);
          if (status.code !== constants_1.Status.OK) {
            stream.emit("error", call_1.callErrorFromStatus(status));
          }
          stream.emit("status", status);
        }
      });
      call.sendMessage(argument);
      call.halfClose();
      return stream;
    }
    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {
      var _a, _b;
      const checkedArguments = this.checkMetadataAndOptions(metadata, options);
      const methodDefinition = {
        path: method,
        requestStream: true,
        responseStream: true,
        requestSerialize: serialize,
        responseDeserialize: deserialize
      };
      let callProperties = {
        metadata: checkedArguments.metadata,
        call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),
        channel: this[CHANNEL_SYMBOL],
        methodDefinition,
        callOptions: checkedArguments.options
      };
      if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
        callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
      }
      const stream = callProperties.call;
      const interceptorArgs = {
        clientInterceptors: this[INTERCEPTOR_SYMBOL],
        clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
        callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
        callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
      };
      const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
      stream.call = call;
      if (callProperties.callOptions.credentials) {
        call.setCredentials(callProperties.callOptions.credentials);
      }
      let receivedStatus = false;
      call.start(callProperties.metadata, {
        onReceiveMetadata(metadata2) {
          stream.emit("metadata", metadata2);
        },
        onReceiveMessage(message) {
          stream.push(message);
        },
        onReceiveStatus(status) {
          if (receivedStatus) {
            return;
          }
          receivedStatus = true;
          stream.push(null);
          if (status.code !== constants_1.Status.OK) {
            stream.emit("error", call_1.callErrorFromStatus(status));
          }
          stream.emit("status", status);
        }
      });
      return stream;
    }
  };
  exports2.Client = Client;
});

// node_modules/@grpc/grpc-js/build/src/make-client.js
var require_make_client = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.loadPackageDefinition = exports2.makeClientConstructor = void 0;
  var client_1 = require_client();
  var requesterFuncs = {
    unary: client_1.Client.prototype.makeUnaryRequest,
    server_stream: client_1.Client.prototype.makeServerStreamRequest,
    client_stream: client_1.Client.prototype.makeClientStreamRequest,
    bidi: client_1.Client.prototype.makeBidiStreamRequest
  };
  function isPrototypePolluted(key) {
    return ["__proto__", "prototype", "constructor"].includes(key);
  }
  function makeClientConstructor(methods, serviceName, classOptions) {
    if (!classOptions) {
      classOptions = {};
    }
    class ServiceClientImpl extends client_1.Client {
    }
    Object.keys(methods).forEach((name) => {
      if (isPrototypePolluted(name)) {
        return;
      }
      const attrs = methods[name];
      let methodType;
      if (typeof name === "string" && name.charAt(0) === "$") {
        throw new Error("Method names cannot start with $");
      }
      if (attrs.requestStream) {
        if (attrs.responseStream) {
          methodType = "bidi";
        } else {
          methodType = "client_stream";
        }
      } else {
        if (attrs.responseStream) {
          methodType = "server_stream";
        } else {
          methodType = "unary";
        }
      }
      const serialize = attrs.requestSerialize;
      const deserialize = attrs.responseDeserialize;
      const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);
      ServiceClientImpl.prototype[name] = methodFunc;
      Object.assign(ServiceClientImpl.prototype[name], attrs);
      if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {
        ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name];
      }
    });
    ServiceClientImpl.service = methods;
    return ServiceClientImpl;
  }
  exports2.makeClientConstructor = makeClientConstructor;
  function partial(fn, path, serialize, deserialize) {
    return function(...args) {
      return fn.call(this, path, serialize, deserialize, ...args);
    };
  }
  function isProtobufTypeDefinition(obj) {
    return "format" in obj;
  }
  function loadPackageDefinition(packageDef) {
    const result = {};
    for (const serviceFqn in packageDef) {
      if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {
        const service = packageDef[serviceFqn];
        const nameComponents = serviceFqn.split(".");
        if (nameComponents.some((comp) => isPrototypePolluted(comp))) {
          continue;
        }
        const serviceName = nameComponents[nameComponents.length - 1];
        let current = result;
        for (const packageName of nameComponents.slice(0, -1)) {
          if (!current[packageName]) {
            current[packageName] = {};
          }
          current = current[packageName];
        }
        if (isProtobufTypeDefinition(service)) {
          current[serviceName] = service;
        } else {
          current[serviceName] = makeClientConstructor(service, serviceName, {});
        }
      }
    }
    return result;
  }
  exports2.loadPackageDefinition = loadPackageDefinition;
});

// node_modules/@grpc/grpc-js/build/src/server-call.js
var require_server_call = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Http2ServerCallStream = exports2.ServerDuplexStreamImpl = exports2.ServerWritableStreamImpl = exports2.ServerReadableStreamImpl = exports2.ServerUnaryCallImpl = void 0;
  var events_1 = require("events");
  var http2 = require("http2");
  var stream_1 = require("stream");
  var constants_1 = require_constants();
  var metadata_1 = require_metadata();
  var stream_decoder_1 = require_stream_decoder();
  var logging = require_logging();
  var TRACER_NAME = "server_call";
  function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
  }
  var GRPC_ACCEPT_ENCODING_HEADER = "grpc-accept-encoding";
  var GRPC_ENCODING_HEADER = "grpc-encoding";
  var GRPC_MESSAGE_HEADER = "grpc-message";
  var GRPC_STATUS_HEADER = "grpc-status";
  var GRPC_TIMEOUT_HEADER = "grpc-timeout";
  var DEADLINE_REGEX = /(\d{1,8})\s*([HMSmun])/;
  var deadlineUnitsToMs = {
    H: 36e5,
    M: 6e4,
    S: 1e3,
    m: 1,
    u: 1e-3,
    n: 1e-6
  };
  var defaultResponseHeaders = {
    [GRPC_ACCEPT_ENCODING_HEADER]: "identity",
    [GRPC_ENCODING_HEADER]: "identity",
    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: "application/grpc+proto"
  };
  var defaultResponseOptions = {
    waitForTrailers: true
  };
  var ServerUnaryCallImpl = class extends events_1.EventEmitter {
    constructor(call, metadata, request) {
      super();
      this.call = call;
      this.metadata = metadata;
      this.request = request;
      this.cancelled = false;
      this.call.setupSurfaceCall(this);
    }
    getPeer() {
      return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
      this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
      return this.call.getDeadline();
    }
  };
  exports2.ServerUnaryCallImpl = ServerUnaryCallImpl;
  var ServerReadableStreamImpl = class extends stream_1.Readable {
    constructor(call, metadata, deserialize) {
      super({objectMode: true});
      this.call = call;
      this.metadata = metadata;
      this.deserialize = deserialize;
      this.cancelled = false;
      this.call.setupSurfaceCall(this);
      this.call.setupReadable(this);
    }
    _read(size) {
      if (!this.call.consumeUnpushedMessages(this)) {
        return;
      }
      this.call.resume();
    }
    getPeer() {
      return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
      this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
      return this.call.getDeadline();
    }
  };
  exports2.ServerReadableStreamImpl = ServerReadableStreamImpl;
  var ServerWritableStreamImpl = class extends stream_1.Writable {
    constructor(call, metadata, serialize, request) {
      super({objectMode: true});
      this.call = call;
      this.metadata = metadata;
      this.serialize = serialize;
      this.request = request;
      this.cancelled = false;
      this.trailingMetadata = new metadata_1.Metadata();
      this.call.setupSurfaceCall(this);
      this.on("error", (err) => {
        this.call.sendError(err);
        this.end();
      });
    }
    getPeer() {
      return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
      this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
      return this.call.getDeadline();
    }
    _write(chunk, encoding, callback) {
      try {
        const response = this.call.serializeMessage(chunk);
        if (!this.call.write(response)) {
          this.call.once("drain", callback);
          return;
        }
      } catch (err) {
        err.code = constants_1.Status.INTERNAL;
        this.emit("error", err);
      }
      callback();
    }
    _final(callback) {
      this.call.sendStatus({
        code: constants_1.Status.OK,
        details: "OK",
        metadata: this.trailingMetadata
      });
      callback(null);
    }
    end(metadata) {
      if (metadata) {
        this.trailingMetadata = metadata;
      }
      super.end();
    }
  };
  exports2.ServerWritableStreamImpl = ServerWritableStreamImpl;
  var ServerDuplexStreamImpl = class extends stream_1.Duplex {
    constructor(call, metadata, serialize, deserialize) {
      super({objectMode: true});
      this.call = call;
      this.metadata = metadata;
      this.serialize = serialize;
      this.deserialize = deserialize;
      this.cancelled = false;
      this.trailingMetadata = new metadata_1.Metadata();
      this.call.setupSurfaceCall(this);
      this.call.setupReadable(this);
      this.on("error", (err) => {
        this.call.sendError(err);
        this.end();
      });
    }
    getPeer() {
      return this.call.getPeer();
    }
    sendMetadata(responseMetadata) {
      this.call.sendMetadata(responseMetadata);
    }
    getDeadline() {
      return this.call.getDeadline();
    }
    end(metadata) {
      if (metadata) {
        this.trailingMetadata = metadata;
      }
      super.end();
    }
  };
  exports2.ServerDuplexStreamImpl = ServerDuplexStreamImpl;
  ServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;
  ServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;
  ServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final;
  ServerDuplexStreamImpl.prototype.end = ServerWritableStreamImpl.prototype.end;
  var Http2ServerCallStream = class extends events_1.EventEmitter {
    constructor(stream, handler, options) {
      super();
      this.stream = stream;
      this.handler = handler;
      this.options = options;
      this.cancelled = false;
      this.deadlineTimer = setTimeout(() => {
      }, 0);
      this.deadline = Infinity;
      this.wantTrailers = false;
      this.metadataSent = false;
      this.canPush = false;
      this.isPushPending = false;
      this.bufferedMessages = [];
      this.messagesToPush = [];
      this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
      this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
      this.stream.once("error", (err) => {
      });
      this.stream.once("close", () => {
        var _a;
        trace("Request to method " + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + " stream closed with rstCode " + this.stream.rstCode);
        this.cancelled = true;
        this.emit("cancelled", "cancelled");
      });
      this.stream.on("drain", () => {
        this.emit("drain");
      });
      if ("grpc.max_send_message_length" in options) {
        this.maxSendMessageSize = options["grpc.max_send_message_length"];
      }
      if ("grpc.max_receive_message_length" in options) {
        this.maxReceiveMessageSize = options["grpc.max_receive_message_length"];
      }
      clearTimeout(this.deadlineTimer);
    }
    checkCancelled() {
      if (this.stream.destroyed) {
        this.cancelled = true;
      }
      return this.cancelled;
    }
    sendMetadata(customMetadata) {
      if (this.checkCancelled()) {
        return;
      }
      if (this.metadataSent) {
        return;
      }
      this.metadataSent = true;
      const custom = customMetadata ? customMetadata.toHttp2Headers() : null;
      const headers = Object.assign({}, defaultResponseHeaders, custom);
      this.stream.respond(headers, defaultResponseOptions);
    }
    receiveMetadata(headers) {
      const metadata = metadata_1.Metadata.fromHttp2Headers(headers);
      const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);
      if (timeoutHeader.length > 0) {
        const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);
        if (match === null) {
          const err = new Error("Invalid deadline");
          err.code = constants_1.Status.OUT_OF_RANGE;
          this.sendError(err);
          return;
        }
        const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;
        const now = new Date();
        this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);
        this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);
        metadata.remove(GRPC_TIMEOUT_HEADER);
      }
      metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);
      metadata.remove(http2.constants.HTTP2_HEADER_TE);
      metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);
      metadata.remove("grpc-encoding");
      metadata.remove("grpc-accept-encoding");
      return metadata;
    }
    receiveUnaryMessage() {
      return new Promise((resolve, reject) => {
        const stream = this.stream;
        const chunks = [];
        let totalLength = 0;
        stream.on("data", (data) => {
          chunks.push(data);
          totalLength += data.byteLength;
        });
        stream.once("end", async () => {
          try {
            const requestBytes = Buffer.concat(chunks, totalLength);
            if (this.maxReceiveMessageSize !== -1 && requestBytes.length > this.maxReceiveMessageSize) {
              this.sendError({
                code: constants_1.Status.RESOURCE_EXHAUSTED,
                details: `Received message larger than max (${requestBytes.length} vs. ${this.maxReceiveMessageSize})`
              });
              resolve();
            }
            resolve(this.deserializeMessage(requestBytes));
          } catch (err) {
            err.code = constants_1.Status.INTERNAL;
            this.sendError(err);
            resolve();
          }
        });
      });
    }
    serializeMessage(value) {
      const messageBuffer = this.handler.serialize(value);
      const byteLength = messageBuffer.byteLength;
      const output = Buffer.allocUnsafe(byteLength + 5);
      output.writeUInt8(0, 0);
      output.writeUInt32BE(byteLength, 1);
      messageBuffer.copy(output, 5);
      return output;
    }
    deserializeMessage(bytes) {
      const receivedMessage = bytes.slice(5);
      return this.handler.deserialize(receivedMessage);
    }
    async sendUnaryMessage(err, value, metadata, flags) {
      if (this.checkCancelled()) {
        return;
      }
      if (!metadata) {
        metadata = new metadata_1.Metadata();
      }
      if (err) {
        if (!Object.prototype.hasOwnProperty.call(err, "metadata")) {
          err.metadata = metadata;
        }
        this.sendError(err);
        return;
      }
      try {
        const response = this.serializeMessage(value);
        this.write(response);
        this.sendStatus({code: constants_1.Status.OK, details: "OK", metadata});
      } catch (err2) {
        err2.code = constants_1.Status.INTERNAL;
        this.sendError(err2);
      }
    }
    sendStatus(statusObj) {
      var _a;
      if (this.checkCancelled()) {
        return;
      }
      trace("Request to method " + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + " ended with status code: " + constants_1.Status[statusObj.code] + " details: " + statusObj.details);
      clearTimeout(this.deadlineTimer);
      if (!this.wantTrailers) {
        this.wantTrailers = true;
        this.stream.once("wantTrailers", () => {
          const trailersToSend = Object.assign({
            [GRPC_STATUS_HEADER]: statusObj.code,
            [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)
          }, statusObj.metadata.toHttp2Headers());
          this.stream.sendTrailers(trailersToSend);
        });
        this.sendMetadata();
        this.stream.end();
      }
    }
    sendError(error) {
      if (this.checkCancelled()) {
        return;
      }
      const status = {
        code: constants_1.Status.UNKNOWN,
        details: "message" in error ? error.message : "Unknown Error",
        metadata: "metadata" in error && error.metadata !== void 0 ? error.metadata : new metadata_1.Metadata()
      };
      if ("code" in error && typeof error.code === "number" && Number.isInteger(error.code)) {
        status.code = error.code;
        if ("details" in error && typeof error.details === "string") {
          status.details = error.details;
        }
      }
      this.sendStatus(status);
    }
    write(chunk) {
      if (this.checkCancelled()) {
        return;
      }
      if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {
        this.sendError({
          code: constants_1.Status.RESOURCE_EXHAUSTED,
          details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`
        });
        return;
      }
      this.sendMetadata();
      return this.stream.write(chunk);
    }
    resume() {
      this.stream.resume();
    }
    setupSurfaceCall(call) {
      this.once("cancelled", (reason) => {
        call.cancelled = true;
        call.emit("cancelled", reason);
      });
    }
    setupReadable(readable) {
      const decoder = new stream_decoder_1.StreamDecoder();
      this.stream.on("data", async (data) => {
        const messages = decoder.write(data);
        for (const message of messages) {
          if (this.maxReceiveMessageSize !== -1 && message.length > this.maxReceiveMessageSize) {
            this.sendError({
              code: constants_1.Status.RESOURCE_EXHAUSTED,
              details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`
            });
            return;
          }
          this.pushOrBufferMessage(readable, message);
        }
      });
      this.stream.once("end", () => {
        this.pushOrBufferMessage(readable, null);
      });
    }
    consumeUnpushedMessages(readable) {
      this.canPush = true;
      while (this.messagesToPush.length > 0) {
        const nextMessage = this.messagesToPush.shift();
        const canPush = readable.push(nextMessage);
        if (nextMessage === null || canPush === false) {
          this.canPush = false;
          break;
        }
      }
      return this.canPush;
    }
    pushOrBufferMessage(readable, messageBytes) {
      if (this.isPushPending) {
        this.bufferedMessages.push(messageBytes);
      } else {
        this.pushMessage(readable, messageBytes);
      }
    }
    async pushMessage(readable, messageBytes) {
      if (messageBytes === null) {
        if (this.canPush) {
          readable.push(null);
        } else {
          this.messagesToPush.push(null);
        }
        return;
      }
      this.isPushPending = true;
      try {
        const deserialized = await this.deserializeMessage(messageBytes);
        if (this.canPush) {
          if (!readable.push(deserialized)) {
            this.canPush = false;
            this.stream.pause();
          }
        } else {
          this.messagesToPush.push(deserialized);
        }
      } catch (error) {
        this.bufferedMessages.length = 0;
        if (!("code" in error && typeof error.code === "number" && Number.isInteger(error.code) && error.code >= constants_1.Status.OK && error.code <= constants_1.Status.UNAUTHENTICATED)) {
          error.code = constants_1.Status.INTERNAL;
        }
        readable.emit("error", error);
      }
      this.isPushPending = false;
      if (this.bufferedMessages.length > 0) {
        this.pushMessage(readable, this.bufferedMessages.shift());
      }
    }
    getPeer() {
      const socket = this.stream.session.socket;
      if (socket.remoteAddress) {
        if (socket.remotePort) {
          return `${socket.remoteAddress}:${socket.remotePort}`;
        } else {
          return socket.remoteAddress;
        }
      } else {
        return "unknown";
      }
    }
    getDeadline() {
      return this.deadline;
    }
  };
  exports2.Http2ServerCallStream = Http2ServerCallStream;
  function handleExpiredDeadline(call) {
    const err = new Error("Deadline exceeded");
    err.code = constants_1.Status.DEADLINE_EXCEEDED;
    call.sendError(err);
    call.cancelled = true;
    call.emit("cancelled", "deadline");
  }
});

// node_modules/@grpc/grpc-js/build/src/server.js
var require_server = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Server = void 0;
  var http2 = require("http2");
  var constants_1 = require_constants();
  var metadata_1 = require_metadata();
  var server_call_1 = require_server_call();
  var resolver_1 = require_resolver();
  var logging = require_logging();
  var subchannel_1 = require_subchannel();
  var uri_parser_1 = require_uri_parser();
  var TRACER_NAME = "server";
  function trace(text) {
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
  }
  function noop() {
  }
  function getUnimplementedStatusResponse(methodName) {
    return {
      code: constants_1.Status.UNIMPLEMENTED,
      details: `The server does not implement the method ${methodName}`,
      metadata: new metadata_1.Metadata()
    };
  }
  function getDefaultHandler(handlerType, methodName) {
    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);
    switch (handlerType) {
      case "unary":
        return (call, callback) => {
          callback(unimplementedStatusResponse, null);
        };
      case "clientStream":
        return (call, callback) => {
          callback(unimplementedStatusResponse, null);
        };
      case "serverStream":
        return (call) => {
          call.emit("error", unimplementedStatusResponse);
        };
      case "bidi":
        return (call) => {
          call.emit("error", unimplementedStatusResponse);
        };
      default:
        throw new Error(`Invalid handlerType ${handlerType}`);
    }
  }
  var Server = class {
    constructor(options) {
      this.http2ServerList = [];
      this.handlers = new Map();
      this.sessions = new Set();
      this.started = false;
      this.options = options !== null && options !== void 0 ? options : {};
    }
    addProtoService() {
      throw new Error("Not implemented. Use addService() instead");
    }
    addService(service, implementation) {
      if (service === null || typeof service !== "object" || implementation === null || typeof implementation !== "object") {
        throw new Error("addService() requires two objects as arguments");
      }
      const serviceKeys = Object.keys(service);
      if (serviceKeys.length === 0) {
        throw new Error("Cannot add an empty service to a server");
      }
      serviceKeys.forEach((name) => {
        const attrs = service[name];
        let methodType;
        if (attrs.requestStream) {
          if (attrs.responseStream) {
            methodType = "bidi";
          } else {
            methodType = "clientStream";
          }
        } else {
          if (attrs.responseStream) {
            methodType = "serverStream";
          } else {
            methodType = "unary";
          }
        }
        let implFn = implementation[name];
        let impl;
        if (implFn === void 0 && typeof attrs.originalName === "string") {
          implFn = implementation[attrs.originalName];
        }
        if (implFn !== void 0) {
          impl = implFn.bind(implementation);
        } else {
          impl = getDefaultHandler(methodType, name);
        }
        const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);
        if (success === false) {
          throw new Error(`Method handler for ${attrs.path} already provided.`);
        }
      });
    }
    removeService(service) {
      if (service === null || typeof service !== "object") {
        throw new Error("removeService() requires object as argument");
      }
      const serviceKeys = Object.keys(service);
      serviceKeys.forEach((name) => {
        const attrs = service[name];
        this.unregister(attrs.path);
      });
    }
    bind(port, creds) {
      throw new Error("Not implemented. Use bindAsync() instead");
    }
    bindAsync(port, creds, callback) {
      if (this.started === true) {
        throw new Error("server is already started");
      }
      if (typeof port !== "string") {
        throw new TypeError("port must be a string");
      }
      if (creds === null || typeof creds !== "object") {
        throw new TypeError("creds must be an object");
      }
      if (typeof callback !== "function") {
        throw new TypeError("callback must be a function");
      }
      const initialPortUri = uri_parser_1.parseUri(port);
      if (initialPortUri === null) {
        throw new Error(`Could not parse port "${port}"`);
      }
      const portUri = resolver_1.mapUriDefaultScheme(initialPortUri);
      if (portUri === null) {
        throw new Error(`Could not get a default scheme for port "${port}"`);
      }
      const serverOptions = {
        maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER
      };
      if ("grpc.max_concurrent_streams" in this.options) {
        serverOptions.settings = {
          maxConcurrentStreams: this.options["grpc.max_concurrent_streams"]
        };
      }
      const setupServer = () => {
        let http2Server;
        if (creds._isSecure()) {
          const secureServerOptions = Object.assign(serverOptions, creds._getSettings());
          http2Server = http2.createSecureServer(secureServerOptions);
        } else {
          http2Server = http2.createServer(serverOptions);
        }
        http2Server.setTimeout(0, noop);
        this._setupHandlers(http2Server);
        return http2Server;
      };
      const bindSpecificPort = (addressList, portNum, previousCount) => {
        if (addressList.length === 0) {
          return Promise.resolve({port: portNum, count: previousCount});
        }
        return Promise.all(addressList.map((address) => {
          trace("Attempting to bind " + subchannel_1.subchannelAddressToString(address));
          let addr;
          if (subchannel_1.isTcpSubchannelAddress(address)) {
            addr = {
              host: address.host,
              port: portNum
            };
          } else {
            addr = address;
          }
          const http2Server = setupServer();
          return new Promise((resolve, reject) => {
            function onError(err) {
              resolve(err);
            }
            http2Server.once("error", onError);
            http2Server.listen(addr, () => {
              trace("Successfully bound " + subchannel_1.subchannelAddressToString(address));
              this.http2ServerList.push(http2Server);
              const boundAddress = http2Server.address();
              if (typeof boundAddress === "string") {
                resolve(portNum);
              } else {
                resolve(boundAddress.port);
              }
              http2Server.removeListener("error", onError);
            });
          });
        })).then((results) => {
          let count = 0;
          for (const result of results) {
            if (typeof result === "number") {
              count += 1;
              if (result !== portNum) {
                throw new Error("Invalid state: multiple port numbers added from single address");
              }
            }
          }
          return {
            port: portNum,
            count: count + previousCount
          };
        });
      };
      const bindWildcardPort = (addressList) => {
        if (addressList.length === 0) {
          return Promise.resolve({port: 0, count: 0});
        }
        const address = addressList[0];
        const http2Server = setupServer();
        return new Promise((resolve, reject) => {
          function onError(err) {
            resolve(bindWildcardPort(addressList.slice(1)));
          }
          http2Server.once("error", onError);
          http2Server.listen(address, () => {
            this.http2ServerList.push(http2Server);
            resolve(bindSpecificPort(addressList.slice(1), http2Server.address().port, 1));
            http2Server.removeListener("error", onError);
          });
        });
      };
      const resolverListener = {
        onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {
          resolverListener.onSuccessfulResolution = () => {
          };
          if (addressList.length === 0) {
            callback(new Error(`No addresses resolved for port ${port}`), 0);
            return;
          }
          let bindResultPromise;
          if (subchannel_1.isTcpSubchannelAddress(addressList[0])) {
            if (addressList[0].port === 0) {
              bindResultPromise = bindWildcardPort(addressList);
            } else {
              bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);
            }
          } else {
            bindResultPromise = bindSpecificPort(addressList, 1, 0);
          }
          bindResultPromise.then((bindResult) => {
            if (bindResult.count === 0) {
              const errorString = `No address added out of total ${addressList.length} resolved`;
              logging.log(constants_1.LogVerbosity.ERROR, errorString);
              callback(new Error(errorString), 0);
            } else {
              if (bindResult.count < addressList.length) {
                logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);
              }
              callback(null, bindResult.port);
            }
          }, (error) => {
            const errorString = `No address added out of total ${addressList.length} resolved`;
            logging.log(constants_1.LogVerbosity.ERROR, errorString);
            callback(new Error(errorString), 0);
          });
        },
        onError: (error) => {
          callback(new Error(error.details), 0);
        }
      };
      const resolver = resolver_1.createResolver(portUri, resolverListener, this.options);
      resolver.updateResolution();
    }
    forceShutdown() {
      for (const http2Server of this.http2ServerList) {
        if (http2Server.listening) {
          http2Server.close();
        }
      }
      this.started = false;
      this.sessions.forEach((session) => {
        session.destroy(http2.constants.NGHTTP2_CANCEL);
      });
      this.sessions.clear();
    }
    register(name, handler, serialize, deserialize, type) {
      if (this.handlers.has(name)) {
        return false;
      }
      this.handlers.set(name, {
        func: handler,
        serialize,
        deserialize,
        type,
        path: name
      });
      return true;
    }
    unregister(name) {
      return this.handlers.delete(name);
    }
    start() {
      if (this.http2ServerList.length === 0 || this.http2ServerList.every((http2Server) => http2Server.listening !== true)) {
        throw new Error("server must be bound in order to start");
      }
      if (this.started === true) {
        throw new Error("server is already started");
      }
      this.started = true;
    }
    tryShutdown(callback) {
      let pendingChecks = 0;
      function maybeCallback() {
        pendingChecks--;
        if (pendingChecks === 0) {
          callback();
        }
      }
      this.started = false;
      for (const http2Server of this.http2ServerList) {
        if (http2Server.listening) {
          pendingChecks++;
          http2Server.close(maybeCallback);
        }
      }
      this.sessions.forEach((session) => {
        if (!session.closed) {
          pendingChecks += 1;
          session.close(maybeCallback);
        }
      });
      if (pendingChecks === 0) {
        callback();
      }
    }
    addHttp2Port() {
      throw new Error("Not yet implemented");
    }
    _setupHandlers(http2Server) {
      if (http2Server === null) {
        return;
      }
      http2Server.on("stream", (stream, headers) => {
        const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];
        if (typeof contentType !== "string" || !contentType.startsWith("application/grpc")) {
          stream.respond({
            [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE
          }, {endStream: true});
          return;
        }
        try {
          const path = headers[http2.constants.HTTP2_HEADER_PATH];
          const serverAddress = http2Server.address();
          let serverAddressString = "null";
          if (serverAddress) {
            if (typeof serverAddress === "string") {
              serverAddressString = serverAddress;
            } else {
              serverAddressString = serverAddress.address + ":" + serverAddress.port;
            }
          }
          trace("Received call to method " + path + " at address " + serverAddressString);
          const handler = this.handlers.get(path);
          if (handler === void 0) {
            trace("No handler registered for method " + path + ". Sending UNIMPLEMENTED status.");
            throw getUnimplementedStatusResponse(path);
          }
          const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);
          const metadata = call.receiveMetadata(headers);
          switch (handler.type) {
            case "unary":
              handleUnary(call, handler, metadata);
              break;
            case "clientStream":
              handleClientStreaming(call, handler, metadata);
              break;
            case "serverStream":
              handleServerStreaming(call, handler, metadata);
              break;
            case "bidi":
              handleBidiStreaming(call, handler, metadata);
              break;
            default:
              throw new Error(`Unknown handler type: ${handler.type}`);
          }
        } catch (err) {
          const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);
          if (err.code === void 0) {
            err.code = constants_1.Status.INTERNAL;
          }
          call.sendError(err);
        }
      });
      http2Server.on("session", (session) => {
        if (!this.started) {
          session.destroy();
          return;
        }
        this.sessions.add(session);
        session.on("close", () => {
          this.sessions.delete(session);
        });
      });
    }
  };
  exports2.Server = Server;
  async function handleUnary(call, handler, metadata) {
    const request = await call.receiveUnaryMessage();
    if (request === void 0 || call.cancelled) {
      return;
    }
    const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);
    handler.func(emitter, (err, value, trailer, flags) => {
      call.sendUnaryMessage(err, value, trailer, flags);
    });
  }
  function handleClientStreaming(call, handler, metadata) {
    const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize);
    function respond(err, value, trailer, flags) {
      stream.destroy();
      call.sendUnaryMessage(err, value, trailer, flags);
    }
    if (call.cancelled) {
      return;
    }
    stream.on("error", respond);
    handler.func(stream, respond);
  }
  async function handleServerStreaming(call, handler, metadata) {
    const request = await call.receiveUnaryMessage();
    if (request === void 0 || call.cancelled) {
      return;
    }
    const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);
    handler.func(stream);
  }
  function handleBidiStreaming(call, handler, metadata) {
    const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize);
    if (call.cancelled) {
      return;
    }
    handler.func(stream);
  }
});

// node_modules/@grpc/grpc-js/build/src/server-credentials.js
var require_server_credentials = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ServerCredentials = void 0;
  var tls_helpers_1 = require_tls_helpers();
  var ServerCredentials = class {
    static createInsecure() {
      return new InsecureServerCredentials();
    }
    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {
      if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {
        throw new TypeError("rootCerts must be null or a Buffer");
      }
      if (!Array.isArray(keyCertPairs)) {
        throw new TypeError("keyCertPairs must be an array");
      }
      if (typeof checkClientCertificate !== "boolean") {
        throw new TypeError("checkClientCertificate must be a boolean");
      }
      const cert = [];
      const key = [];
      for (let i = 0; i < keyCertPairs.length; i++) {
        const pair = keyCertPairs[i];
        if (pair === null || typeof pair !== "object") {
          throw new TypeError(`keyCertPair[${i}] must be an object`);
        }
        if (!Buffer.isBuffer(pair.private_key)) {
          throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);
        }
        if (!Buffer.isBuffer(pair.cert_chain)) {
          throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);
        }
        cert.push(pair.cert_chain);
        key.push(pair.private_key);
      }
      return new SecureServerCredentials({
        ca: rootCerts || tls_helpers_1.getDefaultRootsData() || void 0,
        cert,
        key,
        requestCert: checkClientCertificate,
        ciphers: tls_helpers_1.CIPHER_SUITES
      });
    }
  };
  exports2.ServerCredentials = ServerCredentials;
  var InsecureServerCredentials = class extends ServerCredentials {
    _isSecure() {
      return false;
    }
    _getSettings() {
      return null;
    }
  };
  var SecureServerCredentials = class extends ServerCredentials {
    constructor(options) {
      super();
      this.options = options;
    }
    _isSecure() {
      return true;
    }
    _getSettings() {
      return this.options;
    }
  };
});

// node_modules/@grpc/grpc-js/build/src/status-builder.js
var require_status_builder = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.StatusBuilder = void 0;
  var StatusBuilder = class {
    constructor() {
      this.code = null;
      this.details = null;
      this.metadata = null;
    }
    withCode(code) {
      this.code = code;
      return this;
    }
    withDetails(details) {
      this.details = details;
      return this;
    }
    withMetadata(metadata) {
      this.metadata = metadata;
      return this;
    }
    build() {
      const status = {};
      if (this.code !== null) {
        status.code = this.code;
      }
      if (this.details !== null) {
        status.details = this.details;
      }
      if (this.metadata !== null) {
        status.metadata = this.metadata;
      }
      return status;
    }
  };
  exports2.StatusBuilder = StatusBuilder;
});

// node_modules/@grpc/grpc-js/build/src/experimental.js
var require_experimental = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var logging_1 = require_logging();
  Object.defineProperty(exports2, "trace", {enumerable: true, get: function() {
    return logging_1.trace;
  }});
  var resolver_1 = require_resolver();
  Object.defineProperty(exports2, "registerResolver", {enumerable: true, get: function() {
    return resolver_1.registerResolver;
  }});
  var uri_parser_1 = require_uri_parser();
  Object.defineProperty(exports2, "uriToString", {enumerable: true, get: function() {
    return uri_parser_1.uriToString;
  }});
  var channel_credentials_1 = require_channel_credentials();
  Object.defineProperty(exports2, "createGoogleDefaultCredentials", {enumerable: true, get: function() {
    return channel_credentials_1.createGoogleDefaultCredentials;
  }});
  var backoff_timeout_1 = require_backoff_timeout();
  Object.defineProperty(exports2, "BackoffTimeout", {enumerable: true, get: function() {
    return backoff_timeout_1.BackoffTimeout;
  }});
  var load_balancer_1 = require_load_balancer();
  Object.defineProperty(exports2, "registerLoadBalancerType", {enumerable: true, get: function() {
    return load_balancer_1.registerLoadBalancerType;
  }});
  Object.defineProperty(exports2, "getFirstUsableConfig", {enumerable: true, get: function() {
    return load_balancer_1.getFirstUsableConfig;
  }});
  Object.defineProperty(exports2, "validateLoadBalancingConfig", {enumerable: true, get: function() {
    return load_balancer_1.validateLoadBalancingConfig;
  }});
  var subchannel_1 = require_subchannel();
  Object.defineProperty(exports2, "subchannelAddressToString", {enumerable: true, get: function() {
    return subchannel_1.subchannelAddressToString;
  }});
  var load_balancer_child_handler_1 = require_load_balancer_child_handler();
  Object.defineProperty(exports2, "ChildLoadBalancerHandler", {enumerable: true, get: function() {
    return load_balancer_child_handler_1.ChildLoadBalancerHandler;
  }});
  var picker_1 = require_picker();
  Object.defineProperty(exports2, "UnavailablePicker", {enumerable: true, get: function() {
    return picker_1.UnavailablePicker;
  }});
  Object.defineProperty(exports2, "QueuePicker", {enumerable: true, get: function() {
    return picker_1.QueuePicker;
  }});
  Object.defineProperty(exports2, "PickResultType", {enumerable: true, get: function() {
    return picker_1.PickResultType;
  }});
  var filter_1 = require_filter();
  Object.defineProperty(exports2, "BaseFilter", {enumerable: true, get: function() {
    return filter_1.BaseFilter;
  }});
  var filter_stack_1 = require_filter_stack();
  Object.defineProperty(exports2, "FilterStackFactory", {enumerable: true, get: function() {
    return filter_stack_1.FilterStackFactory;
  }});
});

// node_modules/@grpc/grpc-js/build/src/index.js
var require_src8 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.experimental = exports2.StatusBuilder = exports2.getClientChannel = exports2.ServerCredentials = exports2.Server = exports2.setLogVerbosity = exports2.setLogger = exports2.load = exports2.loadObject = exports2.CallCredentials = exports2.ChannelCredentials = exports2.waitForClientReady = exports2.closeClient = exports2.Channel = exports2.makeGenericClientConstructor = exports2.makeClientConstructor = exports2.loadPackageDefinition = exports2.Client = exports2.propagate = exports2.connectivityState = exports2.status = exports2.logVerbosity = exports2.Metadata = exports2.credentials = void 0;
  var semver = require_semver();
  var call_credentials_1 = require_call_credentials();
  Object.defineProperty(exports2, "CallCredentials", {enumerable: true, get: function() {
    return call_credentials_1.CallCredentials;
  }});
  var channel_1 = require_channel();
  Object.defineProperty(exports2, "connectivityState", {enumerable: true, get: function() {
    return channel_1.ConnectivityState;
  }});
  Object.defineProperty(exports2, "Channel", {enumerable: true, get: function() {
    return channel_1.ChannelImplementation;
  }});
  var channel_credentials_1 = require_channel_credentials();
  Object.defineProperty(exports2, "ChannelCredentials", {enumerable: true, get: function() {
    return channel_credentials_1.ChannelCredentials;
  }});
  var client_1 = require_client();
  Object.defineProperty(exports2, "Client", {enumerable: true, get: function() {
    return client_1.Client;
  }});
  var constants_1 = require_constants();
  Object.defineProperty(exports2, "logVerbosity", {enumerable: true, get: function() {
    return constants_1.LogVerbosity;
  }});
  Object.defineProperty(exports2, "status", {enumerable: true, get: function() {
    return constants_1.Status;
  }});
  Object.defineProperty(exports2, "propagate", {enumerable: true, get: function() {
    return constants_1.Propagate;
  }});
  var logging = require_logging();
  var make_client_1 = require_make_client();
  Object.defineProperty(exports2, "loadPackageDefinition", {enumerable: true, get: function() {
    return make_client_1.loadPackageDefinition;
  }});
  Object.defineProperty(exports2, "makeClientConstructor", {enumerable: true, get: function() {
    return make_client_1.makeClientConstructor;
  }});
  Object.defineProperty(exports2, "makeGenericClientConstructor", {enumerable: true, get: function() {
    return make_client_1.makeClientConstructor;
  }});
  var metadata_1 = require_metadata();
  Object.defineProperty(exports2, "Metadata", {enumerable: true, get: function() {
    return metadata_1.Metadata;
  }});
  var server_1 = require_server();
  Object.defineProperty(exports2, "Server", {enumerable: true, get: function() {
    return server_1.Server;
  }});
  var server_credentials_1 = require_server_credentials();
  Object.defineProperty(exports2, "ServerCredentials", {enumerable: true, get: function() {
    return server_credentials_1.ServerCredentials;
  }});
  var status_builder_1 = require_status_builder();
  Object.defineProperty(exports2, "StatusBuilder", {enumerable: true, get: function() {
    return status_builder_1.StatusBuilder;
  }});
  var supportedNodeVersions = require_package2().engines.node;
  if (!semver.satisfies(process.version, supportedNodeVersions)) {
    throw new Error(`@grpc/grpc-js only works on Node ${supportedNodeVersions}`);
  }
  exports2.credentials = {
    combineChannelCredentials: (channelCredentials, ...callCredentials) => {
      return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);
    },
    combineCallCredentials: (first, ...additional) => {
      return additional.reduce((acc, other) => acc.compose(other), first);
    },
    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,
    createSsl: channel_credentials_1.ChannelCredentials.createSsl,
    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,
    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,
    createEmpty: call_credentials_1.CallCredentials.createEmpty
  };
  exports2.closeClient = (client) => client.close();
  exports2.waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);
  exports2.loadObject = (value, options) => {
    throw new Error("Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead");
  };
  exports2.load = (filename, format, options) => {
    throw new Error("Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead");
  };
  exports2.setLogger = (logger) => {
    logging.setLogger(logger);
  };
  exports2.setLogVerbosity = (verbosity) => {
    logging.setLoggerVerbosity(verbosity);
  };
  exports2.getClientChannel = (client) => {
    return client_1.Client.prototype.getChannel.call(client);
  };
  var client_interceptors_1 = require_client_interceptors();
  Object.defineProperty(exports2, "ListenerBuilder", {enumerable: true, get: function() {
    return client_interceptors_1.ListenerBuilder;
  }});
  Object.defineProperty(exports2, "RequesterBuilder", {enumerable: true, get: function() {
    return client_interceptors_1.RequesterBuilder;
  }});
  Object.defineProperty(exports2, "InterceptingCall", {enumerable: true, get: function() {
    return client_interceptors_1.InterceptingCall;
  }});
  Object.defineProperty(exports2, "InterceptorConfigurationError", {enumerable: true, get: function() {
    return client_interceptors_1.InterceptorConfigurationError;
  }});
  var experimental = require_experimental();
  exports2.experimental = experimental;
  var resolver = require_resolver();
  var load_balancer = require_load_balancer();
  (() => {
    resolver.registerAll();
    load_balancer.registerAll();
  })();
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = asPromise;
  function asPromise(fn, ctx) {
    var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
    while (index < arguments.length)
      params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
      params[offset] = function callback(err) {
        if (pending) {
          pending = false;
          if (err)
            reject(err);
          else {
            var params2 = new Array(arguments.length - 1), offset2 = 0;
            while (offset2 < params2.length)
              params2[offset2++] = arguments[offset2];
            resolve.apply(null, params2);
          }
        }
      };
      try {
        fn.apply(ctx || null, params);
      } catch (err) {
        if (pending) {
          pending = false;
          reject(err);
        }
      }
    });
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS((exports2) => {
  "use strict";
  var base64 = exports2;
  base64.length = function length(string) {
    var p = string.length;
    if (!p)
      return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
      ++n;
    return Math.ceil(string.length * 3) / 4 - n;
  };
  var b64 = new Array(64);
  var s64 = new Array(123);
  for (var i = 0; i < 64; )
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
  base64.encode = function encode(buffer, start, end) {
    var parts = null, chunk = [];
    var i2 = 0, j = 0, t;
    while (start < end) {
      var b = buffer[start++];
      switch (j) {
        case 0:
          chunk[i2++] = b64[b >> 2];
          t = (b & 3) << 4;
          j = 1;
          break;
        case 1:
          chunk[i2++] = b64[t | b >> 4];
          t = (b & 15) << 2;
          j = 2;
          break;
        case 2:
          chunk[i2++] = b64[t | b >> 6];
          chunk[i2++] = b64[b & 63];
          j = 0;
          break;
      }
      if (i2 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i2 = 0;
      }
    }
    if (j) {
      chunk[i2++] = b64[t];
      chunk[i2++] = 61;
      if (j === 1)
        chunk[i2++] = 61;
    }
    if (parts) {
      if (i2)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i2));
  };
  var invalidEncoding = "invalid encoding";
  base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, t;
    for (var i2 = 0; i2 < string.length; ) {
      var c = string.charCodeAt(i2++);
      if (c === 61 && j > 1)
        break;
      if ((c = s64[c]) === void 0)
        throw Error(invalidEncoding);
      switch (j) {
        case 0:
          t = c;
          j = 1;
          break;
        case 1:
          buffer[offset++] = t << 2 | (c & 48) >> 4;
          t = c;
          j = 2;
          break;
        case 2:
          buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
          t = c;
          j = 3;
          break;
        case 3:
          buffer[offset++] = (t & 3) << 6 | c;
          j = 0;
          break;
      }
    }
    if (j === 1)
      throw Error(invalidEncoding);
    return offset - start;
  };
  base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
  };
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = EventEmitter;
  function EventEmitter() {
    this._listeners = {};
  }
  EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
      fn,
      ctx: ctx || this
    });
    return this;
  };
  EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === void 0)
      this._listeners = {};
    else {
      if (fn === void 0)
        this._listeners[evt] = [];
      else {
        var listeners = this._listeners[evt];
        for (var i = 0; i < listeners.length; )
          if (listeners[i].fn === fn)
            listeners.splice(i, 1);
          else
            ++i;
      }
    }
    return this;
  };
  EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
      var args = [], i = 1;
      for (; i < arguments.length; )
        args.push(arguments[i++]);
      for (i = 0; i < listeners.length; )
        listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
  };
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = factory(factory);
  function factory(exports3) {
    if (typeof Float32Array !== "undefined")
      (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
    else
      (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
    if (typeof Float64Array !== "undefined")
      (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
    else
      (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf, pos + off0);
            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
    return exports3;
  }
  function writeUintLE(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  function writeUintBE(val, buf, pos) {
    buf[pos] = val >>> 24;
    buf[pos + 1] = val >>> 16 & 255;
    buf[pos + 2] = val >>> 8 & 255;
    buf[pos + 3] = val & 255;
  }
  function readUintLE(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
  }
  function readUintBE(buf, pos) {
    return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS((exports, module) => {
  "use strict";
  module.exports = inquire;
  function inquire(moduleName) {
    try {
      var mod = eval("quire".replace(/^/, "re"))(moduleName);
      if (mod && (mod.length || Object.keys(mod).length))
        return mod;
    } catch (e) {
    }
    return null;
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS((exports2) => {
  "use strict";
  var utf8 = exports2;
  utf8.length = function utf8_length(string) {
    var len = 0, c = 0;
    for (var i = 0; i < string.length; ++i) {
      c = string.charCodeAt(i);
      if (c < 128)
        len += 1;
      else if (c < 2048)
        len += 2;
      else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
        ++i;
        len += 4;
      } else
        len += 3;
    }
    return len;
  };
  utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
      return "";
    var parts = null, chunk = [], i = 0, t;
    while (start < end) {
      t = buffer[start++];
      if (t < 128)
        chunk[i++] = t;
      else if (t > 191 && t < 224)
        chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
      else if (t > 239 && t < 365) {
        t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
        chunk[i++] = 55296 + (t >> 10);
        chunk[i++] = 56320 + (t & 1023);
      } else
        chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
      if (i > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i = 0;
      }
    }
    if (parts) {
      if (i)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
  };
  utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset, c1, c2;
    for (var i = 0; i < string.length; ++i) {
      c1 = string.charCodeAt(i);
      if (c1 < 128) {
        buffer[offset++] = c1;
      } else if (c1 < 2048) {
        buffer[offset++] = c1 >> 6 | 192;
        buffer[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
        ++i;
        buffer[offset++] = c1 >> 18 | 240;
        buffer[offset++] = c1 >> 12 & 63 | 128;
        buffer[offset++] = c1 >> 6 & 63 | 128;
        buffer[offset++] = c1 & 63 | 128;
      } else {
        buffer[offset++] = c1 >> 12 | 224;
        buffer[offset++] = c1 >> 6 & 63 | 128;
        buffer[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start;
  };
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = pool;
  function pool(alloc, slice, size) {
    var SIZE = size || 8192;
    var MAX = SIZE >>> 1;
    var slab = null;
    var offset = SIZE;
    return function pool_alloc(size2) {
      if (size2 < 1 || size2 > MAX)
        return alloc(size2);
      if (offset + size2 > SIZE) {
        slab = alloc(SIZE);
        offset = 0;
      }
      var buf = slice.call(slab, offset, offset += size2);
      if (offset & 7)
        offset = (offset | 7) + 1;
      return buf;
    };
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = LongBits;
  var util = require_minimal();
  function LongBits(lo, hi) {
    this.lo = lo >>> 0;
    this.hi = hi >>> 0;
  }
  var zero = LongBits.zero = new LongBits(0, 0);
  zero.toNumber = function() {
    return 0;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
  LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
      return zero;
    var sign = value < 0;
    if (sign)
      value = -value;
    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295)
          hi = 0;
      }
    }
    return new LongBits(lo, hi);
  };
  LongBits.from = function from(value) {
    if (typeof value === "number")
      return LongBits.fromNumber(value);
    if (util.isString(value)) {
      if (util.Long)
        value = util.Long.fromString(value);
      else
        return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
  };
  LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
      var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
      if (!lo)
        hi = hi + 1 >>> 0;
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned)};
  };
  var charCodeAt = String.prototype.charCodeAt;
  LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
      return zero;
    return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
  };
  LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
  };
  LongBits.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.length = function length() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS((exports2) => {
  "use strict";
  var util = exports2;
  util.asPromise = require_aspromise();
  util.base64 = require_base64();
  util.EventEmitter = require_eventemitter();
  util.float = require_float();
  util.inquire = require_inquire();
  util.utf8 = require_utf8();
  util.pool = require_pool();
  util.LongBits = require_longbits();
  util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
  util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
  util.emptyArray = Object.freeze ? Object.freeze([]) : [];
  util.emptyObject = Object.freeze ? Object.freeze({}) : {};
  util.isInteger = Number.isInteger || function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
  util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
  };
  util.isObject = function isObject(value) {
    return value && typeof value === "object";
  };
  util.isset = util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop))
      return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
  };
  util.Buffer = function() {
    try {
      var Buffer2 = util.inquire("buffer").Buffer;
      return Buffer2.prototype.utf8Write ? Buffer2 : null;
    } catch (e) {
      return null;
    }
  }();
  util._Buffer_from = null;
  util._Buffer_allocUnsafe = null;
  util.newBuffer = function newBuffer(sizeOrArray) {
    return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
  };
  util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  util.Long = util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long");
  util.key2Re = /^true|false|0|1$/;
  util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
  util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
  util.longToHash = function longToHash(value) {
    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
  };
  util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
      return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
  };
  function merge(dst, src, ifNotSet) {
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
      if (dst[keys[i]] === void 0 || !ifNotSet)
        dst[keys[i]] = src[keys[i]];
    return dst;
  }
  util.merge = merge;
  util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
  };
  function newError(name) {
    function CustomError(message, properties) {
      if (!(this instanceof CustomError))
        return new CustomError(message, properties);
      Object.defineProperty(this, "message", {get: function() {
        return message;
      }});
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, CustomError);
      else
        Object.defineProperty(this, "stack", {value: new Error().stack || ""});
      if (properties)
        merge(this, properties);
    }
    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
    Object.defineProperty(CustomError.prototype, "name", {get: function() {
      return name;
    }});
    CustomError.prototype.toString = function toString() {
      return this.name + ": " + this.message;
    };
    return CustomError;
  }
  util.newError = newError;
  util.ProtocolError = newError("ProtocolError");
  util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
      fieldMap[fieldNames[i]] = 1;
    return function() {
      for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
        if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
          return keys[i2];
    };
  };
  util.oneOfSetter = function setOneOf(fieldNames) {
    return function(name) {
      for (var i = 0; i < fieldNames.length; ++i)
        if (fieldNames[i] !== name)
          delete this[fieldNames[i]];
    };
  };
  util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
  };
  util._configure = function() {
    var Buffer2 = util.Buffer;
    if (!Buffer2) {
      util._Buffer_from = util._Buffer_allocUnsafe = null;
      return;
    }
    util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
      return new Buffer2(value, encoding);
    };
    util._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
      return new Buffer2(size);
    };
  };
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Writer;
  var util = require_minimal();
  var BufferWriter;
  var LongBits = util.LongBits;
  var base64 = util.base64;
  var utf8 = util.utf8;
  function Op(fn, len, val) {
    this.fn = fn;
    this.len = len;
    this.next = void 0;
    this.val = val;
  }
  function noop() {
  }
  function State(writer) {
    this.head = writer.head;
    this.tail = writer.tail;
    this.len = writer.len;
    this.next = writer.states;
  }
  function Writer() {
    this.len = 0;
    this.head = new Op(noop, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  var create = function create2() {
    return util.Buffer ? function create_buffer_setup() {
      return (Writer.create = function create_buffer() {
        return new BufferWriter();
      })();
    } : function create_array() {
      return new Writer();
    };
  };
  Writer.create = create();
  Writer.alloc = function alloc(size) {
    return new util.Array(size);
  };
  if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
  Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
  };
  function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
  }
  function writeVarint32(val, buf, pos) {
    while (val > 127) {
      buf[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf[pos] = val;
  }
  function VarintOp(len, val) {
    this.len = len;
    this.next = void 0;
    this.val = val;
  }
  VarintOp.prototype = Object.create(Op.prototype);
  VarintOp.prototype.fn = writeVarint32;
  Writer.prototype.uint32 = function write_uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
  };
  Writer.prototype.int32 = function write_int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
  };
  Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
  };
  function writeVarint64(val, buf, pos) {
    while (val.hi) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
  }
  Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.int64 = Writer.prototype.uint64;
  Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
  };
  function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
  };
  Writer.prototype.sfixed32 = Writer.prototype.fixed32;
  Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  };
  Writer.prototype.sfixed64 = Writer.prototype.fixed64;
  Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
  };
  Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
  };
  var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytes_for(val, buf, pos) {
    for (var i = 0; i < val.length; ++i)
      buf[pos + i] = val[i];
  };
  Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
      return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
      var buf = Writer.alloc(len = base64.length(value));
      base64.decode(value, buf, 0);
      value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
  };
  Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
  };
  Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
  };
  Writer.prototype.reset = function reset() {
    if (this.states) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
    }
    return this;
  };
  Writer.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len = this.len;
    this.reset().uint32(len);
    if (len) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len;
    }
    return this;
  };
  Writer.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
    while (head) {
      head.fn(head.val, buf, pos);
      pos += head.len;
      head = head.next;
    }
    return buf;
  };
  Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
  };
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = BufferWriter;
  var Writer = require_writer();
  (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
  var util = require_minimal();
  function BufferWriter() {
    Writer.call(this);
  }
  BufferWriter._configure = function() {
    BufferWriter.alloc = util._Buffer_allocUnsafe;
    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytesBuffer_copy(val, buf, pos) {
      if (val.copy)
        val.copy(buf, pos, 0, val.length);
      else
        for (var i = 0; i < val.length; )
          buf[pos++] = val[i++];
    };
  };
  BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
      value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
      this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
  };
  function writeStringBuffer(val, buf, pos) {
    if (val.length < 40)
      util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
      buf.utf8Write(val, pos);
    else
      buf.write(val, pos);
  }
  BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
      this._push(writeStringBuffer, len, value);
    return this;
  };
  BufferWriter._configure();
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Reader;
  var util = require_minimal();
  var BufferReader;
  var LongBits = util.LongBits;
  var utf8 = util.utf8;
  function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
  }
  function Reader(buffer) {
    this.buf = buffer;
    this.pos = 0;
    this.len = buffer.length;
  }
  var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
    if (buffer instanceof Uint8Array || Array.isArray(buffer))
      return new Reader(buffer);
    throw Error("illegal buffer");
  } : function create_array2(buffer) {
    if (Array.isArray(buffer))
      return new Reader(buffer);
    throw Error("illegal buffer");
  };
  var create = function create2() {
    return util.Buffer ? function create_buffer_setup(buffer) {
      return (Reader.create = function create_buffer(buffer2) {
        return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
      })(buffer);
    } : create_array;
  };
  Reader.create = create();
  Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
  Reader.prototype.uint32 = function read_uint32_setup() {
    var value = 4294967295;
    return function read_uint32() {
      value = (this.buf[this.pos] & 127) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      if ((this.pos += 5) > this.len) {
        this.pos = this.len;
        throw indexOutOfRange(this, 10);
      }
      return value;
    };
  }();
  Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
  };
  Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
  };
  function readLongVarint() {
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) {
      for (; i < 4; ++i) {
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
      i = 0;
    } else {
      for (; i < 3; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
      return bits;
    }
    if (this.len - this.pos > 4) {
      for (; i < 5; ++i) {
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    } else {
      for (; i < 5; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    }
    throw Error("invalid varint encoding");
  }
  Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
  };
  function readFixed32_end(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
  }
  Reader.prototype.fixed32 = function read_fixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
  };
  Reader.prototype.sfixed32 = function read_sfixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
  };
  function readFixed64() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
  }
  Reader.prototype.float = function read_float() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
  };
  Reader.prototype.double = function read_double() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
  };
  Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(), start = this.pos, end = this.pos + length;
    if (end > this.len)
      throw indexOutOfRange(this, length);
    this.pos += length;
    if (Array.isArray(this.buf))
      return this.buf.slice(start, end);
    return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
  };
  Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
  };
  Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
      if (this.pos + length > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
    } else {
      do {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
      } while (this.buf[this.pos++] & 128);
    }
    return this;
  };
  Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      default:
        throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
  };
  Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();
    var fn = util.Long ? "toLong" : "toNumber";
    util.merge(Reader.prototype, {
      int64: function read_int64() {
        return readLongVarint.call(this)[fn](false);
      },
      uint64: function read_uint64() {
        return readLongVarint.call(this)[fn](true);
      },
      sint64: function read_sint64() {
        return readLongVarint.call(this).zzDecode()[fn](false);
      },
      fixed64: function read_fixed64() {
        return readFixed64.call(this)[fn](true);
      },
      sfixed64: function read_sfixed64() {
        return readFixed64.call(this)[fn](false);
      }
    });
  };
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = BufferReader;
  var Reader = require_reader();
  (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
  var util = require_minimal();
  function BufferReader(buffer) {
    Reader.call(this, buffer);
  }
  BufferReader._configure = function() {
    if (util.Buffer)
      BufferReader.prototype._slice = util.Buffer.prototype.slice;
  };
  BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32();
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
  };
  BufferReader._configure();
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Service;
  var util = require_minimal();
  (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
  function Service(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function")
      throw TypeError("rpcImpl must be a function");
    util.EventEmitter.call(this);
    this.rpcImpl = rpcImpl;
    this.requestDelimited = Boolean(requestDelimited);
    this.responseDelimited = Boolean(responseDelimited);
  }
  Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
    if (!request)
      throw TypeError("request must be specified");
    var self2 = this;
    if (!callback)
      return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
    if (!self2.rpcImpl) {
      setTimeout(function() {
        callback(Error("already ended"));
      }, 0);
      return void 0;
    }
    try {
      return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
        if (err) {
          self2.emit("error", err, method);
          return callback(err);
        }
        if (response === null) {
          self2.end(true);
          return void 0;
        }
        if (!(response instanceof responseCtor)) {
          try {
            response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
          } catch (err2) {
            self2.emit("error", err2, method);
            return callback(err2);
          }
        }
        self2.emit("data", response, method);
        return callback(null, response);
      });
    } catch (err) {
      self2.emit("error", err, method);
      setTimeout(function() {
        callback(err);
      }, 0);
      return void 0;
    }
  };
  Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
      if (!endedByRPC)
        this.rpcImpl(null, null, null);
      this.rpcImpl = null;
      this.emit("end").off();
    }
    return this;
  };
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS((exports2) => {
  "use strict";
  var rpc = exports2;
  rpc.Service = require_service();
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {};
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS((exports2) => {
  "use strict";
  var protobuf = exports2;
  protobuf.build = "minimal";
  protobuf.Writer = require_writer();
  protobuf.BufferWriter = require_writer_buffer();
  protobuf.Reader = require_reader();
  protobuf.BufferReader = require_reader_buffer();
  protobuf.util = require_minimal();
  protobuf.rpc = require_rpc();
  protobuf.roots = require_roots();
  protobuf.configure = configure;
  function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
  }
  configure();
});

// node_modules/@protobufjs/codegen/index.js
var require_codegen = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = codegen;
  function codegen(functionParams, functionName) {
    if (typeof functionParams === "string") {
      functionName = functionParams;
      functionParams = void 0;
    }
    var body = [];
    function Codegen(formatStringOrScope) {
      if (typeof formatStringOrScope !== "string") {
        var source = toString();
        if (codegen.verbose)
          console.log("codegen: " + source);
        source = "return " + source;
        if (formatStringOrScope) {
          var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
          while (scopeOffset < scopeKeys.length) {
            scopeParams[scopeOffset] = scopeKeys[scopeOffset];
            scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
          }
          scopeParams[scopeOffset] = source;
          return Function.apply(null, scopeParams).apply(null, scopeValues);
        }
        return Function(source)();
      }
      var formatParams = new Array(arguments.length - 1), formatOffset = 0;
      while (formatOffset < formatParams.length)
        formatParams[formatOffset] = arguments[++formatOffset];
      formatOffset = 0;
      formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
        var value = formatParams[formatOffset++];
        switch ($1) {
          case "d":
          case "f":
            return String(Number(value));
          case "i":
            return String(Math.floor(value));
          case "j":
            return JSON.stringify(value);
          case "s":
            return String(value);
        }
        return "%";
      });
      if (formatOffset !== formatParams.length)
        throw Error("parameter count mismatch");
      body.push(formatStringOrScope);
      return Codegen;
    }
    function toString(functionNameOverride) {
      return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
    }
    Codegen.toString = toString;
    return Codegen;
  }
  codegen.verbose = false;
});

// node_modules/@protobufjs/fetch/index.js
var require_fetch = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = fetch;
  var asPromise = require_aspromise();
  var inquire2 = require_inquire();
  var fs = inquire2("fs");
  function fetch(filename, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else if (!options)
      options = {};
    if (!callback)
      return asPromise(fetch, this, filename, options);
    if (!options.xhr && fs && fs.readFile)
      return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
        return err && typeof XMLHttpRequest !== "undefined" ? fetch.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
      });
    return fetch.xhr(filename, options, callback);
  }
  fetch.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function fetchOnReadyStateChange() {
      if (xhr.readyState !== 4)
        return void 0;
      if (xhr.status !== 0 && xhr.status !== 200)
        return callback(Error("status " + xhr.status));
      if (options.binary) {
        var buffer = xhr.response;
        if (!buffer) {
          buffer = [];
          for (var i = 0; i < xhr.responseText.length; ++i)
            buffer.push(xhr.responseText.charCodeAt(i) & 255);
        }
        return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
      }
      return callback(null, xhr.responseText);
    };
    if (options.binary) {
      if ("overrideMimeType" in xhr)
        xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.responseType = "arraybuffer";
    }
    xhr.open("GET", filename);
    xhr.send();
  };
});

// node_modules/@protobufjs/path/index.js
var require_path = __commonJS((exports2) => {
  "use strict";
  var path = exports2;
  var isAbsolute = path.isAbsolute = function isAbsolute2(path2) {
    return /^(?:\/|\w+:)/.test(path2);
  };
  var normalize = path.normalize = function normalize2(path2) {
    path2 = path2.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
    var parts = path2.split("/"), absolute = isAbsolute(path2), prefix = "";
    if (absolute)
      prefix = parts.shift() + "/";
    for (var i = 0; i < parts.length; ) {
      if (parts[i] === "..") {
        if (i > 0 && parts[i - 1] !== "..")
          parts.splice(--i, 2);
        else if (absolute)
          parts.splice(i, 1);
        else
          ++i;
      } else if (parts[i] === ".")
        parts.splice(i, 1);
      else
        ++i;
    }
    return prefix + parts.join("/");
  };
  path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
      includePath = normalize(includePath);
    if (isAbsolute(includePath))
      return includePath;
    if (!alreadyNormalized)
      originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
  };
});

// node_modules/protobufjs/src/types.js
var require_types = __commonJS((exports2) => {
  "use strict";
  var types = exports2;
  var util = require_util2();
  var s = [
    "double",
    "float",
    "int32",
    "uint32",
    "sint32",
    "fixed32",
    "sfixed32",
    "int64",
    "uint64",
    "sint64",
    "fixed64",
    "sfixed64",
    "bool",
    "string",
    "bytes"
  ];
  function bake(values, offset) {
    var i = 0, o = {};
    offset |= 0;
    while (i < values.length)
      o[s[i + offset]] = values[i++];
    return o;
  }
  types.basic = bake([
    1,
    5,
    0,
    0,
    0,
    5,
    5,
    0,
    0,
    0,
    1,
    1,
    0,
    2,
    2
  ]);
  types.defaults = bake([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    false,
    "",
    util.emptyArray,
    null
  ]);
  types.long = bake([
    0,
    0,
    0,
    1,
    1
  ], 7);
  types.mapKey = bake([
    0,
    0,
    0,
    5,
    5,
    0,
    0,
    0,
    1,
    1,
    0,
    2
  ], 2);
  types.packed = bake([
    1,
    5,
    0,
    0,
    0,
    5,
    5,
    0,
    0,
    0,
    1,
    1,
    0
  ]);
});

// node_modules/protobufjs/src/field.js
var require_field = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Field;
  var ReflectionObject = require_object();
  ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";
  var Enum = require_enum();
  var types = require_types();
  var util = require_util2();
  var Type;
  var ruleRe = /^required|optional|repeated$/;
  Field.fromJSON = function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
  };
  function Field(name, id, type, rule, extend, options, comment) {
    if (util.isObject(rule)) {
      comment = extend;
      options = rule;
      rule = extend = void 0;
    } else if (util.isObject(extend)) {
      comment = options;
      options = extend;
      extend = void 0;
    }
    ReflectionObject.call(this, name, options);
    if (!util.isInteger(id) || id < 0)
      throw TypeError("id must be a non-negative integer");
    if (!util.isString(type))
      throw TypeError("type must be a string");
    if (rule !== void 0 && !ruleRe.test(rule = rule.toString().toLowerCase()))
      throw TypeError("rule must be a string rule");
    if (extend !== void 0 && !util.isString(extend))
      throw TypeError("extend must be a string");
    this.rule = rule && rule !== "optional" ? rule : void 0;
    this.type = type;
    this.id = id;
    this.extend = extend || void 0;
    this.required = rule === "required";
    this.optional = !this.required;
    this.repeated = rule === "repeated";
    this.map = false;
    this.message = null;
    this.partOf = null;
    this.typeDefault = null;
    this.defaultValue = null;
    this.long = util.Long ? types.long[type] !== void 0 : false;
    this.bytes = type === "bytes";
    this.resolvedType = null;
    this.extensionField = null;
    this.declaringField = null;
    this._packed = null;
    this.comment = comment;
  }
  Object.defineProperty(Field.prototype, "packed", {
    get: function() {
      if (this._packed === null)
        this._packed = this.getOption("packed") !== false;
      return this._packed;
    }
  });
  Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (name === "packed")
      this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
  };
  Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "rule",
      this.rule !== "optional" && this.rule || void 0,
      "type",
      this.type,
      "id",
      this.id,
      "extend",
      this.extend,
      "options",
      this.options,
      "comment",
      keepComments ? this.comment : void 0
    ]);
  };
  Field.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    if ((this.typeDefault = types.defaults[this.type]) === void 0) {
      this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
      if (this.resolvedType instanceof Type)
        this.typeDefault = null;
      else
        this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
    }
    if (this.options && this.options["default"] != null) {
      this.typeDefault = this.options["default"];
      if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
        this.typeDefault = this.resolvedType.values[this.typeDefault];
    }
    if (this.options) {
      if (this.options.packed === true || this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof Enum))
        delete this.options.packed;
      if (!Object.keys(this.options).length)
        this.options = void 0;
    }
    if (this.long) {
      this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
      if (Object.freeze)
        Object.freeze(this.typeDefault);
    } else if (this.bytes && typeof this.typeDefault === "string") {
      var buf;
      if (util.base64.test(this.typeDefault))
        util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
      else
        util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
      this.typeDefault = buf;
    }
    if (this.map)
      this.defaultValue = util.emptyObject;
    else if (this.repeated)
      this.defaultValue = util.emptyArray;
    else
      this.defaultValue = this.typeDefault;
    if (this.parent instanceof Type)
      this.parent.ctor.prototype[this.name] = this.defaultValue;
    return ReflectionObject.prototype.resolve.call(this);
  };
  Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
    if (typeof fieldType === "function")
      fieldType = util.decorateType(fieldType).name;
    else if (fieldType && typeof fieldType === "object")
      fieldType = util.decorateEnum(fieldType).name;
    return function fieldDecorator(prototype, fieldName) {
      util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, {default: defaultValue}));
    };
  };
  Field._configure = function configure(Type_) {
    Type = Type_;
  };
});

// node_modules/protobufjs/src/namespace.js
var require_namespace = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Namespace;
  var ReflectionObject = require_object();
  ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";
  var Field = require_field();
  var util = require_util2();
  var Type;
  var Service;
  var Enum;
  Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
  };
  function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
      return void 0;
    var obj = {};
    for (var i = 0; i < array.length; ++i)
      obj[array[i].name] = array[i].toJSON(toJSONOptions);
    return obj;
  }
  Namespace.arrayToJSON = arrayToJSON;
  Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved) {
      for (var i = 0; i < reserved.length; ++i)
        if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
          return true;
    }
    return false;
  };
  Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved) {
      for (var i = 0; i < reserved.length; ++i)
        if (reserved[i] === name)
          return true;
    }
    return false;
  };
  function Namespace(name, options) {
    ReflectionObject.call(this, name, options);
    this.nested = void 0;
    this._nestedArray = null;
  }
  function clearCache(namespace) {
    namespace._nestedArray = null;
    return namespace;
  }
  Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
      return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
  });
  Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util.toObject([
      "options",
      this.options,
      "nested",
      arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
  };
  Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    if (nestedJson) {
      for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
        nested = nestedJson[names[i]];
        ns.add((nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : nested.id !== void 0 ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));
      }
    }
    return this;
  };
  Namespace.prototype.get = function get(name) {
    return this.nested && this.nested[name] || null;
  };
  Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
      return this.nested[name].values;
    throw Error("no such enum: " + name);
  };
  Namespace.prototype.add = function add(object) {
    if (!(object instanceof Field && object.extend !== void 0 || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace))
      throw TypeError("object must be a valid nested object");
    if (!this.nested)
      this.nested = {};
    else {
      var prev = this.get(object.name);
      if (prev) {
        if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
          var nested = prev.nestedArray;
          for (var i = 0; i < nested.length; ++i)
            object.add(nested[i]);
          this.remove(prev);
          if (!this.nested)
            this.nested = {};
          object.setOptions(prev.options, true);
        } else
          throw Error("duplicate name '" + object.name + "' in " + this);
      }
    }
    this.nested[object.name] = object;
    object.onAdd(this);
    return clearCache(this);
  };
  Namespace.prototype.remove = function remove(object) {
    if (!(object instanceof ReflectionObject))
      throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
      throw Error(object + " is not a member of " + this);
    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
      this.nested = void 0;
    object.onRemove(this);
    return clearCache(this);
  };
  Namespace.prototype.define = function define2(path, json) {
    if (util.isString(path))
      path = path.split(".");
    else if (!Array.isArray(path))
      throw TypeError("illegal path");
    if (path && path.length && path[0] === "")
      throw Error("path must be relative");
    var ptr = this;
    while (path.length > 0) {
      var part = path.shift();
      if (ptr.nested && ptr.nested[part]) {
        ptr = ptr.nested[part];
        if (!(ptr instanceof Namespace))
          throw Error("path conflicts with non-namespace objects");
      } else
        ptr.add(ptr = new Namespace(part));
    }
    if (json)
      ptr.addJSON(json);
    return ptr;
  };
  Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
      if (nested[i] instanceof Namespace)
        nested[i++].resolveAll();
      else
        nested[i++].resolve();
    return this.resolve();
  };
  Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {
    if (typeof filterTypes === "boolean") {
      parentAlreadyChecked = filterTypes;
      filterTypes = void 0;
    } else if (filterTypes && !Array.isArray(filterTypes))
      filterTypes = [filterTypes];
    if (util.isString(path) && path.length) {
      if (path === ".")
        return this.root;
      path = path.split(".");
    } else if (!path.length)
      return this;
    if (path[0] === "")
      return this.root.lookup(path.slice(1), filterTypes);
    var found = this.get(path[0]);
    if (found) {
      if (path.length === 1) {
        if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
          return found;
      } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
        return found;
    } else
      for (var i = 0; i < this.nestedArray.length; ++i)
        if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
          return found;
    if (this.parent === null || parentAlreadyChecked)
      return null;
    return this.parent.lookup(path, filterTypes);
  };
  Namespace.prototype.lookupType = function lookupType(path) {
    var found = this.lookup(path, [Type]);
    if (!found)
      throw Error("no such type: " + path);
    return found;
  };
  Namespace.prototype.lookupEnum = function lookupEnum(path) {
    var found = this.lookup(path, [Enum]);
    if (!found)
      throw Error("no such Enum '" + path + "' in " + this);
    return found;
  };
  Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [Type, Enum]);
    if (!found)
      throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
  };
  Namespace.prototype.lookupService = function lookupService(path) {
    var found = this.lookup(path, [Service]);
    if (!found)
      throw Error("no such Service '" + path + "' in " + this);
    return found;
  };
  Namespace._configure = function(Type_, Service_, Enum_) {
    Type = Type_;
    Service = Service_;
    Enum = Enum_;
  };
});

// node_modules/protobufjs/src/oneof.js
var require_oneof = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = OneOf;
  var ReflectionObject = require_object();
  ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
  var Field = require_field();
  var util = require_util2();
  function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
      options = fieldNames;
      fieldNames = void 0;
    }
    ReflectionObject.call(this, name, options);
    if (!(fieldNames === void 0 || Array.isArray(fieldNames)))
      throw TypeError("fieldNames must be an Array");
    this.oneof = fieldNames || [];
    this.fieldsArray = [];
    this.comment = comment;
  }
  OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
  };
  OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "options",
      this.options,
      "oneof",
      this.oneof,
      "comment",
      keepComments ? this.comment : void 0
    ]);
  };
  function addFieldsToParent(oneof) {
    if (oneof.parent) {
      for (var i = 0; i < oneof.fieldsArray.length; ++i)
        if (!oneof.fieldsArray[i].parent)
          oneof.parent.add(oneof.fieldsArray[i]);
    }
  }
  OneOf.prototype.add = function add(field) {
    if (!(field instanceof Field))
      throw TypeError("field must be a Field");
    if (field.parent && field.parent !== this.parent)
      field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this;
    addFieldsToParent(this);
    return this;
  };
  OneOf.prototype.remove = function remove(field) {
    if (!(field instanceof Field))
      throw TypeError("field must be a Field");
    var index = this.fieldsArray.indexOf(field);
    if (index < 0)
      throw Error(field + " is not a member of " + this);
    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);
    if (index > -1)
      this.oneof.splice(index, 1);
    field.partOf = null;
    return this;
  };
  OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self2 = this;
    for (var i = 0; i < this.oneof.length; ++i) {
      var field = parent.get(this.oneof[i]);
      if (field && !field.partOf) {
        field.partOf = self2;
        self2.fieldsArray.push(field);
      }
    }
    addFieldsToParent(this);
  };
  OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field; i < this.fieldsArray.length; ++i)
      if ((field = this.fieldsArray[i]).parent)
        field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
  };
  OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length), index = 0;
    while (index < arguments.length)
      fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
      util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
      Object.defineProperty(prototype, oneofName, {
        get: util.oneOfGetter(fieldNames),
        set: util.oneOfSetter(fieldNames)
      });
    };
  };
});

// node_modules/protobufjs/src/mapfield.js
var require_mapfield = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = MapField;
  var Field = require_field();
  ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";
  var types = require_types();
  var util = require_util2();
  function MapField(name, id, keyType, type, options, comment) {
    Field.call(this, name, id, type, void 0, void 0, options, comment);
    if (!util.isString(keyType))
      throw TypeError("keyType must be a string");
    this.keyType = keyType;
    this.resolvedKeyType = null;
    this.map = true;
  }
  MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
  };
  MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "keyType",
      this.keyType,
      "type",
      this.type,
      "id",
      this.id,
      "extend",
      this.extend,
      "options",
      this.options,
      "comment",
      keepComments ? this.comment : void 0
    ]);
  };
  MapField.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    if (types.mapKey[this.keyType] === void 0)
      throw Error("invalid key type: " + this.keyType);
    return Field.prototype.resolve.call(this);
  };
  MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
    if (typeof fieldValueType === "function")
      fieldValueType = util.decorateType(fieldValueType).name;
    else if (fieldValueType && typeof fieldValueType === "object")
      fieldValueType = util.decorateEnum(fieldValueType).name;
    return function mapFieldDecorator(prototype, fieldName) {
      util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
  };
});

// node_modules/protobufjs/src/method.js
var require_method = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Method;
  var ReflectionObject = require_object();
  ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
  var util = require_util2();
  function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {
    if (util.isObject(requestStream)) {
      options = requestStream;
      requestStream = responseStream = void 0;
    } else if (util.isObject(responseStream)) {
      options = responseStream;
      responseStream = void 0;
    }
    if (!(type === void 0 || util.isString(type)))
      throw TypeError("type must be a string");
    if (!util.isString(requestType))
      throw TypeError("requestType must be a string");
    if (!util.isString(responseType))
      throw TypeError("responseType must be a string");
    ReflectionObject.call(this, name, options);
    this.type = type || "rpc";
    this.requestType = requestType;
    this.requestStream = requestStream ? true : void 0;
    this.responseType = responseType;
    this.responseStream = responseStream ? true : void 0;
    this.resolvedRequestType = null;
    this.resolvedResponseType = null;
    this.comment = comment;
    this.parsedOptions = parsedOptions;
  }
  Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
  };
  Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "type",
      this.type !== "rpc" && this.type || void 0,
      "requestType",
      this.requestType,
      "requestStream",
      this.requestStream,
      "responseType",
      this.responseType,
      "responseStream",
      this.responseStream,
      "options",
      this.options,
      "comment",
      keepComments ? this.comment : void 0,
      "parsedOptions",
      this.parsedOptions
    ]);
  };
  Method.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);
    return ReflectionObject.prototype.resolve.call(this);
  };
});

// node_modules/protobufjs/src/service.js
var require_service2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Service;
  var Namespace = require_namespace();
  ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";
  var Method = require_method();
  var util = require_util2();
  var rpc = require_rpc();
  function Service(name, options) {
    Namespace.call(this, name, options);
    this.methods = {};
    this._methodsArray = null;
  }
  Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    if (json.methods)
      for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
        service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
      service.addJSON(json.nested);
    service.comment = json.comment;
    return service;
  };
  Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "options",
      inherited && inherited.options || void 0,
      "methods",
      Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || {},
      "nested",
      inherited && inherited.nested || void 0,
      "comment",
      keepComments ? this.comment : void 0
    ]);
  };
  Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
      return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
  });
  function clearCache(service) {
    service._methodsArray = null;
    return service;
  }
  Service.prototype.get = function get(name) {
    return this.methods[name] || Namespace.prototype.get.call(this, name);
  };
  Service.prototype.resolveAll = function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i < methods.length; ++i)
      methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
  };
  Service.prototype.add = function add(object) {
    if (this.get(object.name))
      throw Error("duplicate name '" + object.name + "' in " + this);
    if (object instanceof Method) {
      this.methods[object.name] = object;
      object.parent = this;
      return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
  };
  Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {
      if (this.methods[object.name] !== object)
        throw Error(object + " is not a member of " + this);
      delete this.methods[object.name];
      object.parent = null;
      return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
  };
  Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method; i < this.methodsArray.length; ++i) {
      var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
      rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
        m: method,
        q: method.resolvedRequestType.ctor,
        s: method.resolvedResponseType.ctor
      });
    }
    return rpcService;
  };
});

// node_modules/protobufjs/src/message.js
var require_message = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Message;
  var util = require_minimal();
  function Message(properties) {
    if (properties)
      for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
        this[keys[i]] = properties[keys[i]];
  }
  Message.create = function create(properties) {
    return this.$type.create(properties);
  };
  Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
  };
  Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
  };
  Message.decode = function decode(reader) {
    return this.$type.decode(reader);
  };
  Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
  };
  Message.verify = function verify(message) {
    return this.$type.verify(message);
  };
  Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
  };
  Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
  };
  Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
  };
});

// node_modules/protobufjs/src/decoder.js
var require_decoder = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = decoder;
  var Enum = require_enum();
  var types = require_types();
  var util = require_util2();
  function missing(field) {
    return "missing required '" + field.name + "'";
  }
  function decoder(mtype) {
    var gen = util.codegen(["r", "l"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field2) {
      return field2.map;
    }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
    if (mtype.group)
      gen("if((t&7)===4)")("break");
    gen("switch(t>>>3){");
    var i = 0;
    for (; i < mtype.fieldsArray.length; ++i) {
      var field = mtype._fieldsArray[i].resolve(), type = field.resolvedType instanceof Enum ? "int32" : field.type, ref = "m" + util.safeProp(field.name);
      gen("case %i:", field.id);
      if (field.map) {
        gen("if(%s===util.emptyObject)", ref)("%s={}", ref)("var c2 = r.uint32()+r.pos");
        if (types.defaults[field.keyType] !== void 0)
          gen("k=%j", types.defaults[field.keyType]);
        else
          gen("k=null");
        if (types.defaults[type] !== void 0)
          gen("value=%j", types.defaults[type]);
        else
          gen("value=null");
        gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field.keyType)("case 2:");
        if (types.basic[type] === void 0)
          gen("value=types[%i].decode(r,r.uint32())", i);
        else
          gen("value=r.%s()", type);
        gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
        if (types.long[field.keyType] !== void 0)
          gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref);
        else
          gen("%s[k]=value", ref);
      } else if (field.repeated) {
        gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);
        if (types.packed[type] !== void 0)
          gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else");
        if (types.basic[type] === void 0)
          gen(field.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
        else
          gen("%s.push(r.%s())", ref, type);
      } else if (types.basic[type] === void 0)
        gen(field.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref, i);
      else
        gen("%s=r.%s()", ref, type);
      gen("break");
    }
    gen("default:")("r.skipType(t&7)")("break")("}")("}");
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
      var rfield = mtype._fieldsArray[i];
      if (rfield.required)
        gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }
    return gen("return m");
  }
});

// node_modules/protobufjs/src/verifier.js
var require_verifier = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = verifier;
  var Enum = require_enum();
  var util = require_util2();
  function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
  }
  function genVerifyValue(gen, field, fieldIndex, ref) {
    if (field.resolvedType) {
      if (field.resolvedType instanceof Enum) {
        gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));
        for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j)
          gen("case %i:", field.resolvedType.values[keys[j]]);
        gen("break")("}");
      } else {
        gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
      }
    } else {
      switch (field.type) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
          break;
        case "float":
        case "double":
          gen('if(typeof %s!=="number")', ref)("return%j", invalid(field, "number"));
          break;
        case "bool":
          gen('if(typeof %s!=="boolean")', ref)("return%j", invalid(field, "boolean"));
          break;
        case "string":
          gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
          break;
        case "bytes":
          gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref, ref, ref)("return%j", invalid(field, "buffer"));
          break;
      }
    }
    return gen;
  }
  function genVerifyKey(gen, field, ref) {
    switch (field.keyType) {
      case "int32":
      case "uint32":
      case "sint32":
      case "fixed32":
      case "sfixed32":
        gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
        break;
      case "int64":
      case "uint64":
      case "sint64":
      case "fixed64":
      case "sfixed64":
        gen("if(!util.key64Re.test(%s))", ref)("return%j", invalid(field, "integer|Long key"));
        break;
      case "bool":
        gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
        break;
    }
    return gen;
  }
  function verifier(mtype) {
    var gen = util.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
    var oneofs = mtype.oneofsArray, seenFirstField = {};
    if (oneofs.length)
      gen("var p={}");
    for (var i = 0; i < mtype.fieldsArray.length; ++i) {
      var field = mtype._fieldsArray[i].resolve(), ref = "m" + util.safeProp(field.name);
      if (field.optional)
        gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name);
      if (field.map) {
        gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
        genVerifyKey(gen, field, "k[i]");
        genVerifyValue(gen, field, i, ref + "[k[i]]")("}");
      } else if (field.repeated) {
        gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
        genVerifyValue(gen, field, i, ref + "[i]")("}");
      } else {
        if (field.partOf) {
          var oneofProp = util.safeProp(field.partOf.name);
          if (seenFirstField[field.partOf.name] === 1)
            gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
          seenFirstField[field.partOf.name] = 1;
          gen("p%s=1", oneofProp);
        }
        genVerifyValue(gen, field, i, ref);
      }
      if (field.optional)
        gen("}");
    }
    return gen("return null");
  }
});

// node_modules/protobufjs/src/converter.js
var require_converter = __commonJS((exports2) => {
  "use strict";
  var converter = exports2;
  var Enum = require_enum();
  var util = require_util2();
  function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    if (field.resolvedType) {
      if (field.resolvedType instanceof Enum) {
        gen("switch(d%s){", prop);
        for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
          if (field.repeated && values[keys[i]] === field.typeDefault)
            gen("default:");
          gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
        }
        gen("}");
      } else
        gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
      var isUnsigned = false;
      switch (field.type) {
        case "double":
        case "float":
          gen("m%s=Number(d%s)", prop, prop);
          break;
        case "uint32":
        case "fixed32":
          gen("m%s=d%s>>>0", prop, prop);
          break;
        case "int32":
        case "sint32":
        case "sfixed32":
          gen("m%s=d%s|0", prop, prop);
          break;
        case "uint64":
          isUnsigned = true;
        case "int64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
          break;
        case "bytes":
          gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length)", prop)("m%s=d%s", prop, prop);
          break;
        case "string":
          gen("m%s=String(d%s)", prop, prop);
          break;
        case "bool":
          gen("m%s=Boolean(d%s)", prop, prop);
          break;
      }
    }
    return gen;
  }
  converter.fromObject = function fromObject(mtype) {
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
    if (!fields.length)
      return gen("return new this.ctor");
    gen("var m=new this.ctor");
    for (var i = 0; i < fields.length; ++i) {
      var field = fields[i].resolve(), prop = util.safeProp(field.name);
      if (field.map) {
        gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
        genValuePartial_fromObject(gen, field, i, prop + "[ks[i]]")("}")("}");
      } else if (field.repeated) {
        gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
        genValuePartial_fromObject(gen, field, i, prop + "[i]")("}")("}");
      } else {
        if (!(field.resolvedType instanceof Enum))
          gen("if(d%s!=null){", prop);
        genValuePartial_fromObject(gen, field, i, prop);
        if (!(field.resolvedType instanceof Enum))
          gen("}");
      }
    }
    return gen("return m");
  };
  function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    if (field.resolvedType) {
      if (field.resolvedType instanceof Enum)
        gen("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);
      else
        gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
      var isUnsigned = false;
      switch (field.type) {
        case "double":
        case "float":
          gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
          break;
        case "uint64":
          isUnsigned = true;
        case "int64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
          break;
        case "bytes":
          gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
          break;
        default:
          gen("d%s=m%s", prop, prop);
          break;
      }
    }
    return gen;
  }
  converter.toObject = function toObject(mtype) {
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
      return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
    var repeatedFields = [], mapFields = [], normalFields = [], i = 0;
    for (; i < fields.length; ++i)
      if (!fields[i].partOf)
        (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
    if (repeatedFields.length) {
      gen("if(o.arrays||o.defaults){");
      for (i = 0; i < repeatedFields.length; ++i)
        gen("d%s=[]", util.safeProp(repeatedFields[i].name));
      gen("}");
    }
    if (mapFields.length) {
      gen("if(o.objects||o.defaults){");
      for (i = 0; i < mapFields.length; ++i)
        gen("d%s={}", util.safeProp(mapFields[i].name));
      gen("}");
    }
    if (normalFields.length) {
      gen("if(o.defaults){");
      for (i = 0; i < normalFields.length; ++i) {
        var field = normalFields[i], prop = util.safeProp(field.name);
        if (field.resolvedType instanceof Enum)
          gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
        else if (field.long)
          gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
        else if (field.bytes) {
          var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
          gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
        } else
          gen("d%s=%j", prop, field.typeDefault);
      }
      gen("}");
    }
    var hasKs2 = false;
    for (i = 0; i < fields.length; ++i) {
      var field = fields[i], index = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);
      if (field.map) {
        if (!hasKs2) {
          hasKs2 = true;
          gen("var ks2");
        }
        gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
        genValuePartial_toObject(gen, field, index, prop + "[ks2[j]]")("}");
      } else if (field.repeated) {
        gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
        genValuePartial_toObject(gen, field, index, prop + "[j]")("}");
      } else {
        gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name);
        genValuePartial_toObject(gen, field, index, prop);
        if (field.partOf)
          gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
      }
      gen("}");
    }
    return gen("return d");
  };
});

// node_modules/protobufjs/src/wrappers.js
var require_wrappers = __commonJS((exports2) => {
  "use strict";
  var wrappers = exports2;
  var Message = require_message();
  wrappers[".google.protobuf.Any"] = {
    fromObject: function(object) {
      if (object && object["@type"]) {
        var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
        var type = this.lookup(name);
        if (type) {
          var type_url = object["@type"].charAt(0) === "." ? object["@type"].substr(1) : object["@type"];
          if (type_url.indexOf("/") === -1) {
            type_url = "/" + type_url;
          }
          return this.create({
            type_url,
            value: type.encode(type.fromObject(object)).finish()
          });
        }
      }
      return this.fromObject(object);
    },
    toObject: function(message, options) {
      var googleApi = "type.googleapis.com/";
      var prefix = "";
      var name = "";
      if (options && options.json && message.type_url && message.value) {
        name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
        prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
        var type = this.lookup(name);
        if (type)
          message = type.decode(message.value);
      }
      if (!(message instanceof this.ctor) && message instanceof Message) {
        var object = message.$type.toObject(message, options);
        var messageName = message.$type.fullName[0] === "." ? message.$type.fullName.substr(1) : message.$type.fullName;
        if (prefix === "") {
          prefix = googleApi;
        }
        name = prefix + messageName;
        object["@type"] = name;
        return object;
      }
      return this.toObject(message, options);
    }
  };
});

// node_modules/protobufjs/src/type.js
var require_type = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Type;
  var Namespace = require_namespace();
  ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";
  var Enum = require_enum();
  var OneOf = require_oneof();
  var Field = require_field();
  var MapField = require_mapfield();
  var Service = require_service2();
  var Message = require_message();
  var Reader = require_reader();
  var Writer = require_writer();
  var util = require_util2();
  var encoder = require_encoder();
  var decoder = require_decoder();
  var verifier = require_verifier();
  var converter = require_converter();
  var wrappers = require_wrappers();
  function Type(name, options) {
    Namespace.call(this, name, options);
    this.fields = {};
    this.oneofs = void 0;
    this.extensions = void 0;
    this.reserved = void 0;
    this.group = void 0;
    this._fieldsById = null;
    this._fieldsArray = null;
    this._oneofsArray = null;
    this._ctor = null;
  }
  Object.defineProperties(Type.prototype, {
    fieldsById: {
      get: function() {
        if (this._fieldsById)
          return this._fieldsById;
        this._fieldsById = {};
        for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
          var field = this.fields[names[i]], id = field.id;
          if (this._fieldsById[id])
            throw Error("duplicate id " + id + " in " + this);
          this._fieldsById[id] = field;
        }
        return this._fieldsById;
      }
    },
    fieldsArray: {
      get: function() {
        return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
      }
    },
    oneofsArray: {
      get: function() {
        return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
      }
    },
    ctor: {
      get: function() {
        return this._ctor || (this.ctor = Type.generateConstructor(this)());
      },
      set: function(ctor) {
        var prototype = ctor.prototype;
        if (!(prototype instanceof Message)) {
          (ctor.prototype = new Message()).constructor = ctor;
          util.merge(ctor.prototype, prototype);
        }
        ctor.$type = ctor.prototype.$type = this;
        util.merge(ctor, Message, true);
        this._ctor = ctor;
        var i = 0;
        for (; i < this.fieldsArray.length; ++i)
          this._fieldsArray[i].resolve();
        var ctorProperties = {};
        for (i = 0; i < this.oneofsArray.length; ++i)
          ctorProperties[this._oneofsArray[i].resolve().name] = {
            get: util.oneOfGetter(this._oneofsArray[i].oneof),
            set: util.oneOfSetter(this._oneofsArray[i].oneof)
          };
        if (i)
          Object.defineProperties(ctor.prototype, ctorProperties);
      }
    }
  });
  Type.generateConstructor = function generateConstructor(mtype) {
    var gen = util.codegen(["p"], mtype.name);
    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
      if ((field = mtype._fieldsArray[i]).map)
        gen("this%s={}", util.safeProp(field.name));
      else if (field.repeated)
        gen("this%s=[]", util.safeProp(field.name));
    return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
  };
  function clearCache(type) {
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
  }
  Type.fromJSON = function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields), i = 0;
    for (; i < names.length; ++i)
      type.add((typeof json.fields[names[i]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]]));
    if (json.oneofs)
      for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
        type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
      for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
        var nested = json.nested[names[i]];
        type.add((nested.id !== void 0 ? Field.fromJSON : nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : Namespace.fromJSON)(names[i], nested));
      }
    if (json.extensions && json.extensions.length)
      type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
      type.reserved = json.reserved;
    if (json.group)
      type.group = true;
    if (json.comment)
      type.comment = json.comment;
    return type;
  };
  Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "options",
      inherited && inherited.options || void 0,
      "oneofs",
      Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
      "fields",
      Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {
        return !obj.declaringField;
      }), toJSONOptions) || {},
      "extensions",
      this.extensions && this.extensions.length ? this.extensions : void 0,
      "reserved",
      this.reserved && this.reserved.length ? this.reserved : void 0,
      "group",
      this.group || void 0,
      "nested",
      inherited && inherited.nested || void 0,
      "comment",
      keepComments ? this.comment : void 0
    ]);
  };
  Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
      fields[i++].resolve();
    var oneofs = this.oneofsArray;
    i = 0;
    while (i < oneofs.length)
      oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
  };
  Type.prototype.get = function get(name) {
    return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;
  };
  Type.prototype.add = function add(object) {
    if (this.get(object.name))
      throw Error("duplicate name '" + object.name + "' in " + this);
    if (object instanceof Field && object.extend === void 0) {
      if (this._fieldsById ? this._fieldsById[object.id] : this.fieldsById[object.id])
        throw Error("duplicate id " + object.id + " in " + this);
      if (this.isReservedId(object.id))
        throw Error("id " + object.id + " is reserved in " + this);
      if (this.isReservedName(object.name))
        throw Error("name '" + object.name + "' is reserved in " + this);
      if (object.parent)
        object.parent.remove(object);
      this.fields[object.name] = object;
      object.message = this;
      object.onAdd(this);
      return clearCache(this);
    }
    if (object instanceof OneOf) {
      if (!this.oneofs)
        this.oneofs = {};
      this.oneofs[object.name] = object;
      object.onAdd(this);
      return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
  };
  Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === void 0) {
      if (!this.fields || this.fields[object.name] !== object)
        throw Error(object + " is not a member of " + this);
      delete this.fields[object.name];
      object.parent = null;
      object.onRemove(this);
      return clearCache(this);
    }
    if (object instanceof OneOf) {
      if (!this.oneofs || this.oneofs[object.name] !== object)
        throw Error(object + " is not a member of " + this);
      delete this.oneofs[object.name];
      object.parent = null;
      object.onRemove(this);
      return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
  };
  Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
  };
  Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
  };
  Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
  };
  Type.prototype.setup = function setup() {
    var fullName = this.fullName, types = [];
    for (var i = 0; i < this.fieldsArray.length; ++i)
      types.push(this._fieldsArray[i].resolve().resolvedType);
    this.encode = encoder(this)({
      Writer,
      types,
      util
    });
    this.decode = decoder(this)({
      Reader,
      types,
      util
    });
    this.verify = verifier(this)({
      types,
      util
    });
    this.fromObject = converter.fromObject(this)({
      types,
      util
    });
    this.toObject = converter.toObject(this)({
      types,
      util
    });
    var wrapper = wrappers[fullName];
    if (wrapper) {
      var originalThis = Object.create(this);
      originalThis.fromObject = this.fromObject;
      this.fromObject = wrapper.fromObject.bind(originalThis);
      originalThis.toObject = this.toObject;
      this.toObject = wrapper.toObject.bind(originalThis);
    }
    return this;
  };
  Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer);
  };
  Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
  };
  Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length);
  };
  Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
      reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
  };
  Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message);
  };
  Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
  };
  Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
  };
  Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
      util.decorateType(target, typeName);
    };
  };
});

// node_modules/protobufjs/src/root.js
var require_root = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Root;
  var Namespace = require_namespace();
  ((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";
  var Field = require_field();
  var Enum = require_enum();
  var OneOf = require_oneof();
  var util = require_util2();
  var Type;
  var parse;
  var common;
  function Root(options) {
    Namespace.call(this, "", options);
    this.deferred = [];
    this.files = [];
  }
  Root.fromJSON = function fromJSON(json, root) {
    if (!root)
      root = new Root();
    if (json.options)
      root.setOptions(json.options);
    return root.addJSON(json.nested);
  };
  Root.prototype.resolvePath = util.path.resolve;
  Root.prototype.fetch = util.fetch;
  function SYNC() {
  }
  Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = void 0;
    }
    var self2 = this;
    if (!callback)
      return util.asPromise(load, self2, filename, options);
    var sync = callback === SYNC;
    function finish(err, root) {
      if (!callback)
        return;
      var cb = callback;
      callback = null;
      if (sync)
        throw err;
      cb(err, root);
    }
    function getBundledFileName(filename2) {
      var idx = filename2.lastIndexOf("google/protobuf/");
      if (idx > -1) {
        var altname = filename2.substring(idx);
        if (altname in common)
          return altname;
      }
      return null;
    }
    function process2(filename2, source) {
      try {
        if (util.isString(source) && source.charAt(0) === "{")
          source = JSON.parse(source);
        if (!util.isString(source))
          self2.setOptions(source.options).addJSON(source.nested);
        else {
          parse.filename = filename2;
          var parsed = parse(source, self2, options), resolved2, i2 = 0;
          if (parsed.imports) {
            for (; i2 < parsed.imports.length; ++i2)
              if (resolved2 = getBundledFileName(parsed.imports[i2]) || self2.resolvePath(filename2, parsed.imports[i2]))
                fetch(resolved2);
          }
          if (parsed.weakImports) {
            for (i2 = 0; i2 < parsed.weakImports.length; ++i2)
              if (resolved2 = getBundledFileName(parsed.weakImports[i2]) || self2.resolvePath(filename2, parsed.weakImports[i2]))
                fetch(resolved2, true);
          }
        }
      } catch (err) {
        finish(err);
      }
      if (!sync && !queued)
        finish(null, self2);
    }
    function fetch(filename2, weak) {
      if (self2.files.indexOf(filename2) > -1)
        return;
      self2.files.push(filename2);
      if (filename2 in common) {
        if (sync)
          process2(filename2, common[filename2]);
        else {
          ++queued;
          setTimeout(function() {
            --queued;
            process2(filename2, common[filename2]);
          });
        }
        return;
      }
      if (sync) {
        var source;
        try {
          source = util.fs.readFileSync(filename2).toString("utf8");
        } catch (err) {
          if (!weak)
            finish(err);
          return;
        }
        process2(filename2, source);
      } else {
        ++queued;
        self2.fetch(filename2, function(err, source2) {
          --queued;
          if (!callback)
            return;
          if (err) {
            if (!weak)
              finish(err);
            else if (!queued)
              finish(null, self2);
            return;
          }
          process2(filename2, source2);
        });
      }
    }
    var queued = 0;
    if (util.isString(filename))
      filename = [filename];
    for (var i = 0, resolved; i < filename.length; ++i)
      if (resolved = self2.resolvePath("", filename[i]))
        fetch(resolved);
    if (sync)
      return self2;
    if (!queued)
      finish(null, self2);
    return void 0;
  };
  Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
      throw Error("not supported");
    return this.load(filename, options, SYNC);
  };
  Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
      throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
        return "'extend " + field.extend + "' in " + field.parent.fullName;
      }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
  };
  var exposeRe = /^[A-Z]/;
  function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
      var sisterField = new Field(field.fullName, field.id, field.type, field.rule, void 0, field.options);
      sisterField.declaringField = field;
      field.extensionField = sisterField;
      extendedType.add(sisterField);
      return true;
    }
    return false;
  }
  Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {
      if (object.extend !== void 0 && !object.extensionField) {
        if (!tryHandleExtension(this, object))
          this.deferred.push(object);
      }
    } else if (object instanceof Enum) {
      if (exposeRe.test(object.name))
        object.parent[object.name] = object.values;
    } else if (!(object instanceof OneOf)) {
      if (object instanceof Type)
        for (var i = 0; i < this.deferred.length; )
          if (tryHandleExtension(this, this.deferred[i]))
            this.deferred.splice(i, 1);
          else
            ++i;
      for (var j = 0; j < object.nestedArray.length; ++j)
        this._handleAdd(object._nestedArray[j]);
      if (exposeRe.test(object.name))
        object.parent[object.name] = object;
    }
  };
  Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {
      if (object.extend !== void 0) {
        if (object.extensionField) {
          object.extensionField.parent.remove(object.extensionField);
          object.extensionField = null;
        } else {
          var index = this.deferred.indexOf(object);
          if (index > -1)
            this.deferred.splice(index, 1);
        }
      }
    } else if (object instanceof Enum) {
      if (exposeRe.test(object.name))
        delete object.parent[object.name];
    } else if (object instanceof Namespace) {
      for (var i = 0; i < object.nestedArray.length; ++i)
        this._handleRemove(object._nestedArray[i]);
      if (exposeRe.test(object.name))
        delete object.parent[object.name];
    }
  };
  Root._configure = function(Type_, parse_, common_) {
    Type = Type_;
    parse = parse_;
    common = common_;
  };
});

// node_modules/protobufjs/src/util.js
var require_util2 = __commonJS((exports2, module2) => {
  "use strict";
  var util = module2.exports = require_minimal();
  var roots = require_roots();
  var Type;
  var Enum;
  util.codegen = require_codegen();
  util.fetch = require_fetch();
  util.path = require_path();
  util.fs = util.inquire("fs");
  util.toArray = function toArray(object) {
    if (object) {
      var keys = Object.keys(object), array = new Array(keys.length), index = 0;
      while (index < keys.length)
        array[index] = object[keys[index++]];
      return array;
    }
    return [];
  };
  util.toObject = function toObject(array) {
    var object = {}, index = 0;
    while (index < array.length) {
      var key = array[index++], val = array[index++];
      if (val !== void 0)
        object[key] = val;
    }
    return object;
  };
  var safePropBackslashRe = /\\/g;
  var safePropQuoteRe = /"/g;
  util.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
  };
  util.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
      return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, '\\"') + '"]';
    return "." + prop;
  };
  util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
  };
  var camelCaseRe = /_([a-z])/g;
  util.camelCase = function camelCase(str) {
    return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
      return $1.toUpperCase();
    });
  };
  util.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
  };
  util.decorateType = function decorateType(ctor, typeName) {
    if (ctor.$type) {
      if (typeName && ctor.$type.name !== typeName) {
        util.decorateRoot.remove(ctor.$type);
        ctor.$type.name = typeName;
        util.decorateRoot.add(ctor.$type);
      }
      return ctor.$type;
    }
    if (!Type)
      Type = require_type();
    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor;
    Object.defineProperty(ctor, "$type", {value: type, enumerable: false});
    Object.defineProperty(ctor.prototype, "$type", {value: type, enumerable: false});
    return type;
  };
  var decorateEnumIndex = 0;
  util.decorateEnum = function decorateEnum(object) {
    if (object.$type)
      return object.$type;
    if (!Enum)
      Enum = require_enum();
    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", {value: enm, enumerable: false});
    return enm;
  };
  util.setProperty = function setProperty(dst, path, value) {
    function setProp(dst2, path2, value2) {
      var part = path2.shift();
      if (path2.length > 0) {
        dst2[part] = setProp(dst2[part] || {}, path2, value2);
      } else {
        var prevValue = dst2[part];
        if (prevValue)
          value2 = [].concat(prevValue).concat(value2);
        dst2[part] = value2;
      }
      return dst2;
    }
    if (typeof dst !== "object")
      throw TypeError("dst must be an object");
    if (!path)
      throw TypeError("path must be specified");
    path = path.split(".");
    return setProp(dst, path, value);
  };
  Object.defineProperty(util, "decorateRoot", {
    get: function() {
      return roots["decorated"] || (roots["decorated"] = new (require_root())());
    }
  });
});

// node_modules/protobufjs/src/object.js
var require_object = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = ReflectionObject;
  ReflectionObject.className = "ReflectionObject";
  var util = require_util2();
  var Root;
  function ReflectionObject(name, options) {
    if (!util.isString(name))
      throw TypeError("name must be a string");
    if (options && !util.isObject(options))
      throw TypeError("options must be an object");
    this.options = options;
    this.parsedOptions = null;
    this.name = name;
    this.parent = null;
    this.resolved = false;
    this.comment = null;
    this.filename = null;
  }
  Object.defineProperties(ReflectionObject.prototype, {
    root: {
      get: function() {
        var ptr = this;
        while (ptr.parent !== null)
          ptr = ptr.parent;
        return ptr;
      }
    },
    fullName: {
      get: function() {
        var path = [this.name], ptr = this.parent;
        while (ptr) {
          path.unshift(ptr.name);
          ptr = ptr.parent;
        }
        return path.join(".");
      }
    }
  });
  ReflectionObject.prototype.toJSON = function toJSON() {
    throw Error();
  };
  ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
      this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
      root._handleAdd(this);
  };
  ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
      root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
  };
  ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
      return this;
    if (this.root instanceof Root)
      this.resolved = true;
    return this;
  };
  ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
      return this.options[name];
    return void 0;
  };
  ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === void 0)
      (this.options || (this.options = {}))[name] = value;
    return this;
  };
  ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
    if (!this.parsedOptions) {
      this.parsedOptions = [];
    }
    var parsedOptions = this.parsedOptions;
    if (propName) {
      var opt = parsedOptions.find(function(opt2) {
        return Object.prototype.hasOwnProperty.call(opt2, name);
      });
      if (opt) {
        var newValue = opt[name];
        util.setProperty(newValue, propName, value);
      } else {
        opt = {};
        opt[name] = util.setProperty({}, propName, value);
        parsedOptions.push(opt);
      }
    } else {
      var newOpt = {};
      newOpt[name] = value;
      parsedOptions.push(newOpt);
    }
    return this;
  };
  ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
      for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
        this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
  };
  ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className, fullName = this.fullName;
    if (fullName.length)
      return className + " " + fullName;
    return className;
  };
  ReflectionObject._configure = function(Root_) {
    Root = Root_;
  };
});

// node_modules/protobufjs/src/enum.js
var require_enum = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Enum;
  var ReflectionObject = require_object();
  ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
  var Namespace = require_namespace();
  var util = require_util2();
  function Enum(name, values, options, comment, comments) {
    ReflectionObject.call(this, name, options);
    if (values && typeof values !== "object")
      throw TypeError("values must be an object");
    this.valuesById = {};
    this.values = Object.create(this.valuesById);
    this.comment = comment;
    this.comments = comments || {};
    this.reserved = void 0;
    if (values) {
      for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
        if (typeof values[keys[i]] === "number")
          this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
    }
  }
  Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    return enm;
  };
  Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
      "options",
      this.options,
      "values",
      this.values,
      "reserved",
      this.reserved && this.reserved.length ? this.reserved : void 0,
      "comment",
      keepComments ? this.comment : void 0,
      "comments",
      keepComments ? this.comments : void 0
    ]);
  };
  Enum.prototype.add = function add(name, id, comment) {
    if (!util.isString(name))
      throw TypeError("name must be a string");
    if (!util.isInteger(id))
      throw TypeError("id must be an integer");
    if (this.values[name] !== void 0)
      throw Error("duplicate name '" + name + "' in " + this);
    if (this.isReservedId(id))
      throw Error("id " + id + " is reserved in " + this);
    if (this.isReservedName(name))
      throw Error("name '" + name + "' is reserved in " + this);
    if (this.valuesById[id] !== void 0) {
      if (!(this.options && this.options.allow_alias))
        throw Error("duplicate id " + id + " in " + this);
      this.values[name] = id;
    } else
      this.valuesById[this.values[name] = id] = name;
    this.comments[name] = comment || null;
    return this;
  };
  Enum.prototype.remove = function remove(name) {
    if (!util.isString(name))
      throw TypeError("name must be a string");
    var val = this.values[name];
    if (val == null)
      throw Error("name '" + name + "' does not exist in " + this);
    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];
    return this;
  };
  Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
  };
  Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
  };
});

// node_modules/protobufjs/src/encoder.js
var require_encoder = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = encoder;
  var Enum = require_enum();
  var types = require_types();
  var util = require_util2();
  function genTypePartial(gen, field, fieldIndex, ref) {
    return field.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
  }
  function encoder(mtype) {
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
    var i, ref;
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    for (var i = 0; i < fields.length; ++i) {
      var field = fields[i].resolve(), index = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? "int32" : field.type, wireType = types.basic[type];
      ref = "m" + util.safeProp(field.name);
      if (field.map) {
        gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
        if (wireType === void 0)
          gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref);
        else
          gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
        gen("}")("}");
      } else if (field.repeated) {
        gen("if(%s!=null&&%s.length){", ref, ref);
        if (field.packed && types.packed[type] !== void 0) {
          gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()");
        } else {
          gen("for(var i=0;i<%s.length;++i)", ref);
          if (wireType === void 0)
            genTypePartial(gen, field, index, ref + "[i]");
          else
            gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
        }
        gen("}");
      } else {
        if (field.optional)
          gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name);
        if (wireType === void 0)
          genTypePartial(gen, field, index, ref);
        else
          gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
      }
    }
    return gen("return w");
  }
});

// node_modules/protobufjs/src/index-light.js
var require_index_light = __commonJS((exports2, module2) => {
  "use strict";
  var protobuf = module2.exports = require_index_minimal();
  protobuf.build = "light";
  function load(filename, root, callback) {
    if (typeof root === "function") {
      callback = root;
      root = new protobuf.Root();
    } else if (!root)
      root = new protobuf.Root();
    return root.load(filename, callback);
  }
  protobuf.load = load;
  function loadSync(filename, root) {
    if (!root)
      root = new protobuf.Root();
    return root.loadSync(filename);
  }
  protobuf.loadSync = loadSync;
  protobuf.encoder = require_encoder();
  protobuf.decoder = require_decoder();
  protobuf.verifier = require_verifier();
  protobuf.converter = require_converter();
  protobuf.ReflectionObject = require_object();
  protobuf.Namespace = require_namespace();
  protobuf.Root = require_root();
  protobuf.Enum = require_enum();
  protobuf.Type = require_type();
  protobuf.Field = require_field();
  protobuf.OneOf = require_oneof();
  protobuf.MapField = require_mapfield();
  protobuf.Service = require_service2();
  protobuf.Method = require_method();
  protobuf.Message = require_message();
  protobuf.wrappers = require_wrappers();
  protobuf.types = require_types();
  protobuf.util = require_util2();
  protobuf.ReflectionObject._configure(protobuf.Root);
  protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
  protobuf.Root._configure(protobuf.Type);
  protobuf.Field._configure(protobuf.Type);
});

// node_modules/protobufjs/src/tokenize.js
var require_tokenize = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = tokenize;
  var delimRe = /[\s{}=;:[\],'"()<>]/g;
  var stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g;
  var stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
  var setCommentRe = /^ *[*/]+ */;
  var setCommentAltRe = /^\s*\*?\/*/;
  var setCommentSplitRe = /\n/g;
  var whitespaceRe = /\s/;
  var unescapeRe = /\\(.?)/g;
  var unescapeMap = {
    "0": "\0",
    r: "\r",
    n: "\n",
    t: "	"
  };
  function unescape2(str) {
    return str.replace(unescapeRe, function($0, $1) {
      switch ($1) {
        case "\\":
        case "":
          return $1;
        default:
          return unescapeMap[$1] || "";
      }
    });
  }
  tokenize.unescape = unescape2;
  function tokenize(source, alternateCommentMode) {
    source = source.toString();
    var offset = 0, length = source.length, line = 1, commentType = null, commentText = null, commentLine = 0, commentLineEmpty = false, commentIsLeading = false;
    var stack = [];
    var stringDelim = null;
    function illegal(subject) {
      return Error("illegal " + subject + " (line " + line + ")");
    }
    function readString() {
      var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
      re.lastIndex = offset - 1;
      var match = re.exec(source);
      if (!match)
        throw illegal("string");
      offset = re.lastIndex;
      push(stringDelim);
      stringDelim = null;
      return unescape2(match[1]);
    }
    function charAt(pos) {
      return source.charAt(pos);
    }
    function setComment(start, end, isLeading) {
      commentType = source.charAt(start++);
      commentLine = line;
      commentLineEmpty = false;
      commentIsLeading = isLeading;
      var lookback;
      if (alternateCommentMode) {
        lookback = 2;
      } else {
        lookback = 3;
      }
      var commentOffset = start - lookback, c;
      do {
        if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === "\n") {
          commentLineEmpty = true;
          break;
        }
      } while (c === " " || c === "	");
      var lines = source.substring(start, end).split(setCommentSplitRe);
      for (var i = 0; i < lines.length; ++i)
        lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "").trim();
      commentText = lines.join("\n").trim();
    }
    function isDoubleSlashCommentLine(startOffset) {
      var endOffset = findEndOfLine(startOffset);
      var lineText = source.substring(startOffset, endOffset);
      var isComment = /^\s*\/{1,2}/.test(lineText);
      return isComment;
    }
    function findEndOfLine(cursor) {
      var endOffset = cursor;
      while (endOffset < length && charAt(endOffset) !== "\n") {
        endOffset++;
      }
      return endOffset;
    }
    function next() {
      if (stack.length > 0)
        return stack.shift();
      if (stringDelim)
        return readString();
      var repeat, prev, curr, start, isDoc, isLeadingComment = offset === 0;
      do {
        if (offset === length)
          return null;
        repeat = false;
        while (whitespaceRe.test(curr = charAt(offset))) {
          if (curr === "\n") {
            isLeadingComment = true;
            ++line;
          }
          if (++offset === length)
            return null;
        }
        if (charAt(offset) === "/") {
          if (++offset === length) {
            throw illegal("comment");
          }
          if (charAt(offset) === "/") {
            if (!alternateCommentMode) {
              isDoc = charAt(start = offset + 1) === "/";
              while (charAt(++offset) !== "\n") {
                if (offset === length) {
                  return null;
                }
              }
              ++offset;
              if (isDoc) {
                setComment(start, offset - 1, isLeadingComment);
              }
              ++line;
              repeat = true;
            } else {
              start = offset;
              isDoc = false;
              if (isDoubleSlashCommentLine(offset)) {
                isDoc = true;
                do {
                  offset = findEndOfLine(offset);
                  if (offset === length) {
                    break;
                  }
                  offset++;
                } while (isDoubleSlashCommentLine(offset));
              } else {
                offset = Math.min(length, findEndOfLine(offset) + 1);
              }
              if (isDoc) {
                setComment(start, offset, isLeadingComment);
              }
              line++;
              repeat = true;
            }
          } else if ((curr = charAt(offset)) === "*") {
            start = offset + 1;
            isDoc = alternateCommentMode || charAt(start) === "*";
            do {
              if (curr === "\n") {
                ++line;
              }
              if (++offset === length) {
                throw illegal("comment");
              }
              prev = curr;
              curr = charAt(offset);
            } while (prev !== "*" || curr !== "/");
            ++offset;
            if (isDoc) {
              setComment(start, offset - 2, isLeadingComment);
            }
            repeat = true;
          } else {
            return "/";
          }
        }
      } while (repeat);
      var end = offset;
      delimRe.lastIndex = 0;
      var delim = delimRe.test(charAt(end++));
      if (!delim)
        while (end < length && !delimRe.test(charAt(end)))
          ++end;
      var token = source.substring(offset, offset = end);
      if (token === '"' || token === "'")
        stringDelim = token;
      return token;
    }
    function push(token) {
      stack.push(token);
    }
    function peek() {
      if (!stack.length) {
        var token = next();
        if (token === null)
          return null;
        push(token);
      }
      return stack[0];
    }
    function skip(expected, optional) {
      var actual = peek(), equals = actual === expected;
      if (equals) {
        next();
        return true;
      }
      if (!optional)
        throw illegal("token '" + actual + "', '" + expected + "' expected");
      return false;
    }
    function cmnt(trailingLine) {
      var ret = null;
      if (trailingLine === void 0) {
        if (commentLine === line - 1 && (alternateCommentMode || commentType === "*" || commentLineEmpty)) {
          ret = commentIsLeading ? commentText : null;
        }
      } else {
        if (commentLine < trailingLine) {
          peek();
        }
        if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === "/")) {
          ret = commentIsLeading ? null : commentText;
        }
      }
      return ret;
    }
    return Object.defineProperty({
      next,
      peek,
      push,
      skip,
      cmnt
    }, "line", {
      get: function() {
        return line;
      }
    });
  }
});

// node_modules/protobufjs/src/parse.js
var require_parse2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = parse;
  parse.filename = null;
  parse.defaults = {keepCase: false};
  var tokenize = require_tokenize();
  var Root = require_root();
  var Type = require_type();
  var Field = require_field();
  var MapField = require_mapfield();
  var OneOf = require_oneof();
  var Enum = require_enum();
  var Service = require_service2();
  var Method = require_method();
  var types = require_types();
  var util = require_util2();
  var base10Re = /^[1-9][0-9]*$/;
  var base10NegRe = /^-?[1-9][0-9]*$/;
  var base16Re = /^0[x][0-9a-fA-F]+$/;
  var base16NegRe = /^-?0[x][0-9a-fA-F]+$/;
  var base8Re = /^0[0-7]+$/;
  var base8NegRe = /^-?0[0-7]+$/;
  var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
  var nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
  var typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
  var fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;
  function parse(source, root, options) {
    if (!(root instanceof Root)) {
      options = root;
      root = new Root();
    }
    if (!options)
      options = parse.defaults;
    var preferTrailingComment = options.preferTrailingComment || false;
    var tn = tokenize(source, options.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;
    var head = true, pkg, imports, weakImports, syntax, isProto3 = false;
    var ptr = root;
    var applyCase = options.keepCase ? function(name) {
      return name;
    } : util.camelCase;
    function illegal(token2, name, insideTryCatch) {
      var filename = parse.filename;
      if (!insideTryCatch)
        parse.filename = null;
      return Error("illegal " + (name || "token") + " '" + token2 + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
    }
    function readString() {
      var values = [], token2;
      do {
        if ((token2 = next()) !== '"' && token2 !== "'")
          throw illegal(token2);
        values.push(next());
        skip(token2);
        token2 = peek();
      } while (token2 === '"' || token2 === "'");
      return values.join("");
    }
    function readValue(acceptTypeRef) {
      var token2 = next();
      switch (token2) {
        case "'":
        case '"':
          push(token2);
          return readString();
        case "true":
        case "TRUE":
          return true;
        case "false":
        case "FALSE":
          return false;
      }
      try {
        return parseNumber(token2, true);
      } catch (e) {
        if (acceptTypeRef && typeRefRe.test(token2))
          return token2;
        throw illegal(token2, "value");
      }
    }
    function readRanges(target, acceptStrings) {
      var token2, start;
      do {
        if (acceptStrings && ((token2 = peek()) === '"' || token2 === "'"))
          target.push(readString());
        else
          target.push([start = parseId(next()), skip("to", true) ? parseId(next()) : start]);
      } while (skip(",", true));
      skip(";");
    }
    function parseNumber(token2, insideTryCatch) {
      var sign = 1;
      if (token2.charAt(0) === "-") {
        sign = -1;
        token2 = token2.substring(1);
      }
      switch (token2) {
        case "inf":
        case "INF":
        case "Inf":
          return sign * Infinity;
        case "nan":
        case "NAN":
        case "Nan":
        case "NaN":
          return NaN;
        case "0":
          return 0;
      }
      if (base10Re.test(token2))
        return sign * parseInt(token2, 10);
      if (base16Re.test(token2))
        return sign * parseInt(token2, 16);
      if (base8Re.test(token2))
        return sign * parseInt(token2, 8);
      if (numberRe.test(token2))
        return sign * parseFloat(token2);
      throw illegal(token2, "number", insideTryCatch);
    }
    function parseId(token2, acceptNegative) {
      switch (token2) {
        case "max":
        case "MAX":
        case "Max":
          return 536870911;
        case "0":
          return 0;
      }
      if (!acceptNegative && token2.charAt(0) === "-")
        throw illegal(token2, "id");
      if (base10NegRe.test(token2))
        return parseInt(token2, 10);
      if (base16NegRe.test(token2))
        return parseInt(token2, 16);
      if (base8NegRe.test(token2))
        return parseInt(token2, 8);
      throw illegal(token2, "id");
    }
    function parsePackage() {
      if (pkg !== void 0)
        throw illegal("package");
      pkg = next();
      if (!typeRefRe.test(pkg))
        throw illegal(pkg, "name");
      ptr = ptr.define(pkg);
      skip(";");
    }
    function parseImport() {
      var token2 = peek();
      var whichImports;
      switch (token2) {
        case "weak":
          whichImports = weakImports || (weakImports = []);
          next();
          break;
        case "public":
          next();
        default:
          whichImports = imports || (imports = []);
          break;
      }
      token2 = readString();
      skip(";");
      whichImports.push(token2);
    }
    function parseSyntax() {
      skip("=");
      syntax = readString();
      isProto3 = syntax === "proto3";
      if (!isProto3 && syntax !== "proto2")
        throw illegal(syntax, "syntax");
      skip(";");
    }
    function parseCommon(parent, token2) {
      switch (token2) {
        case "option":
          parseOption(parent, token2);
          skip(";");
          return true;
        case "message":
          parseType(parent, token2);
          return true;
        case "enum":
          parseEnum(parent, token2);
          return true;
        case "service":
          parseService(parent, token2);
          return true;
        case "extend":
          parseExtension(parent, token2);
          return true;
      }
      return false;
    }
    function ifBlock(obj, fnIf, fnElse) {
      var trailingLine = tn.line;
      if (obj) {
        if (typeof obj.comment !== "string") {
          obj.comment = cmnt();
        }
        obj.filename = parse.filename;
      }
      if (skip("{", true)) {
        var token2;
        while ((token2 = next()) !== "}")
          fnIf(token2);
        skip(";", true);
      } else {
        if (fnElse)
          fnElse();
        skip(";");
        if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
          obj.comment = cmnt(trailingLine) || obj.comment;
      }
    }
    function parseType(parent, token2) {
      if (!nameRe.test(token2 = next()))
        throw illegal(token2, "type name");
      var type = new Type(token2);
      ifBlock(type, function parseType_block(token3) {
        if (parseCommon(type, token3))
          return;
        switch (token3) {
          case "map":
            parseMapField(type, token3);
            break;
          case "required":
          case "optional":
          case "repeated":
            parseField(type, token3);
            break;
          case "oneof":
            parseOneOf(type, token3);
            break;
          case "extensions":
            readRanges(type.extensions || (type.extensions = []));
            break;
          case "reserved":
            readRanges(type.reserved || (type.reserved = []), true);
            break;
          default:
            if (!isProto3 || !typeRefRe.test(token3))
              throw illegal(token3);
            push(token3);
            parseField(type, "optional");
            break;
        }
      });
      parent.add(type);
    }
    function parseField(parent, rule, extend) {
      var type = next();
      if (type === "group") {
        parseGroup(parent, rule);
        return;
      }
      if (!typeRefRe.test(type))
        throw illegal(type, "type");
      var name = next();
      if (!nameRe.test(name))
        throw illegal(name, "name");
      name = applyCase(name);
      skip("=");
      var field = new Field(name, parseId(next()), type, rule, extend);
      ifBlock(field, function parseField_block(token2) {
        if (token2 === "option") {
          parseOption(field, token2);
          skip(";");
        } else
          throw illegal(token2);
      }, function parseField_line() {
        parseInlineOptions(field);
      });
      parent.add(field);
      if (!isProto3 && field.repeated && (types.packed[type] !== void 0 || types.basic[type] === void 0))
        field.setOption("packed", false, true);
    }
    function parseGroup(parent, rule) {
      var name = next();
      if (!nameRe.test(name))
        throw illegal(name, "name");
      var fieldName = util.lcFirst(name);
      if (name === fieldName)
        name = util.ucFirst(name);
      skip("=");
      var id = parseId(next());
      var type = new Type(name);
      type.group = true;
      var field = new Field(fieldName, id, name, rule);
      field.filename = parse.filename;
      ifBlock(type, function parseGroup_block(token2) {
        switch (token2) {
          case "option":
            parseOption(type, token2);
            skip(";");
            break;
          case "required":
          case "optional":
          case "repeated":
            parseField(type, token2);
            break;
          default:
            throw illegal(token2);
        }
      });
      parent.add(type).add(field);
    }
    function parseMapField(parent) {
      skip("<");
      var keyType = next();
      if (types.mapKey[keyType] === void 0)
        throw illegal(keyType, "type");
      skip(",");
      var valueType = next();
      if (!typeRefRe.test(valueType))
        throw illegal(valueType, "type");
      skip(">");
      var name = next();
      if (!nameRe.test(name))
        throw illegal(name, "name");
      skip("=");
      var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
      ifBlock(field, function parseMapField_block(token2) {
        if (token2 === "option") {
          parseOption(field, token2);
          skip(";");
        } else
          throw illegal(token2);
      }, function parseMapField_line() {
        parseInlineOptions(field);
      });
      parent.add(field);
    }
    function parseOneOf(parent, token2) {
      if (!nameRe.test(token2 = next()))
        throw illegal(token2, "name");
      var oneof = new OneOf(applyCase(token2));
      ifBlock(oneof, function parseOneOf_block(token3) {
        if (token3 === "option") {
          parseOption(oneof, token3);
          skip(";");
        } else {
          push(token3);
          parseField(oneof, "optional");
        }
      });
      parent.add(oneof);
    }
    function parseEnum(parent, token2) {
      if (!nameRe.test(token2 = next()))
        throw illegal(token2, "name");
      var enm = new Enum(token2);
      ifBlock(enm, function parseEnum_block(token3) {
        switch (token3) {
          case "option":
            parseOption(enm, token3);
            skip(";");
            break;
          case "reserved":
            readRanges(enm.reserved || (enm.reserved = []), true);
            break;
          default:
            parseEnumValue(enm, token3);
        }
      });
      parent.add(enm);
    }
    function parseEnumValue(parent, token2) {
      if (!nameRe.test(token2))
        throw illegal(token2, "name");
      skip("=");
      var value = parseId(next(), true), dummy = {};
      ifBlock(dummy, function parseEnumValue_block(token3) {
        if (token3 === "option") {
          parseOption(dummy, token3);
          skip(";");
        } else
          throw illegal(token3);
      }, function parseEnumValue_line() {
        parseInlineOptions(dummy);
      });
      parent.add(token2, value, dummy.comment);
    }
    function parseOption(parent, token2) {
      var isCustom = skip("(", true);
      if (!typeRefRe.test(token2 = next()))
        throw illegal(token2, "name");
      var name = token2;
      var option = name;
      var propName;
      if (isCustom) {
        skip(")");
        name = "(" + name + ")";
        option = name;
        token2 = peek();
        if (fqTypeRefRe.test(token2)) {
          propName = token2.substr(1);
          name += token2;
          next();
        }
      }
      skip("=");
      var optionValue = parseOptionValue(parent, name);
      setParsedOption(parent, option, optionValue, propName);
    }
    function parseOptionValue(parent, name) {
      if (skip("{", true)) {
        var result = {};
        while (!skip("}", true)) {
          if (!nameRe.test(token = next()))
            throw illegal(token, "name");
          var value;
          var propName = token;
          if (peek() === "{")
            value = parseOptionValue(parent, name + "." + token);
          else {
            skip(":");
            if (peek() === "{")
              value = parseOptionValue(parent, name + "." + token);
            else {
              value = readValue(true);
              setOption(parent, name + "." + token, value);
            }
          }
          var prevValue = result[propName];
          if (prevValue)
            value = [].concat(prevValue).concat(value);
          result[propName] = value;
          skip(",", true);
        }
        return result;
      }
      var simpleValue = readValue(true);
      setOption(parent, name, simpleValue);
      return simpleValue;
    }
    function setOption(parent, name, value) {
      if (parent.setOption)
        parent.setOption(name, value);
    }
    function setParsedOption(parent, name, value, propName) {
      if (parent.setParsedOption)
        parent.setParsedOption(name, value, propName);
    }
    function parseInlineOptions(parent) {
      if (skip("[", true)) {
        do {
          parseOption(parent, "option");
        } while (skip(",", true));
        skip("]");
      }
      return parent;
    }
    function parseService(parent, token2) {
      if (!nameRe.test(token2 = next()))
        throw illegal(token2, "service name");
      var service = new Service(token2);
      ifBlock(service, function parseService_block(token3) {
        if (parseCommon(service, token3))
          return;
        if (token3 === "rpc")
          parseMethod(service, token3);
        else
          throw illegal(token3);
      });
      parent.add(service);
    }
    function parseMethod(parent, token2) {
      var commentText = cmnt();
      var type = token2;
      if (!nameRe.test(token2 = next()))
        throw illegal(token2, "name");
      var name = token2, requestType, requestStream, responseType, responseStream;
      skip("(");
      if (skip("stream", true))
        requestStream = true;
      if (!typeRefRe.test(token2 = next()))
        throw illegal(token2);
      requestType = token2;
      skip(")");
      skip("returns");
      skip("(");
      if (skip("stream", true))
        responseStream = true;
      if (!typeRefRe.test(token2 = next()))
        throw illegal(token2);
      responseType = token2;
      skip(")");
      var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
      method.comment = commentText;
      ifBlock(method, function parseMethod_block(token3) {
        if (token3 === "option") {
          parseOption(method, token3);
          skip(";");
        } else
          throw illegal(token3);
      });
      parent.add(method);
    }
    function parseExtension(parent, token2) {
      if (!typeRefRe.test(token2 = next()))
        throw illegal(token2, "reference");
      var reference = token2;
      ifBlock(null, function parseExtension_block(token3) {
        switch (token3) {
          case "required":
          case "repeated":
          case "optional":
            parseField(parent, token3, reference);
            break;
          default:
            if (!isProto3 || !typeRefRe.test(token3))
              throw illegal(token3);
            push(token3);
            parseField(parent, "optional", reference);
            break;
        }
      });
    }
    var token;
    while ((token = next()) !== null) {
      switch (token) {
        case "package":
          if (!head)
            throw illegal(token);
          parsePackage();
          break;
        case "import":
          if (!head)
            throw illegal(token);
          parseImport();
          break;
        case "syntax":
          if (!head)
            throw illegal(token);
          parseSyntax();
          break;
        case "option":
          parseOption(ptr, token);
          skip(";");
          break;
        default:
          if (parseCommon(ptr, token)) {
            head = false;
            continue;
          }
          throw illegal(token);
      }
    }
    parse.filename = null;
    return {
      package: pkg,
      imports,
      weakImports,
      syntax,
      root
    };
  }
});

// node_modules/protobufjs/src/common.js
var require_common3 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = common;
  var commonRe = /\/|\./;
  function common(name, json) {
    if (!commonRe.test(name)) {
      name = "google/protobuf/" + name + ".proto";
      json = {nested: {google: {nested: {protobuf: {nested: json}}}}};
    }
    common[name] = json;
  }
  common("any", {
    Any: {
      fields: {
        type_url: {
          type: "string",
          id: 1
        },
        value: {
          type: "bytes",
          id: 2
        }
      }
    }
  });
  var timeType;
  common("duration", {
    Duration: timeType = {
      fields: {
        seconds: {
          type: "int64",
          id: 1
        },
        nanos: {
          type: "int32",
          id: 2
        }
      }
    }
  });
  common("timestamp", {
    Timestamp: timeType
  });
  common("empty", {
    Empty: {
      fields: {}
    }
  });
  common("struct", {
    Struct: {
      fields: {
        fields: {
          keyType: "string",
          type: "Value",
          id: 1
        }
      }
    },
    Value: {
      oneofs: {
        kind: {
          oneof: [
            "nullValue",
            "numberValue",
            "stringValue",
            "boolValue",
            "structValue",
            "listValue"
          ]
        }
      },
      fields: {
        nullValue: {
          type: "NullValue",
          id: 1
        },
        numberValue: {
          type: "double",
          id: 2
        },
        stringValue: {
          type: "string",
          id: 3
        },
        boolValue: {
          type: "bool",
          id: 4
        },
        structValue: {
          type: "Struct",
          id: 5
        },
        listValue: {
          type: "ListValue",
          id: 6
        }
      }
    },
    NullValue: {
      values: {
        NULL_VALUE: 0
      }
    },
    ListValue: {
      fields: {
        values: {
          rule: "repeated",
          type: "Value",
          id: 1
        }
      }
    }
  });
  common("wrappers", {
    DoubleValue: {
      fields: {
        value: {
          type: "double",
          id: 1
        }
      }
    },
    FloatValue: {
      fields: {
        value: {
          type: "float",
          id: 1
        }
      }
    },
    Int64Value: {
      fields: {
        value: {
          type: "int64",
          id: 1
        }
      }
    },
    UInt64Value: {
      fields: {
        value: {
          type: "uint64",
          id: 1
        }
      }
    },
    Int32Value: {
      fields: {
        value: {
          type: "int32",
          id: 1
        }
      }
    },
    UInt32Value: {
      fields: {
        value: {
          type: "uint32",
          id: 1
        }
      }
    },
    BoolValue: {
      fields: {
        value: {
          type: "bool",
          id: 1
        }
      }
    },
    StringValue: {
      fields: {
        value: {
          type: "string",
          id: 1
        }
      }
    },
    BytesValue: {
      fields: {
        value: {
          type: "bytes",
          id: 1
        }
      }
    }
  });
  common("field_mask", {
    FieldMask: {
      fields: {
        paths: {
          rule: "repeated",
          type: "string",
          id: 1
        }
      }
    }
  });
  common.get = function get(file) {
    return common[file] || null;
  };
});

// node_modules/protobufjs/src/index.js
var require_src9 = __commonJS((exports2, module2) => {
  "use strict";
  var protobuf = module2.exports = require_index_light();
  protobuf.build = "full";
  protobuf.tokenize = require_tokenize();
  protobuf.parse = require_parse2();
  protobuf.common = require_common3();
  protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
});

// node_modules/protobufjs/index.js
var require_protobufjs = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_src9();
});

// node_modules/protobufjs/google/protobuf/descriptor.json
var require_descriptor = __commonJS((exports2, module2) => {
  module2.exports = {
    nested: {
      google: {
        nested: {
          protobuf: {
            nested: {
              FileDescriptorSet: {
                fields: {
                  file: {
                    rule: "repeated",
                    type: "FileDescriptorProto",
                    id: 1
                  }
                }
              },
              FileDescriptorProto: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  package: {
                    type: "string",
                    id: 2
                  },
                  dependency: {
                    rule: "repeated",
                    type: "string",
                    id: 3
                  },
                  publicDependency: {
                    rule: "repeated",
                    type: "int32",
                    id: 10,
                    options: {
                      packed: false
                    }
                  },
                  weakDependency: {
                    rule: "repeated",
                    type: "int32",
                    id: 11,
                    options: {
                      packed: false
                    }
                  },
                  messageType: {
                    rule: "repeated",
                    type: "DescriptorProto",
                    id: 4
                  },
                  enumType: {
                    rule: "repeated",
                    type: "EnumDescriptorProto",
                    id: 5
                  },
                  service: {
                    rule: "repeated",
                    type: "ServiceDescriptorProto",
                    id: 6
                  },
                  extension: {
                    rule: "repeated",
                    type: "FieldDescriptorProto",
                    id: 7
                  },
                  options: {
                    type: "FileOptions",
                    id: 8
                  },
                  sourceCodeInfo: {
                    type: "SourceCodeInfo",
                    id: 9
                  },
                  syntax: {
                    type: "string",
                    id: 12
                  }
                }
              },
              DescriptorProto: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  field: {
                    rule: "repeated",
                    type: "FieldDescriptorProto",
                    id: 2
                  },
                  extension: {
                    rule: "repeated",
                    type: "FieldDescriptorProto",
                    id: 6
                  },
                  nestedType: {
                    rule: "repeated",
                    type: "DescriptorProto",
                    id: 3
                  },
                  enumType: {
                    rule: "repeated",
                    type: "EnumDescriptorProto",
                    id: 4
                  },
                  extensionRange: {
                    rule: "repeated",
                    type: "ExtensionRange",
                    id: 5
                  },
                  oneofDecl: {
                    rule: "repeated",
                    type: "OneofDescriptorProto",
                    id: 8
                  },
                  options: {
                    type: "MessageOptions",
                    id: 7
                  },
                  reservedRange: {
                    rule: "repeated",
                    type: "ReservedRange",
                    id: 9
                  },
                  reservedName: {
                    rule: "repeated",
                    type: "string",
                    id: 10
                  }
                },
                nested: {
                  ExtensionRange: {
                    fields: {
                      start: {
                        type: "int32",
                        id: 1
                      },
                      end: {
                        type: "int32",
                        id: 2
                      }
                    }
                  },
                  ReservedRange: {
                    fields: {
                      start: {
                        type: "int32",
                        id: 1
                      },
                      end: {
                        type: "int32",
                        id: 2
                      }
                    }
                  }
                }
              },
              FieldDescriptorProto: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  number: {
                    type: "int32",
                    id: 3
                  },
                  label: {
                    type: "Label",
                    id: 4
                  },
                  type: {
                    type: "Type",
                    id: 5
                  },
                  typeName: {
                    type: "string",
                    id: 6
                  },
                  extendee: {
                    type: "string",
                    id: 2
                  },
                  defaultValue: {
                    type: "string",
                    id: 7
                  },
                  oneofIndex: {
                    type: "int32",
                    id: 9
                  },
                  jsonName: {
                    type: "string",
                    id: 10
                  },
                  options: {
                    type: "FieldOptions",
                    id: 8
                  }
                },
                nested: {
                  Type: {
                    values: {
                      TYPE_DOUBLE: 1,
                      TYPE_FLOAT: 2,
                      TYPE_INT64: 3,
                      TYPE_UINT64: 4,
                      TYPE_INT32: 5,
                      TYPE_FIXED64: 6,
                      TYPE_FIXED32: 7,
                      TYPE_BOOL: 8,
                      TYPE_STRING: 9,
                      TYPE_GROUP: 10,
                      TYPE_MESSAGE: 11,
                      TYPE_BYTES: 12,
                      TYPE_UINT32: 13,
                      TYPE_ENUM: 14,
                      TYPE_SFIXED32: 15,
                      TYPE_SFIXED64: 16,
                      TYPE_SINT32: 17,
                      TYPE_SINT64: 18
                    }
                  },
                  Label: {
                    values: {
                      LABEL_OPTIONAL: 1,
                      LABEL_REQUIRED: 2,
                      LABEL_REPEATED: 3
                    }
                  }
                }
              },
              OneofDescriptorProto: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  options: {
                    type: "OneofOptions",
                    id: 2
                  }
                }
              },
              EnumDescriptorProto: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  value: {
                    rule: "repeated",
                    type: "EnumValueDescriptorProto",
                    id: 2
                  },
                  options: {
                    type: "EnumOptions",
                    id: 3
                  }
                }
              },
              EnumValueDescriptorProto: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  number: {
                    type: "int32",
                    id: 2
                  },
                  options: {
                    type: "EnumValueOptions",
                    id: 3
                  }
                }
              },
              ServiceDescriptorProto: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  method: {
                    rule: "repeated",
                    type: "MethodDescriptorProto",
                    id: 2
                  },
                  options: {
                    type: "ServiceOptions",
                    id: 3
                  }
                }
              },
              MethodDescriptorProto: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  inputType: {
                    type: "string",
                    id: 2
                  },
                  outputType: {
                    type: "string",
                    id: 3
                  },
                  options: {
                    type: "MethodOptions",
                    id: 4
                  },
                  clientStreaming: {
                    type: "bool",
                    id: 5
                  },
                  serverStreaming: {
                    type: "bool",
                    id: 6
                  }
                }
              },
              FileOptions: {
                fields: {
                  javaPackage: {
                    type: "string",
                    id: 1
                  },
                  javaOuterClassname: {
                    type: "string",
                    id: 8
                  },
                  javaMultipleFiles: {
                    type: "bool",
                    id: 10
                  },
                  javaGenerateEqualsAndHash: {
                    type: "bool",
                    id: 20,
                    options: {
                      deprecated: true
                    }
                  },
                  javaStringCheckUtf8: {
                    type: "bool",
                    id: 27
                  },
                  optimizeFor: {
                    type: "OptimizeMode",
                    id: 9,
                    options: {
                      default: "SPEED"
                    }
                  },
                  goPackage: {
                    type: "string",
                    id: 11
                  },
                  ccGenericServices: {
                    type: "bool",
                    id: 16
                  },
                  javaGenericServices: {
                    type: "bool",
                    id: 17
                  },
                  pyGenericServices: {
                    type: "bool",
                    id: 18
                  },
                  deprecated: {
                    type: "bool",
                    id: 23
                  },
                  ccEnableArenas: {
                    type: "bool",
                    id: 31
                  },
                  objcClassPrefix: {
                    type: "string",
                    id: 36
                  },
                  csharpNamespace: {
                    type: "string",
                    id: 37
                  },
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  }
                },
                extensions: [
                  [
                    1e3,
                    536870911
                  ]
                ],
                reserved: [
                  [
                    38,
                    38
                  ]
                ],
                nested: {
                  OptimizeMode: {
                    values: {
                      SPEED: 1,
                      CODE_SIZE: 2,
                      LITE_RUNTIME: 3
                    }
                  }
                }
              },
              MessageOptions: {
                fields: {
                  messageSetWireFormat: {
                    type: "bool",
                    id: 1
                  },
                  noStandardDescriptorAccessor: {
                    type: "bool",
                    id: 2
                  },
                  deprecated: {
                    type: "bool",
                    id: 3
                  },
                  mapEntry: {
                    type: "bool",
                    id: 7
                  },
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  }
                },
                extensions: [
                  [
                    1e3,
                    536870911
                  ]
                ],
                reserved: [
                  [
                    8,
                    8
                  ]
                ]
              },
              FieldOptions: {
                fields: {
                  ctype: {
                    type: "CType",
                    id: 1,
                    options: {
                      default: "STRING"
                    }
                  },
                  packed: {
                    type: "bool",
                    id: 2
                  },
                  jstype: {
                    type: "JSType",
                    id: 6,
                    options: {
                      default: "JS_NORMAL"
                    }
                  },
                  lazy: {
                    type: "bool",
                    id: 5
                  },
                  deprecated: {
                    type: "bool",
                    id: 3
                  },
                  weak: {
                    type: "bool",
                    id: 10
                  },
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  }
                },
                extensions: [
                  [
                    1e3,
                    536870911
                  ]
                ],
                reserved: [
                  [
                    4,
                    4
                  ]
                ],
                nested: {
                  CType: {
                    values: {
                      STRING: 0,
                      CORD: 1,
                      STRING_PIECE: 2
                    }
                  },
                  JSType: {
                    values: {
                      JS_NORMAL: 0,
                      JS_STRING: 1,
                      JS_NUMBER: 2
                    }
                  }
                }
              },
              OneofOptions: {
                fields: {
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  }
                },
                extensions: [
                  [
                    1e3,
                    536870911
                  ]
                ]
              },
              EnumOptions: {
                fields: {
                  allowAlias: {
                    type: "bool",
                    id: 2
                  },
                  deprecated: {
                    type: "bool",
                    id: 3
                  },
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  }
                },
                extensions: [
                  [
                    1e3,
                    536870911
                  ]
                ]
              },
              EnumValueOptions: {
                fields: {
                  deprecated: {
                    type: "bool",
                    id: 1
                  },
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  }
                },
                extensions: [
                  [
                    1e3,
                    536870911
                  ]
                ]
              },
              ServiceOptions: {
                fields: {
                  deprecated: {
                    type: "bool",
                    id: 33
                  },
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  }
                },
                extensions: [
                  [
                    1e3,
                    536870911
                  ]
                ]
              },
              MethodOptions: {
                fields: {
                  deprecated: {
                    type: "bool",
                    id: 33
                  },
                  uninterpretedOption: {
                    rule: "repeated",
                    type: "UninterpretedOption",
                    id: 999
                  }
                },
                extensions: [
                  [
                    1e3,
                    536870911
                  ]
                ]
              },
              UninterpretedOption: {
                fields: {
                  name: {
                    rule: "repeated",
                    type: "NamePart",
                    id: 2
                  },
                  identifierValue: {
                    type: "string",
                    id: 3
                  },
                  positiveIntValue: {
                    type: "uint64",
                    id: 4
                  },
                  negativeIntValue: {
                    type: "int64",
                    id: 5
                  },
                  doubleValue: {
                    type: "double",
                    id: 6
                  },
                  stringValue: {
                    type: "bytes",
                    id: 7
                  },
                  aggregateValue: {
                    type: "string",
                    id: 8
                  }
                },
                nested: {
                  NamePart: {
                    fields: {
                      namePart: {
                        rule: "required",
                        type: "string",
                        id: 1
                      },
                      isExtension: {
                        rule: "required",
                        type: "bool",
                        id: 2
                      }
                    }
                  }
                }
              },
              SourceCodeInfo: {
                fields: {
                  location: {
                    rule: "repeated",
                    type: "Location",
                    id: 1
                  }
                },
                nested: {
                  Location: {
                    fields: {
                      path: {
                        rule: "repeated",
                        type: "int32",
                        id: 1
                      },
                      span: {
                        rule: "repeated",
                        type: "int32",
                        id: 2
                      },
                      leadingComments: {
                        type: "string",
                        id: 3
                      },
                      trailingComments: {
                        type: "string",
                        id: 4
                      },
                      leadingDetachedComments: {
                        rule: "repeated",
                        type: "string",
                        id: 6
                      }
                    }
                  }
                }
              },
              GeneratedCodeInfo: {
                fields: {
                  annotation: {
                    rule: "repeated",
                    type: "Annotation",
                    id: 1
                  }
                },
                nested: {
                  Annotation: {
                    fields: {
                      path: {
                        rule: "repeated",
                        type: "int32",
                        id: 1
                      },
                      sourceFile: {
                        type: "string",
                        id: 2
                      },
                      begin: {
                        type: "int32",
                        id: 3
                      },
                      end: {
                        type: "int32",
                        id: 4
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };
});

// node_modules/protobufjs/ext/descriptor/index.js
var require_descriptor2 = __commonJS((exports2, module2) => {
  "use strict";
  var $protobuf = require_protobufjs();
  module2.exports = exports2 = $protobuf.descriptor = $protobuf.Root.fromJSON(require_descriptor()).lookup(".google.protobuf");
  var Namespace = $protobuf.Namespace;
  var Root = $protobuf.Root;
  var Enum = $protobuf.Enum;
  var Type = $protobuf.Type;
  var Field = $protobuf.Field;
  var MapField = $protobuf.MapField;
  var OneOf = $protobuf.OneOf;
  var Service = $protobuf.Service;
  var Method = $protobuf.Method;
  Root.fromDescriptor = function fromDescriptor(descriptor) {
    if (typeof descriptor.length === "number")
      descriptor = exports2.FileDescriptorSet.decode(descriptor);
    var root = new Root();
    if (descriptor.file) {
      var fileDescriptor, filePackage;
      for (var j = 0, i; j < descriptor.file.length; ++j) {
        filePackage = root;
        if ((fileDescriptor = descriptor.file[j])["package"] && fileDescriptor["package"].length)
          filePackage = root.define(fileDescriptor["package"]);
        if (fileDescriptor.name && fileDescriptor.name.length)
          root.files.push(filePackage.filename = fileDescriptor.name);
        if (fileDescriptor.messageType)
          for (i = 0; i < fileDescriptor.messageType.length; ++i)
            filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));
        if (fileDescriptor.enumType)
          for (i = 0; i < fileDescriptor.enumType.length; ++i)
            filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));
        if (fileDescriptor.extension)
          for (i = 0; i < fileDescriptor.extension.length; ++i)
            filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));
        if (fileDescriptor.service)
          for (i = 0; i < fileDescriptor.service.length; ++i)
            filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));
        var opts = fromDescriptorOptions(fileDescriptor.options, exports2.FileOptions);
        if (opts) {
          var ks = Object.keys(opts);
          for (i = 0; i < ks.length; ++i)
            filePackage.setOption(ks[i], opts[ks[i]]);
        }
      }
    }
    return root;
  };
  Root.prototype.toDescriptor = function toDescriptor(syntax) {
    var set = exports2.FileDescriptorSet.create();
    Root_toDescriptorRecursive(this, set.file, syntax);
    return set;
  };
  function Root_toDescriptorRecursive(ns, files, syntax) {
    var file = exports2.FileDescriptorProto.create({name: ns.filename || (ns.fullName.substring(1).replace(/\./g, "_") || "root") + ".proto"});
    if (syntax)
      file.syntax = syntax;
    if (!(ns instanceof Root))
      file["package"] = ns.fullName.substring(1);
    for (var i = 0, nested; i < ns.nestedArray.length; ++i)
      if ((nested = ns._nestedArray[i]) instanceof Type)
        file.messageType.push(nested.toDescriptor(syntax));
      else if (nested instanceof Enum)
        file.enumType.push(nested.toDescriptor());
      else if (nested instanceof Field)
        file.extension.push(nested.toDescriptor(syntax));
      else if (nested instanceof Service)
        file.service.push(nested.toDescriptor());
      else if (nested instanceof Namespace)
        Root_toDescriptorRecursive(nested, files, syntax);
    file.options = toDescriptorOptions(ns.options, exports2.FileOptions);
    if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length)
      files.push(file);
  }
  var unnamedMessageIndex = 0;
  Type.fromDescriptor = function fromDescriptor(descriptor, syntax) {
    if (typeof descriptor.length === "number")
      descriptor = exports2.DescriptorProto.decode(descriptor);
    var type = new Type(descriptor.name.length ? descriptor.name : "Type" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports2.MessageOptions)), i;
    if (descriptor.oneofDecl)
      for (i = 0; i < descriptor.oneofDecl.length; ++i)
        type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));
    if (descriptor.field)
      for (i = 0; i < descriptor.field.length; ++i) {
        var field = Field.fromDescriptor(descriptor.field[i], syntax);
        type.add(field);
        if (descriptor.field[i].hasOwnProperty("oneofIndex"))
          type.oneofsArray[descriptor.field[i].oneofIndex].add(field);
      }
    if (descriptor.extension)
      for (i = 0; i < descriptor.extension.length; ++i)
        type.add(Field.fromDescriptor(descriptor.extension[i], syntax));
    if (descriptor.nestedType)
      for (i = 0; i < descriptor.nestedType.length; ++i) {
        type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));
        if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry)
          type.setOption("map_entry", true);
      }
    if (descriptor.enumType)
      for (i = 0; i < descriptor.enumType.length; ++i)
        type.add(Enum.fromDescriptor(descriptor.enumType[i]));
    if (descriptor.extensionRange && descriptor.extensionRange.length) {
      type.extensions = [];
      for (i = 0; i < descriptor.extensionRange.length; ++i)
        type.extensions.push([descriptor.extensionRange[i].start, descriptor.extensionRange[i].end]);
    }
    if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {
      type.reserved = [];
      if (descriptor.reservedRange)
        for (i = 0; i < descriptor.reservedRange.length; ++i)
          type.reserved.push([descriptor.reservedRange[i].start, descriptor.reservedRange[i].end]);
      if (descriptor.reservedName)
        for (i = 0; i < descriptor.reservedName.length; ++i)
          type.reserved.push(descriptor.reservedName[i]);
    }
    return type;
  };
  Type.prototype.toDescriptor = function toDescriptor(syntax) {
    var descriptor = exports2.DescriptorProto.create({name: this.name}), i;
    for (i = 0; i < this.fieldsArray.length; ++i) {
      var fieldDescriptor;
      descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));
      if (this._fieldsArray[i] instanceof MapField) {
        var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType), valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType), valueTypeName = valueType === 11 || valueType === 14 ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type : void 0;
        descriptor.nestedType.push(exports2.DescriptorProto.create({
          name: fieldDescriptor.typeName,
          field: [
            exports2.FieldDescriptorProto.create({name: "key", number: 1, label: 1, type: keyType}),
            exports2.FieldDescriptorProto.create({name: "value", number: 2, label: 1, type: valueType, typeName: valueTypeName})
          ],
          options: exports2.MessageOptions.create({mapEntry: true})
        }));
      }
    }
    for (i = 0; i < this.oneofsArray.length; ++i)
      descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());
    for (i = 0; i < this.nestedArray.length; ++i) {
      if (this._nestedArray[i] instanceof Field)
        descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));
      else if (this._nestedArray[i] instanceof Type)
        descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));
      else if (this._nestedArray[i] instanceof Enum)
        descriptor.enumType.push(this._nestedArray[i].toDescriptor());
    }
    if (this.extensions)
      for (i = 0; i < this.extensions.length; ++i)
        descriptor.extensionRange.push(exports2.DescriptorProto.ExtensionRange.create({start: this.extensions[i][0], end: this.extensions[i][1]}));
    if (this.reserved)
      for (i = 0; i < this.reserved.length; ++i)
        if (typeof this.reserved[i] === "string")
          descriptor.reservedName.push(this.reserved[i]);
        else
          descriptor.reservedRange.push(exports2.DescriptorProto.ReservedRange.create({start: this.reserved[i][0], end: this.reserved[i][1]}));
    descriptor.options = toDescriptorOptions(this.options, exports2.MessageOptions);
    return descriptor;
  };
  var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
  Field.fromDescriptor = function fromDescriptor(descriptor, syntax) {
    if (typeof descriptor.length === "number")
      descriptor = exports2.DescriptorProto.decode(descriptor);
    if (typeof descriptor.number !== "number")
      throw Error("missing field id");
    var fieldType;
    if (descriptor.typeName && descriptor.typeName.length)
      fieldType = descriptor.typeName;
    else
      fieldType = fromDescriptorType(descriptor.type);
    var fieldRule;
    switch (descriptor.label) {
      case 1:
        fieldRule = void 0;
        break;
      case 2:
        fieldRule = "required";
        break;
      case 3:
        fieldRule = "repeated";
        break;
      default:
        throw Error("illegal label: " + descriptor.label);
    }
    var extendee = descriptor.extendee;
    if (descriptor.extendee !== void 0) {
      extendee = extendee.length ? extendee : void 0;
    }
    var field = new Field(descriptor.name.length ? descriptor.name : "field" + descriptor.number, descriptor.number, fieldType, fieldRule, extendee);
    field.options = fromDescriptorOptions(descriptor.options, exports2.FieldOptions);
    if (descriptor.defaultValue && descriptor.defaultValue.length) {
      var defaultValue = descriptor.defaultValue;
      switch (defaultValue) {
        case "true":
        case "TRUE":
          defaultValue = true;
          break;
        case "false":
        case "FALSE":
          defaultValue = false;
          break;
        default:
          var match = numberRe.exec(defaultValue);
          if (match)
            defaultValue = parseInt(defaultValue);
          break;
      }
      field.setOption("default", defaultValue);
    }
    if (packableDescriptorType(descriptor.type)) {
      if (syntax === "proto3") {
        if (descriptor.options && !descriptor.options.packed)
          field.setOption("packed", false);
      } else if (!(descriptor.options && descriptor.options.packed))
        field.setOption("packed", false);
    }
    return field;
  };
  Field.prototype.toDescriptor = function toDescriptor(syntax) {
    var descriptor = exports2.FieldDescriptorProto.create({name: this.name, number: this.id});
    if (this.map) {
      descriptor.type = 11;
      descriptor.typeName = $protobuf.util.ucFirst(this.name);
      descriptor.label = 3;
    } else {
      switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {
        case 10:
        case 11:
        case 14:
          descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;
          break;
      }
      switch (this.rule) {
        case "repeated":
          descriptor.label = 3;
          break;
        case "required":
          descriptor.label = 2;
          break;
        default:
          descriptor.label = 1;
          break;
      }
    }
    descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;
    if (this.partOf) {
      if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0)
        throw Error("missing oneof");
    }
    if (this.options) {
      descriptor.options = toDescriptorOptions(this.options, exports2.FieldOptions);
      if (this.options["default"] != null)
        descriptor.defaultValue = String(this.options["default"]);
    }
    if (syntax === "proto3") {
      if (!this.packed)
        (descriptor.options || (descriptor.options = exports2.FieldOptions.create())).packed = false;
    } else if (this.packed)
      (descriptor.options || (descriptor.options = exports2.FieldOptions.create())).packed = true;
    return descriptor;
  };
  var unnamedEnumIndex = 0;
  Enum.fromDescriptor = function fromDescriptor(descriptor) {
    if (typeof descriptor.length === "number")
      descriptor = exports2.EnumDescriptorProto.decode(descriptor);
    var values = {};
    if (descriptor.value)
      for (var i = 0; i < descriptor.value.length; ++i) {
        var name = descriptor.value[i].name, value = descriptor.value[i].number || 0;
        values[name && name.length ? name : "NAME" + value] = value;
      }
    return new Enum(descriptor.name && descriptor.name.length ? descriptor.name : "Enum" + unnamedEnumIndex++, values, fromDescriptorOptions(descriptor.options, exports2.EnumOptions));
  };
  Enum.prototype.toDescriptor = function toDescriptor() {
    var values = [];
    for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i)
      values.push(exports2.EnumValueDescriptorProto.create({name: ks[i], number: this.values[ks[i]]}));
    return exports2.EnumDescriptorProto.create({
      name: this.name,
      value: values,
      options: toDescriptorOptions(this.options, exports2.EnumOptions)
    });
  };
  var unnamedOneofIndex = 0;
  OneOf.fromDescriptor = function fromDescriptor(descriptor) {
    if (typeof descriptor.length === "number")
      descriptor = exports2.OneofDescriptorProto.decode(descriptor);
    return new OneOf(descriptor.name && descriptor.name.length ? descriptor.name : "oneof" + unnamedOneofIndex++);
  };
  OneOf.prototype.toDescriptor = function toDescriptor() {
    return exports2.OneofDescriptorProto.create({
      name: this.name
    });
  };
  var unnamedServiceIndex = 0;
  Service.fromDescriptor = function fromDescriptor(descriptor) {
    if (typeof descriptor.length === "number")
      descriptor = exports2.ServiceDescriptorProto.decode(descriptor);
    var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : "Service" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports2.ServiceOptions));
    if (descriptor.method)
      for (var i = 0; i < descriptor.method.length; ++i)
        service.add(Method.fromDescriptor(descriptor.method[i]));
    return service;
  };
  Service.prototype.toDescriptor = function toDescriptor() {
    var methods = [];
    for (var i = 0; i < this.methodsArray.length; ++i)
      methods.push(this._methodsArray[i].toDescriptor());
    return exports2.ServiceDescriptorProto.create({
      name: this.name,
      method: methods,
      options: toDescriptorOptions(this.options, exports2.ServiceOptions)
    });
  };
  var unnamedMethodIndex = 0;
  Method.fromDescriptor = function fromDescriptor(descriptor) {
    if (typeof descriptor.length === "number")
      descriptor = exports2.MethodDescriptorProto.decode(descriptor);
    return new Method(descriptor.name && descriptor.name.length ? descriptor.name : "Method" + unnamedMethodIndex++, "rpc", descriptor.inputType, descriptor.outputType, Boolean(descriptor.clientStreaming), Boolean(descriptor.serverStreaming), fromDescriptorOptions(descriptor.options, exports2.MethodOptions));
  };
  Method.prototype.toDescriptor = function toDescriptor() {
    return exports2.MethodDescriptorProto.create({
      name: this.name,
      inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,
      outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,
      clientStreaming: this.requestStream,
      serverStreaming: this.responseStream,
      options: toDescriptorOptions(this.options, exports2.MethodOptions)
    });
  };
  function fromDescriptorType(type) {
    switch (type) {
      case 1:
        return "double";
      case 2:
        return "float";
      case 3:
        return "int64";
      case 4:
        return "uint64";
      case 5:
        return "int32";
      case 6:
        return "fixed64";
      case 7:
        return "fixed32";
      case 8:
        return "bool";
      case 9:
        return "string";
      case 12:
        return "bytes";
      case 13:
        return "uint32";
      case 15:
        return "sfixed32";
      case 16:
        return "sfixed64";
      case 17:
        return "sint32";
      case 18:
        return "sint64";
    }
    throw Error("illegal type: " + type);
  }
  function packableDescriptorType(type) {
    switch (type) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
        return true;
    }
    return false;
  }
  function toDescriptorType(type, resolvedType) {
    switch (type) {
      case "double":
        return 1;
      case "float":
        return 2;
      case "int64":
        return 3;
      case "uint64":
        return 4;
      case "int32":
        return 5;
      case "fixed64":
        return 6;
      case "fixed32":
        return 7;
      case "bool":
        return 8;
      case "string":
        return 9;
      case "bytes":
        return 12;
      case "uint32":
        return 13;
      case "sfixed32":
        return 15;
      case "sfixed64":
        return 16;
      case "sint32":
        return 17;
      case "sint64":
        return 18;
    }
    if (resolvedType instanceof Enum)
      return 14;
    if (resolvedType instanceof Type)
      return resolvedType.group ? 10 : 11;
    throw Error("illegal type: " + type);
  }
  function fromDescriptorOptions(options, type) {
    if (!options)
      return void 0;
    var out = [];
    for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i)
      if ((key = (field = type._fieldsArray[i]).name) !== "uninterpretedOption") {
        if (options.hasOwnProperty(key)) {
          val = options[key];
          if (field.resolvedType instanceof Enum && typeof val === "number" && field.resolvedType.valuesById[val] !== void 0)
            val = field.resolvedType.valuesById[val];
          out.push(underScore(key), val);
        }
      }
    return out.length ? $protobuf.util.toObject(out) : void 0;
  }
  function toDescriptorOptions(options, type) {
    if (!options)
      return void 0;
    var out = [];
    for (var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i) {
      val = options[key = ks[i]];
      if (key === "default")
        continue;
      var field = type.fields[key];
      if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)]))
        continue;
      out.push(key, val);
    }
    return out.length ? type.fromObject($protobuf.util.toObject(out)) : void 0;
  }
  function shortname(from, to) {
    var fromPath = from.fullName.split("."), toPath = to.fullName.split("."), i = 0, j = 0, k = toPath.length - 1;
    if (!(from instanceof Root) && to instanceof Namespace)
      while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {
        var other = to.lookup(fromPath[i++], true);
        if (other !== null && other !== to)
          break;
        ++j;
      }
    else
      for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j)
        ;
    return toPath.slice(j).join(".");
  }
  function underScore(str) {
    return str.substring(0, 1) + str.substring(1).replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) {
      return "_" + $1.toLowerCase();
    });
  }
});

// node_modules/lodash.camelcase/index.js
var require_lodash = __commonJS((exports2, module2) => {
  var INFINITY = 1 / 0;
  var symbolTag = "[object Symbol]";
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsAstralRange = "\\ud800-\\udfff";
  var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
  var rsComboSymbolsRange = "\\u20d0-\\u20f0";
  var rsDingbatRange = "\\u2700-\\u27bf";
  var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
  var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
  var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
  var rsPunctuationRange = "\\u2000-\\u206f";
  var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
  var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
  var rsVarRange = "\\ufe0e\\ufe0f";
  var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos = "['\u2019]";
  var rsAstral = "[" + rsAstralRange + "]";
  var rsBreak = "[" + rsBreakRange + "]";
  var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
  var rsDigits = "\\d+";
  var rsDingbat = "[" + rsDingbatRange + "]";
  var rsLower = "[" + rsLowerRange + "]";
  var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
  var rsFitz = "\\ud83c[\\udffb-\\udfff]";
  var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
  var rsNonAstral = "[^" + rsAstralRange + "]";
  var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
  var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
  var rsUpper = "[" + rsUpperRange + "]";
  var rsZWJ = "\\u200d";
  var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
  var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
  var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
  var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
  var reOptMod = rsModifier + "?";
  var rsOptVar = "[" + rsVarRange + "]?";
  var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
  var rsSeq = rsOptVar + reOptMod + rsOptJoin;
  var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
  var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
  var reApos = RegExp(rsApos, "g");
  var reComboMark = RegExp(rsCombo, "g");
  var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
  var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
    rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
    rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
    rsUpper + "+" + rsOptUpperContr,
    rsDigits,
    rsEmoji
  ].join("|"), "g");
  var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  var deburredLetters = {
    \u00C0: "A",
    \u00C1: "A",
    \u00C2: "A",
    \u00C3: "A",
    \u00C4: "A",
    \u00C5: "A",
    \u00E0: "a",
    \u00E1: "a",
    \u00E2: "a",
    \u00E3: "a",
    \u00E4: "a",
    \u00E5: "a",
    \u00C7: "C",
    \u00E7: "c",
    \u00D0: "D",
    \u00F0: "d",
    \u00C8: "E",
    \u00C9: "E",
    \u00CA: "E",
    \u00CB: "E",
    \u00E8: "e",
    \u00E9: "e",
    \u00EA: "e",
    \u00EB: "e",
    \u00CC: "I",
    \u00CD: "I",
    \u00CE: "I",
    \u00CF: "I",
    \u00EC: "i",
    \u00ED: "i",
    \u00EE: "i",
    \u00EF: "i",
    \u00D1: "N",
    \u00F1: "n",
    \u00D2: "O",
    \u00D3: "O",
    \u00D4: "O",
    \u00D5: "O",
    \u00D6: "O",
    \u00D8: "O",
    \u00F2: "o",
    \u00F3: "o",
    \u00F4: "o",
    \u00F5: "o",
    \u00F6: "o",
    \u00F8: "o",
    \u00D9: "U",
    \u00DA: "U",
    \u00DB: "U",
    \u00DC: "U",
    \u00F9: "u",
    \u00FA: "u",
    \u00FB: "u",
    \u00FC: "u",
    \u00DD: "Y",
    \u00FD: "y",
    \u00FF: "y",
    \u00C6: "Ae",
    \u00E6: "ae",
    \u00DE: "Th",
    \u00FE: "th",
    \u00DF: "ss",
    \u0100: "A",
    \u0102: "A",
    \u0104: "A",
    \u0101: "a",
    \u0103: "a",
    \u0105: "a",
    \u0106: "C",
    \u0108: "C",
    \u010A: "C",
    \u010C: "C",
    \u0107: "c",
    \u0109: "c",
    \u010B: "c",
    \u010D: "c",
    \u010E: "D",
    \u0110: "D",
    \u010F: "d",
    \u0111: "d",
    \u0112: "E",
    \u0114: "E",
    \u0116: "E",
    \u0118: "E",
    \u011A: "E",
    \u0113: "e",
    \u0115: "e",
    \u0117: "e",
    \u0119: "e",
    \u011B: "e",
    \u011C: "G",
    \u011E: "G",
    \u0120: "G",
    \u0122: "G",
    \u011D: "g",
    \u011F: "g",
    \u0121: "g",
    \u0123: "g",
    \u0124: "H",
    \u0126: "H",
    \u0125: "h",
    \u0127: "h",
    \u0128: "I",
    \u012A: "I",
    \u012C: "I",
    \u012E: "I",
    \u0130: "I",
    \u0129: "i",
    \u012B: "i",
    \u012D: "i",
    \u012F: "i",
    \u0131: "i",
    \u0134: "J",
    \u0135: "j",
    \u0136: "K",
    \u0137: "k",
    \u0138: "k",
    \u0139: "L",
    \u013B: "L",
    \u013D: "L",
    \u013F: "L",
    \u0141: "L",
    \u013A: "l",
    \u013C: "l",
    \u013E: "l",
    \u0140: "l",
    \u0142: "l",
    \u0143: "N",
    \u0145: "N",
    \u0147: "N",
    \u014A: "N",
    \u0144: "n",
    \u0146: "n",
    \u0148: "n",
    \u014B: "n",
    \u014C: "O",
    \u014E: "O",
    \u0150: "O",
    \u014D: "o",
    \u014F: "o",
    \u0151: "o",
    \u0154: "R",
    \u0156: "R",
    \u0158: "R",
    \u0155: "r",
    \u0157: "r",
    \u0159: "r",
    \u015A: "S",
    \u015C: "S",
    \u015E: "S",
    \u0160: "S",
    \u015B: "s",
    \u015D: "s",
    \u015F: "s",
    \u0161: "s",
    \u0162: "T",
    \u0164: "T",
    \u0166: "T",
    \u0163: "t",
    \u0165: "t",
    \u0167: "t",
    \u0168: "U",
    \u016A: "U",
    \u016C: "U",
    \u016E: "U",
    \u0170: "U",
    \u0172: "U",
    \u0169: "u",
    \u016B: "u",
    \u016D: "u",
    \u016F: "u",
    \u0171: "u",
    \u0173: "u",
    \u0174: "W",
    \u0175: "w",
    \u0176: "Y",
    \u0177: "y",
    \u0178: "Y",
    \u0179: "Z",
    \u017B: "Z",
    \u017D: "Z",
    \u017A: "z",
    \u017C: "z",
    \u017E: "z",
    \u0132: "IJ",
    \u0133: "ij",
    \u0152: "Oe",
    \u0153: "oe",
    \u0149: "'n",
    \u017F: "ss"
  };
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function asciiToArray(string) {
    return string.split("");
  }
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? void 0 : object[key];
    };
  }
  var deburrLetter = basePropertyOf(deburredLetters);
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }
  function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
  var symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseSlice(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function castSlice(array, start, end) {
    var length = array.length;
    end = end === void 0 ? length : end;
    return !start && end >= length ? array : baseSlice(array, start, end);
  }
  function createCaseFirst(methodName) {
    return function(string) {
      string = toString(string);
      var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
      var chr = strSymbols ? strSymbols[0] : string.charAt(0);
      var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
      return chr[methodName]() + trailing;
    };
  }
  function createCompounder(callback) {
    return function(string) {
      return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
    };
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  var camelCase = createCompounder(function(result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize(word) : word);
  });
  function capitalize(string) {
    return upperFirst(toString(string).toLowerCase());
  }
  function deburr(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
  }
  var upperFirst = createCaseFirst("toUpperCase");
  function words(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? void 0 : pattern;
    if (pattern === void 0) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  }
  module2.exports = camelCase;
});

// node_modules/protobufjs/google/protobuf/api.json
var require_api = __commonJS((exports2, module2) => {
  module2.exports = {
    nested: {
      google: {
        nested: {
          protobuf: {
            nested: {
              Api: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  methods: {
                    rule: "repeated",
                    type: "Method",
                    id: 2
                  },
                  options: {
                    rule: "repeated",
                    type: "Option",
                    id: 3
                  },
                  version: {
                    type: "string",
                    id: 4
                  },
                  sourceContext: {
                    type: "SourceContext",
                    id: 5
                  },
                  mixins: {
                    rule: "repeated",
                    type: "Mixin",
                    id: 6
                  },
                  syntax: {
                    type: "Syntax",
                    id: 7
                  }
                }
              },
              Method: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  requestTypeUrl: {
                    type: "string",
                    id: 2
                  },
                  requestStreaming: {
                    type: "bool",
                    id: 3
                  },
                  responseTypeUrl: {
                    type: "string",
                    id: 4
                  },
                  responseStreaming: {
                    type: "bool",
                    id: 5
                  },
                  options: {
                    rule: "repeated",
                    type: "Option",
                    id: 6
                  },
                  syntax: {
                    type: "Syntax",
                    id: 7
                  }
                }
              },
              Mixin: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  root: {
                    type: "string",
                    id: 2
                  }
                }
              },
              SourceContext: {
                fields: {
                  fileName: {
                    type: "string",
                    id: 1
                  }
                }
              },
              Option: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  value: {
                    type: "Any",
                    id: 2
                  }
                }
              },
              Syntax: {
                values: {
                  SYNTAX_PROTO2: 0,
                  SYNTAX_PROTO3: 1
                }
              }
            }
          }
        }
      }
    }
  };
});

// node_modules/protobufjs/google/protobuf/source_context.json
var require_source_context = __commonJS((exports2, module2) => {
  module2.exports = {
    nested: {
      google: {
        nested: {
          protobuf: {
            nested: {
              SourceContext: {
                fields: {
                  fileName: {
                    type: "string",
                    id: 1
                  }
                }
              }
            }
          }
        }
      }
    }
  };
});

// node_modules/protobufjs/google/protobuf/type.json
var require_type2 = __commonJS((exports2, module2) => {
  module2.exports = {
    nested: {
      google: {
        nested: {
          protobuf: {
            nested: {
              Type: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  fields: {
                    rule: "repeated",
                    type: "Field",
                    id: 2
                  },
                  oneofs: {
                    rule: "repeated",
                    type: "string",
                    id: 3
                  },
                  options: {
                    rule: "repeated",
                    type: "Option",
                    id: 4
                  },
                  sourceContext: {
                    type: "SourceContext",
                    id: 5
                  },
                  syntax: {
                    type: "Syntax",
                    id: 6
                  }
                }
              },
              Field: {
                fields: {
                  kind: {
                    type: "Kind",
                    id: 1
                  },
                  cardinality: {
                    type: "Cardinality",
                    id: 2
                  },
                  number: {
                    type: "int32",
                    id: 3
                  },
                  name: {
                    type: "string",
                    id: 4
                  },
                  typeUrl: {
                    type: "string",
                    id: 6
                  },
                  oneofIndex: {
                    type: "int32",
                    id: 7
                  },
                  packed: {
                    type: "bool",
                    id: 8
                  },
                  options: {
                    rule: "repeated",
                    type: "Option",
                    id: 9
                  },
                  jsonName: {
                    type: "string",
                    id: 10
                  },
                  defaultValue: {
                    type: "string",
                    id: 11
                  }
                },
                nested: {
                  Kind: {
                    values: {
                      TYPE_UNKNOWN: 0,
                      TYPE_DOUBLE: 1,
                      TYPE_FLOAT: 2,
                      TYPE_INT64: 3,
                      TYPE_UINT64: 4,
                      TYPE_INT32: 5,
                      TYPE_FIXED64: 6,
                      TYPE_FIXED32: 7,
                      TYPE_BOOL: 8,
                      TYPE_STRING: 9,
                      TYPE_GROUP: 10,
                      TYPE_MESSAGE: 11,
                      TYPE_BYTES: 12,
                      TYPE_UINT32: 13,
                      TYPE_ENUM: 14,
                      TYPE_SFIXED32: 15,
                      TYPE_SFIXED64: 16,
                      TYPE_SINT32: 17,
                      TYPE_SINT64: 18
                    }
                  },
                  Cardinality: {
                    values: {
                      CARDINALITY_UNKNOWN: 0,
                      CARDINALITY_OPTIONAL: 1,
                      CARDINALITY_REQUIRED: 2,
                      CARDINALITY_REPEATED: 3
                    }
                  }
                }
              },
              Enum: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  enumvalue: {
                    rule: "repeated",
                    type: "EnumValue",
                    id: 2
                  },
                  options: {
                    rule: "repeated",
                    type: "Option",
                    id: 3
                  },
                  sourceContext: {
                    type: "SourceContext",
                    id: 4
                  },
                  syntax: {
                    type: "Syntax",
                    id: 5
                  }
                }
              },
              EnumValue: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  number: {
                    type: "int32",
                    id: 2
                  },
                  options: {
                    rule: "repeated",
                    type: "Option",
                    id: 3
                  }
                }
              },
              Option: {
                fields: {
                  name: {
                    type: "string",
                    id: 1
                  },
                  value: {
                    type: "Any",
                    id: 2
                  }
                }
              },
              Syntax: {
                values: {
                  SYNTAX_PROTO2: 0,
                  SYNTAX_PROTO3: 1
                }
              },
              Any: {
                fields: {
                  type_url: {
                    type: "string",
                    id: 1
                  },
                  value: {
                    type: "bytes",
                    id: 2
                  }
                }
              },
              SourceContext: {
                fields: {
                  fileName: {
                    type: "string",
                    id: 1
                  }
                }
              }
            }
          }
        }
      }
    }
  };
});

// node_modules/@grpc/proto-loader/build/src/index.js
var require_src10 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  /**
   * @license
   * Copyright 2018 gRPC authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   */
  var fs = require("fs");
  var path = require("path");
  var Protobuf = require_protobufjs();
  var descriptor = require_descriptor2();
  var camelCase = require_lodash();
  var descriptorOptions = {
    longs: String,
    enums: String,
    bytes: String,
    defaults: true,
    oneofs: true,
    json: true
  };
  function joinName(baseName, name) {
    if (baseName === "") {
      return name;
    } else {
      return baseName + "." + name;
    }
  }
  function isHandledReflectionObject(obj) {
    return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;
  }
  function isNamespaceBase(obj) {
    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;
  }
  function getAllHandledReflectionObjects(obj, parentName) {
    const objName = joinName(parentName, obj.name);
    if (isHandledReflectionObject(obj)) {
      return [[objName, obj]];
    } else {
      if (isNamespaceBase(obj) && typeof obj.nested !== "undefined") {
        return Object.keys(obj.nested).map((name) => {
          return getAllHandledReflectionObjects(obj.nested[name], objName);
        }).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
      }
    }
    return [];
  }
  function createDeserializer(cls, options) {
    return function deserialize(argBuf) {
      return cls.toObject(cls.decode(argBuf), options);
    };
  }
  function createSerializer(cls) {
    return function serialize(arg) {
      const message = cls.fromObject(arg);
      return cls.encode(message).finish();
    };
  }
  function createMethodDefinition(method, serviceName, options, fileDescriptors) {
    const requestType = method.resolvedRequestType;
    const responseType = method.resolvedResponseType;
    return {
      path: "/" + serviceName + "/" + method.name,
      requestStream: !!method.requestStream,
      responseStream: !!method.responseStream,
      requestSerialize: createSerializer(requestType),
      requestDeserialize: createDeserializer(requestType, options),
      responseSerialize: createSerializer(responseType),
      responseDeserialize: createDeserializer(responseType, options),
      originalName: camelCase(method.name),
      requestType: createMessageDefinition(requestType, fileDescriptors),
      responseType: createMessageDefinition(responseType, fileDescriptors)
    };
  }
  function createServiceDefinition(service, name, options, fileDescriptors) {
    const def = {};
    for (const method of service.methodsArray) {
      def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);
    }
    return def;
  }
  function createMessageDefinition(message, fileDescriptors) {
    const messageDescriptor = message.toDescriptor("proto3");
    return {
      format: "Protocol Buffer 3 DescriptorProto",
      type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),
      fileDescriptorProtos: fileDescriptors
    };
  }
  function createEnumDefinition(enumType, fileDescriptors) {
    const enumDescriptor = enumType.toDescriptor("proto3");
    return {
      format: "Protocol Buffer 3 EnumDescriptorProto",
      type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),
      fileDescriptorProtos: fileDescriptors
    };
  }
  function createDefinition(obj, name, options, fileDescriptors) {
    if (obj instanceof Protobuf.Service) {
      return createServiceDefinition(obj, name, options, fileDescriptors);
    } else if (obj instanceof Protobuf.Type) {
      return createMessageDefinition(obj, fileDescriptors);
    } else if (obj instanceof Protobuf.Enum) {
      return createEnumDefinition(obj, fileDescriptors);
    } else {
      throw new Error("Type mismatch in reflection object handling");
    }
  }
  function createPackageDefinition(root, options) {
    const def = {};
    root.resolveAll();
    const descriptorList = root.toDescriptor("proto3").file;
    const bufferList = descriptorList.map((value) => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));
    for (const [name, obj] of getAllHandledReflectionObjects(root, "")) {
      def[name] = createDefinition(obj, name, options, bufferList);
    }
    return def;
  }
  function addIncludePathResolver(root, includePaths) {
    const originalResolvePath = root.resolvePath;
    root.resolvePath = (origin, target) => {
      if (path.isAbsolute(target)) {
        return target;
      }
      for (const directory of includePaths) {
        const fullPath = path.join(directory, target);
        try {
          fs.accessSync(fullPath, fs.constants.R_OK);
          return fullPath;
        } catch (err) {
          continue;
        }
      }
      process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);
      return originalResolvePath(origin, target);
    };
  }
  function createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {
    options = options || {};
    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);
    root.resolveAll();
    return createPackageDefinition(root, options);
  }
  function load(filename, options) {
    const root = new Protobuf.Root();
    options = options || {};
    if (!!options.includeDirs) {
      if (!Array.isArray(options.includeDirs)) {
        return Promise.reject(new Error("The includeDirs option must be an array"));
      }
      addIncludePathResolver(root, options.includeDirs);
    }
    return root.load(filename, options).then((loadedRoot) => {
      loadedRoot.resolveAll();
      return createPackageDefinition(root, options);
    });
  }
  exports2.load = load;
  function loadSync(filename, options) {
    const root = new Protobuf.Root();
    options = options || {};
    if (!!options.includeDirs) {
      if (!Array.isArray(options.includeDirs)) {
        throw new Error("The includeDirs option must be an array");
      }
      addIncludePathResolver(root, options.includeDirs);
    }
    const loadedRoot = root.loadSync(filename, options);
    loadedRoot.resolveAll();
    return createPackageDefinition(root, options);
  }
  exports2.loadSync = loadSync;
  function loadFileDescriptorSetFromBuffer(descriptorSet, options) {
    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);
    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
  }
  exports2.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;
  function loadFileDescriptorSetFromObject(descriptorSet, options) {
    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);
    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
  }
  exports2.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;
  var apiDescriptor = require_api();
  var descriptorDescriptor = require_descriptor();
  var sourceContextDescriptor = require_source_context();
  var typeDescriptor = require_type2();
  Protobuf.common("api", apiDescriptor.nested.google.nested.protobuf.nested);
  Protobuf.common("descriptor", descriptorDescriptor.nested.google.nested.protobuf.nested);
  Protobuf.common("source_context", sourceContextDescriptor.nested.google.nested.protobuf.nested);
  Protobuf.common("type", typeDescriptor.nested.google.nested.protobuf.nested);
});

// node_modules/@firebase/firestore/dist/node-cjs/database-31f1ed21-f1c2f54e.js
var require_database_31f1ed21_f1c2f54e = __commonJS((exports2) => {
  "use strict";
  var tslib = require_tslib();
  var util = require_index_node_cjs();
  var logger = require_index_cjs2();
  var util$1 = require("util");
  var crypto2 = require("crypto");
  var grpcJs = require_src8();
  var package_json = require_package2();
  var path = require("path");
  var protoLoader = require_src10();
  /**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var ListenSequence = function() {
    function ListenSequence2(previousValue, sequenceNumberSyncer) {
      var _this = this;
      this.previousValue = previousValue;
      if (sequenceNumberSyncer) {
        sequenceNumberSyncer.sequenceNumberHandler = function(sequenceNumber) {
          return _this.setPreviousValue(sequenceNumber);
        };
        this.writeNewSequenceNumber = function(sequenceNumber) {
          return sequenceNumberSyncer.writeSequenceNumber(sequenceNumber);
        };
      }
    }
    ListenSequence2.prototype.setPreviousValue = function(externalPreviousValue) {
      this.previousValue = Math.max(externalPreviousValue, this.previousValue);
      return this.previousValue;
    };
    ListenSequence2.prototype.next = function() {
      var nextValue = ++this.previousValue;
      if (this.writeNewSequenceNumber) {
        this.writeNewSequenceNumber(nextValue);
      }
      return nextValue;
    };
    return ListenSequence2;
  }();
  ListenSequence.INVALID = -1;
  var version = "8.3.3";
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function formatJSON(value) {
    return util$1.inspect(value, {depth: 100});
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var logClient = new logger.Logger("@firebase/firestore");
  function getLogLevel() {
    return logClient.logLevel;
  }
  function setLogLevel(logLevel) {
    logClient.setLogLevel(logLevel);
  }
  function logDebug(msg) {
    var obj = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      obj[_i - 1] = arguments[_i];
    }
    if (logClient.logLevel <= logger.LogLevel.DEBUG) {
      var args = obj.map(argToString);
      logClient.debug.apply(logClient, tslib.__spreadArray(["Firestore (" + version + "): " + msg], args));
    }
  }
  function logError(msg) {
    var obj = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      obj[_i - 1] = arguments[_i];
    }
    if (logClient.logLevel <= logger.LogLevel.ERROR) {
      var args = obj.map(argToString);
      logClient.error.apply(logClient, tslib.__spreadArray(["Firestore (" + version + "): " + msg], args));
    }
  }
  function logWarn(msg) {
    var obj = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      obj[_i - 1] = arguments[_i];
    }
    if (logClient.logLevel <= logger.LogLevel.WARN) {
      var args = obj.map(argToString);
      logClient.warn.apply(logClient, tslib.__spreadArray(["Firestore (" + version + "): " + msg], args));
    }
  }
  function argToString(obj) {
    if (typeof obj === "string") {
      return obj;
    } else {
      try {
        return formatJSON(obj);
      } catch (e) {
        return obj;
      }
    }
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function fail(failure) {
    if (failure === void 0) {
      failure = "Unexpected state";
    }
    var message = "FIRESTORE (" + version + ") INTERNAL ASSERTION FAILED: " + failure;
    logError(message);
    throw new Error(message);
  }
  function hardAssert(assertion, message) {
    if (!assertion) {
      fail();
    }
  }
  function debugCast(obj, constructor) {
    return obj;
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var Code = {
    OK: "ok",
    CANCELLED: "cancelled",
    UNKNOWN: "unknown",
    INVALID_ARGUMENT: "invalid-argument",
    DEADLINE_EXCEEDED: "deadline-exceeded",
    NOT_FOUND: "not-found",
    ALREADY_EXISTS: "already-exists",
    PERMISSION_DENIED: "permission-denied",
    UNAUTHENTICATED: "unauthenticated",
    RESOURCE_EXHAUSTED: "resource-exhausted",
    FAILED_PRECONDITION: "failed-precondition",
    ABORTED: "aborted",
    OUT_OF_RANGE: "out-of-range",
    UNIMPLEMENTED: "unimplemented",
    INTERNAL: "internal",
    UNAVAILABLE: "unavailable",
    DATA_LOSS: "data-loss"
  };
  var FirestoreError = function(_super) {
    tslib.__extends(FirestoreError2, _super);
    function FirestoreError2(code, message) {
      var _this = _super.call(this, message) || this;
      _this.code = code;
      _this.message = message;
      _this.name = "FirebaseError";
      _this.toString = function() {
        return _this.name + ": [code=" + _this.code + "]: " + _this.message;
      };
      return _this;
    }
    return FirestoreError2;
  }(Error);
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var DOCUMENT_KEY_NAME = "__name__";
  var BasePath = function() {
    function BasePath2(segments, offset, length) {
      if (offset === void 0) {
        offset = 0;
      } else if (offset > segments.length) {
        fail();
      }
      if (length === void 0) {
        length = segments.length - offset;
      } else if (length > segments.length - offset) {
        fail();
      }
      this.segments = segments;
      this.offset = offset;
      this.len = length;
    }
    Object.defineProperty(BasePath2.prototype, "length", {
      get: function() {
        return this.len;
      },
      enumerable: false,
      configurable: true
    });
    BasePath2.prototype.isEqual = function(other) {
      return BasePath2.comparator(this, other) === 0;
    };
    BasePath2.prototype.child = function(nameOrPath) {
      var segments = this.segments.slice(this.offset, this.limit());
      if (nameOrPath instanceof BasePath2) {
        nameOrPath.forEach(function(segment) {
          segments.push(segment);
        });
      } else {
        segments.push(nameOrPath);
      }
      return this.construct(segments);
    };
    BasePath2.prototype.limit = function() {
      return this.offset + this.length;
    };
    BasePath2.prototype.popFirst = function(size) {
      size = size === void 0 ? 1 : size;
      return this.construct(this.segments, this.offset + size, this.length - size);
    };
    BasePath2.prototype.popLast = function() {
      return this.construct(this.segments, this.offset, this.length - 1);
    };
    BasePath2.prototype.firstSegment = function() {
      return this.segments[this.offset];
    };
    BasePath2.prototype.lastSegment = function() {
      return this.get(this.length - 1);
    };
    BasePath2.prototype.get = function(index) {
      return this.segments[this.offset + index];
    };
    BasePath2.prototype.isEmpty = function() {
      return this.length === 0;
    };
    BasePath2.prototype.isPrefixOf = function(other) {
      if (other.length < this.length) {
        return false;
      }
      for (var i = 0; i < this.length; i++) {
        if (this.get(i) !== other.get(i)) {
          return false;
        }
      }
      return true;
    };
    BasePath2.prototype.isImmediateParentOf = function(potentialChild) {
      if (this.length + 1 !== potentialChild.length) {
        return false;
      }
      for (var i = 0; i < this.length; i++) {
        if (this.get(i) !== potentialChild.get(i)) {
          return false;
        }
      }
      return true;
    };
    BasePath2.prototype.forEach = function(fn) {
      for (var i = this.offset, end = this.limit(); i < end; i++) {
        fn(this.segments[i]);
      }
    };
    BasePath2.prototype.toArray = function() {
      return this.segments.slice(this.offset, this.limit());
    };
    BasePath2.comparator = function(p1, p2) {
      var len = Math.min(p1.length, p2.length);
      for (var i = 0; i < len; i++) {
        var left = p1.get(i);
        var right = p2.get(i);
        if (left < right) {
          return -1;
        }
        if (left > right) {
          return 1;
        }
      }
      if (p1.length < p2.length) {
        return -1;
      }
      if (p1.length > p2.length) {
        return 1;
      }
      return 0;
    };
    return BasePath2;
  }();
  var ResourcePath = function(_super) {
    tslib.__extends(ResourcePath2, _super);
    function ResourcePath2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ResourcePath2.prototype.construct = function(segments, offset, length) {
      return new ResourcePath2(segments, offset, length);
    };
    ResourcePath2.prototype.canonicalString = function() {
      return this.toArray().join("/");
    };
    ResourcePath2.prototype.toString = function() {
      return this.canonicalString();
    };
    ResourcePath2.fromString = function() {
      var pathComponents = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        pathComponents[_i] = arguments[_i];
      }
      var segments = [];
      for (var _d = 0, pathComponents_1 = pathComponents; _d < pathComponents_1.length; _d++) {
        var path2 = pathComponents_1[_d];
        if (path2.indexOf("//") >= 0) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid segment (" + path2 + "). Paths must not contain // in them.");
        }
        segments.push.apply(segments, path2.split("/").filter(function(segment) {
          return segment.length > 0;
        }));
      }
      return new ResourcePath2(segments);
    };
    ResourcePath2.emptyPath = function() {
      return new ResourcePath2([]);
    };
    return ResourcePath2;
  }(BasePath);
  var identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
  var FieldPath = function(_super) {
    tslib.__extends(FieldPath2, _super);
    function FieldPath2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    FieldPath2.prototype.construct = function(segments, offset, length) {
      return new FieldPath2(segments, offset, length);
    };
    FieldPath2.isValidIdentifier = function(segment) {
      return identifierRegExp.test(segment);
    };
    FieldPath2.prototype.canonicalString = function() {
      return this.toArray().map(function(str) {
        str = str.replace(/\\/g, "\\\\").replace(/`/g, "\\`");
        if (!FieldPath2.isValidIdentifier(str)) {
          str = "`" + str + "`";
        }
        return str;
      }).join(".");
    };
    FieldPath2.prototype.toString = function() {
      return this.canonicalString();
    };
    FieldPath2.prototype.isKeyField = function() {
      return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;
    };
    FieldPath2.keyField = function() {
      return new FieldPath2([DOCUMENT_KEY_NAME]);
    };
    FieldPath2.fromServerFormat = function(path2) {
      var segments = [];
      var current = "";
      var i = 0;
      var addCurrentSegment = function() {
        if (current.length === 0) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field path (" + path2 + "). Paths must not be empty, begin with '.', end with '.', or contain '..'");
        }
        segments.push(current);
        current = "";
      };
      var inBackticks = false;
      while (i < path2.length) {
        var c = path2[i];
        if (c === "\\") {
          if (i + 1 === path2.length) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Path has trailing escape character: " + path2);
          }
          var next = path2[i + 1];
          if (!(next === "\\" || next === "." || next === "`")) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Path has invalid escape sequence: " + path2);
          }
          current += next;
          i += 2;
        } else if (c === "`") {
          inBackticks = !inBackticks;
          i++;
        } else if (c === "." && !inBackticks) {
          addCurrentSegment();
          i++;
        } else {
          current += c;
          i++;
        }
      }
      addCurrentSegment();
      if (inBackticks) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Unterminated ` in path: " + path2);
      }
      return new FieldPath2(segments);
    };
    FieldPath2.emptyPath = function() {
      return new FieldPath2([]);
    };
    return FieldPath2;
  }(BasePath);
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var escapeChar = "";
  var encodedSeparatorChar = "";
  var encodedNul = "";
  var encodedEscape = "";
  function encodeResourcePath(path2) {
    var result = "";
    for (var i = 0; i < path2.length; i++) {
      if (result.length > 0) {
        result = encodeSeparator(result);
      }
      result = encodeSegment(path2.get(i), result);
    }
    return encodeSeparator(result);
  }
  function encodeSegment(segment, resultBuf) {
    var result = resultBuf;
    var length = segment.length;
    for (var i = 0; i < length; i++) {
      var c = segment.charAt(i);
      switch (c) {
        case "\0":
          result += escapeChar + encodedNul;
          break;
        case escapeChar:
          result += escapeChar + encodedEscape;
          break;
        default:
          result += c;
      }
    }
    return result;
  }
  function encodeSeparator(result) {
    return result + escapeChar + encodedSeparatorChar;
  }
  function decodeResourcePath(path2) {
    var length = path2.length;
    hardAssert(length >= 2);
    if (length === 2) {
      hardAssert(path2.charAt(0) === escapeChar && path2.charAt(1) === encodedSeparatorChar);
      return ResourcePath.emptyPath();
    }
    var lastReasonableEscapeIndex = length - 2;
    var segments = [];
    var segmentBuilder = "";
    for (var start = 0; start < length; ) {
      var end = path2.indexOf(escapeChar, start);
      if (end < 0 || end > lastReasonableEscapeIndex) {
        fail();
      }
      var next = path2.charAt(end + 1);
      switch (next) {
        case encodedSeparatorChar:
          var currentPiece = path2.substring(start, end);
          var segment = void 0;
          if (segmentBuilder.length === 0) {
            segment = currentPiece;
          } else {
            segmentBuilder += currentPiece;
            segment = segmentBuilder;
            segmentBuilder = "";
          }
          segments.push(segment);
          break;
        case encodedNul:
          segmentBuilder += path2.substring(start, end);
          segmentBuilder += "\0";
          break;
        case encodedEscape:
          segmentBuilder += path2.substring(start, end + 1);
          break;
        default:
          fail();
      }
      start = end + 2;
    }
    return new ResourcePath(segments);
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var SCHEMA_VERSION = 11;
  var DbTimestamp = function() {
    function DbTimestamp2(seconds, nanoseconds) {
      this.seconds = seconds;
      this.nanoseconds = nanoseconds;
    }
    return DbTimestamp2;
  }();
  var DbPrimaryClient = function() {
    function DbPrimaryClient2(ownerId, allowTabSynchronization, leaseTimestampMs) {
      this.ownerId = ownerId;
      this.allowTabSynchronization = allowTabSynchronization;
      this.leaseTimestampMs = leaseTimestampMs;
    }
    return DbPrimaryClient2;
  }();
  DbPrimaryClient.store = "owner";
  DbPrimaryClient.key = "owner";
  var DbMutationQueue = function() {
    function DbMutationQueue2(userId, lastAcknowledgedBatchId, lastStreamToken) {
      this.userId = userId;
      this.lastAcknowledgedBatchId = lastAcknowledgedBatchId;
      this.lastStreamToken = lastStreamToken;
    }
    return DbMutationQueue2;
  }();
  DbMutationQueue.store = "mutationQueues";
  DbMutationQueue.keyPath = "userId";
  var DbMutationBatch = function() {
    function DbMutationBatch2(userId, batchId, localWriteTimeMs, baseMutations, mutations) {
      this.userId = userId;
      this.batchId = batchId;
      this.localWriteTimeMs = localWriteTimeMs;
      this.baseMutations = baseMutations;
      this.mutations = mutations;
    }
    return DbMutationBatch2;
  }();
  DbMutationBatch.store = "mutations";
  DbMutationBatch.keyPath = "batchId";
  DbMutationBatch.userMutationsIndex = "userMutationsIndex";
  DbMutationBatch.userMutationsKeyPath = ["userId", "batchId"];
  var DbDocumentMutation = function() {
    function DbDocumentMutation2() {
    }
    DbDocumentMutation2.prefixForUser = function(userId) {
      return [userId];
    };
    DbDocumentMutation2.prefixForPath = function(userId, path2) {
      return [userId, encodeResourcePath(path2)];
    };
    DbDocumentMutation2.key = function(userId, path2, batchId) {
      return [userId, encodeResourcePath(path2), batchId];
    };
    return DbDocumentMutation2;
  }();
  DbDocumentMutation.store = "documentMutations";
  DbDocumentMutation.PLACEHOLDER = new DbDocumentMutation();
  var DbNoDocument = function() {
    function DbNoDocument2(path2, readTime) {
      this.path = path2;
      this.readTime = readTime;
    }
    return DbNoDocument2;
  }();
  var DbUnknownDocument = function() {
    function DbUnknownDocument2(path2, version2) {
      this.path = path2;
      this.version = version2;
    }
    return DbUnknownDocument2;
  }();
  var DbRemoteDocument = function() {
    function DbRemoteDocument2(unknownDocument, noDocument, document2, hasCommittedMutations, readTime, parentPath) {
      this.unknownDocument = unknownDocument;
      this.noDocument = noDocument;
      this.document = document2;
      this.hasCommittedMutations = hasCommittedMutations;
      this.readTime = readTime;
      this.parentPath = parentPath;
    }
    return DbRemoteDocument2;
  }();
  DbRemoteDocument.store = "remoteDocuments";
  DbRemoteDocument.readTimeIndex = "readTimeIndex";
  DbRemoteDocument.readTimeIndexPath = "readTime";
  DbRemoteDocument.collectionReadTimeIndex = "collectionReadTimeIndex";
  DbRemoteDocument.collectionReadTimeIndexPath = ["parentPath", "readTime"];
  var DbRemoteDocumentGlobal = function() {
    function DbRemoteDocumentGlobal2(byteSize) {
      this.byteSize = byteSize;
    }
    return DbRemoteDocumentGlobal2;
  }();
  DbRemoteDocumentGlobal.store = "remoteDocumentGlobal";
  DbRemoteDocumentGlobal.key = "remoteDocumentGlobalKey";
  var DbTarget = function() {
    function DbTarget2(targetId, canonicalId2, readTime, resumeToken, lastListenSequenceNumber, lastLimboFreeSnapshotVersion, query2) {
      this.targetId = targetId;
      this.canonicalId = canonicalId2;
      this.readTime = readTime;
      this.resumeToken = resumeToken;
      this.lastListenSequenceNumber = lastListenSequenceNumber;
      this.lastLimboFreeSnapshotVersion = lastLimboFreeSnapshotVersion;
      this.query = query2;
    }
    return DbTarget2;
  }();
  DbTarget.store = "targets";
  DbTarget.keyPath = "targetId";
  DbTarget.queryTargetsIndexName = "queryTargetsIndex";
  DbTarget.queryTargetsKeyPath = ["canonicalId", "targetId"];
  var DbTargetDocument = function() {
    function DbTargetDocument2(targetId, path2, sequenceNumber) {
      this.targetId = targetId;
      this.path = path2;
      this.sequenceNumber = sequenceNumber;
    }
    return DbTargetDocument2;
  }();
  DbTargetDocument.store = "targetDocuments";
  DbTargetDocument.keyPath = ["targetId", "path"];
  DbTargetDocument.documentTargetsIndex = "documentTargetsIndex";
  DbTargetDocument.documentTargetsKeyPath = ["path", "targetId"];
  var DbTargetGlobal = function() {
    function DbTargetGlobal2(highestTargetId, highestListenSequenceNumber, lastRemoteSnapshotVersion, targetCount) {
      this.highestTargetId = highestTargetId;
      this.highestListenSequenceNumber = highestListenSequenceNumber;
      this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;
      this.targetCount = targetCount;
    }
    return DbTargetGlobal2;
  }();
  DbTargetGlobal.key = "targetGlobalKey";
  DbTargetGlobal.store = "targetGlobal";
  var DbCollectionParent = function() {
    function DbCollectionParent2(collectionId, parent) {
      this.collectionId = collectionId;
      this.parent = parent;
    }
    return DbCollectionParent2;
  }();
  DbCollectionParent.store = "collectionParents";
  DbCollectionParent.keyPath = ["collectionId", "parent"];
  var DbClientMetadata = function() {
    function DbClientMetadata2(clientId, updateTimeMs, networkEnabled, inForeground) {
      this.clientId = clientId;
      this.updateTimeMs = updateTimeMs;
      this.networkEnabled = networkEnabled;
      this.inForeground = inForeground;
    }
    return DbClientMetadata2;
  }();
  DbClientMetadata.store = "clientMetadata";
  DbClientMetadata.keyPath = "clientId";
  var DbBundle = function() {
    function DbBundle2(bundleId, createTime, version2) {
      this.bundleId = bundleId;
      this.createTime = createTime;
      this.version = version2;
    }
    return DbBundle2;
  }();
  DbBundle.store = "bundles";
  DbBundle.keyPath = "bundleId";
  var DbNamedQuery = function() {
    function DbNamedQuery2(name, readTime, bundledQuery) {
      this.name = name;
      this.readTime = readTime;
      this.bundledQuery = bundledQuery;
    }
    return DbNamedQuery2;
  }();
  DbNamedQuery.store = "namedQueries";
  DbNamedQuery.keyPath = "name";
  var V1_STORES = [
    DbMutationQueue.store,
    DbMutationBatch.store,
    DbDocumentMutation.store,
    DbRemoteDocument.store,
    DbTarget.store,
    DbPrimaryClient.store,
    DbTargetGlobal.store,
    DbTargetDocument.store
  ];
  var V3_STORES = V1_STORES;
  var V4_STORES = tslib.__spreadArray(tslib.__spreadArray([], V3_STORES), [DbClientMetadata.store]);
  var V6_STORES = tslib.__spreadArray(tslib.__spreadArray([], V4_STORES), [DbRemoteDocumentGlobal.store]);
  var V8_STORES = tslib.__spreadArray(tslib.__spreadArray([], V6_STORES), [DbCollectionParent.store]);
  var V11_STORES = tslib.__spreadArray(tslib.__spreadArray([], V8_STORES), [DbBundle.store, DbNamedQuery.store]);
  var ALL_STORES = V11_STORES;
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var PRIMARY_LEASE_LOST_ERROR_MSG = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
  var PersistenceTransaction = function() {
    function PersistenceTransaction2() {
      this.onCommittedListeners = [];
    }
    PersistenceTransaction2.prototype.addOnCommittedListener = function(listener) {
      this.onCommittedListeners.push(listener);
    };
    PersistenceTransaction2.prototype.raiseOnCommittedEvent = function() {
      this.onCommittedListeners.forEach(function(listener) {
        return listener();
      });
    };
    return PersistenceTransaction2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var Deferred = function() {
    function Deferred2() {
      var _this = this;
      this.promise = new Promise(function(resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      });
    }
    return Deferred2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var PersistencePromise = function() {
    function PersistencePromise2(callback) {
      var _this = this;
      this.nextCallback = null;
      this.catchCallback = null;
      this.result = void 0;
      this.error = void 0;
      this.isDone = false;
      this.callbackAttached = false;
      callback(function(value) {
        _this.isDone = true;
        _this.result = value;
        if (_this.nextCallback) {
          _this.nextCallback(value);
        }
      }, function(error) {
        _this.isDone = true;
        _this.error = error;
        if (_this.catchCallback) {
          _this.catchCallback(error);
        }
      });
    }
    PersistencePromise2.prototype.catch = function(fn) {
      return this.next(void 0, fn);
    };
    PersistencePromise2.prototype.next = function(nextFn, catchFn) {
      var _this = this;
      if (this.callbackAttached) {
        fail();
      }
      this.callbackAttached = true;
      if (this.isDone) {
        if (!this.error) {
          return this.wrapSuccess(nextFn, this.result);
        } else {
          return this.wrapFailure(catchFn, this.error);
        }
      } else {
        return new PersistencePromise2(function(resolve, reject) {
          _this.nextCallback = function(value) {
            _this.wrapSuccess(nextFn, value).next(resolve, reject);
          };
          _this.catchCallback = function(error) {
            _this.wrapFailure(catchFn, error).next(resolve, reject);
          };
        });
      }
    };
    PersistencePromise2.prototype.toPromise = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        _this.next(resolve, reject);
      });
    };
    PersistencePromise2.prototype.wrapUserFunction = function(fn) {
      try {
        var result = fn();
        if (result instanceof PersistencePromise2) {
          return result;
        } else {
          return PersistencePromise2.resolve(result);
        }
      } catch (e) {
        return PersistencePromise2.reject(e);
      }
    };
    PersistencePromise2.prototype.wrapSuccess = function(nextFn, value) {
      if (nextFn) {
        return this.wrapUserFunction(function() {
          return nextFn(value);
        });
      } else {
        return PersistencePromise2.resolve(value);
      }
    };
    PersistencePromise2.prototype.wrapFailure = function(catchFn, error) {
      if (catchFn) {
        return this.wrapUserFunction(function() {
          return catchFn(error);
        });
      } else {
        return PersistencePromise2.reject(error);
      }
    };
    PersistencePromise2.resolve = function(result) {
      return new PersistencePromise2(function(resolve, reject) {
        resolve(result);
      });
    };
    PersistencePromise2.reject = function(error) {
      return new PersistencePromise2(function(resolve, reject) {
        reject(error);
      });
    };
    PersistencePromise2.waitFor = function(all) {
      return new PersistencePromise2(function(resolve, reject) {
        var expectedCount = 0;
        var resolvedCount = 0;
        var done = false;
        all.forEach(function(element) {
          ++expectedCount;
          element.next(function() {
            ++resolvedCount;
            if (done && resolvedCount === expectedCount) {
              resolve();
            }
          }, function(err) {
            return reject(err);
          });
        });
        done = true;
        if (resolvedCount === expectedCount) {
          resolve();
        }
      });
    };
    PersistencePromise2.or = function(predicates) {
      var p = PersistencePromise2.resolve(false);
      var _loop_1 = function(predicate2) {
        p = p.next(function(isTrue) {
          if (isTrue) {
            return PersistencePromise2.resolve(isTrue);
          } else {
            return predicate2();
          }
        });
      };
      for (var _i = 0, predicates_1 = predicates; _i < predicates_1.length; _i++) {
        var predicate = predicates_1[_i];
        _loop_1(predicate);
      }
      return p;
    };
    PersistencePromise2.forEach = function(collection2, f) {
      var _this = this;
      var promises = [];
      collection2.forEach(function(r, s) {
        promises.push(f.call(_this, r, s));
      });
      return this.waitFor(promises);
    };
    return PersistencePromise2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LOG_TAG = "SimpleDb";
  var TRANSACTION_RETRY_COUNT = 3;
  var SimpleDbTransaction = function() {
    function SimpleDbTransaction2(action, transaction) {
      var _this = this;
      this.action = action;
      this.transaction = transaction;
      this.aborted = false;
      this.completionDeferred = new Deferred();
      this.transaction.oncomplete = function() {
        _this.completionDeferred.resolve();
      };
      this.transaction.onabort = function() {
        if (transaction.error) {
          _this.completionDeferred.reject(new IndexedDbTransactionError(action, transaction.error));
        } else {
          _this.completionDeferred.resolve();
        }
      };
      this.transaction.onerror = function(event) {
        var error = checkForAndReportiOSError(event.target.error);
        _this.completionDeferred.reject(new IndexedDbTransactionError(action, error));
      };
    }
    SimpleDbTransaction2.open = function(db2, action, mode, objectStoreNames) {
      try {
        return new SimpleDbTransaction2(action, db2.transaction(objectStoreNames, mode));
      } catch (e) {
        throw new IndexedDbTransactionError(action, e);
      }
    };
    Object.defineProperty(SimpleDbTransaction2.prototype, "completionPromise", {
      get: function() {
        return this.completionDeferred.promise;
      },
      enumerable: false,
      configurable: true
    });
    SimpleDbTransaction2.prototype.abort = function(error) {
      if (error) {
        this.completionDeferred.reject(error);
      }
      if (!this.aborted) {
        logDebug(LOG_TAG, "Aborting transaction:", error ? error.message : "Client-initiated abort");
        this.aborted = true;
        this.transaction.abort();
      }
    };
    SimpleDbTransaction2.prototype.store = function(storeName) {
      var store = this.transaction.objectStore(storeName);
      return new SimpleDbStore(store);
    };
    return SimpleDbTransaction2;
  }();
  var SimpleDb = function() {
    function SimpleDb2(name, version2, schemaConverter) {
      this.name = name;
      this.version = version2;
      this.schemaConverter = schemaConverter;
      var iOSVersion = SimpleDb2.getIOSVersion(util.getUA());
      if (iOSVersion === 12.2) {
        logError("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
      }
    }
    SimpleDb2.delete = function(name) {
      logDebug(LOG_TAG, "Removing database:", name);
      return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();
    };
    SimpleDb2.isAvailable = function() {
      if (typeof indexedDB === "undefined") {
        return false;
      }
      if (SimpleDb2.isMockPersistence()) {
        return true;
      }
      var ua = util.getUA();
      var iOSVersion = SimpleDb2.getIOSVersion(ua);
      var isUnsupportedIOS = 0 < iOSVersion && iOSVersion < 10;
      var androidVersion = SimpleDb2.getAndroidVersion(ua);
      var isUnsupportedAndroid = 0 < androidVersion && androidVersion < 4.5;
      if (ua.indexOf("MSIE ") > 0 || ua.indexOf("Trident/") > 0 || ua.indexOf("Edge/") > 0 || isUnsupportedIOS || isUnsupportedAndroid) {
        return false;
      } else {
        return true;
      }
    };
    SimpleDb2.isMockPersistence = function() {
      var _a;
      return typeof process !== "undefined" && ((_a = process.env) === null || _a === void 0 ? void 0 : _a.USE_MOCK_PERSISTENCE) === "YES";
    };
    SimpleDb2.getStore = function(txn, store) {
      return txn.store(store);
    };
    SimpleDb2.getIOSVersion = function(ua) {
      var iOSVersionRegex = ua.match(/i(?:phone|pad|pod) os ([\d_]+)/i);
      var version2 = iOSVersionRegex ? iOSVersionRegex[1].split("_").slice(0, 2).join(".") : "-1";
      return Number(version2);
    };
    SimpleDb2.getAndroidVersion = function(ua) {
      var androidVersionRegex = ua.match(/Android ([\d.]+)/i);
      var version2 = androidVersionRegex ? androidVersionRegex[1].split(".").slice(0, 2).join(".") : "-1";
      return Number(version2);
    };
    SimpleDb2.prototype.ensureDb = function(action) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var _d;
        var _this = this;
        return tslib.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              if (!!this.db)
                return [3, 2];
              logDebug(LOG_TAG, "Opening database:", this.name);
              _d = this;
              return [4, new Promise(function(resolve, reject) {
                var request = indexedDB.open(_this.name, _this.version);
                request.onsuccess = function(event) {
                  var db2 = event.target.result;
                  resolve(db2);
                };
                request.onblocked = function() {
                  reject(new IndexedDbTransactionError(action, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
                };
                request.onerror = function(event) {
                  var error = event.target.error;
                  if (error.name === "VersionError") {
                    reject(new FirestoreError(Code.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh."));
                  } else {
                    reject(new IndexedDbTransactionError(action, error));
                  }
                };
                request.onupgradeneeded = function(event) {
                  logDebug(LOG_TAG, 'Database "' + _this.name + '" requires upgrade from version:', event.oldVersion);
                  var db2 = event.target.result;
                  _this.schemaConverter.createOrUpgrade(db2, request.transaction, event.oldVersion, _this.version).next(function() {
                    logDebug(LOG_TAG, "Database upgrade to version " + _this.version + " complete");
                  });
                };
              })];
            case 1:
              _d.db = _e.sent();
              _e.label = 2;
            case 2:
              if (this.versionchangelistener) {
                this.db.onversionchange = function(event) {
                  return _this.versionchangelistener(event);
                };
              }
              return [2, this.db];
          }
        });
      });
    };
    SimpleDb2.prototype.setVersionChangeListener = function(versionChangeListener) {
      this.versionchangelistener = versionChangeListener;
      if (this.db) {
        this.db.onversionchange = function(event) {
          return versionChangeListener(event);
        };
      }
    };
    SimpleDb2.prototype.runTransaction = function(action, mode, objectStores, transactionFn) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var readonly, attemptNumber, _loop_2, this_1, state_1;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              readonly = mode === "readonly";
              attemptNumber = 0;
              _loop_2 = function() {
                var transaction_1, transactionFnResult, error_1, retryable;
                return tslib.__generator(this, function(_e) {
                  switch (_e.label) {
                    case 0:
                      ++attemptNumber;
                      _e.label = 1;
                    case 1:
                      _e.trys.push([1, 4, , 5]);
                      return [4, this_1.ensureDb(action)];
                    case 2:
                      this_1.db = _e.sent();
                      transaction_1 = SimpleDbTransaction.open(this_1.db, action, readonly ? "readonly" : "readwrite", objectStores);
                      transactionFnResult = transactionFn(transaction_1).catch(function(error) {
                        transaction_1.abort(error);
                        return PersistencePromise.reject(error);
                      }).toPromise();
                      transactionFnResult.catch(function() {
                      });
                      return [4, transaction_1.completionPromise];
                    case 3:
                      _e.sent();
                      return [2, {value: transactionFnResult}];
                    case 4:
                      error_1 = _e.sent();
                      retryable = error_1.name !== "FirebaseError" && attemptNumber < TRANSACTION_RETRY_COUNT;
                      logDebug(LOG_TAG, "Transaction failed with error:", error_1.message, "Retrying:", retryable);
                      this_1.close();
                      if (!retryable) {
                        return [2, {value: Promise.reject(error_1)}];
                      }
                      return [3, 5];
                    case 5:
                      return [2];
                  }
                });
              };
              this_1 = this;
              _d.label = 1;
            case 1:
              return [5, _loop_2()];
            case 2:
              state_1 = _d.sent();
              if (typeof state_1 === "object")
                return [2, state_1.value];
              return [3, 1];
            case 3:
              return [2];
          }
        });
      });
    };
    SimpleDb2.prototype.close = function() {
      if (this.db) {
        this.db.close();
      }
      this.db = void 0;
    };
    return SimpleDb2;
  }();
  var IterationController = function() {
    function IterationController2(dbCursor) {
      this.dbCursor = dbCursor;
      this.shouldStop = false;
      this.nextKey = null;
    }
    Object.defineProperty(IterationController2.prototype, "isDone", {
      get: function() {
        return this.shouldStop;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IterationController2.prototype, "skipToKey", {
      get: function() {
        return this.nextKey;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(IterationController2.prototype, "cursor", {
      set: function(value) {
        this.dbCursor = value;
      },
      enumerable: false,
      configurable: true
    });
    IterationController2.prototype.done = function() {
      this.shouldStop = true;
    };
    IterationController2.prototype.skip = function(key) {
      this.nextKey = key;
    };
    IterationController2.prototype.delete = function() {
      return wrapRequest(this.dbCursor.delete());
    };
    return IterationController2;
  }();
  var IndexedDbTransactionError = function(_super) {
    tslib.__extends(IndexedDbTransactionError2, _super);
    function IndexedDbTransactionError2(actionName, cause) {
      var _this = _super.call(this, Code.UNAVAILABLE, "IndexedDB transaction '" + actionName + "' failed: " + cause) || this;
      _this.name = "IndexedDbTransactionError";
      return _this;
    }
    return IndexedDbTransactionError2;
  }(FirestoreError);
  function isIndexedDbTransactionError(e) {
    return e.name === "IndexedDbTransactionError";
  }
  var SimpleDbStore = function() {
    function SimpleDbStore2(store) {
      this.store = store;
    }
    SimpleDbStore2.prototype.put = function(keyOrValue, value) {
      var request;
      if (value !== void 0) {
        logDebug(LOG_TAG, "PUT", this.store.name, keyOrValue, value);
        request = this.store.put(value, keyOrValue);
      } else {
        logDebug(LOG_TAG, "PUT", this.store.name, "<auto-key>", keyOrValue);
        request = this.store.put(keyOrValue);
      }
      return wrapRequest(request);
    };
    SimpleDbStore2.prototype.add = function(value) {
      logDebug(LOG_TAG, "ADD", this.store.name, value, value);
      var request = this.store.add(value);
      return wrapRequest(request);
    };
    SimpleDbStore2.prototype.get = function(key) {
      var _this = this;
      var request = this.store.get(key);
      return wrapRequest(request).next(function(result) {
        if (result === void 0) {
          result = null;
        }
        logDebug(LOG_TAG, "GET", _this.store.name, key, result);
        return result;
      });
    };
    SimpleDbStore2.prototype.delete = function(key) {
      logDebug(LOG_TAG, "DELETE", this.store.name, key);
      var request = this.store.delete(key);
      return wrapRequest(request);
    };
    SimpleDbStore2.prototype.count = function() {
      logDebug(LOG_TAG, "COUNT", this.store.name);
      var request = this.store.count();
      return wrapRequest(request);
    };
    SimpleDbStore2.prototype.loadAll = function(indexOrRange, range) {
      var cursor = this.cursor(this.options(indexOrRange, range));
      var results = [];
      return this.iterateCursor(cursor, function(key, value) {
        results.push(value);
      }).next(function() {
        return results;
      });
    };
    SimpleDbStore2.prototype.deleteAll = function(indexOrRange, range) {
      logDebug(LOG_TAG, "DELETE ALL", this.store.name);
      var options = this.options(indexOrRange, range);
      options.keysOnly = false;
      var cursor = this.cursor(options);
      return this.iterateCursor(cursor, function(key, value, control) {
        return control.delete();
      });
    };
    SimpleDbStore2.prototype.iterate = function(optionsOrCallback, callback) {
      var options;
      if (!callback) {
        options = {};
        callback = optionsOrCallback;
      } else {
        options = optionsOrCallback;
      }
      var cursor = this.cursor(options);
      return this.iterateCursor(cursor, callback);
    };
    SimpleDbStore2.prototype.iterateSerial = function(callback) {
      var cursorRequest = this.cursor({});
      return new PersistencePromise(function(resolve, reject) {
        cursorRequest.onerror = function(event) {
          var error = checkForAndReportiOSError(event.target.error);
          reject(error);
        };
        cursorRequest.onsuccess = function(event) {
          var cursor = event.target.result;
          if (!cursor) {
            resolve();
            return;
          }
          callback(cursor.primaryKey, cursor.value).next(function(shouldContinue) {
            if (shouldContinue) {
              cursor.continue();
            } else {
              resolve();
            }
          });
        };
      });
    };
    SimpleDbStore2.prototype.iterateCursor = function(cursorRequest, fn) {
      var results = [];
      return new PersistencePromise(function(resolve, reject) {
        cursorRequest.onerror = function(event) {
          reject(event.target.error);
        };
        cursorRequest.onsuccess = function(event) {
          var cursor = event.target.result;
          if (!cursor) {
            resolve();
            return;
          }
          var controller = new IterationController(cursor);
          var userResult = fn(cursor.primaryKey, cursor.value, controller);
          if (userResult instanceof PersistencePromise) {
            var userPromise = userResult.catch(function(err) {
              controller.done();
              return PersistencePromise.reject(err);
            });
            results.push(userPromise);
          }
          if (controller.isDone) {
            resolve();
          } else if (controller.skipToKey === null) {
            cursor.continue();
          } else {
            cursor.continue(controller.skipToKey);
          }
        };
      }).next(function() {
        return PersistencePromise.waitFor(results);
      });
    };
    SimpleDbStore2.prototype.options = function(indexOrRange, range) {
      var indexName = void 0;
      if (indexOrRange !== void 0) {
        if (typeof indexOrRange === "string") {
          indexName = indexOrRange;
        } else {
          range = indexOrRange;
        }
      }
      return {index: indexName, range};
    };
    SimpleDbStore2.prototype.cursor = function(options) {
      var direction = "next";
      if (options.reverse) {
        direction = "prev";
      }
      if (options.index) {
        var index = this.store.index(options.index);
        if (options.keysOnly) {
          return index.openKeyCursor(options.range, direction);
        } else {
          return index.openCursor(options.range, direction);
        }
      } else {
        return this.store.openCursor(options.range, direction);
      }
    };
    return SimpleDbStore2;
  }();
  function wrapRequest(request) {
    return new PersistencePromise(function(resolve, reject) {
      request.onsuccess = function(event) {
        var result = event.target.result;
        resolve(result);
      };
      request.onerror = function(event) {
        var error = checkForAndReportiOSError(event.target.error);
        reject(error);
      };
    });
  }
  var reportedIOSError = false;
  function checkForAndReportiOSError(error) {
    var iOSVersion = SimpleDb.getIOSVersion(util.getUA());
    if (iOSVersion >= 12.2 && iOSVersion < 13) {
      var IOS_ERROR = "An internal error was encountered in the Indexed Database server";
      if (error.message.indexOf(IOS_ERROR) >= 0) {
        var newError_1 = new FirestoreError("internal", "IOS_INDEXEDDB_BUG1: IndexedDb has thrown '" + IOS_ERROR + "'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
        if (!reportedIOSError) {
          reportedIOSError = true;
          setTimeout(function() {
            throw newError_1;
          }, 0);
        }
        return newError_1;
      }
    }
    return error;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var IndexedDbTransaction = function(_super) {
    tslib.__extends(IndexedDbTransaction2, _super);
    function IndexedDbTransaction2(simpleDbTransaction, currentSequenceNumber) {
      var _this = _super.call(this) || this;
      _this.simpleDbTransaction = simpleDbTransaction;
      _this.currentSequenceNumber = currentSequenceNumber;
      return _this;
    }
    return IndexedDbTransaction2;
  }(PersistenceTransaction);
  function getStore(txn, store) {
    var indexedDbTransaction = debugCast(txn);
    return SimpleDb.getStore(indexedDbTransaction.simpleDbTransaction, store);
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function randomBytes(nBytes) {
    return crypto2.randomBytes(nBytes);
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var AutoId = function() {
    function AutoId2() {
    }
    AutoId2.newId = function() {
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      var maxMultiple = Math.floor(256 / chars.length) * chars.length;
      var autoId = "";
      var targetLength = 20;
      while (autoId.length < targetLength) {
        var bytes = randomBytes(40);
        for (var i = 0; i < bytes.length; ++i) {
          if (autoId.length < targetLength && bytes[i] < maxMultiple) {
            autoId += chars.charAt(bytes[i] % chars.length);
          }
        }
      }
      return autoId;
    };
    return AutoId2;
  }();
  function primitiveComparator(left, right) {
    if (left < right) {
      return -1;
    }
    if (left > right) {
      return 1;
    }
    return 0;
  }
  function arrayEquals(left, right, comparator) {
    if (left.length !== right.length) {
      return false;
    }
    return left.every(function(value, index) {
      return comparator(value, right[index]);
    });
  }
  function immediateSuccessor(s) {
    return s + "\0";
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var MIN_SECONDS = -62135596800;
  var Timestamp = function() {
    function Timestamp2(seconds, nanoseconds) {
      this.seconds = seconds;
      this.nanoseconds = nanoseconds;
      if (nanoseconds < 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + nanoseconds);
      }
      if (nanoseconds >= 1e9) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + nanoseconds);
      }
      if (seconds < MIN_SECONDS) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp seconds out of range: " + seconds);
      }
      if (seconds >= 253402300800) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp seconds out of range: " + seconds);
      }
    }
    Timestamp2.now = function() {
      return Timestamp2.fromMillis(Date.now());
    };
    Timestamp2.fromDate = function(date) {
      return Timestamp2.fromMillis(date.getTime());
    };
    Timestamp2.fromMillis = function(milliseconds) {
      var seconds = Math.floor(milliseconds / 1e3);
      var nanos = (milliseconds - seconds * 1e3) * 1e6;
      return new Timestamp2(seconds, nanos);
    };
    Timestamp2.prototype.toDate = function() {
      return new Date(this.toMillis());
    };
    Timestamp2.prototype.toMillis = function() {
      return this.seconds * 1e3 + this.nanoseconds / 1e6;
    };
    Timestamp2.prototype._compareTo = function(other) {
      if (this.seconds === other.seconds) {
        return primitiveComparator(this.nanoseconds, other.nanoseconds);
      }
      return primitiveComparator(this.seconds, other.seconds);
    };
    Timestamp2.prototype.isEqual = function(other) {
      return other.seconds === this.seconds && other.nanoseconds === this.nanoseconds;
    };
    Timestamp2.prototype.toString = function() {
      return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
    };
    Timestamp2.prototype.toJSON = function() {
      return {seconds: this.seconds, nanoseconds: this.nanoseconds};
    };
    Timestamp2.prototype.valueOf = function() {
      var adjustedSeconds = this.seconds - MIN_SECONDS;
      var formattedSeconds = String(adjustedSeconds).padStart(12, "0");
      var formattedNanoseconds = String(this.nanoseconds).padStart(9, "0");
      return formattedSeconds + "." + formattedNanoseconds;
    };
    return Timestamp2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var SnapshotVersion = function() {
    function SnapshotVersion2(timestamp) {
      this.timestamp = timestamp;
    }
    SnapshotVersion2.fromTimestamp = function(value) {
      return new SnapshotVersion2(value);
    };
    SnapshotVersion2.min = function() {
      return new SnapshotVersion2(new Timestamp(0, 0));
    };
    SnapshotVersion2.prototype.compareTo = function(other) {
      return this.timestamp._compareTo(other.timestamp);
    };
    SnapshotVersion2.prototype.isEqual = function(other) {
      return this.timestamp.isEqual(other.timestamp);
    };
    SnapshotVersion2.prototype.toMicroseconds = function() {
      return this.timestamp.seconds * 1e6 + this.timestamp.nanoseconds / 1e3;
    };
    SnapshotVersion2.prototype.toString = function() {
      return "SnapshotVersion(" + this.timestamp.toString() + ")";
    };
    SnapshotVersion2.prototype.toTimestamp = function() {
      return this.timestamp;
    };
    return SnapshotVersion2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function objectSize(obj) {
    var count = 0;
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        count++;
      }
    }
    return count;
  }
  function forEach(obj, fn) {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn(key, obj[key]);
      }
    }
  }
  function isEmpty(obj) {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return false;
      }
    }
    return true;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var FieldMask = function() {
    function FieldMask2(fields) {
      this.fields = fields;
      fields.sort(FieldPath.comparator);
    }
    FieldMask2.prototype.covers = function(fieldPath) {
      for (var _i = 0, _d = this.fields; _i < _d.length; _i++) {
        var fieldMaskPath = _d[_i];
        if (fieldMaskPath.isPrefixOf(fieldPath)) {
          return true;
        }
      }
      return false;
    };
    FieldMask2.prototype.isEqual = function(other) {
      return arrayEquals(this.fields, other.fields, function(l, r) {
        return l.isEqual(r);
      });
    };
    return FieldMask2;
  }();
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function decodeBase64(encoded) {
    if (/[^-A-Za-z0-9+/=]/.test(encoded)) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Not a valid Base64 string: " + encoded);
    }
    return new Buffer(encoded, "base64").toString("binary");
  }
  function encodeBase64(raw) {
    return new Buffer(raw, "binary").toString("base64");
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var ByteString = function() {
    function ByteString2(binaryString) {
      this.binaryString = binaryString;
    }
    ByteString2.fromBase64String = function(base64) {
      var binaryString = decodeBase64(base64);
      return new ByteString2(binaryString);
    };
    ByteString2.fromUint8Array = function(array) {
      var binaryString = binaryStringFromUint8Array(array);
      return new ByteString2(binaryString);
    };
    ByteString2.prototype.toBase64 = function() {
      return encodeBase64(this.binaryString);
    };
    ByteString2.prototype.toUint8Array = function() {
      return uint8ArrayFromBinaryString(this.binaryString);
    };
    ByteString2.prototype.approximateByteSize = function() {
      return this.binaryString.length * 2;
    };
    ByteString2.prototype.compareTo = function(other) {
      return primitiveComparator(this.binaryString, other.binaryString);
    };
    ByteString2.prototype.isEqual = function(other) {
      return this.binaryString === other.binaryString;
    };
    return ByteString2;
  }();
  ByteString.EMPTY_BYTE_STRING = new ByteString("");
  function binaryStringFromUint8Array(array) {
    var binaryString = "";
    for (var i = 0; i < array.length; ++i) {
      binaryString += String.fromCharCode(array[i]);
    }
    return binaryString;
  }
  function uint8ArrayFromBinaryString(binaryString) {
    var buffer = new Uint8Array(binaryString.length);
    for (var i = 0; i < binaryString.length; i++) {
      buffer[i] = binaryString.charCodeAt(i);
    }
    return buffer;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var ISO_TIMESTAMP_REG_EXP = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
  function normalizeTimestamp(date) {
    hardAssert(!!date);
    if (typeof date === "string") {
      var nanos = 0;
      var fraction = ISO_TIMESTAMP_REG_EXP.exec(date);
      hardAssert(!!fraction);
      if (fraction[1]) {
        var nanoStr = fraction[1];
        nanoStr = (nanoStr + "000000000").substr(0, 9);
        nanos = Number(nanoStr);
      }
      var parsedDate = new Date(date);
      var seconds = Math.floor(parsedDate.getTime() / 1e3);
      return {seconds, nanos};
    } else {
      var seconds = normalizeNumber(date.seconds);
      var nanos = normalizeNumber(date.nanos);
      return {seconds, nanos};
    }
  }
  function normalizeNumber(value) {
    if (typeof value === "number") {
      return value;
    } else if (typeof value === "string") {
      return Number(value);
    } else {
      return 0;
    }
  }
  function normalizeByteString(blob) {
    if (typeof blob === "string") {
      return ByteString.fromBase64String(blob);
    } else {
      return ByteString.fromUint8Array(blob);
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var SERVER_TIMESTAMP_SENTINEL = "server_timestamp";
  var TYPE_KEY = "__type__";
  var PREVIOUS_VALUE_KEY = "__previous_value__";
  var LOCAL_WRITE_TIME_KEY = "__local_write_time__";
  function isServerTimestamp(value) {
    var _a, _b;
    var type = (_b = (((_a = value === null || value === void 0 ? void 0 : value.mapValue) === null || _a === void 0 ? void 0 : _a.fields) || {})[TYPE_KEY]) === null || _b === void 0 ? void 0 : _b.stringValue;
    return type === SERVER_TIMESTAMP_SENTINEL;
  }
  function serverTimestamp(localWriteTime, previousValue) {
    var _d;
    var mapValue = {
      fields: (_d = {}, _d[TYPE_KEY] = {
        stringValue: SERVER_TIMESTAMP_SENTINEL
      }, _d[LOCAL_WRITE_TIME_KEY] = {
        timestampValue: {
          seconds: localWriteTime.seconds,
          nanos: localWriteTime.nanoseconds
        }
      }, _d)
    };
    if (previousValue) {
      mapValue.fields[PREVIOUS_VALUE_KEY] = previousValue;
    }
    return {mapValue};
  }
  function getPreviousValue(value) {
    var previousValue = value.mapValue.fields[PREVIOUS_VALUE_KEY];
    if (isServerTimestamp(previousValue)) {
      return getPreviousValue(previousValue);
    }
    return previousValue;
  }
  function getLocalWriteTime(value) {
    var localWriteTime = normalizeTimestamp(value.mapValue.fields[LOCAL_WRITE_TIME_KEY].timestampValue);
    return new Timestamp(localWriteTime.seconds, localWriteTime.nanos);
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var BATCHID_UNKNOWN = -1;
  function isNullOrUndefined(value) {
    return value === null || value === void 0;
  }
  function isNegativeZero(value) {
    return value === 0 && 1 / value === 1 / -0;
  }
  function isSafeInteger(value) {
    return typeof value === "number" && Number.isInteger(value) && !isNegativeZero(value) && value <= Number.MAX_SAFE_INTEGER && value >= Number.MIN_SAFE_INTEGER;
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var DocumentKey = function() {
    function DocumentKey2(path2) {
      this.path = path2;
    }
    DocumentKey2.fromPath = function(path2) {
      return new DocumentKey2(ResourcePath.fromString(path2));
    };
    DocumentKey2.fromName = function(name) {
      return new DocumentKey2(ResourcePath.fromString(name).popFirst(5));
    };
    DocumentKey2.prototype.hasCollectionId = function(collectionId) {
      return this.path.length >= 2 && this.path.get(this.path.length - 2) === collectionId;
    };
    DocumentKey2.prototype.isEqual = function(other) {
      return other !== null && ResourcePath.comparator(this.path, other.path) === 0;
    };
    DocumentKey2.prototype.toString = function() {
      return this.path.toString();
    };
    DocumentKey2.comparator = function(k1, k2) {
      return ResourcePath.comparator(k1.path, k2.path);
    };
    DocumentKey2.isDocumentKey = function(path2) {
      return path2.length % 2 === 0;
    };
    DocumentKey2.fromSegments = function(segments) {
      return new DocumentKey2(new ResourcePath(segments.slice()));
    };
    return DocumentKey2;
  }();
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function typeOrder(value) {
    if ("nullValue" in value) {
      return 0;
    } else if ("booleanValue" in value) {
      return 1;
    } else if ("integerValue" in value || "doubleValue" in value) {
      return 2;
    } else if ("timestampValue" in value) {
      return 3;
    } else if ("stringValue" in value) {
      return 5;
    } else if ("bytesValue" in value) {
      return 6;
    } else if ("referenceValue" in value) {
      return 7;
    } else if ("geoPointValue" in value) {
      return 8;
    } else if ("arrayValue" in value) {
      return 9;
    } else if ("mapValue" in value) {
      if (isServerTimestamp(value)) {
        return 4;
      }
      return 10;
    } else {
      return fail();
    }
  }
  function valueEquals(left, right) {
    var leftType = typeOrder(left);
    var rightType = typeOrder(right);
    if (leftType !== rightType) {
      return false;
    }
    switch (leftType) {
      case 0:
        return true;
      case 1:
        return left.booleanValue === right.booleanValue;
      case 4:
        return getLocalWriteTime(left).isEqual(getLocalWriteTime(right));
      case 3:
        return timestampEquals(left, right);
      case 5:
        return left.stringValue === right.stringValue;
      case 6:
        return blobEquals(left, right);
      case 7:
        return left.referenceValue === right.referenceValue;
      case 8:
        return geoPointEquals(left, right);
      case 2:
        return numberEquals(left, right);
      case 9:
        return arrayEquals(left.arrayValue.values || [], right.arrayValue.values || [], valueEquals);
      case 10:
        return objectEquals(left, right);
      default:
        return fail();
    }
  }
  function timestampEquals(left, right) {
    if (typeof left.timestampValue === "string" && typeof right.timestampValue === "string" && left.timestampValue.length === right.timestampValue.length) {
      return left.timestampValue === right.timestampValue;
    }
    var leftTimestamp = normalizeTimestamp(left.timestampValue);
    var rightTimestamp = normalizeTimestamp(right.timestampValue);
    return leftTimestamp.seconds === rightTimestamp.seconds && leftTimestamp.nanos === rightTimestamp.nanos;
  }
  function geoPointEquals(left, right) {
    return normalizeNumber(left.geoPointValue.latitude) === normalizeNumber(right.geoPointValue.latitude) && normalizeNumber(left.geoPointValue.longitude) === normalizeNumber(right.geoPointValue.longitude);
  }
  function blobEquals(left, right) {
    return normalizeByteString(left.bytesValue).isEqual(normalizeByteString(right.bytesValue));
  }
  function numberEquals(left, right) {
    if ("integerValue" in left && "integerValue" in right) {
      return normalizeNumber(left.integerValue) === normalizeNumber(right.integerValue);
    } else if ("doubleValue" in left && "doubleValue" in right) {
      var n1 = normalizeNumber(left.doubleValue);
      var n2 = normalizeNumber(right.doubleValue);
      if (n1 === n2) {
        return isNegativeZero(n1) === isNegativeZero(n2);
      } else {
        return isNaN(n1) && isNaN(n2);
      }
    }
    return false;
  }
  function objectEquals(left, right) {
    var leftMap = left.mapValue.fields || {};
    var rightMap = right.mapValue.fields || {};
    if (objectSize(leftMap) !== objectSize(rightMap)) {
      return false;
    }
    for (var key in leftMap) {
      if (leftMap.hasOwnProperty(key)) {
        if (rightMap[key] === void 0 || !valueEquals(leftMap[key], rightMap[key])) {
          return false;
        }
      }
    }
    return true;
  }
  function arrayValueContains(haystack, needle) {
    return (haystack.values || []).find(function(v) {
      return valueEquals(v, needle);
    }) !== void 0;
  }
  function valueCompare(left, right) {
    var leftType = typeOrder(left);
    var rightType = typeOrder(right);
    if (leftType !== rightType) {
      return primitiveComparator(leftType, rightType);
    }
    switch (leftType) {
      case 0:
        return 0;
      case 1:
        return primitiveComparator(left.booleanValue, right.booleanValue);
      case 2:
        return compareNumbers(left, right);
      case 3:
        return compareTimestamps(left.timestampValue, right.timestampValue);
      case 4:
        return compareTimestamps(getLocalWriteTime(left), getLocalWriteTime(right));
      case 5:
        return primitiveComparator(left.stringValue, right.stringValue);
      case 6:
        return compareBlobs(left.bytesValue, right.bytesValue);
      case 7:
        return compareReferences(left.referenceValue, right.referenceValue);
      case 8:
        return compareGeoPoints(left.geoPointValue, right.geoPointValue);
      case 9:
        return compareArrays(left.arrayValue, right.arrayValue);
      case 10:
        return compareMaps(left.mapValue, right.mapValue);
      default:
        throw fail();
    }
  }
  function compareNumbers(left, right) {
    var leftNumber = normalizeNumber(left.integerValue || left.doubleValue);
    var rightNumber = normalizeNumber(right.integerValue || right.doubleValue);
    if (leftNumber < rightNumber) {
      return -1;
    } else if (leftNumber > rightNumber) {
      return 1;
    } else if (leftNumber === rightNumber) {
      return 0;
    } else {
      if (isNaN(leftNumber)) {
        return isNaN(rightNumber) ? 0 : -1;
      } else {
        return 1;
      }
    }
  }
  function compareTimestamps(left, right) {
    if (typeof left === "string" && typeof right === "string" && left.length === right.length) {
      return primitiveComparator(left, right);
    }
    var leftTimestamp = normalizeTimestamp(left);
    var rightTimestamp = normalizeTimestamp(right);
    var comparison = primitiveComparator(leftTimestamp.seconds, rightTimestamp.seconds);
    if (comparison !== 0) {
      return comparison;
    }
    return primitiveComparator(leftTimestamp.nanos, rightTimestamp.nanos);
  }
  function compareReferences(leftPath, rightPath) {
    var leftSegments = leftPath.split("/");
    var rightSegments = rightPath.split("/");
    for (var i = 0; i < leftSegments.length && i < rightSegments.length; i++) {
      var comparison = primitiveComparator(leftSegments[i], rightSegments[i]);
      if (comparison !== 0) {
        return comparison;
      }
    }
    return primitiveComparator(leftSegments.length, rightSegments.length);
  }
  function compareGeoPoints(left, right) {
    var comparison = primitiveComparator(normalizeNumber(left.latitude), normalizeNumber(right.latitude));
    if (comparison !== 0) {
      return comparison;
    }
    return primitiveComparator(normalizeNumber(left.longitude), normalizeNumber(right.longitude));
  }
  function compareBlobs(left, right) {
    var leftBytes = normalizeByteString(left);
    var rightBytes = normalizeByteString(right);
    return leftBytes.compareTo(rightBytes);
  }
  function compareArrays(left, right) {
    var leftArray = left.values || [];
    var rightArray = right.values || [];
    for (var i = 0; i < leftArray.length && i < rightArray.length; ++i) {
      var compare = valueCompare(leftArray[i], rightArray[i]);
      if (compare) {
        return compare;
      }
    }
    return primitiveComparator(leftArray.length, rightArray.length);
  }
  function compareMaps(left, right) {
    var leftMap = left.fields || {};
    var leftKeys = Object.keys(leftMap);
    var rightMap = right.fields || {};
    var rightKeys = Object.keys(rightMap);
    leftKeys.sort();
    rightKeys.sort();
    for (var i = 0; i < leftKeys.length && i < rightKeys.length; ++i) {
      var keyCompare = primitiveComparator(leftKeys[i], rightKeys[i]);
      if (keyCompare !== 0) {
        return keyCompare;
      }
      var compare = valueCompare(leftMap[leftKeys[i]], rightMap[rightKeys[i]]);
      if (compare !== 0) {
        return compare;
      }
    }
    return primitiveComparator(leftKeys.length, rightKeys.length);
  }
  function canonicalId(value) {
    return canonifyValue(value);
  }
  function canonifyValue(value) {
    if ("nullValue" in value) {
      return "null";
    } else if ("booleanValue" in value) {
      return "" + value.booleanValue;
    } else if ("integerValue" in value) {
      return "" + value.integerValue;
    } else if ("doubleValue" in value) {
      return "" + value.doubleValue;
    } else if ("timestampValue" in value) {
      return canonifyTimestamp(value.timestampValue);
    } else if ("stringValue" in value) {
      return value.stringValue;
    } else if ("bytesValue" in value) {
      return canonifyByteString(value.bytesValue);
    } else if ("referenceValue" in value) {
      return canonifyReference(value.referenceValue);
    } else if ("geoPointValue" in value) {
      return canonifyGeoPoint(value.geoPointValue);
    } else if ("arrayValue" in value) {
      return canonifyArray(value.arrayValue);
    } else if ("mapValue" in value) {
      return canonifyMap(value.mapValue);
    } else {
      return fail();
    }
  }
  function canonifyByteString(byteString) {
    return normalizeByteString(byteString).toBase64();
  }
  function canonifyTimestamp(timestamp) {
    var normalizedTimestamp = normalizeTimestamp(timestamp);
    return "time(" + normalizedTimestamp.seconds + "," + normalizedTimestamp.nanos + ")";
  }
  function canonifyGeoPoint(geoPoint) {
    return "geo(" + geoPoint.latitude + "," + geoPoint.longitude + ")";
  }
  function canonifyReference(referenceValue) {
    return DocumentKey.fromName(referenceValue).toString();
  }
  function canonifyMap(mapValue) {
    var sortedKeys = Object.keys(mapValue.fields || {}).sort();
    var result = "{";
    var first = true;
    for (var _i = 0, sortedKeys_1 = sortedKeys; _i < sortedKeys_1.length; _i++) {
      var key = sortedKeys_1[_i];
      if (!first) {
        result += ",";
      } else {
        first = false;
      }
      result += key + ":" + canonifyValue(mapValue.fields[key]);
    }
    return result + "}";
  }
  function canonifyArray(arrayValue) {
    var result = "[";
    var first = true;
    for (var _i = 0, _d = arrayValue.values || []; _i < _d.length; _i++) {
      var value = _d[_i];
      if (!first) {
        result += ",";
      } else {
        first = false;
      }
      result += canonifyValue(value);
    }
    return result + "]";
  }
  function refValue(databaseId, key) {
    return {
      referenceValue: "projects/" + databaseId.projectId + "/databases/" + databaseId.database + "/documents/" + key.path.canonicalString()
    };
  }
  function isInteger(value) {
    return !!value && "integerValue" in value;
  }
  function isDouble(value) {
    return !!value && "doubleValue" in value;
  }
  function isNumber(value) {
    return isInteger(value) || isDouble(value);
  }
  function isArray(value) {
    return !!value && "arrayValue" in value;
  }
  function isNullValue(value) {
    return !!value && "nullValue" in value;
  }
  function isNanValue(value) {
    return !!value && "doubleValue" in value && isNaN(Number(value.doubleValue));
  }
  function isMapValue(value) {
    return !!value && "mapValue" in value;
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var ObjectValue = function() {
    function ObjectValue2(proto) {
      this.overlayMap = new Map();
      this.partialValue = proto;
    }
    ObjectValue2.empty = function() {
      return new ObjectValue2({mapValue: {}});
    };
    ObjectValue2.prototype.field = function(path2) {
      return ObjectValue2.extractNestedValue(this.buildProto(), path2);
    };
    ObjectValue2.prototype.toProto = function() {
      return this.field(FieldPath.emptyPath());
    };
    ObjectValue2.prototype.set = function(path2, value) {
      this.setOverlay(path2, value);
    };
    ObjectValue2.prototype.setAll = function(data) {
      var _this = this;
      data.forEach(function(value, fieldPath) {
        if (value) {
          _this.set(fieldPath, value);
        } else {
          _this.delete(fieldPath);
        }
      });
    };
    ObjectValue2.prototype.delete = function(path2) {
      this.setOverlay(path2, null);
    };
    ObjectValue2.prototype.isEqual = function(other) {
      return valueEquals(this.buildProto(), other.buildProto());
    };
    ObjectValue2.prototype.setOverlay = function(path2, value) {
      var currentLevel = this.overlayMap;
      for (var i = 0; i < path2.length - 1; ++i) {
        var currentSegment = path2.get(i);
        var currentValue = currentLevel.get(currentSegment);
        if (currentValue instanceof Map) {
          currentLevel = currentValue;
        } else if (currentValue && typeOrder(currentValue) === 10) {
          currentValue = new Map(Object.entries(currentValue.mapValue.fields || {}));
          currentLevel.set(currentSegment, currentValue);
          currentLevel = currentValue;
        } else {
          currentValue = new Map();
          currentLevel.set(currentSegment, currentValue);
          currentLevel = currentValue;
        }
      }
      currentLevel.set(path2.lastSegment(), value);
    };
    ObjectValue2.prototype.applyOverlay = function(currentPath, currentOverlays) {
      var _this = this;
      var modified = false;
      var existingValue = ObjectValue2.extractNestedValue(this.partialValue, currentPath);
      var resultAtPath = isMapValue(existingValue) ? Object.assign({}, existingValue.mapValue.fields) : {};
      currentOverlays.forEach(function(value, pathSegment) {
        if (value instanceof Map) {
          var nested = _this.applyOverlay(currentPath.child(pathSegment), value);
          if (nested != null) {
            resultAtPath[pathSegment] = nested;
            modified = true;
          }
        } else if (value !== null) {
          resultAtPath[pathSegment] = value;
          modified = true;
        } else if (resultAtPath.hasOwnProperty(pathSegment)) {
          delete resultAtPath[pathSegment];
          modified = true;
        }
      });
      return modified ? {mapValue: {fields: resultAtPath}} : null;
    };
    ObjectValue2.prototype.buildProto = function() {
      var mergedResult = this.applyOverlay(FieldPath.emptyPath(), this.overlayMap);
      if (mergedResult != null) {
        this.partialValue = mergedResult;
        this.overlayMap.clear();
      }
      return this.partialValue;
    };
    ObjectValue2.extractNestedValue = function(proto, path2) {
      if (path2.isEmpty()) {
        return proto;
      } else {
        var value = proto;
        for (var i = 0; i < path2.length - 1; ++i) {
          if (!value.mapValue.fields) {
            return null;
          }
          value = value.mapValue.fields[path2.get(i)];
          if (!isMapValue(value)) {
            return null;
          }
        }
        value = (value.mapValue.fields || {})[path2.lastSegment()];
        return value || null;
      }
    };
    ObjectValue2.prototype.clone = function() {
      return new ObjectValue2(this.buildProto());
    };
    return ObjectValue2;
  }();
  function extractFieldMask(value) {
    var fields = [];
    forEach(value.fields || {}, function(key, value2) {
      var currentPath = new FieldPath([key]);
      if (isMapValue(value2)) {
        var nestedMask = extractFieldMask(value2.mapValue);
        var nestedFields = nestedMask.fields;
        if (nestedFields.length === 0) {
          fields.push(currentPath);
        } else {
          for (var _i = 0, nestedFields_1 = nestedFields; _i < nestedFields_1.length; _i++) {
            var nestedPath = nestedFields_1[_i];
            fields.push(currentPath.child(nestedPath));
          }
        }
      } else {
        fields.push(currentPath);
      }
    });
    return new FieldMask(fields);
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var MutableDocument = function() {
    function MutableDocument2(key, documentType, version2, data, documentState) {
      this.key = key;
      this.documentType = documentType;
      this.version = version2;
      this.data = data;
      this.documentState = documentState;
    }
    MutableDocument2.newInvalidDocument = function(documentKey) {
      return new MutableDocument2(documentKey, 0, SnapshotVersion.min(), ObjectValue.empty(), 0);
    };
    MutableDocument2.newFoundDocument = function(documentKey, version2, value) {
      return new MutableDocument2(documentKey, 1, version2, value, 0);
    };
    MutableDocument2.newNoDocument = function(documentKey, version2) {
      return new MutableDocument2(documentKey, 2, version2, ObjectValue.empty(), 0);
    };
    MutableDocument2.newUnknownDocument = function(documentKey, version2) {
      return new MutableDocument2(documentKey, 3, version2, ObjectValue.empty(), 2);
    };
    MutableDocument2.prototype.convertToFoundDocument = function(version2, value) {
      this.version = version2;
      this.documentType = 1;
      this.data = value;
      this.documentState = 0;
      return this;
    };
    MutableDocument2.prototype.convertToNoDocument = function(version2) {
      this.version = version2;
      this.documentType = 2;
      this.data = ObjectValue.empty();
      this.documentState = 0;
      return this;
    };
    MutableDocument2.prototype.convertToUnknownDocument = function(version2) {
      this.version = version2;
      this.documentType = 3;
      this.data = ObjectValue.empty();
      this.documentState = 2;
      return this;
    };
    MutableDocument2.prototype.setHasCommittedMutations = function() {
      this.documentState = 2;
      return this;
    };
    MutableDocument2.prototype.setHasLocalMutations = function() {
      this.documentState = 1;
      return this;
    };
    Object.defineProperty(MutableDocument2.prototype, "hasLocalMutations", {
      get: function() {
        return this.documentState === 1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MutableDocument2.prototype, "hasCommittedMutations", {
      get: function() {
        return this.documentState === 2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MutableDocument2.prototype, "hasPendingWrites", {
      get: function() {
        return this.hasLocalMutations || this.hasCommittedMutations;
      },
      enumerable: false,
      configurable: true
    });
    MutableDocument2.prototype.isValidDocument = function() {
      return this.documentType !== 0;
    };
    MutableDocument2.prototype.isFoundDocument = function() {
      return this.documentType === 1;
    };
    MutableDocument2.prototype.isNoDocument = function() {
      return this.documentType === 2;
    };
    MutableDocument2.prototype.isUnknownDocument = function() {
      return this.documentType === 3;
    };
    MutableDocument2.prototype.isEqual = function(other) {
      return other instanceof MutableDocument2 && this.key.isEqual(other.key) && this.version.isEqual(other.version) && this.documentType === other.documentType && this.documentState === other.documentState && this.data.isEqual(other.data);
    };
    MutableDocument2.prototype.clone = function() {
      return new MutableDocument2(this.key, this.documentType, this.version, this.data.clone(), this.documentState);
    };
    MutableDocument2.prototype.toString = function() {
      return "Document(" + this.key + ", " + this.version + ", " + JSON.stringify(this.data.toProto()) + ", " + ("{documentType: " + this.documentType + "}), ") + ("{documentState: " + this.documentState + "})");
    };
    return MutableDocument2;
  }();
  function compareDocumentsByField(field, d1, d2) {
    var v1 = d1.data.field(field);
    var v2 = d2.data.field(field);
    if (v1 !== null && v2 !== null) {
      return valueCompare(v1, v2);
    } else {
      return fail();
    }
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var TargetImpl = function() {
    function TargetImpl2(path2, collectionGroup2, orderBy2, filters, limit2, startAt2, endAt2) {
      if (collectionGroup2 === void 0) {
        collectionGroup2 = null;
      }
      if (orderBy2 === void 0) {
        orderBy2 = [];
      }
      if (filters === void 0) {
        filters = [];
      }
      if (limit2 === void 0) {
        limit2 = null;
      }
      if (startAt2 === void 0) {
        startAt2 = null;
      }
      if (endAt2 === void 0) {
        endAt2 = null;
      }
      this.path = path2;
      this.collectionGroup = collectionGroup2;
      this.orderBy = orderBy2;
      this.filters = filters;
      this.limit = limit2;
      this.startAt = startAt2;
      this.endAt = endAt2;
      this.memoizedCanonicalId = null;
    }
    return TargetImpl2;
  }();
  function newTarget(path2, collectionGroup2, orderBy2, filters, limit2, startAt2, endAt2) {
    if (collectionGroup2 === void 0) {
      collectionGroup2 = null;
    }
    if (orderBy2 === void 0) {
      orderBy2 = [];
    }
    if (filters === void 0) {
      filters = [];
    }
    if (limit2 === void 0) {
      limit2 = null;
    }
    if (startAt2 === void 0) {
      startAt2 = null;
    }
    if (endAt2 === void 0) {
      endAt2 = null;
    }
    return new TargetImpl(path2, collectionGroup2, orderBy2, filters, limit2, startAt2, endAt2);
  }
  function canonifyTarget(target) {
    var targetImpl = debugCast(target);
    if (targetImpl.memoizedCanonicalId === null) {
      var canonicalId_1 = targetImpl.path.canonicalString();
      if (targetImpl.collectionGroup !== null) {
        canonicalId_1 += "|cg:" + targetImpl.collectionGroup;
      }
      canonicalId_1 += "|f:";
      canonicalId_1 += targetImpl.filters.map(function(f) {
        return canonifyFilter(f);
      }).join(",");
      canonicalId_1 += "|ob:";
      canonicalId_1 += targetImpl.orderBy.map(function(o) {
        return canonifyOrderBy(o);
      }).join(",");
      if (!isNullOrUndefined(targetImpl.limit)) {
        canonicalId_1 += "|l:";
        canonicalId_1 += targetImpl.limit;
      }
      if (targetImpl.startAt) {
        canonicalId_1 += "|lb:";
        canonicalId_1 += canonifyBound(targetImpl.startAt);
      }
      if (targetImpl.endAt) {
        canonicalId_1 += "|ub:";
        canonicalId_1 += canonifyBound(targetImpl.endAt);
      }
      targetImpl.memoizedCanonicalId = canonicalId_1;
    }
    return targetImpl.memoizedCanonicalId;
  }
  function stringifyTarget(target) {
    var str = target.path.canonicalString();
    if (target.collectionGroup !== null) {
      str += " collectionGroup=" + target.collectionGroup;
    }
    if (target.filters.length > 0) {
      str += ", filters: [" + target.filters.map(function(f) {
        return stringifyFilter(f);
      }).join(", ") + "]";
    }
    if (!isNullOrUndefined(target.limit)) {
      str += ", limit: " + target.limit;
    }
    if (target.orderBy.length > 0) {
      str += ", orderBy: [" + target.orderBy.map(function(o) {
        return stringifyOrderBy(o);
      }).join(", ") + "]";
    }
    if (target.startAt) {
      str += ", startAt: " + canonifyBound(target.startAt);
    }
    if (target.endAt) {
      str += ", endAt: " + canonifyBound(target.endAt);
    }
    return "Target(" + str + ")";
  }
  function targetEquals(left, right) {
    if (left.limit !== right.limit) {
      return false;
    }
    if (left.orderBy.length !== right.orderBy.length) {
      return false;
    }
    for (var i = 0; i < left.orderBy.length; i++) {
      if (!orderByEquals(left.orderBy[i], right.orderBy[i])) {
        return false;
      }
    }
    if (left.filters.length !== right.filters.length) {
      return false;
    }
    for (var i = 0; i < left.filters.length; i++) {
      if (!filterEquals(left.filters[i], right.filters[i])) {
        return false;
      }
    }
    if (left.collectionGroup !== right.collectionGroup) {
      return false;
    }
    if (!left.path.isEqual(right.path)) {
      return false;
    }
    if (!boundEquals(left.startAt, right.startAt)) {
      return false;
    }
    return boundEquals(left.endAt, right.endAt);
  }
  function isDocumentTarget(target) {
    return DocumentKey.isDocumentKey(target.path) && target.collectionGroup === null && target.filters.length === 0;
  }
  var Filter = function() {
    function Filter2() {
    }
    return Filter2;
  }();
  var FieldFilter = function(_super) {
    tslib.__extends(FieldFilter2, _super);
    function FieldFilter2(field, op, value) {
      var _this = _super.call(this) || this;
      _this.field = field;
      _this.op = op;
      _this.value = value;
      return _this;
    }
    FieldFilter2.create = function(field, op, value) {
      if (field.isKeyField()) {
        if (op === "in" || op === "not-in") {
          return this.createKeyFieldInFilter(field, op, value);
        } else {
          return new KeyFieldFilter(field, op, value);
        }
      } else if (op === "array-contains") {
        return new ArrayContainsFilter(field, value);
      } else if (op === "in") {
        return new InFilter(field, value);
      } else if (op === "not-in") {
        return new NotInFilter(field, value);
      } else if (op === "array-contains-any") {
        return new ArrayContainsAnyFilter(field, value);
      } else {
        return new FieldFilter2(field, op, value);
      }
    };
    FieldFilter2.createKeyFieldInFilter = function(field, op, value) {
      return op === "in" ? new KeyFieldInFilter(field, value) : new KeyFieldNotInFilter(field, value);
    };
    FieldFilter2.prototype.matches = function(doc2) {
      var other = doc2.data.field(this.field);
      if (this.op === "!=") {
        return other !== null && this.matchesComparison(valueCompare(other, this.value));
      }
      return other !== null && typeOrder(this.value) === typeOrder(other) && this.matchesComparison(valueCompare(other, this.value));
    };
    FieldFilter2.prototype.matchesComparison = function(comparison) {
      switch (this.op) {
        case "<":
          return comparison < 0;
        case "<=":
          return comparison <= 0;
        case "==":
          return comparison === 0;
        case "!=":
          return comparison !== 0;
        case ">":
          return comparison > 0;
        case ">=":
          return comparison >= 0;
        default:
          return fail();
      }
    };
    FieldFilter2.prototype.isInequality = function() {
      return [
        "<",
        "<=",
        ">",
        ">=",
        "!=",
        "not-in"
      ].indexOf(this.op) >= 0;
    };
    return FieldFilter2;
  }(Filter);
  function canonifyFilter(filter) {
    return filter.field.canonicalString() + filter.op.toString() + canonicalId(filter.value);
  }
  function filterEquals(f1, f2) {
    return f1.op === f2.op && f1.field.isEqual(f2.field) && valueEquals(f1.value, f2.value);
  }
  function stringifyFilter(filter) {
    return filter.field.canonicalString() + " " + filter.op + " " + canonicalId(filter.value);
  }
  var KeyFieldFilter = function(_super) {
    tslib.__extends(KeyFieldFilter2, _super);
    function KeyFieldFilter2(field, op, value) {
      var _this = _super.call(this, field, op, value) || this;
      _this.key = DocumentKey.fromName(value.referenceValue);
      return _this;
    }
    KeyFieldFilter2.prototype.matches = function(doc2) {
      var comparison = DocumentKey.comparator(doc2.key, this.key);
      return this.matchesComparison(comparison);
    };
    return KeyFieldFilter2;
  }(FieldFilter);
  var KeyFieldInFilter = function(_super) {
    tslib.__extends(KeyFieldInFilter2, _super);
    function KeyFieldInFilter2(field, value) {
      var _this = _super.call(this, field, "in", value) || this;
      _this.keys = extractDocumentKeysFromArrayValue("in", value);
      return _this;
    }
    KeyFieldInFilter2.prototype.matches = function(doc2) {
      return this.keys.some(function(key) {
        return key.isEqual(doc2.key);
      });
    };
    return KeyFieldInFilter2;
  }(FieldFilter);
  var KeyFieldNotInFilter = function(_super) {
    tslib.__extends(KeyFieldNotInFilter2, _super);
    function KeyFieldNotInFilter2(field, value) {
      var _this = _super.call(this, field, "not-in", value) || this;
      _this.keys = extractDocumentKeysFromArrayValue("not-in", value);
      return _this;
    }
    KeyFieldNotInFilter2.prototype.matches = function(doc2) {
      return !this.keys.some(function(key) {
        return key.isEqual(doc2.key);
      });
    };
    return KeyFieldNotInFilter2;
  }(FieldFilter);
  function extractDocumentKeysFromArrayValue(op, value) {
    var _a;
    return (((_a = value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) || []).map(function(v) {
      return DocumentKey.fromName(v.referenceValue);
    });
  }
  var ArrayContainsFilter = function(_super) {
    tslib.__extends(ArrayContainsFilter2, _super);
    function ArrayContainsFilter2(field, value) {
      return _super.call(this, field, "array-contains", value) || this;
    }
    ArrayContainsFilter2.prototype.matches = function(doc2) {
      var other = doc2.data.field(this.field);
      return isArray(other) && arrayValueContains(other.arrayValue, this.value);
    };
    return ArrayContainsFilter2;
  }(FieldFilter);
  var InFilter = function(_super) {
    tslib.__extends(InFilter2, _super);
    function InFilter2(field, value) {
      return _super.call(this, field, "in", value) || this;
    }
    InFilter2.prototype.matches = function(doc2) {
      var other = doc2.data.field(this.field);
      return other !== null && arrayValueContains(this.value.arrayValue, other);
    };
    return InFilter2;
  }(FieldFilter);
  var NotInFilter = function(_super) {
    tslib.__extends(NotInFilter2, _super);
    function NotInFilter2(field, value) {
      return _super.call(this, field, "not-in", value) || this;
    }
    NotInFilter2.prototype.matches = function(doc2) {
      if (arrayValueContains(this.value.arrayValue, {nullValue: "NULL_VALUE"})) {
        return false;
      }
      var other = doc2.data.field(this.field);
      return other !== null && !arrayValueContains(this.value.arrayValue, other);
    };
    return NotInFilter2;
  }(FieldFilter);
  var ArrayContainsAnyFilter = function(_super) {
    tslib.__extends(ArrayContainsAnyFilter2, _super);
    function ArrayContainsAnyFilter2(field, value) {
      return _super.call(this, field, "array-contains-any", value) || this;
    }
    ArrayContainsAnyFilter2.prototype.matches = function(doc2) {
      var _this = this;
      var other = doc2.data.field(this.field);
      if (!isArray(other) || !other.arrayValue.values) {
        return false;
      }
      return other.arrayValue.values.some(function(val) {
        return arrayValueContains(_this.value.arrayValue, val);
      });
    };
    return ArrayContainsAnyFilter2;
  }(FieldFilter);
  var Bound = function() {
    function Bound2(position, before) {
      this.position = position;
      this.before = before;
    }
    return Bound2;
  }();
  function canonifyBound(bound) {
    return (bound.before ? "b" : "a") + ":" + bound.position.map(function(p) {
      return canonicalId(p);
    }).join(",");
  }
  var OrderBy = function() {
    function OrderBy2(field, dir) {
      if (dir === void 0) {
        dir = "asc";
      }
      this.field = field;
      this.dir = dir;
    }
    return OrderBy2;
  }();
  function canonifyOrderBy(orderBy2) {
    return orderBy2.field.canonicalString() + orderBy2.dir;
  }
  function stringifyOrderBy(orderBy2) {
    return orderBy2.field.canonicalString() + " (" + orderBy2.dir + ")";
  }
  function orderByEquals(left, right) {
    return left.dir === right.dir && left.field.isEqual(right.field);
  }
  function sortsBeforeDocument(bound, orderBy2, doc2) {
    var comparison = 0;
    for (var i = 0; i < bound.position.length; i++) {
      var orderByComponent = orderBy2[i];
      var component = bound.position[i];
      if (orderByComponent.field.isKeyField()) {
        comparison = DocumentKey.comparator(DocumentKey.fromName(component.referenceValue), doc2.key);
      } else {
        var docValue = doc2.data.field(orderByComponent.field);
        comparison = valueCompare(component, docValue);
      }
      if (orderByComponent.dir === "desc") {
        comparison = comparison * -1;
      }
      if (comparison !== 0) {
        break;
      }
    }
    return bound.before ? comparison <= 0 : comparison < 0;
  }
  function boundEquals(left, right) {
    if (left === null) {
      return right === null;
    } else if (right === null) {
      return false;
    }
    if (left.before !== right.before || left.position.length !== right.position.length) {
      return false;
    }
    for (var i = 0; i < left.position.length; i++) {
      var leftPosition = left.position[i];
      var rightPosition = right.position[i];
      if (!valueEquals(leftPosition, rightPosition)) {
        return false;
      }
    }
    return true;
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var QueryImpl = function() {
    function QueryImpl2(path2, collectionGroup2, explicitOrderBy, filters, limit2, limitType, startAt2, endAt2) {
      if (collectionGroup2 === void 0) {
        collectionGroup2 = null;
      }
      if (explicitOrderBy === void 0) {
        explicitOrderBy = [];
      }
      if (filters === void 0) {
        filters = [];
      }
      if (limit2 === void 0) {
        limit2 = null;
      }
      if (limitType === void 0) {
        limitType = "F";
      }
      if (startAt2 === void 0) {
        startAt2 = null;
      }
      if (endAt2 === void 0) {
        endAt2 = null;
      }
      this.path = path2;
      this.collectionGroup = collectionGroup2;
      this.explicitOrderBy = explicitOrderBy;
      this.filters = filters;
      this.limit = limit2;
      this.limitType = limitType;
      this.startAt = startAt2;
      this.endAt = endAt2;
      this.memoizedOrderBy = null;
      this.memoizedTarget = null;
      if (this.startAt)
        ;
      if (this.endAt)
        ;
    }
    return QueryImpl2;
  }();
  function newQuery(path2, collectionGroup2, explicitOrderBy, filters, limit2, limitType, startAt2, endAt2) {
    return new QueryImpl(path2, collectionGroup2, explicitOrderBy, filters, limit2, limitType, startAt2, endAt2);
  }
  function newQueryForPath(path2) {
    return new QueryImpl(path2);
  }
  function asCollectionQueryAtPath(query2, path2) {
    return new QueryImpl(path2, null, query2.explicitOrderBy.slice(), query2.filters.slice(), query2.limit, query2.limitType, query2.startAt, query2.endAt);
  }
  function matchesAllDocuments(query2) {
    return query2.filters.length === 0 && query2.limit === null && query2.startAt == null && query2.endAt == null && (query2.explicitOrderBy.length === 0 || query2.explicitOrderBy.length === 1 && query2.explicitOrderBy[0].field.isKeyField());
  }
  function hasLimitToFirst(query2) {
    return !isNullOrUndefined(query2.limit) && query2.limitType === "F";
  }
  function hasLimitToLast(query2) {
    return !isNullOrUndefined(query2.limit) && query2.limitType === "L";
  }
  function getFirstOrderByField(query2) {
    return query2.explicitOrderBy.length > 0 ? query2.explicitOrderBy[0].field : null;
  }
  function getInequalityFilterField(query2) {
    for (var _i = 0, _d = query2.filters; _i < _d.length; _i++) {
      var filter = _d[_i];
      if (filter.isInequality()) {
        return filter.field;
      }
    }
    return null;
  }
  function findFilterOperator(query2, operators) {
    for (var _i = 0, _d = query2.filters; _i < _d.length; _i++) {
      var filter = _d[_i];
      if (operators.indexOf(filter.op) >= 0) {
        return filter.op;
      }
    }
    return null;
  }
  function newQueryForCollectionGroup(collectionId) {
    return new QueryImpl(ResourcePath.emptyPath(), collectionId);
  }
  function isDocumentQuery(query2) {
    return DocumentKey.isDocumentKey(query2.path) && query2.collectionGroup === null && query2.filters.length === 0;
  }
  function isCollectionGroupQuery(query2) {
    return query2.collectionGroup !== null;
  }
  function queryOrderBy(query2) {
    var queryImpl = debugCast(query2);
    if (queryImpl.memoizedOrderBy === null) {
      queryImpl.memoizedOrderBy = [];
      var inequalityField = getInequalityFilterField(queryImpl);
      var firstOrderByField = getFirstOrderByField(queryImpl);
      if (inequalityField !== null && firstOrderByField === null) {
        if (!inequalityField.isKeyField()) {
          queryImpl.memoizedOrderBy.push(new OrderBy(inequalityField));
        }
        queryImpl.memoizedOrderBy.push(new OrderBy(FieldPath.keyField(), "asc"));
      } else {
        var foundKeyOrdering = false;
        for (var _i = 0, _d = queryImpl.explicitOrderBy; _i < _d.length; _i++) {
          var orderBy_1 = _d[_i];
          queryImpl.memoizedOrderBy.push(orderBy_1);
          if (orderBy_1.field.isKeyField()) {
            foundKeyOrdering = true;
          }
        }
        if (!foundKeyOrdering) {
          var lastDirection = queryImpl.explicitOrderBy.length > 0 ? queryImpl.explicitOrderBy[queryImpl.explicitOrderBy.length - 1].dir : "asc";
          queryImpl.memoizedOrderBy.push(new OrderBy(FieldPath.keyField(), lastDirection));
        }
      }
    }
    return queryImpl.memoizedOrderBy;
  }
  function queryToTarget(query2) {
    var queryImpl = debugCast(query2);
    if (!queryImpl.memoizedTarget) {
      if (queryImpl.limitType === "F") {
        queryImpl.memoizedTarget = newTarget(queryImpl.path, queryImpl.collectionGroup, queryOrderBy(queryImpl), queryImpl.filters, queryImpl.limit, queryImpl.startAt, queryImpl.endAt);
      } else {
        var orderBys = [];
        for (var _i = 0, _d = queryOrderBy(queryImpl); _i < _d.length; _i++) {
          var orderBy_2 = _d[_i];
          var dir = orderBy_2.dir === "desc" ? "asc" : "desc";
          orderBys.push(new OrderBy(orderBy_2.field, dir));
        }
        var startAt_1 = queryImpl.endAt ? new Bound(queryImpl.endAt.position, !queryImpl.endAt.before) : null;
        var endAt_1 = queryImpl.startAt ? new Bound(queryImpl.startAt.position, !queryImpl.startAt.before) : null;
        queryImpl.memoizedTarget = newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, startAt_1, endAt_1);
      }
    }
    return queryImpl.memoizedTarget;
  }
  function queryWithAddedFilter(query2, filter) {
    var newFilters = query2.filters.concat([filter]);
    return new QueryImpl(query2.path, query2.collectionGroup, query2.explicitOrderBy.slice(), newFilters, query2.limit, query2.limitType, query2.startAt, query2.endAt);
  }
  function queryWithAddedOrderBy(query2, orderBy2) {
    var newOrderBy = query2.explicitOrderBy.concat([orderBy2]);
    return new QueryImpl(query2.path, query2.collectionGroup, newOrderBy, query2.filters.slice(), query2.limit, query2.limitType, query2.startAt, query2.endAt);
  }
  function queryWithLimit(query2, limit2, limitType) {
    return new QueryImpl(query2.path, query2.collectionGroup, query2.explicitOrderBy.slice(), query2.filters.slice(), limit2, limitType, query2.startAt, query2.endAt);
  }
  function queryWithStartAt(query2, bound) {
    return new QueryImpl(query2.path, query2.collectionGroup, query2.explicitOrderBy.slice(), query2.filters.slice(), query2.limit, query2.limitType, bound, query2.endAt);
  }
  function queryWithEndAt(query2, bound) {
    return new QueryImpl(query2.path, query2.collectionGroup, query2.explicitOrderBy.slice(), query2.filters.slice(), query2.limit, query2.limitType, query2.startAt, bound);
  }
  function queryEquals(left, right) {
    return targetEquals(queryToTarget(left), queryToTarget(right)) && left.limitType === right.limitType;
  }
  function canonifyQuery(query2) {
    return canonifyTarget(queryToTarget(query2)) + "|lt:" + query2.limitType;
  }
  function stringifyQuery(query2) {
    return "Query(target=" + stringifyTarget(queryToTarget(query2)) + "; limitType=" + query2.limitType + ")";
  }
  function queryMatches(query2, doc2) {
    return doc2.isFoundDocument() && queryMatchesPathAndCollectionGroup(query2, doc2) && queryMatchesOrderBy(query2, doc2) && queryMatchesFilters(query2, doc2) && queryMatchesBounds(query2, doc2);
  }
  function queryMatchesPathAndCollectionGroup(query2, doc2) {
    var docPath = doc2.key.path;
    if (query2.collectionGroup !== null) {
      return doc2.key.hasCollectionId(query2.collectionGroup) && query2.path.isPrefixOf(docPath);
    } else if (DocumentKey.isDocumentKey(query2.path)) {
      return query2.path.isEqual(docPath);
    } else {
      return query2.path.isImmediateParentOf(docPath);
    }
  }
  function queryMatchesOrderBy(query2, doc2) {
    for (var _i = 0, _d = query2.explicitOrderBy; _i < _d.length; _i++) {
      var orderBy_3 = _d[_i];
      if (!orderBy_3.field.isKeyField() && doc2.data.field(orderBy_3.field) === null) {
        return false;
      }
    }
    return true;
  }
  function queryMatchesFilters(query2, doc2) {
    for (var _i = 0, _d = query2.filters; _i < _d.length; _i++) {
      var filter = _d[_i];
      if (!filter.matches(doc2)) {
        return false;
      }
    }
    return true;
  }
  function queryMatchesBounds(query2, doc2) {
    if (query2.startAt && !sortsBeforeDocument(query2.startAt, queryOrderBy(query2), doc2)) {
      return false;
    }
    if (query2.endAt && sortsBeforeDocument(query2.endAt, queryOrderBy(query2), doc2)) {
      return false;
    }
    return true;
  }
  function newQueryComparator(query2) {
    return function(d1, d2) {
      var comparedOnKeyField = false;
      for (var _i = 0, _d = queryOrderBy(query2); _i < _d.length; _i++) {
        var orderBy_4 = _d[_i];
        var comp = compareDocs(orderBy_4, d1, d2);
        if (comp !== 0) {
          return comp;
        }
        comparedOnKeyField = comparedOnKeyField || orderBy_4.field.isKeyField();
      }
      return 0;
    };
  }
  function compareDocs(orderBy2, d1, d2) {
    var comparison = orderBy2.field.isKeyField() ? DocumentKey.comparator(d1.key, d2.key) : compareDocumentsByField(orderBy2.field, d1, d2);
    switch (orderBy2.dir) {
      case "asc":
        return comparison;
      case "desc":
        return -1 * comparison;
      default:
        return fail();
    }
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var SortedMap = function() {
    function SortedMap2(comparator, root) {
      this.comparator = comparator;
      this.root = root ? root : LLRBNode.EMPTY;
    }
    SortedMap2.prototype.insert = function(key, value) {
      return new SortedMap2(this.comparator, this.root.insert(key, value, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
    };
    SortedMap2.prototype.remove = function(key) {
      return new SortedMap2(this.comparator, this.root.remove(key, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
    };
    SortedMap2.prototype.get = function(key) {
      var node = this.root;
      while (!node.isEmpty()) {
        var cmp = this.comparator(key, node.key);
        if (cmp === 0) {
          return node.value;
        } else if (cmp < 0) {
          node = node.left;
        } else if (cmp > 0) {
          node = node.right;
        }
      }
      return null;
    };
    SortedMap2.prototype.indexOf = function(key) {
      var prunedNodes = 0;
      var node = this.root;
      while (!node.isEmpty()) {
        var cmp = this.comparator(key, node.key);
        if (cmp === 0) {
          return prunedNodes + node.left.size;
        } else if (cmp < 0) {
          node = node.left;
        } else {
          prunedNodes += node.left.size + 1;
          node = node.right;
        }
      }
      return -1;
    };
    SortedMap2.prototype.isEmpty = function() {
      return this.root.isEmpty();
    };
    Object.defineProperty(SortedMap2.prototype, "size", {
      get: function() {
        return this.root.size;
      },
      enumerable: false,
      configurable: true
    });
    SortedMap2.prototype.minKey = function() {
      return this.root.minKey();
    };
    SortedMap2.prototype.maxKey = function() {
      return this.root.maxKey();
    };
    SortedMap2.prototype.inorderTraversal = function(action) {
      return this.root.inorderTraversal(action);
    };
    SortedMap2.prototype.forEach = function(fn) {
      this.inorderTraversal(function(k, v) {
        fn(k, v);
        return false;
      });
    };
    SortedMap2.prototype.toString = function() {
      var descriptions = [];
      this.inorderTraversal(function(k, v) {
        descriptions.push(k + ":" + v);
        return false;
      });
      return "{" + descriptions.join(", ") + "}";
    };
    SortedMap2.prototype.reverseTraversal = function(action) {
      return this.root.reverseTraversal(action);
    };
    SortedMap2.prototype.getIterator = function() {
      return new SortedMapIterator(this.root, null, this.comparator, false);
    };
    SortedMap2.prototype.getIteratorFrom = function(key) {
      return new SortedMapIterator(this.root, key, this.comparator, false);
    };
    SortedMap2.prototype.getReverseIterator = function() {
      return new SortedMapIterator(this.root, null, this.comparator, true);
    };
    SortedMap2.prototype.getReverseIteratorFrom = function(key) {
      return new SortedMapIterator(this.root, key, this.comparator, true);
    };
    return SortedMap2;
  }();
  var SortedMapIterator = function() {
    function SortedMapIterator2(node, startKey, comparator, isReverse) {
      this.isReverse = isReverse;
      this.nodeStack = [];
      var cmp = 1;
      while (!node.isEmpty()) {
        cmp = startKey ? comparator(node.key, startKey) : 1;
        if (isReverse) {
          cmp *= -1;
        }
        if (cmp < 0) {
          if (this.isReverse) {
            node = node.left;
          } else {
            node = node.right;
          }
        } else if (cmp === 0) {
          this.nodeStack.push(node);
          break;
        } else {
          this.nodeStack.push(node);
          if (this.isReverse) {
            node = node.right;
          } else {
            node = node.left;
          }
        }
      }
    }
    SortedMapIterator2.prototype.getNext = function() {
      var node = this.nodeStack.pop();
      var result = {key: node.key, value: node.value};
      if (this.isReverse) {
        node = node.left;
        while (!node.isEmpty()) {
          this.nodeStack.push(node);
          node = node.right;
        }
      } else {
        node = node.right;
        while (!node.isEmpty()) {
          this.nodeStack.push(node);
          node = node.left;
        }
      }
      return result;
    };
    SortedMapIterator2.prototype.hasNext = function() {
      return this.nodeStack.length > 0;
    };
    SortedMapIterator2.prototype.peek = function() {
      if (this.nodeStack.length === 0) {
        return null;
      }
      var node = this.nodeStack[this.nodeStack.length - 1];
      return {key: node.key, value: node.value};
    };
    return SortedMapIterator2;
  }();
  var LLRBNode = function() {
    function LLRBNode2(key, value, color, left, right) {
      this.key = key;
      this.value = value;
      this.color = color != null ? color : LLRBNode2.RED;
      this.left = left != null ? left : LLRBNode2.EMPTY;
      this.right = right != null ? right : LLRBNode2.EMPTY;
      this.size = this.left.size + 1 + this.right.size;
    }
    LLRBNode2.prototype.copy = function(key, value, color, left, right) {
      return new LLRBNode2(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
    };
    LLRBNode2.prototype.isEmpty = function() {
      return false;
    };
    LLRBNode2.prototype.inorderTraversal = function(action) {
      return this.left.inorderTraversal(action) || action(this.key, this.value) || this.right.inorderTraversal(action);
    };
    LLRBNode2.prototype.reverseTraversal = function(action) {
      return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);
    };
    LLRBNode2.prototype.min = function() {
      if (this.left.isEmpty()) {
        return this;
      } else {
        return this.left.min();
      }
    };
    LLRBNode2.prototype.minKey = function() {
      return this.min().key;
    };
    LLRBNode2.prototype.maxKey = function() {
      if (this.right.isEmpty()) {
        return this.key;
      } else {
        return this.right.maxKey();
      }
    };
    LLRBNode2.prototype.insert = function(key, value, comparator) {
      var n = this;
      var cmp = comparator(key, n.key);
      if (cmp < 0) {
        n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
      } else if (cmp === 0) {
        n = n.copy(null, value, null, null, null);
      } else {
        n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
      }
      return n.fixUp();
    };
    LLRBNode2.prototype.removeMin = function() {
      if (this.left.isEmpty()) {
        return LLRBNode2.EMPTY;
      }
      var n = this;
      if (!n.left.isRed() && !n.left.left.isRed()) {
        n = n.moveRedLeft();
      }
      n = n.copy(null, null, null, n.left.removeMin(), null);
      return n.fixUp();
    };
    LLRBNode2.prototype.remove = function(key, comparator) {
      var smallest;
      var n = this;
      if (comparator(key, n.key) < 0) {
        if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {
          n = n.moveRedLeft();
        }
        n = n.copy(null, null, null, n.left.remove(key, comparator), null);
      } else {
        if (n.left.isRed()) {
          n = n.rotateRight();
        }
        if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {
          n = n.moveRedRight();
        }
        if (comparator(key, n.key) === 0) {
          if (n.right.isEmpty()) {
            return LLRBNode2.EMPTY;
          } else {
            smallest = n.right.min();
            n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());
          }
        }
        n = n.copy(null, null, null, null, n.right.remove(key, comparator));
      }
      return n.fixUp();
    };
    LLRBNode2.prototype.isRed = function() {
      return this.color;
    };
    LLRBNode2.prototype.fixUp = function() {
      var n = this;
      if (n.right.isRed() && !n.left.isRed()) {
        n = n.rotateLeft();
      }
      if (n.left.isRed() && n.left.left.isRed()) {
        n = n.rotateRight();
      }
      if (n.left.isRed() && n.right.isRed()) {
        n = n.colorFlip();
      }
      return n;
    };
    LLRBNode2.prototype.moveRedLeft = function() {
      var n = this.colorFlip();
      if (n.right.left.isRed()) {
        n = n.copy(null, null, null, null, n.right.rotateRight());
        n = n.rotateLeft();
        n = n.colorFlip();
      }
      return n;
    };
    LLRBNode2.prototype.moveRedRight = function() {
      var n = this.colorFlip();
      if (n.left.left.isRed()) {
        n = n.rotateRight();
        n = n.colorFlip();
      }
      return n;
    };
    LLRBNode2.prototype.rotateLeft = function() {
      var nl = this.copy(null, null, LLRBNode2.RED, null, this.right.left);
      return this.right.copy(null, null, this.color, nl, null);
    };
    LLRBNode2.prototype.rotateRight = function() {
      var nr = this.copy(null, null, LLRBNode2.RED, this.left.right, null);
      return this.left.copy(null, null, this.color, null, nr);
    };
    LLRBNode2.prototype.colorFlip = function() {
      var left = this.left.copy(null, null, !this.left.color, null, null);
      var right = this.right.copy(null, null, !this.right.color, null, null);
      return this.copy(null, null, !this.color, left, right);
    };
    LLRBNode2.prototype.checkMaxDepth = function() {
      var blackDepth = this.check();
      if (Math.pow(2, blackDepth) <= this.size + 1) {
        return true;
      } else {
        return false;
      }
    };
    LLRBNode2.prototype.check = function() {
      if (this.isRed() && this.left.isRed()) {
        throw fail();
      }
      if (this.right.isRed()) {
        throw fail();
      }
      var blackDepth = this.left.check();
      if (blackDepth !== this.right.check()) {
        throw fail();
      } else {
        return blackDepth + (this.isRed() ? 0 : 1);
      }
    };
    return LLRBNode2;
  }();
  LLRBNode.EMPTY = null;
  LLRBNode.RED = true;
  LLRBNode.BLACK = false;
  var LLRBEmptyNode = function() {
    function LLRBEmptyNode2() {
      this.size = 0;
    }
    Object.defineProperty(LLRBEmptyNode2.prototype, "key", {
      get: function() {
        throw fail();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LLRBEmptyNode2.prototype, "value", {
      get: function() {
        throw fail();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LLRBEmptyNode2.prototype, "color", {
      get: function() {
        throw fail();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LLRBEmptyNode2.prototype, "left", {
      get: function() {
        throw fail();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LLRBEmptyNode2.prototype, "right", {
      get: function() {
        throw fail();
      },
      enumerable: false,
      configurable: true
    });
    LLRBEmptyNode2.prototype.copy = function(key, value, color, left, right) {
      return this;
    };
    LLRBEmptyNode2.prototype.insert = function(key, value, comparator) {
      return new LLRBNode(key, value);
    };
    LLRBEmptyNode2.prototype.remove = function(key, comparator) {
      return this;
    };
    LLRBEmptyNode2.prototype.isEmpty = function() {
      return true;
    };
    LLRBEmptyNode2.prototype.inorderTraversal = function(action) {
      return false;
    };
    LLRBEmptyNode2.prototype.reverseTraversal = function(action) {
      return false;
    };
    LLRBEmptyNode2.prototype.minKey = function() {
      return null;
    };
    LLRBEmptyNode2.prototype.maxKey = function() {
      return null;
    };
    LLRBEmptyNode2.prototype.isRed = function() {
      return false;
    };
    LLRBEmptyNode2.prototype.checkMaxDepth = function() {
      return true;
    };
    LLRBEmptyNode2.prototype.check = function() {
      return 0;
    };
    return LLRBEmptyNode2;
  }();
  LLRBNode.EMPTY = new LLRBEmptyNode();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var SortedSet = function() {
    function SortedSet2(comparator) {
      this.comparator = comparator;
      this.data = new SortedMap(this.comparator);
    }
    SortedSet2.prototype.has = function(elem) {
      return this.data.get(elem) !== null;
    };
    SortedSet2.prototype.first = function() {
      return this.data.minKey();
    };
    SortedSet2.prototype.last = function() {
      return this.data.maxKey();
    };
    Object.defineProperty(SortedSet2.prototype, "size", {
      get: function() {
        return this.data.size;
      },
      enumerable: false,
      configurable: true
    });
    SortedSet2.prototype.indexOf = function(elem) {
      return this.data.indexOf(elem);
    };
    SortedSet2.prototype.forEach = function(cb) {
      this.data.inorderTraversal(function(k, v) {
        cb(k);
        return false;
      });
    };
    SortedSet2.prototype.forEachInRange = function(range, cb) {
      var iter = this.data.getIteratorFrom(range[0]);
      while (iter.hasNext()) {
        var elem = iter.getNext();
        if (this.comparator(elem.key, range[1]) >= 0) {
          return;
        }
        cb(elem.key);
      }
    };
    SortedSet2.prototype.forEachWhile = function(cb, start) {
      var iter;
      if (start !== void 0) {
        iter = this.data.getIteratorFrom(start);
      } else {
        iter = this.data.getIterator();
      }
      while (iter.hasNext()) {
        var elem = iter.getNext();
        var result = cb(elem.key);
        if (!result) {
          return;
        }
      }
    };
    SortedSet2.prototype.firstAfterOrEqual = function(elem) {
      var iter = this.data.getIteratorFrom(elem);
      return iter.hasNext() ? iter.getNext().key : null;
    };
    SortedSet2.prototype.getIterator = function() {
      return new SortedSetIterator(this.data.getIterator());
    };
    SortedSet2.prototype.getIteratorFrom = function(key) {
      return new SortedSetIterator(this.data.getIteratorFrom(key));
    };
    SortedSet2.prototype.add = function(elem) {
      return this.copy(this.data.remove(elem).insert(elem, true));
    };
    SortedSet2.prototype.delete = function(elem) {
      if (!this.has(elem)) {
        return this;
      }
      return this.copy(this.data.remove(elem));
    };
    SortedSet2.prototype.isEmpty = function() {
      return this.data.isEmpty();
    };
    SortedSet2.prototype.unionWith = function(other) {
      var result = this;
      if (result.size < other.size) {
        result = other;
        other = this;
      }
      other.forEach(function(elem) {
        result = result.add(elem);
      });
      return result;
    };
    SortedSet2.prototype.isEqual = function(other) {
      if (!(other instanceof SortedSet2)) {
        return false;
      }
      if (this.size !== other.size) {
        return false;
      }
      var thisIt = this.data.getIterator();
      var otherIt = other.data.getIterator();
      while (thisIt.hasNext()) {
        var thisElem = thisIt.getNext().key;
        var otherElem = otherIt.getNext().key;
        if (this.comparator(thisElem, otherElem) !== 0) {
          return false;
        }
      }
      return true;
    };
    SortedSet2.prototype.toArray = function() {
      var res = [];
      this.forEach(function(targetId) {
        res.push(targetId);
      });
      return res;
    };
    SortedSet2.prototype.toString = function() {
      var result = [];
      this.forEach(function(elem) {
        return result.push(elem);
      });
      return "SortedSet(" + result.toString() + ")";
    };
    SortedSet2.prototype.copy = function(data) {
      var result = new SortedSet2(this.comparator);
      result.data = data;
      return result;
    };
    return SortedSet2;
  }();
  var SortedSetIterator = function() {
    function SortedSetIterator2(iter) {
      this.iter = iter;
    }
    SortedSetIterator2.prototype.getNext = function() {
      return this.iter.getNext().key;
    };
    SortedSetIterator2.prototype.hasNext = function() {
      return this.iter.hasNext();
    };
    return SortedSetIterator2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var EMPTY_MUTABLE_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);
  function mutableDocumentMap() {
    return EMPTY_MUTABLE_DOCUMENT_MAP;
  }
  var EMPTY_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);
  function documentMap() {
    return EMPTY_DOCUMENT_MAP;
  }
  var EMPTY_DOCUMENT_VERSION_MAP = new SortedMap(DocumentKey.comparator);
  function documentVersionMap() {
    return EMPTY_DOCUMENT_VERSION_MAP;
  }
  var EMPTY_DOCUMENT_KEY_SET = new SortedSet(DocumentKey.comparator);
  function documentKeySet() {
    var keys = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      keys[_i] = arguments[_i];
    }
    var set = EMPTY_DOCUMENT_KEY_SET;
    for (var _d = 0, keys_1 = keys; _d < keys_1.length; _d++) {
      var key = keys_1[_d];
      set = set.add(key);
    }
    return set;
  }
  var EMPTY_TARGET_ID_SET = new SortedSet(primitiveComparator);
  function targetIdSet() {
    return EMPTY_TARGET_ID_SET;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function toDouble(serializer, value) {
    if (serializer.useProto3Json) {
      if (isNaN(value)) {
        return {doubleValue: "NaN"};
      } else if (value === Infinity) {
        return {doubleValue: "Infinity"};
      } else if (value === -Infinity) {
        return {doubleValue: "-Infinity"};
      }
    }
    return {doubleValue: isNegativeZero(value) ? "-0" : value};
  }
  function toInteger(value) {
    return {integerValue: "" + value};
  }
  function toNumber(serializer, value) {
    return isSafeInteger(value) ? toInteger(value) : toDouble(serializer, value);
  }
  /**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var TransformOperation = function() {
    function TransformOperation2() {
      this._ = void 0;
    }
    return TransformOperation2;
  }();
  function applyTransformOperationToLocalView(transform, previousValue, localWriteTime) {
    if (transform instanceof ServerTimestampTransform) {
      return serverTimestamp(localWriteTime, previousValue);
    } else if (transform instanceof ArrayUnionTransformOperation) {
      return applyArrayUnionTransformOperation(transform, previousValue);
    } else if (transform instanceof ArrayRemoveTransformOperation) {
      return applyArrayRemoveTransformOperation(transform, previousValue);
    } else {
      return applyNumericIncrementTransformOperationToLocalView(transform, previousValue);
    }
  }
  function applyTransformOperationToRemoteDocument(transform, previousValue, transformResult) {
    if (transform instanceof ArrayUnionTransformOperation) {
      return applyArrayUnionTransformOperation(transform, previousValue);
    } else if (transform instanceof ArrayRemoveTransformOperation) {
      return applyArrayRemoveTransformOperation(transform, previousValue);
    }
    return transformResult;
  }
  function computeTransformOperationBaseValue(transform, previousValue) {
    if (transform instanceof NumericIncrementTransformOperation) {
      return isNumber(previousValue) ? previousValue : {integerValue: 0};
    }
    return null;
  }
  function transformOperationEquals(left, right) {
    if (left instanceof ArrayUnionTransformOperation && right instanceof ArrayUnionTransformOperation) {
      return arrayEquals(left.elements, right.elements, valueEquals);
    } else if (left instanceof ArrayRemoveTransformOperation && right instanceof ArrayRemoveTransformOperation) {
      return arrayEquals(left.elements, right.elements, valueEquals);
    } else if (left instanceof NumericIncrementTransformOperation && right instanceof NumericIncrementTransformOperation) {
      return valueEquals(left.operand, right.operand);
    }
    return left instanceof ServerTimestampTransform && right instanceof ServerTimestampTransform;
  }
  var ServerTimestampTransform = function(_super) {
    tslib.__extends(ServerTimestampTransform2, _super);
    function ServerTimestampTransform2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return ServerTimestampTransform2;
  }(TransformOperation);
  var ArrayUnionTransformOperation = function(_super) {
    tslib.__extends(ArrayUnionTransformOperation2, _super);
    function ArrayUnionTransformOperation2(elements) {
      var _this = _super.call(this) || this;
      _this.elements = elements;
      return _this;
    }
    return ArrayUnionTransformOperation2;
  }(TransformOperation);
  function applyArrayUnionTransformOperation(transform, previousValue) {
    var values = coercedFieldValuesArray(previousValue);
    var _loop_3 = function(toUnion2) {
      if (!values.some(function(element) {
        return valueEquals(element, toUnion2);
      })) {
        values.push(toUnion2);
      }
    };
    for (var _i = 0, _d = transform.elements; _i < _d.length; _i++) {
      var toUnion = _d[_i];
      _loop_3(toUnion);
    }
    return {arrayValue: {values}};
  }
  var ArrayRemoveTransformOperation = function(_super) {
    tslib.__extends(ArrayRemoveTransformOperation2, _super);
    function ArrayRemoveTransformOperation2(elements) {
      var _this = _super.call(this) || this;
      _this.elements = elements;
      return _this;
    }
    return ArrayRemoveTransformOperation2;
  }(TransformOperation);
  function applyArrayRemoveTransformOperation(transform, previousValue) {
    var values = coercedFieldValuesArray(previousValue);
    var _loop_4 = function(toRemove2) {
      values = values.filter(function(element) {
        return !valueEquals(element, toRemove2);
      });
    };
    for (var _i = 0, _d = transform.elements; _i < _d.length; _i++) {
      var toRemove = _d[_i];
      _loop_4(toRemove);
    }
    return {arrayValue: {values}};
  }
  var NumericIncrementTransformOperation = function(_super) {
    tslib.__extends(NumericIncrementTransformOperation2, _super);
    function NumericIncrementTransformOperation2(serializer, operand) {
      var _this = _super.call(this) || this;
      _this.serializer = serializer;
      _this.operand = operand;
      return _this;
    }
    return NumericIncrementTransformOperation2;
  }(TransformOperation);
  function applyNumericIncrementTransformOperationToLocalView(transform, previousValue) {
    var baseValue = computeTransformOperationBaseValue(transform, previousValue);
    var sum = asNumber(baseValue) + asNumber(transform.operand);
    if (isInteger(baseValue) && isInteger(transform.operand)) {
      return toInteger(sum);
    } else {
      return toDouble(transform.serializer, sum);
    }
  }
  function asNumber(value) {
    return normalizeNumber(value.integerValue || value.doubleValue);
  }
  function coercedFieldValuesArray(value) {
    return isArray(value) && value.arrayValue.values ? value.arrayValue.values.slice() : [];
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var FieldTransform = function() {
    function FieldTransform2(field, transform) {
      this.field = field;
      this.transform = transform;
    }
    return FieldTransform2;
  }();
  function fieldTransformEquals(left, right) {
    return left.field.isEqual(right.field) && transformOperationEquals(left.transform, right.transform);
  }
  function fieldTransformsAreEqual(left, right) {
    if (left === void 0 && right === void 0) {
      return true;
    }
    if (left && right) {
      return arrayEquals(left, right, function(l, r) {
        return fieldTransformEquals(l, r);
      });
    }
    return false;
  }
  var MutationResult = function() {
    function MutationResult2(version2, transformResults) {
      this.version = version2;
      this.transformResults = transformResults;
    }
    return MutationResult2;
  }();
  var Precondition = function() {
    function Precondition2(updateTime, exists) {
      this.updateTime = updateTime;
      this.exists = exists;
    }
    Precondition2.none = function() {
      return new Precondition2();
    };
    Precondition2.exists = function(exists) {
      return new Precondition2(void 0, exists);
    };
    Precondition2.updateTime = function(version2) {
      return new Precondition2(version2);
    };
    Object.defineProperty(Precondition2.prototype, "isNone", {
      get: function() {
        return this.updateTime === void 0 && this.exists === void 0;
      },
      enumerable: false,
      configurable: true
    });
    Precondition2.prototype.isEqual = function(other) {
      return this.exists === other.exists && (this.updateTime ? !!other.updateTime && this.updateTime.isEqual(other.updateTime) : !other.updateTime);
    };
    return Precondition2;
  }();
  function preconditionIsValidForDocument(precondition, document2) {
    if (precondition.updateTime !== void 0) {
      return document2.isFoundDocument() && document2.version.isEqual(precondition.updateTime);
    } else if (precondition.exists !== void 0) {
      return precondition.exists === document2.isFoundDocument();
    } else {
      return true;
    }
  }
  var Mutation = function() {
    function Mutation2() {
    }
    return Mutation2;
  }();
  function applyMutationToRemoteDocument(mutation, document2, mutationResult) {
    if (mutation instanceof SetMutation) {
      applySetMutationToRemoteDocument(mutation, document2, mutationResult);
    } else if (mutation instanceof PatchMutation) {
      applyPatchMutationToRemoteDocument(mutation, document2, mutationResult);
    } else {
      applyDeleteMutationToRemoteDocument(mutation, document2, mutationResult);
    }
  }
  function applyMutationToLocalView(mutation, document2, localWriteTime) {
    if (mutation instanceof SetMutation) {
      applySetMutationToLocalView(mutation, document2, localWriteTime);
    } else if (mutation instanceof PatchMutation) {
      applyPatchMutationToLocalView(mutation, document2, localWriteTime);
    } else {
      applyDeleteMutationToLocalView(mutation, document2);
    }
  }
  function extractMutationBaseValue(mutation, document2) {
    var baseObject = null;
    for (var _i = 0, _d = mutation.fieldTransforms; _i < _d.length; _i++) {
      var fieldTransform = _d[_i];
      var existingValue = document2.data.field(fieldTransform.field);
      var coercedValue = computeTransformOperationBaseValue(fieldTransform.transform, existingValue || null);
      if (coercedValue != null) {
        if (baseObject == null) {
          baseObject = ObjectValue.empty();
        }
        baseObject.set(fieldTransform.field, coercedValue);
      }
    }
    return baseObject ? baseObject : null;
  }
  function mutationEquals(left, right) {
    if (left.type !== right.type) {
      return false;
    }
    if (!left.key.isEqual(right.key)) {
      return false;
    }
    if (!left.precondition.isEqual(right.precondition)) {
      return false;
    }
    if (!fieldTransformsAreEqual(left.fieldTransforms, right.fieldTransforms)) {
      return false;
    }
    if (left.type === 0) {
      return left.value.isEqual(right.value);
    }
    if (left.type === 1) {
      return left.data.isEqual(right.data) && left.fieldMask.isEqual(right.fieldMask);
    }
    return true;
  }
  function getPostMutationVersion(document2) {
    return document2.isFoundDocument() ? document2.version : SnapshotVersion.min();
  }
  var SetMutation = function(_super) {
    tslib.__extends(SetMutation2, _super);
    function SetMutation2(key, value, precondition, fieldTransforms) {
      if (fieldTransforms === void 0) {
        fieldTransforms = [];
      }
      var _this = _super.call(this) || this;
      _this.key = key;
      _this.value = value;
      _this.precondition = precondition;
      _this.fieldTransforms = fieldTransforms;
      _this.type = 0;
      return _this;
    }
    return SetMutation2;
  }(Mutation);
  function applySetMutationToRemoteDocument(mutation, document2, mutationResult) {
    var newData = mutation.value.clone();
    var transformResults = serverTransformResults(mutation.fieldTransforms, document2, mutationResult.transformResults);
    newData.setAll(transformResults);
    document2.convertToFoundDocument(mutationResult.version, newData).setHasCommittedMutations();
  }
  function applySetMutationToLocalView(mutation, document2, localWriteTime) {
    if (!preconditionIsValidForDocument(mutation.precondition, document2)) {
      return;
    }
    var newData = mutation.value.clone();
    var transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document2);
    newData.setAll(transformResults);
    document2.convertToFoundDocument(getPostMutationVersion(document2), newData).setHasLocalMutations();
  }
  var PatchMutation = function(_super) {
    tslib.__extends(PatchMutation2, _super);
    function PatchMutation2(key, data, fieldMask, precondition, fieldTransforms) {
      if (fieldTransforms === void 0) {
        fieldTransforms = [];
      }
      var _this = _super.call(this) || this;
      _this.key = key;
      _this.data = data;
      _this.fieldMask = fieldMask;
      _this.precondition = precondition;
      _this.fieldTransforms = fieldTransforms;
      _this.type = 1;
      return _this;
    }
    return PatchMutation2;
  }(Mutation);
  function applyPatchMutationToRemoteDocument(mutation, document2, mutationResult) {
    if (!preconditionIsValidForDocument(mutation.precondition, document2)) {
      document2.convertToUnknownDocument(mutationResult.version);
      return;
    }
    var transformResults = serverTransformResults(mutation.fieldTransforms, document2, mutationResult.transformResults);
    var newData = document2.data;
    newData.setAll(getPatch(mutation));
    newData.setAll(transformResults);
    document2.convertToFoundDocument(mutationResult.version, newData).setHasCommittedMutations();
  }
  function applyPatchMutationToLocalView(mutation, document2, localWriteTime) {
    if (!preconditionIsValidForDocument(mutation.precondition, document2)) {
      return;
    }
    var transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document2);
    var newData = document2.data;
    newData.setAll(getPatch(mutation));
    newData.setAll(transformResults);
    document2.convertToFoundDocument(getPostMutationVersion(document2), newData).setHasLocalMutations();
  }
  function getPatch(mutation) {
    var result = new Map();
    mutation.fieldMask.fields.forEach(function(fieldPath) {
      if (!fieldPath.isEmpty()) {
        var newValue = mutation.data.field(fieldPath);
        result.set(fieldPath, newValue);
      }
    });
    return result;
  }
  function serverTransformResults(fieldTransforms, mutableDocument, serverTransformResults2) {
    var transformResults = new Map();
    hardAssert(fieldTransforms.length === serverTransformResults2.length);
    for (var i = 0; i < serverTransformResults2.length; i++) {
      var fieldTransform = fieldTransforms[i];
      var transform = fieldTransform.transform;
      var previousValue = mutableDocument.data.field(fieldTransform.field);
      transformResults.set(fieldTransform.field, applyTransformOperationToRemoteDocument(transform, previousValue, serverTransformResults2[i]));
    }
    return transformResults;
  }
  function localTransformResults(fieldTransforms, localWriteTime, mutableDocument) {
    var transformResults = new Map();
    for (var _i = 0, fieldTransforms_1 = fieldTransforms; _i < fieldTransforms_1.length; _i++) {
      var fieldTransform = fieldTransforms_1[_i];
      var transform = fieldTransform.transform;
      var previousValue = mutableDocument.data.field(fieldTransform.field);
      transformResults.set(fieldTransform.field, applyTransformOperationToLocalView(transform, previousValue, localWriteTime));
    }
    return transformResults;
  }
  var DeleteMutation = function(_super) {
    tslib.__extends(DeleteMutation2, _super);
    function DeleteMutation2(key, precondition) {
      var _this = _super.call(this) || this;
      _this.key = key;
      _this.precondition = precondition;
      _this.type = 2;
      _this.fieldTransforms = [];
      return _this;
    }
    return DeleteMutation2;
  }(Mutation);
  function applyDeleteMutationToRemoteDocument(mutation, document2, mutationResult) {
    document2.convertToNoDocument(mutationResult.version).setHasCommittedMutations();
  }
  function applyDeleteMutationToLocalView(mutation, document2) {
    if (preconditionIsValidForDocument(mutation.precondition, document2)) {
      document2.convertToNoDocument(SnapshotVersion.min());
    }
  }
  var VerifyMutation = function(_super) {
    tslib.__extends(VerifyMutation2, _super);
    function VerifyMutation2(key, precondition) {
      var _this = _super.call(this) || this;
      _this.key = key;
      _this.precondition = precondition;
      _this.type = 3;
      _this.fieldTransforms = [];
      return _this;
    }
    return VerifyMutation2;
  }(Mutation);
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var MutationBatch = function() {
    function MutationBatch2(batchId, localWriteTime, baseMutations, mutations) {
      this.batchId = batchId;
      this.localWriteTime = localWriteTime;
      this.baseMutations = baseMutations;
      this.mutations = mutations;
    }
    MutationBatch2.prototype.applyToRemoteDocument = function(document2, batchResult) {
      var mutationResults = batchResult.mutationResults;
      for (var i = 0; i < this.mutations.length; i++) {
        var mutation = this.mutations[i];
        if (mutation.key.isEqual(document2.key)) {
          var mutationResult = mutationResults[i];
          applyMutationToRemoteDocument(mutation, document2, mutationResult);
        }
      }
    };
    MutationBatch2.prototype.applyToLocalView = function(document2) {
      for (var _i = 0, _d = this.baseMutations; _i < _d.length; _i++) {
        var mutation = _d[_i];
        if (mutation.key.isEqual(document2.key)) {
          applyMutationToLocalView(mutation, document2, this.localWriteTime);
        }
      }
      for (var _e = 0, _f = this.mutations; _e < _f.length; _e++) {
        var mutation = _f[_e];
        if (mutation.key.isEqual(document2.key)) {
          applyMutationToLocalView(mutation, document2, this.localWriteTime);
        }
      }
    };
    MutationBatch2.prototype.applyToLocalDocumentSet = function(documentMap2) {
      var _this = this;
      this.mutations.forEach(function(m) {
        var document2 = documentMap2.get(m.key);
        var mutableDocument = document2;
        _this.applyToLocalView(mutableDocument);
        if (!document2.isValidDocument()) {
          mutableDocument.convertToNoDocument(SnapshotVersion.min());
        }
      });
    };
    MutationBatch2.prototype.keys = function() {
      return this.mutations.reduce(function(keys, m) {
        return keys.add(m.key);
      }, documentKeySet());
    };
    MutationBatch2.prototype.isEqual = function(other) {
      return this.batchId === other.batchId && arrayEquals(this.mutations, other.mutations, function(l, r) {
        return mutationEquals(l, r);
      }) && arrayEquals(this.baseMutations, other.baseMutations, function(l, r) {
        return mutationEquals(l, r);
      });
    };
    return MutationBatch2;
  }();
  var MutationBatchResult = function() {
    function MutationBatchResult2(batch, commitVersion, mutationResults, docVersions) {
      this.batch = batch;
      this.commitVersion = commitVersion;
      this.mutationResults = mutationResults;
      this.docVersions = docVersions;
    }
    MutationBatchResult2.from = function(batch, commitVersion, results) {
      hardAssert(batch.mutations.length === results.length);
      var versionMap = documentVersionMap();
      var mutations = batch.mutations;
      for (var i = 0; i < mutations.length; i++) {
        versionMap = versionMap.insert(mutations[i].key, results[i].version);
      }
      return new MutationBatchResult2(batch, commitVersion, results, versionMap);
    };
    return MutationBatchResult2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var ExistenceFilter = function() {
    function ExistenceFilter2(count) {
      this.count = count;
    }
    return ExistenceFilter2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var RpcCode;
  (function(RpcCode2) {
    RpcCode2[RpcCode2["OK"] = 0] = "OK";
    RpcCode2[RpcCode2["CANCELLED"] = 1] = "CANCELLED";
    RpcCode2[RpcCode2["UNKNOWN"] = 2] = "UNKNOWN";
    RpcCode2[RpcCode2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    RpcCode2[RpcCode2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    RpcCode2[RpcCode2["NOT_FOUND"] = 5] = "NOT_FOUND";
    RpcCode2[RpcCode2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    RpcCode2[RpcCode2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    RpcCode2[RpcCode2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
    RpcCode2[RpcCode2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    RpcCode2[RpcCode2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    RpcCode2[RpcCode2["ABORTED"] = 10] = "ABORTED";
    RpcCode2[RpcCode2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    RpcCode2[RpcCode2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    RpcCode2[RpcCode2["INTERNAL"] = 13] = "INTERNAL";
    RpcCode2[RpcCode2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    RpcCode2[RpcCode2["DATA_LOSS"] = 15] = "DATA_LOSS";
  })(RpcCode || (RpcCode = {}));
  function isPermanentError(code) {
    switch (code) {
      case Code.OK:
        return fail();
      case Code.CANCELLED:
      case Code.UNKNOWN:
      case Code.DEADLINE_EXCEEDED:
      case Code.RESOURCE_EXHAUSTED:
      case Code.INTERNAL:
      case Code.UNAVAILABLE:
      case Code.UNAUTHENTICATED:
        return false;
      case Code.INVALID_ARGUMENT:
      case Code.NOT_FOUND:
      case Code.ALREADY_EXISTS:
      case Code.PERMISSION_DENIED:
      case Code.FAILED_PRECONDITION:
      case Code.ABORTED:
      case Code.OUT_OF_RANGE:
      case Code.UNIMPLEMENTED:
      case Code.DATA_LOSS:
        return true;
      default:
        return fail();
    }
  }
  function isPermanentWriteError(code) {
    return isPermanentError(code) && code !== Code.ABORTED;
  }
  function mapCodeFromRpcCode(code) {
    if (code === void 0) {
      logError("GRPC error has no .code");
      return Code.UNKNOWN;
    }
    switch (code) {
      case RpcCode.OK:
        return Code.OK;
      case RpcCode.CANCELLED:
        return Code.CANCELLED;
      case RpcCode.UNKNOWN:
        return Code.UNKNOWN;
      case RpcCode.DEADLINE_EXCEEDED:
        return Code.DEADLINE_EXCEEDED;
      case RpcCode.RESOURCE_EXHAUSTED:
        return Code.RESOURCE_EXHAUSTED;
      case RpcCode.INTERNAL:
        return Code.INTERNAL;
      case RpcCode.UNAVAILABLE:
        return Code.UNAVAILABLE;
      case RpcCode.UNAUTHENTICATED:
        return Code.UNAUTHENTICATED;
      case RpcCode.INVALID_ARGUMENT:
        return Code.INVALID_ARGUMENT;
      case RpcCode.NOT_FOUND:
        return Code.NOT_FOUND;
      case RpcCode.ALREADY_EXISTS:
        return Code.ALREADY_EXISTS;
      case RpcCode.PERMISSION_DENIED:
        return Code.PERMISSION_DENIED;
      case RpcCode.FAILED_PRECONDITION:
        return Code.FAILED_PRECONDITION;
      case RpcCode.ABORTED:
        return Code.ABORTED;
      case RpcCode.OUT_OF_RANGE:
        return Code.OUT_OF_RANGE;
      case RpcCode.UNIMPLEMENTED:
        return Code.UNIMPLEMENTED;
      case RpcCode.DATA_LOSS:
        return Code.DATA_LOSS;
      default:
        return fail();
    }
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var RemoteEvent = function() {
    function RemoteEvent2(snapshotVersion, targetChanges, targetMismatches, documentUpdates, resolvedLimboDocuments) {
      this.snapshotVersion = snapshotVersion;
      this.targetChanges = targetChanges;
      this.targetMismatches = targetMismatches;
      this.documentUpdates = documentUpdates;
      this.resolvedLimboDocuments = resolvedLimboDocuments;
    }
    RemoteEvent2.createSynthesizedRemoteEventForCurrentChange = function(targetId, current) {
      var targetChanges = new Map();
      targetChanges.set(targetId, TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current));
      return new RemoteEvent2(SnapshotVersion.min(), targetChanges, targetIdSet(), mutableDocumentMap(), documentKeySet());
    };
    return RemoteEvent2;
  }();
  var TargetChange = function() {
    function TargetChange2(resumeToken, current, addedDocuments, modifiedDocuments, removedDocuments) {
      this.resumeToken = resumeToken;
      this.current = current;
      this.addedDocuments = addedDocuments;
      this.modifiedDocuments = modifiedDocuments;
      this.removedDocuments = removedDocuments;
    }
    TargetChange2.createSynthesizedTargetChangeForCurrentChange = function(targetId, current) {
      return new TargetChange2(ByteString.EMPTY_BYTE_STRING, current, documentKeySet(), documentKeySet(), documentKeySet());
    };
    return TargetChange2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var DocumentWatchChange = function() {
    function DocumentWatchChange2(updatedTargetIds, removedTargetIds, key, newDoc) {
      this.updatedTargetIds = updatedTargetIds;
      this.removedTargetIds = removedTargetIds;
      this.key = key;
      this.newDoc = newDoc;
    }
    return DocumentWatchChange2;
  }();
  var ExistenceFilterChange = function() {
    function ExistenceFilterChange2(targetId, existenceFilter) {
      this.targetId = targetId;
      this.existenceFilter = existenceFilter;
    }
    return ExistenceFilterChange2;
  }();
  var WatchTargetChange = function() {
    function WatchTargetChange2(state, targetIds, resumeToken, cause) {
      if (resumeToken === void 0) {
        resumeToken = ByteString.EMPTY_BYTE_STRING;
      }
      if (cause === void 0) {
        cause = null;
      }
      this.state = state;
      this.targetIds = targetIds;
      this.resumeToken = resumeToken;
      this.cause = cause;
    }
    return WatchTargetChange2;
  }();
  var TargetState = function() {
    function TargetState2() {
      this.pendingResponses = 0;
      this.documentChanges = snapshotChangesMap();
      this._resumeToken = ByteString.EMPTY_BYTE_STRING;
      this._current = false;
      this._hasPendingChanges = true;
    }
    Object.defineProperty(TargetState2.prototype, "current", {
      get: function() {
        return this._current;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TargetState2.prototype, "resumeToken", {
      get: function() {
        return this._resumeToken;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TargetState2.prototype, "isPending", {
      get: function() {
        return this.pendingResponses !== 0;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TargetState2.prototype, "hasPendingChanges", {
      get: function() {
        return this._hasPendingChanges;
      },
      enumerable: false,
      configurable: true
    });
    TargetState2.prototype.updateResumeToken = function(resumeToken) {
      if (resumeToken.approximateByteSize() > 0) {
        this._hasPendingChanges = true;
        this._resumeToken = resumeToken;
      }
    };
    TargetState2.prototype.toTargetChange = function() {
      var addedDocuments = documentKeySet();
      var modifiedDocuments = documentKeySet();
      var removedDocuments = documentKeySet();
      this.documentChanges.forEach(function(key, changeType) {
        switch (changeType) {
          case 0:
            addedDocuments = addedDocuments.add(key);
            break;
          case 2:
            modifiedDocuments = modifiedDocuments.add(key);
            break;
          case 1:
            removedDocuments = removedDocuments.add(key);
            break;
          default:
            fail();
        }
      });
      return new TargetChange(this._resumeToken, this._current, addedDocuments, modifiedDocuments, removedDocuments);
    };
    TargetState2.prototype.clearPendingChanges = function() {
      this._hasPendingChanges = false;
      this.documentChanges = snapshotChangesMap();
    };
    TargetState2.prototype.addDocumentChange = function(key, changeType) {
      this._hasPendingChanges = true;
      this.documentChanges = this.documentChanges.insert(key, changeType);
    };
    TargetState2.prototype.removeDocumentChange = function(key) {
      this._hasPendingChanges = true;
      this.documentChanges = this.documentChanges.remove(key);
    };
    TargetState2.prototype.recordPendingTargetRequest = function() {
      this.pendingResponses += 1;
    };
    TargetState2.prototype.recordTargetResponse = function() {
      this.pendingResponses -= 1;
    };
    TargetState2.prototype.markCurrent = function() {
      this._hasPendingChanges = true;
      this._current = true;
    };
    return TargetState2;
  }();
  var LOG_TAG$1 = "WatchChangeAggregator";
  var WatchChangeAggregator = function() {
    function WatchChangeAggregator2(metadataProvider) {
      this.metadataProvider = metadataProvider;
      this.targetStates = new Map();
      this.pendingDocumentUpdates = mutableDocumentMap();
      this.pendingDocumentTargetMapping = documentTargetMap();
      this.pendingTargetResets = new SortedSet(primitiveComparator);
    }
    WatchChangeAggregator2.prototype.handleDocumentChange = function(docChange) {
      for (var _i = 0, _d = docChange.updatedTargetIds; _i < _d.length; _i++) {
        var targetId = _d[_i];
        if (docChange.newDoc && docChange.newDoc.isFoundDocument()) {
          this.addDocumentToTarget(targetId, docChange.newDoc);
        } else {
          this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);
        }
      }
      for (var _e = 0, _f = docChange.removedTargetIds; _e < _f.length; _e++) {
        var targetId = _f[_e];
        this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);
      }
    };
    WatchChangeAggregator2.prototype.handleTargetChange = function(targetChange) {
      var _this = this;
      this.forEachTarget(targetChange, function(targetId) {
        var targetState = _this.ensureTargetState(targetId);
        switch (targetChange.state) {
          case 0:
            if (_this.isActiveTarget(targetId)) {
              targetState.updateResumeToken(targetChange.resumeToken);
            }
            break;
          case 1:
            targetState.recordTargetResponse();
            if (!targetState.isPending) {
              targetState.clearPendingChanges();
            }
            targetState.updateResumeToken(targetChange.resumeToken);
            break;
          case 2:
            targetState.recordTargetResponse();
            if (!targetState.isPending) {
              _this.removeTarget(targetId);
            }
            break;
          case 3:
            if (_this.isActiveTarget(targetId)) {
              targetState.markCurrent();
              targetState.updateResumeToken(targetChange.resumeToken);
            }
            break;
          case 4:
            if (_this.isActiveTarget(targetId)) {
              _this.resetTarget(targetId);
              targetState.updateResumeToken(targetChange.resumeToken);
            }
            break;
          default:
            fail();
        }
      });
    };
    WatchChangeAggregator2.prototype.forEachTarget = function(targetChange, fn) {
      var _this = this;
      if (targetChange.targetIds.length > 0) {
        targetChange.targetIds.forEach(fn);
      } else {
        this.targetStates.forEach(function(_, targetId) {
          if (_this.isActiveTarget(targetId)) {
            fn(targetId);
          }
        });
      }
    };
    WatchChangeAggregator2.prototype.handleExistenceFilter = function(watchChange) {
      var targetId = watchChange.targetId;
      var expectedCount = watchChange.existenceFilter.count;
      var targetData = this.targetDataForActiveTarget(targetId);
      if (targetData) {
        var target = targetData.target;
        if (isDocumentTarget(target)) {
          if (expectedCount === 0) {
            var key = new DocumentKey(target.path);
            this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, SnapshotVersion.min()));
          } else {
            hardAssert(expectedCount === 1);
          }
        } else {
          var currentSize = this.getCurrentDocumentCountForTarget(targetId);
          if (currentSize !== expectedCount) {
            this.resetTarget(targetId);
            this.pendingTargetResets = this.pendingTargetResets.add(targetId);
          }
        }
      }
    };
    WatchChangeAggregator2.prototype.createRemoteEvent = function(snapshotVersion) {
      var _this = this;
      var targetChanges = new Map();
      this.targetStates.forEach(function(targetState, targetId) {
        var targetData = _this.targetDataForActiveTarget(targetId);
        if (targetData) {
          if (targetState.current && isDocumentTarget(targetData.target)) {
            var key = new DocumentKey(targetData.target.path);
            if (_this.pendingDocumentUpdates.get(key) === null && !_this.targetContainsDocument(targetId, key)) {
              _this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, snapshotVersion));
            }
          }
          if (targetState.hasPendingChanges) {
            targetChanges.set(targetId, targetState.toTargetChange());
            targetState.clearPendingChanges();
          }
        }
      });
      var resolvedLimboDocuments = documentKeySet();
      this.pendingDocumentTargetMapping.forEach(function(key, targets) {
        var isOnlyLimboTarget = true;
        targets.forEachWhile(function(targetId) {
          var targetData = _this.targetDataForActiveTarget(targetId);
          if (targetData && targetData.purpose !== 2) {
            isOnlyLimboTarget = false;
            return false;
          }
          return true;
        });
        if (isOnlyLimboTarget) {
          resolvedLimboDocuments = resolvedLimboDocuments.add(key);
        }
      });
      var remoteEvent = new RemoteEvent(snapshotVersion, targetChanges, this.pendingTargetResets, this.pendingDocumentUpdates, resolvedLimboDocuments);
      this.pendingDocumentUpdates = mutableDocumentMap();
      this.pendingDocumentTargetMapping = documentTargetMap();
      this.pendingTargetResets = new SortedSet(primitiveComparator);
      return remoteEvent;
    };
    WatchChangeAggregator2.prototype.addDocumentToTarget = function(targetId, document2) {
      if (!this.isActiveTarget(targetId)) {
        return;
      }
      var changeType = this.targetContainsDocument(targetId, document2.key) ? 2 : 0;
      var targetState = this.ensureTargetState(targetId);
      targetState.addDocumentChange(document2.key, changeType);
      this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(document2.key, document2);
      this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(document2.key, this.ensureDocumentTargetMapping(document2.key).add(targetId));
    };
    WatchChangeAggregator2.prototype.removeDocumentFromTarget = function(targetId, key, updatedDocument) {
      if (!this.isActiveTarget(targetId)) {
        return;
      }
      var targetState = this.ensureTargetState(targetId);
      if (this.targetContainsDocument(targetId, key)) {
        targetState.addDocumentChange(key, 1);
      } else {
        targetState.removeDocumentChange(key);
      }
      this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(key, this.ensureDocumentTargetMapping(key).delete(targetId));
      if (updatedDocument) {
        this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(key, updatedDocument);
      }
    };
    WatchChangeAggregator2.prototype.removeTarget = function(targetId) {
      this.targetStates.delete(targetId);
    };
    WatchChangeAggregator2.prototype.getCurrentDocumentCountForTarget = function(targetId) {
      var targetState = this.ensureTargetState(targetId);
      var targetChange = targetState.toTargetChange();
      return this.metadataProvider.getRemoteKeysForTarget(targetId).size + targetChange.addedDocuments.size - targetChange.removedDocuments.size;
    };
    WatchChangeAggregator2.prototype.recordPendingTargetRequest = function(targetId) {
      var targetState = this.ensureTargetState(targetId);
      targetState.recordPendingTargetRequest();
    };
    WatchChangeAggregator2.prototype.ensureTargetState = function(targetId) {
      var result = this.targetStates.get(targetId);
      if (!result) {
        result = new TargetState();
        this.targetStates.set(targetId, result);
      }
      return result;
    };
    WatchChangeAggregator2.prototype.ensureDocumentTargetMapping = function(key) {
      var targetMapping = this.pendingDocumentTargetMapping.get(key);
      if (!targetMapping) {
        targetMapping = new SortedSet(primitiveComparator);
        this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(key, targetMapping);
      }
      return targetMapping;
    };
    WatchChangeAggregator2.prototype.isActiveTarget = function(targetId) {
      var targetActive = this.targetDataForActiveTarget(targetId) !== null;
      if (!targetActive) {
        logDebug(LOG_TAG$1, "Detected inactive target", targetId);
      }
      return targetActive;
    };
    WatchChangeAggregator2.prototype.targetDataForActiveTarget = function(targetId) {
      var targetState = this.targetStates.get(targetId);
      return targetState && targetState.isPending ? null : this.metadataProvider.getTargetDataForTarget(targetId);
    };
    WatchChangeAggregator2.prototype.resetTarget = function(targetId) {
      var _this = this;
      this.targetStates.set(targetId, new TargetState());
      var existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);
      existingKeys.forEach(function(key) {
        _this.removeDocumentFromTarget(targetId, key, null);
      });
    };
    WatchChangeAggregator2.prototype.targetContainsDocument = function(targetId, key) {
      var existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);
      return existingKeys.has(key);
    };
    return WatchChangeAggregator2;
  }();
  function documentTargetMap() {
    return new SortedMap(DocumentKey.comparator);
  }
  function snapshotChangesMap() {
    return new SortedMap(DocumentKey.comparator);
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var DIRECTIONS = function() {
    var dirs = {};
    dirs["asc"] = "ASCENDING";
    dirs["desc"] = "DESCENDING";
    return dirs;
  }();
  var OPERATORS = function() {
    var ops = {};
    ops["<"] = "LESS_THAN";
    ops["<="] = "LESS_THAN_OR_EQUAL";
    ops[">"] = "GREATER_THAN";
    ops[">="] = "GREATER_THAN_OR_EQUAL";
    ops["=="] = "EQUAL";
    ops["!="] = "NOT_EQUAL";
    ops["array-contains"] = "ARRAY_CONTAINS";
    ops["in"] = "IN";
    ops["not-in"] = "NOT_IN";
    ops["array-contains-any"] = "ARRAY_CONTAINS_ANY";
    return ops;
  }();
  function assertPresent(value, description) {
  }
  var JsonProtoSerializer = function() {
    function JsonProtoSerializer2(databaseId, useProto3Json) {
      this.databaseId = databaseId;
      this.useProto3Json = useProto3Json;
    }
    return JsonProtoSerializer2;
  }();
  function fromRpcStatus(status) {
    var code = status.code === void 0 ? Code.UNKNOWN : mapCodeFromRpcCode(status.code);
    return new FirestoreError(code, status.message || "");
  }
  function toInt32Proto(serializer, val) {
    if (serializer.useProto3Json || isNullOrUndefined(val)) {
      return val;
    } else {
      return {value: val};
    }
  }
  function fromInt32Proto(val) {
    var result;
    if (typeof val === "object") {
      result = val.value;
    } else {
      result = val;
    }
    return isNullOrUndefined(result) ? null : result;
  }
  function toTimestamp(serializer, timestamp) {
    if (serializer.useProto3Json) {
      var jsDateStr = new Date(timestamp.seconds * 1e3).toISOString();
      var strUntilSeconds = jsDateStr.replace(/\.\d*/, "").replace("Z", "");
      var nanoStr = ("000000000" + timestamp.nanoseconds).slice(-9);
      return strUntilSeconds + "." + nanoStr + "Z";
    } else {
      return {
        seconds: "" + timestamp.seconds,
        nanos: timestamp.nanoseconds
      };
    }
  }
  function fromTimestamp(date) {
    var timestamp = normalizeTimestamp(date);
    return new Timestamp(timestamp.seconds, timestamp.nanos);
  }
  function toBytes(serializer, bytes) {
    if (serializer.useProto3Json) {
      return bytes.toBase64();
    } else {
      return bytes.toUint8Array();
    }
  }
  function fromBytes(serializer, value) {
    if (serializer.useProto3Json) {
      hardAssert(value === void 0 || typeof value === "string");
      return ByteString.fromBase64String(value ? value : "");
    } else {
      hardAssert(value === void 0 || value instanceof Uint8Array);
      return ByteString.fromUint8Array(value ? value : new Uint8Array());
    }
  }
  function toVersion(serializer, version2) {
    return toTimestamp(serializer, version2.toTimestamp());
  }
  function fromVersion(version2) {
    hardAssert(!!version2);
    return SnapshotVersion.fromTimestamp(fromTimestamp(version2));
  }
  function toResourceName(databaseId, path2) {
    return fullyQualifiedPrefixPath(databaseId).child("documents").child(path2).canonicalString();
  }
  function fromResourceName(name) {
    var resource = ResourcePath.fromString(name);
    hardAssert(isValidResourceName(resource));
    return resource;
  }
  function toName(serializer, key) {
    return toResourceName(serializer.databaseId, key.path);
  }
  function fromName(serializer, name) {
    var resource = fromResourceName(name);
    if (resource.get(1) !== serializer.databaseId.projectId) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + resource.get(1) + " vs " + serializer.databaseId.projectId);
    }
    if (resource.get(3) !== serializer.databaseId.database) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + resource.get(3) + " vs " + serializer.databaseId.database);
    }
    return new DocumentKey(extractLocalPathFromResourceName(resource));
  }
  function toQueryPath(serializer, path2) {
    return toResourceName(serializer.databaseId, path2);
  }
  function fromQueryPath(name) {
    var resourceName = fromResourceName(name);
    if (resourceName.length === 4) {
      return ResourcePath.emptyPath();
    }
    return extractLocalPathFromResourceName(resourceName);
  }
  function getEncodedDatabaseId(serializer) {
    var path2 = new ResourcePath([
      "projects",
      serializer.databaseId.projectId,
      "databases",
      serializer.databaseId.database
    ]);
    return path2.canonicalString();
  }
  function fullyQualifiedPrefixPath(databaseId) {
    return new ResourcePath([
      "projects",
      databaseId.projectId,
      "databases",
      databaseId.database
    ]);
  }
  function extractLocalPathFromResourceName(resourceName) {
    hardAssert(resourceName.length > 4 && resourceName.get(4) === "documents");
    return resourceName.popFirst(5);
  }
  function toMutationDocument(serializer, key, fields) {
    return {
      name: toName(serializer, key),
      fields: fields.toProto().mapValue.fields
    };
  }
  function toDocument(serializer, document2) {
    return {
      name: toName(serializer, document2.key),
      fields: document2.data.toProto().mapValue.fields,
      updateTime: toTimestamp(serializer, document2.version.toTimestamp())
    };
  }
  function fromDocument(serializer, document2, hasCommittedMutations) {
    var key = fromName(serializer, document2.name);
    var version2 = fromVersion(document2.updateTime);
    var data = new ObjectValue({mapValue: {fields: document2.fields}});
    var result = MutableDocument.newFoundDocument(key, version2, data);
    if (hasCommittedMutations) {
      result.setHasCommittedMutations();
    }
    return hasCommittedMutations ? result.setHasCommittedMutations() : result;
  }
  function fromFound(serializer, doc2) {
    hardAssert(!!doc2.found);
    assertPresent(doc2.found.name);
    assertPresent(doc2.found.updateTime);
    var key = fromName(serializer, doc2.found.name);
    var version2 = fromVersion(doc2.found.updateTime);
    var data = new ObjectValue({mapValue: {fields: doc2.found.fields}});
    return MutableDocument.newFoundDocument(key, version2, data);
  }
  function fromMissing(serializer, result) {
    hardAssert(!!result.missing);
    hardAssert(!!result.readTime);
    var key = fromName(serializer, result.missing);
    var version2 = fromVersion(result.readTime);
    return MutableDocument.newNoDocument(key, version2);
  }
  function fromBatchGetDocumentsResponse(serializer, result) {
    if ("found" in result) {
      return fromFound(serializer, result);
    } else if ("missing" in result) {
      return fromMissing(serializer, result);
    }
    return fail();
  }
  function fromWatchChange(serializer, change) {
    var watchChange;
    if ("targetChange" in change) {
      assertPresent(change.targetChange);
      var state = fromWatchTargetChangeState(change.targetChange.targetChangeType || "NO_CHANGE");
      var targetIds = change.targetChange.targetIds || [];
      var resumeToken = fromBytes(serializer, change.targetChange.resumeToken);
      var causeProto = change.targetChange.cause;
      var cause = causeProto && fromRpcStatus(causeProto);
      watchChange = new WatchTargetChange(state, targetIds, resumeToken, cause || null);
    } else if ("documentChange" in change) {
      assertPresent(change.documentChange);
      var entityChange = change.documentChange;
      assertPresent(entityChange.document);
      assertPresent(entityChange.document.name);
      assertPresent(entityChange.document.updateTime);
      var key = fromName(serializer, entityChange.document.name);
      var version_1 = fromVersion(entityChange.document.updateTime);
      var data = new ObjectValue({
        mapValue: {fields: entityChange.document.fields}
      });
      var doc_1 = MutableDocument.newFoundDocument(key, version_1, data);
      var updatedTargetIds = entityChange.targetIds || [];
      var removedTargetIds = entityChange.removedTargetIds || [];
      watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc_1.key, doc_1);
    } else if ("documentDelete" in change) {
      assertPresent(change.documentDelete);
      var docDelete = change.documentDelete;
      assertPresent(docDelete.document);
      var key = fromName(serializer, docDelete.document);
      var version_2 = docDelete.readTime ? fromVersion(docDelete.readTime) : SnapshotVersion.min();
      var doc_2 = MutableDocument.newNoDocument(key, version_2);
      var removedTargetIds = docDelete.removedTargetIds || [];
      watchChange = new DocumentWatchChange([], removedTargetIds, doc_2.key, doc_2);
    } else if ("documentRemove" in change) {
      assertPresent(change.documentRemove);
      var docRemove = change.documentRemove;
      assertPresent(docRemove.document);
      var key = fromName(serializer, docRemove.document);
      var removedTargetIds = docRemove.removedTargetIds || [];
      watchChange = new DocumentWatchChange([], removedTargetIds, key, null);
    } else if ("filter" in change) {
      assertPresent(change.filter);
      var filter = change.filter;
      assertPresent(filter.targetId);
      var count = filter.count || 0;
      var existenceFilter = new ExistenceFilter(count);
      var targetId = filter.targetId;
      watchChange = new ExistenceFilterChange(targetId, existenceFilter);
    } else {
      return fail();
    }
    return watchChange;
  }
  function fromWatchTargetChangeState(state) {
    if (state === "NO_CHANGE") {
      return 0;
    } else if (state === "ADD") {
      return 1;
    } else if (state === "REMOVE") {
      return 2;
    } else if (state === "CURRENT") {
      return 3;
    } else if (state === "RESET") {
      return 4;
    } else {
      return fail();
    }
  }
  function versionFromListenResponse(change) {
    if (!("targetChange" in change)) {
      return SnapshotVersion.min();
    }
    var targetChange = change.targetChange;
    if (targetChange.targetIds && targetChange.targetIds.length) {
      return SnapshotVersion.min();
    }
    if (!targetChange.readTime) {
      return SnapshotVersion.min();
    }
    return fromVersion(targetChange.readTime);
  }
  function toMutation(serializer, mutation) {
    var result;
    if (mutation instanceof SetMutation) {
      result = {
        update: toMutationDocument(serializer, mutation.key, mutation.value)
      };
    } else if (mutation instanceof DeleteMutation) {
      result = {delete: toName(serializer, mutation.key)};
    } else if (mutation instanceof PatchMutation) {
      result = {
        update: toMutationDocument(serializer, mutation.key, mutation.data),
        updateMask: toDocumentMask(mutation.fieldMask)
      };
    } else if (mutation instanceof VerifyMutation) {
      result = {
        verify: toName(serializer, mutation.key)
      };
    } else {
      return fail();
    }
    if (mutation.fieldTransforms.length > 0) {
      result.updateTransforms = mutation.fieldTransforms.map(function(transform) {
        return toFieldTransform(serializer, transform);
      });
    }
    if (!mutation.precondition.isNone) {
      result.currentDocument = toPrecondition(serializer, mutation.precondition);
    }
    return result;
  }
  function fromMutation(serializer, proto) {
    var precondition = proto.currentDocument ? fromPrecondition(proto.currentDocument) : Precondition.none();
    var fieldTransforms = proto.updateTransforms ? proto.updateTransforms.map(function(transform) {
      return fromFieldTransform(serializer, transform);
    }) : [];
    if (proto.update) {
      assertPresent(proto.update.name);
      var key = fromName(serializer, proto.update.name);
      var value = new ObjectValue({
        mapValue: {fields: proto.update.fields}
      });
      if (proto.updateMask) {
        var fieldMask = fromDocumentMask(proto.updateMask);
        return new PatchMutation(key, value, fieldMask, precondition, fieldTransforms);
      } else {
        return new SetMutation(key, value, precondition, fieldTransforms);
      }
    } else if (proto.delete) {
      var key = fromName(serializer, proto.delete);
      return new DeleteMutation(key, precondition);
    } else if (proto.verify) {
      var key = fromName(serializer, proto.verify);
      return new VerifyMutation(key, precondition);
    } else {
      return fail();
    }
  }
  function toPrecondition(serializer, precondition) {
    if (precondition.updateTime !== void 0) {
      return {
        updateTime: toVersion(serializer, precondition.updateTime)
      };
    } else if (precondition.exists !== void 0) {
      return {exists: precondition.exists};
    } else {
      return fail();
    }
  }
  function fromPrecondition(precondition) {
    if (precondition.updateTime !== void 0) {
      return Precondition.updateTime(fromVersion(precondition.updateTime));
    } else if (precondition.exists !== void 0) {
      return Precondition.exists(precondition.exists);
    } else {
      return Precondition.none();
    }
  }
  function fromWriteResult(proto, commitTime) {
    var version2 = proto.updateTime ? fromVersion(proto.updateTime) : fromVersion(commitTime);
    if (version2.isEqual(SnapshotVersion.min())) {
      version2 = fromVersion(commitTime);
    }
    return new MutationResult(version2, proto.transformResults || []);
  }
  function fromWriteResults(protos, commitTime) {
    if (protos && protos.length > 0) {
      hardAssert(commitTime !== void 0);
      return protos.map(function(proto) {
        return fromWriteResult(proto, commitTime);
      });
    } else {
      return [];
    }
  }
  function toFieldTransform(serializer, fieldTransform) {
    var transform = fieldTransform.transform;
    if (transform instanceof ServerTimestampTransform) {
      return {
        fieldPath: fieldTransform.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    } else if (transform instanceof ArrayUnionTransformOperation) {
      return {
        fieldPath: fieldTransform.field.canonicalString(),
        appendMissingElements: {
          values: transform.elements
        }
      };
    } else if (transform instanceof ArrayRemoveTransformOperation) {
      return {
        fieldPath: fieldTransform.field.canonicalString(),
        removeAllFromArray: {
          values: transform.elements
        }
      };
    } else if (transform instanceof NumericIncrementTransformOperation) {
      return {
        fieldPath: fieldTransform.field.canonicalString(),
        increment: transform.operand
      };
    } else {
      throw fail();
    }
  }
  function fromFieldTransform(serializer, proto) {
    var transform = null;
    if ("setToServerValue" in proto) {
      hardAssert(proto.setToServerValue === "REQUEST_TIME");
      transform = new ServerTimestampTransform();
    } else if ("appendMissingElements" in proto) {
      var values = proto.appendMissingElements.values || [];
      transform = new ArrayUnionTransformOperation(values);
    } else if ("removeAllFromArray" in proto) {
      var values = proto.removeAllFromArray.values || [];
      transform = new ArrayRemoveTransformOperation(values);
    } else if ("increment" in proto) {
      transform = new NumericIncrementTransformOperation(serializer, proto.increment);
    } else {
      fail();
    }
    var fieldPath = FieldPath.fromServerFormat(proto.fieldPath);
    return new FieldTransform(fieldPath, transform);
  }
  function toDocumentsTarget(serializer, target) {
    return {documents: [toQueryPath(serializer, target.path)]};
  }
  function fromDocumentsTarget(documentsTarget) {
    var count = documentsTarget.documents.length;
    hardAssert(count === 1);
    var name = documentsTarget.documents[0];
    return queryToTarget(newQueryForPath(fromQueryPath(name)));
  }
  function toQueryTarget(serializer, target) {
    var result = {structuredQuery: {}};
    var path2 = target.path;
    if (target.collectionGroup !== null) {
      result.parent = toQueryPath(serializer, path2);
      result.structuredQuery.from = [
        {
          collectionId: target.collectionGroup,
          allDescendants: true
        }
      ];
    } else {
      result.parent = toQueryPath(serializer, path2.popLast());
      result.structuredQuery.from = [{collectionId: path2.lastSegment()}];
    }
    var where2 = toFilter(target.filters);
    if (where2) {
      result.structuredQuery.where = where2;
    }
    var orderBy2 = toOrder(target.orderBy);
    if (orderBy2) {
      result.structuredQuery.orderBy = orderBy2;
    }
    var limit2 = toInt32Proto(serializer, target.limit);
    if (limit2 !== null) {
      result.structuredQuery.limit = limit2;
    }
    if (target.startAt) {
      result.structuredQuery.startAt = toCursor(target.startAt);
    }
    if (target.endAt) {
      result.structuredQuery.endAt = toCursor(target.endAt);
    }
    return result;
  }
  function convertQueryTargetToQuery(target) {
    var path2 = fromQueryPath(target.parent);
    var query2 = target.structuredQuery;
    var fromCount = query2.from ? query2.from.length : 0;
    var collectionGroup2 = null;
    if (fromCount > 0) {
      hardAssert(fromCount === 1);
      var from = query2.from[0];
      if (from.allDescendants) {
        collectionGroup2 = from.collectionId;
      } else {
        path2 = path2.child(from.collectionId);
      }
    }
    var filterBy = [];
    if (query2.where) {
      filterBy = fromFilter(query2.where);
    }
    var orderBy2 = [];
    if (query2.orderBy) {
      orderBy2 = fromOrder(query2.orderBy);
    }
    var limit2 = null;
    if (query2.limit) {
      limit2 = fromInt32Proto(query2.limit);
    }
    var startAt2 = null;
    if (query2.startAt) {
      startAt2 = fromCursor(query2.startAt);
    }
    var endAt2 = null;
    if (query2.endAt) {
      endAt2 = fromCursor(query2.endAt);
    }
    return newQuery(path2, collectionGroup2, orderBy2, filterBy, limit2, "F", startAt2, endAt2);
  }
  function fromQueryTarget(target) {
    return queryToTarget(convertQueryTargetToQuery(target));
  }
  function toListenRequestLabels(serializer, targetData) {
    var value = toLabel(serializer, targetData.purpose);
    if (value == null) {
      return null;
    } else {
      return {
        "goog-listen-tags": value
      };
    }
  }
  function toLabel(serializer, purpose) {
    switch (purpose) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return fail();
    }
  }
  function toTarget(serializer, targetData) {
    var result;
    var target = targetData.target;
    if (isDocumentTarget(target)) {
      result = {documents: toDocumentsTarget(serializer, target)};
    } else {
      result = {query: toQueryTarget(serializer, target)};
    }
    result.targetId = targetData.targetId;
    if (targetData.resumeToken.approximateByteSize() > 0) {
      result.resumeToken = toBytes(serializer, targetData.resumeToken);
    } else if (targetData.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {
      result.readTime = toTimestamp(serializer, targetData.snapshotVersion.toTimestamp());
    }
    return result;
  }
  function toFilter(filters) {
    if (filters.length === 0) {
      return;
    }
    var protos = filters.map(function(filter) {
      return toUnaryOrFieldFilter(filter);
    });
    if (protos.length === 1) {
      return protos[0];
    }
    return {compositeFilter: {op: "AND", filters: protos}};
  }
  function fromFilter(filter) {
    if (!filter) {
      return [];
    } else if (filter.unaryFilter !== void 0) {
      return [fromUnaryFilter(filter)];
    } else if (filter.fieldFilter !== void 0) {
      return [fromFieldFilter(filter)];
    } else if (filter.compositeFilter !== void 0) {
      return filter.compositeFilter.filters.map(function(f) {
        return fromFilter(f);
      }).reduce(function(accum, current) {
        return accum.concat(current);
      });
    } else {
      return fail();
    }
  }
  function toOrder(orderBys) {
    if (orderBys.length === 0) {
      return;
    }
    return orderBys.map(function(order) {
      return toPropertyOrder(order);
    });
  }
  function fromOrder(orderBys) {
    return orderBys.map(function(order) {
      return fromPropertyOrder(order);
    });
  }
  function toCursor(cursor) {
    return {
      before: cursor.before,
      values: cursor.position
    };
  }
  function fromCursor(cursor) {
    var before = !!cursor.before;
    var position = cursor.values || [];
    return new Bound(position, before);
  }
  function toDirection(dir) {
    return DIRECTIONS[dir];
  }
  function fromDirection(dir) {
    switch (dir) {
      case "ASCENDING":
        return "asc";
      case "DESCENDING":
        return "desc";
      default:
        return void 0;
    }
  }
  function toOperatorName(op) {
    return OPERATORS[op];
  }
  function fromOperatorName(op) {
    switch (op) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      case "OPERATOR_UNSPECIFIED":
        return fail();
      default:
        return fail();
    }
  }
  function toFieldPathReference(path2) {
    return {fieldPath: path2.canonicalString()};
  }
  function fromFieldPathReference(fieldReference) {
    return FieldPath.fromServerFormat(fieldReference.fieldPath);
  }
  function toPropertyOrder(orderBy2) {
    return {
      field: toFieldPathReference(orderBy2.field),
      direction: toDirection(orderBy2.dir)
    };
  }
  function fromPropertyOrder(orderBy2) {
    return new OrderBy(fromFieldPathReference(orderBy2.field), fromDirection(orderBy2.direction));
  }
  function fromFieldFilter(filter) {
    return FieldFilter.create(fromFieldPathReference(filter.fieldFilter.field), fromOperatorName(filter.fieldFilter.op), filter.fieldFilter.value);
  }
  function toUnaryOrFieldFilter(filter) {
    if (filter.op === "==") {
      if (isNanValue(filter.value)) {
        return {
          unaryFilter: {
            field: toFieldPathReference(filter.field),
            op: "IS_NAN"
          }
        };
      } else if (isNullValue(filter.value)) {
        return {
          unaryFilter: {
            field: toFieldPathReference(filter.field),
            op: "IS_NULL"
          }
        };
      }
    } else if (filter.op === "!=") {
      if (isNanValue(filter.value)) {
        return {
          unaryFilter: {
            field: toFieldPathReference(filter.field),
            op: "IS_NOT_NAN"
          }
        };
      } else if (isNullValue(filter.value)) {
        return {
          unaryFilter: {
            field: toFieldPathReference(filter.field),
            op: "IS_NOT_NULL"
          }
        };
      }
    }
    return {
      fieldFilter: {
        field: toFieldPathReference(filter.field),
        op: toOperatorName(filter.op),
        value: filter.value
      }
    };
  }
  function fromUnaryFilter(filter) {
    switch (filter.unaryFilter.op) {
      case "IS_NAN":
        var nanField = fromFieldPathReference(filter.unaryFilter.field);
        return FieldFilter.create(nanField, "==", {
          doubleValue: NaN
        });
      case "IS_NULL":
        var nullField = fromFieldPathReference(filter.unaryFilter.field);
        return FieldFilter.create(nullField, "==", {
          nullValue: "NULL_VALUE"
        });
      case "IS_NOT_NAN":
        var notNanField = fromFieldPathReference(filter.unaryFilter.field);
        return FieldFilter.create(notNanField, "!=", {
          doubleValue: NaN
        });
      case "IS_NOT_NULL":
        var notNullField = fromFieldPathReference(filter.unaryFilter.field);
        return FieldFilter.create(notNullField, "!=", {
          nullValue: "NULL_VALUE"
        });
      case "OPERATOR_UNSPECIFIED":
        return fail();
      default:
        return fail();
    }
  }
  function toDocumentMask(fieldMask) {
    var canonicalFields = [];
    fieldMask.fields.forEach(function(field) {
      return canonicalFields.push(field.canonicalString());
    });
    return {
      fieldPaths: canonicalFields
    };
  }
  function fromDocumentMask(proto) {
    var paths = proto.fieldPaths || [];
    return new FieldMask(paths.map(function(path2) {
      return FieldPath.fromServerFormat(path2);
    }));
  }
  function isValidResourceName(path2) {
    return path2.length >= 4 && path2.get(0) === "projects" && path2.get(2) === "databases";
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var TargetData = function() {
    function TargetData2(target, targetId, purpose, sequenceNumber, snapshotVersion, lastLimboFreeSnapshotVersion, resumeToken) {
      if (snapshotVersion === void 0) {
        snapshotVersion = SnapshotVersion.min();
      }
      if (lastLimboFreeSnapshotVersion === void 0) {
        lastLimboFreeSnapshotVersion = SnapshotVersion.min();
      }
      if (resumeToken === void 0) {
        resumeToken = ByteString.EMPTY_BYTE_STRING;
      }
      this.target = target;
      this.targetId = targetId;
      this.purpose = purpose;
      this.sequenceNumber = sequenceNumber;
      this.snapshotVersion = snapshotVersion;
      this.lastLimboFreeSnapshotVersion = lastLimboFreeSnapshotVersion;
      this.resumeToken = resumeToken;
    }
    TargetData2.prototype.withSequenceNumber = function(sequenceNumber) {
      return new TargetData2(this.target, this.targetId, this.purpose, sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
    };
    TargetData2.prototype.withResumeToken = function(resumeToken, snapshotVersion) {
      return new TargetData2(this.target, this.targetId, this.purpose, this.sequenceNumber, snapshotVersion, this.lastLimboFreeSnapshotVersion, resumeToken);
    };
    TargetData2.prototype.withLastLimboFreeSnapshotVersion = function(lastLimboFreeSnapshotVersion) {
      return new TargetData2(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, lastLimboFreeSnapshotVersion, this.resumeToken);
    };
    return TargetData2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LocalSerializer = function() {
    function LocalSerializer2(remoteSerializer) {
      this.remoteSerializer = remoteSerializer;
    }
    return LocalSerializer2;
  }();
  function fromDbRemoteDocument(localSerializer, remoteDoc) {
    if (remoteDoc.document) {
      return fromDocument(localSerializer.remoteSerializer, remoteDoc.document, !!remoteDoc.hasCommittedMutations);
    } else if (remoteDoc.noDocument) {
      var key = DocumentKey.fromSegments(remoteDoc.noDocument.path);
      var version_3 = fromDbTimestamp(remoteDoc.noDocument.readTime);
      var document_1 = MutableDocument.newNoDocument(key, version_3);
      return remoteDoc.hasCommittedMutations ? document_1.setHasCommittedMutations() : document_1;
    } else if (remoteDoc.unknownDocument) {
      var key = DocumentKey.fromSegments(remoteDoc.unknownDocument.path);
      var version_4 = fromDbTimestamp(remoteDoc.unknownDocument.version);
      return MutableDocument.newUnknownDocument(key, version_4);
    } else {
      return fail();
    }
  }
  function toDbRemoteDocument(localSerializer, document2, readTime) {
    var dbReadTime = toDbTimestampKey(readTime);
    var parentPath = document2.key.path.popLast().toArray();
    if (document2.isFoundDocument()) {
      var doc_3 = toDocument(localSerializer.remoteSerializer, document2);
      var hasCommittedMutations = document2.hasCommittedMutations;
      return new DbRemoteDocument(null, null, doc_3, hasCommittedMutations, dbReadTime, parentPath);
    } else if (document2.isNoDocument()) {
      var path2 = document2.key.path.toArray();
      var readTime_1 = toDbTimestamp(document2.version);
      var hasCommittedMutations = document2.hasCommittedMutations;
      return new DbRemoteDocument(null, new DbNoDocument(path2, readTime_1), null, hasCommittedMutations, dbReadTime, parentPath);
    } else if (document2.isUnknownDocument()) {
      var path2 = document2.key.path.toArray();
      var readTime_2 = toDbTimestamp(document2.version);
      return new DbRemoteDocument(new DbUnknownDocument(path2, readTime_2), null, null, true, dbReadTime, parentPath);
    } else {
      return fail();
    }
  }
  function toDbTimestampKey(snapshotVersion) {
    var timestamp = snapshotVersion.toTimestamp();
    return [timestamp.seconds, timestamp.nanoseconds];
  }
  function fromDbTimestampKey(dbTimestampKey) {
    var timestamp = new Timestamp(dbTimestampKey[0], dbTimestampKey[1]);
    return SnapshotVersion.fromTimestamp(timestamp);
  }
  function toDbTimestamp(snapshotVersion) {
    var timestamp = snapshotVersion.toTimestamp();
    return new DbTimestamp(timestamp.seconds, timestamp.nanoseconds);
  }
  function fromDbTimestamp(dbTimestamp) {
    var timestamp = new Timestamp(dbTimestamp.seconds, dbTimestamp.nanoseconds);
    return SnapshotVersion.fromTimestamp(timestamp);
  }
  function toDbMutationBatch(localSerializer, userId, batch) {
    var serializedBaseMutations = batch.baseMutations.map(function(m) {
      return toMutation(localSerializer.remoteSerializer, m);
    });
    var serializedMutations = batch.mutations.map(function(m) {
      return toMutation(localSerializer.remoteSerializer, m);
    });
    return new DbMutationBatch(userId, batch.batchId, batch.localWriteTime.toMillis(), serializedBaseMutations, serializedMutations);
  }
  function fromDbMutationBatch(localSerializer, dbBatch) {
    var baseMutations = (dbBatch.baseMutations || []).map(function(m) {
      return fromMutation(localSerializer.remoteSerializer, m);
    });
    for (var i = 0; i < dbBatch.mutations.length - 1; ++i) {
      var currentMutation = dbBatch.mutations[i];
      var hasTransform = i + 1 < dbBatch.mutations.length && dbBatch.mutations[i + 1].transform !== void 0;
      if (hasTransform) {
        var transformMutation = dbBatch.mutations[i + 1];
        currentMutation.updateTransforms = transformMutation.transform.fieldTransforms;
        dbBatch.mutations.splice(i + 1, 1);
        ++i;
      }
    }
    var mutations = dbBatch.mutations.map(function(m) {
      return fromMutation(localSerializer.remoteSerializer, m);
    });
    var timestamp = Timestamp.fromMillis(dbBatch.localWriteTimeMs);
    return new MutationBatch(dbBatch.batchId, timestamp, baseMutations, mutations);
  }
  function fromDbTarget(dbTarget) {
    var version2 = fromDbTimestamp(dbTarget.readTime);
    var lastLimboFreeSnapshotVersion = dbTarget.lastLimboFreeSnapshotVersion !== void 0 ? fromDbTimestamp(dbTarget.lastLimboFreeSnapshotVersion) : SnapshotVersion.min();
    var target;
    if (isDocumentQuery$1(dbTarget.query)) {
      target = fromDocumentsTarget(dbTarget.query);
    } else {
      target = fromQueryTarget(dbTarget.query);
    }
    return new TargetData(target, dbTarget.targetId, 0, dbTarget.lastListenSequenceNumber, version2, lastLimboFreeSnapshotVersion, ByteString.fromBase64String(dbTarget.resumeToken));
  }
  function toDbTarget(localSerializer, targetData) {
    var dbTimestamp = toDbTimestamp(targetData.snapshotVersion);
    var dbLastLimboFreeTimestamp = toDbTimestamp(targetData.lastLimboFreeSnapshotVersion);
    var queryProto;
    if (isDocumentTarget(targetData.target)) {
      queryProto = toDocumentsTarget(localSerializer.remoteSerializer, targetData.target);
    } else {
      queryProto = toQueryTarget(localSerializer.remoteSerializer, targetData.target);
    }
    var resumeToken = targetData.resumeToken.toBase64();
    return new DbTarget(targetData.targetId, canonifyTarget(targetData.target), dbTimestamp, resumeToken, targetData.sequenceNumber, dbLastLimboFreeTimestamp, queryProto);
  }
  function isDocumentQuery$1(dbQuery) {
    return dbQuery.documents !== void 0;
  }
  function fromDbBundle(dbBundle) {
    return {
      id: dbBundle.bundleId,
      createTime: fromDbTimestamp(dbBundle.createTime),
      version: dbBundle.version
    };
  }
  function toDbBundle(metadata) {
    return {
      bundleId: metadata.id,
      createTime: toDbTimestamp(fromVersion(metadata.createTime)),
      version: metadata.version
    };
  }
  function fromDbNamedQuery(dbNamedQuery) {
    return {
      name: dbNamedQuery.name,
      query: fromBundledQuery(dbNamedQuery.bundledQuery),
      readTime: fromDbTimestamp(dbNamedQuery.readTime)
    };
  }
  function toDbNamedQuery(query2) {
    return {
      name: query2.name,
      readTime: toDbTimestamp(fromVersion(query2.readTime)),
      bundledQuery: query2.bundledQuery
    };
  }
  function fromBundledQuery(bundledQuery) {
    var query2 = convertQueryTargetToQuery({
      parent: bundledQuery.parent,
      structuredQuery: bundledQuery.structuredQuery
    });
    if (bundledQuery.limitType === "LAST") {
      return queryWithLimit(query2, query2.limit, "L");
    }
    return query2;
  }
  function fromProtoNamedQuery(namedQuery2) {
    return {
      name: namedQuery2.name,
      query: fromBundledQuery(namedQuery2.bundledQuery),
      readTime: fromVersion(namedQuery2.readTime)
    };
  }
  function fromBundleMetadata(metadata) {
    return {
      id: metadata.id,
      version: metadata.version,
      createTime: fromVersion(metadata.createTime)
    };
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var IndexedDbBundleCache = function() {
    function IndexedDbBundleCache2() {
    }
    IndexedDbBundleCache2.prototype.getBundleMetadata = function(transaction, bundleId) {
      return bundlesStore(transaction).get(bundleId).next(function(bundle) {
        if (bundle) {
          return fromDbBundle(bundle);
        }
        return void 0;
      });
    };
    IndexedDbBundleCache2.prototype.saveBundleMetadata = function(transaction, bundleMetadata) {
      return bundlesStore(transaction).put(toDbBundle(bundleMetadata));
    };
    IndexedDbBundleCache2.prototype.getNamedQuery = function(transaction, queryName) {
      return namedQueriesStore(transaction).get(queryName).next(function(query2) {
        if (query2) {
          return fromDbNamedQuery(query2);
        }
        return void 0;
      });
    };
    IndexedDbBundleCache2.prototype.saveNamedQuery = function(transaction, query2) {
      return namedQueriesStore(transaction).put(toDbNamedQuery(query2));
    };
    return IndexedDbBundleCache2;
  }();
  function bundlesStore(txn) {
    return getStore(txn, DbBundle.store);
  }
  function namedQueriesStore(txn) {
    return getStore(txn, DbNamedQuery.store);
  }
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var MemoryIndexManager = function() {
    function MemoryIndexManager2() {
      this.collectionParentIndex = new MemoryCollectionParentIndex();
    }
    MemoryIndexManager2.prototype.addToCollectionParentIndex = function(transaction, collectionPath) {
      this.collectionParentIndex.add(collectionPath);
      return PersistencePromise.resolve();
    };
    MemoryIndexManager2.prototype.getCollectionParents = function(transaction, collectionId) {
      return PersistencePromise.resolve(this.collectionParentIndex.getEntries(collectionId));
    };
    return MemoryIndexManager2;
  }();
  var MemoryCollectionParentIndex = function() {
    function MemoryCollectionParentIndex2() {
      this.index = {};
    }
    MemoryCollectionParentIndex2.prototype.add = function(collectionPath) {
      var collectionId = collectionPath.lastSegment();
      var parentPath = collectionPath.popLast();
      var existingParents = this.index[collectionId] || new SortedSet(ResourcePath.comparator);
      var added = !existingParents.has(parentPath);
      this.index[collectionId] = existingParents.add(parentPath);
      return added;
    };
    MemoryCollectionParentIndex2.prototype.has = function(collectionPath) {
      var collectionId = collectionPath.lastSegment();
      var parentPath = collectionPath.popLast();
      var existingParents = this.index[collectionId];
      return existingParents && existingParents.has(parentPath);
    };
    MemoryCollectionParentIndex2.prototype.getEntries = function(collectionId) {
      var parentPaths = this.index[collectionId] || new SortedSet(ResourcePath.comparator);
      return parentPaths.toArray();
    };
    return MemoryCollectionParentIndex2;
  }();
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var IndexedDbIndexManager = function() {
    function IndexedDbIndexManager2() {
      this.collectionParentsCache = new MemoryCollectionParentIndex();
    }
    IndexedDbIndexManager2.prototype.addToCollectionParentIndex = function(transaction, collectionPath) {
      var _this = this;
      if (!this.collectionParentsCache.has(collectionPath)) {
        var collectionId = collectionPath.lastSegment();
        var parentPath = collectionPath.popLast();
        transaction.addOnCommittedListener(function() {
          _this.collectionParentsCache.add(collectionPath);
        });
        var collectionParent = {
          collectionId,
          parent: encodeResourcePath(parentPath)
        };
        return collectionParentsStore(transaction).put(collectionParent);
      }
      return PersistencePromise.resolve();
    };
    IndexedDbIndexManager2.prototype.getCollectionParents = function(transaction, collectionId) {
      var parentPaths = [];
      var range = IDBKeyRange.bound([collectionId, ""], [immediateSuccessor(collectionId), ""], false, true);
      return collectionParentsStore(transaction).loadAll(range).next(function(entries) {
        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
          var entry = entries_1[_i];
          if (entry.collectionId !== collectionId) {
            break;
          }
          parentPaths.push(decodeResourcePath(entry.parent));
        }
        return parentPaths;
      });
    };
    return IndexedDbIndexManager2;
  }();
  function collectionParentsStore(txn) {
    return getStore(txn, DbCollectionParent.store);
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function removeMutationBatch(txn, userId, batch) {
    var mutationStore = txn.store(DbMutationBatch.store);
    var indexTxn = txn.store(DbDocumentMutation.store);
    var promises = [];
    var range = IDBKeyRange.only(batch.batchId);
    var numDeleted = 0;
    var removePromise = mutationStore.iterate({range}, function(key, value, control) {
      numDeleted++;
      return control.delete();
    });
    promises.push(removePromise.next(function() {
      hardAssert(numDeleted === 1);
    }));
    var removedDocuments = [];
    for (var _i = 0, _d = batch.mutations; _i < _d.length; _i++) {
      var mutation = _d[_i];
      var indexKey = DbDocumentMutation.key(userId, mutation.key.path, batch.batchId);
      promises.push(indexTxn.delete(indexKey));
      removedDocuments.push(mutation.key);
    }
    return PersistencePromise.waitFor(promises).next(function() {
      return removedDocuments;
    });
  }
  function dbDocumentSize(doc2) {
    if (!doc2) {
      return 0;
    }
    var value;
    if (doc2.document) {
      value = doc2.document;
    } else if (doc2.unknownDocument) {
      value = doc2.unknownDocument;
    } else if (doc2.noDocument) {
      value = doc2.noDocument;
    } else {
      throw fail();
    }
    return JSON.stringify(value).length;
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var IndexedDbMutationQueue = function() {
    function IndexedDbMutationQueue2(userId, serializer, indexManager, referenceDelegate) {
      this.userId = userId;
      this.serializer = serializer;
      this.indexManager = indexManager;
      this.referenceDelegate = referenceDelegate;
      this.documentKeysByBatchId = {};
    }
    IndexedDbMutationQueue2.forUser = function(user, serializer, indexManager, referenceDelegate) {
      hardAssert(user.uid !== "");
      var userId = user.isAuthenticated() ? user.uid : "";
      return new IndexedDbMutationQueue2(userId, serializer, indexManager, referenceDelegate);
    };
    IndexedDbMutationQueue2.prototype.checkEmpty = function(transaction) {
      var empty = true;
      var range = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
      return mutationsStore(transaction).iterate({index: DbMutationBatch.userMutationsIndex, range}, function(key, value, control) {
        empty = false;
        control.done();
      }).next(function() {
        return empty;
      });
    };
    IndexedDbMutationQueue2.prototype.addMutationBatch = function(transaction, localWriteTime, baseMutations, mutations) {
      var _this = this;
      var documentStore = documentMutationsStore(transaction);
      var mutationStore = mutationsStore(transaction);
      return mutationStore.add({}).next(function(batchId) {
        hardAssert(typeof batchId === "number");
        var batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);
        var dbBatch = toDbMutationBatch(_this.serializer, _this.userId, batch);
        var promises = [];
        var collectionParents = new SortedSet(function(l, r) {
          return primitiveComparator(l.canonicalString(), r.canonicalString());
        });
        for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
          var mutation = mutations_1[_i];
          var indexKey = DbDocumentMutation.key(_this.userId, mutation.key.path, batchId);
          collectionParents = collectionParents.add(mutation.key.path.popLast());
          promises.push(mutationStore.put(dbBatch));
          promises.push(documentStore.put(indexKey, DbDocumentMutation.PLACEHOLDER));
        }
        collectionParents.forEach(function(parent) {
          promises.push(_this.indexManager.addToCollectionParentIndex(transaction, parent));
        });
        transaction.addOnCommittedListener(function() {
          _this.documentKeysByBatchId[batchId] = batch.keys();
        });
        return PersistencePromise.waitFor(promises).next(function() {
          return batch;
        });
      });
    };
    IndexedDbMutationQueue2.prototype.lookupMutationBatch = function(transaction, batchId) {
      var _this = this;
      return mutationsStore(transaction).get(batchId).next(function(dbBatch) {
        if (dbBatch) {
          hardAssert(dbBatch.userId === _this.userId);
          return fromDbMutationBatch(_this.serializer, dbBatch);
        }
        return null;
      });
    };
    IndexedDbMutationQueue2.prototype.lookupMutationKeys = function(transaction, batchId) {
      var _this = this;
      if (this.documentKeysByBatchId[batchId]) {
        return PersistencePromise.resolve(this.documentKeysByBatchId[batchId]);
      } else {
        return this.lookupMutationBatch(transaction, batchId).next(function(batch) {
          if (batch) {
            var keys = batch.keys();
            _this.documentKeysByBatchId[batchId] = keys;
            return keys;
          } else {
            return null;
          }
        });
      }
    };
    IndexedDbMutationQueue2.prototype.getNextMutationBatchAfterBatchId = function(transaction, batchId) {
      var _this = this;
      var nextBatchId = batchId + 1;
      var range = IDBKeyRange.lowerBound([this.userId, nextBatchId]);
      var foundBatch = null;
      return mutationsStore(transaction).iterate({index: DbMutationBatch.userMutationsIndex, range}, function(key, dbBatch, control) {
        if (dbBatch.userId === _this.userId) {
          hardAssert(dbBatch.batchId >= nextBatchId);
          foundBatch = fromDbMutationBatch(_this.serializer, dbBatch);
        }
        control.done();
      }).next(function() {
        return foundBatch;
      });
    };
    IndexedDbMutationQueue2.prototype.getHighestUnacknowledgedBatchId = function(transaction) {
      var range = IDBKeyRange.upperBound([
        this.userId,
        Number.POSITIVE_INFINITY
      ]);
      var batchId = BATCHID_UNKNOWN;
      return mutationsStore(transaction).iterate({index: DbMutationBatch.userMutationsIndex, range, reverse: true}, function(key, dbBatch, control) {
        batchId = dbBatch.batchId;
        control.done();
      }).next(function() {
        return batchId;
      });
    };
    IndexedDbMutationQueue2.prototype.getAllMutationBatches = function(transaction) {
      var _this = this;
      var range = IDBKeyRange.bound([this.userId, BATCHID_UNKNOWN], [this.userId, Number.POSITIVE_INFINITY]);
      return mutationsStore(transaction).loadAll(DbMutationBatch.userMutationsIndex, range).next(function(dbBatches) {
        return dbBatches.map(function(dbBatch) {
          return fromDbMutationBatch(_this.serializer, dbBatch);
        });
      });
    };
    IndexedDbMutationQueue2.prototype.getAllMutationBatchesAffectingDocumentKey = function(transaction, documentKey) {
      var _this = this;
      var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, documentKey.path);
      var indexStart = IDBKeyRange.lowerBound(indexPrefix);
      var results = [];
      return documentMutationsStore(transaction).iterate({range: indexStart}, function(indexKey, _, control) {
        var userID = indexKey[0], encodedPath = indexKey[1], batchId = indexKey[2];
        var path2 = decodeResourcePath(encodedPath);
        if (userID !== _this.userId || !documentKey.path.isEqual(path2)) {
          control.done();
          return;
        }
        return mutationsStore(transaction).get(batchId).next(function(mutation) {
          if (!mutation) {
            throw fail();
          }
          hardAssert(mutation.userId === _this.userId);
          results.push(fromDbMutationBatch(_this.serializer, mutation));
        });
      }).next(function() {
        return results;
      });
    };
    IndexedDbMutationQueue2.prototype.getAllMutationBatchesAffectingDocumentKeys = function(transaction, documentKeys) {
      var _this = this;
      var uniqueBatchIDs = new SortedSet(primitiveComparator);
      var promises = [];
      documentKeys.forEach(function(documentKey) {
        var indexStart = DbDocumentMutation.prefixForPath(_this.userId, documentKey.path);
        var range = IDBKeyRange.lowerBound(indexStart);
        var promise = documentMutationsStore(transaction).iterate({range}, function(indexKey, _, control) {
          var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];
          var path2 = decodeResourcePath(encodedPath);
          if (userID !== _this.userId || !documentKey.path.isEqual(path2)) {
            control.done();
            return;
          }
          uniqueBatchIDs = uniqueBatchIDs.add(batchID);
        });
        promises.push(promise);
      });
      return PersistencePromise.waitFor(promises).next(function() {
        return _this.lookupMutationBatches(transaction, uniqueBatchIDs);
      });
    };
    IndexedDbMutationQueue2.prototype.getAllMutationBatchesAffectingQuery = function(transaction, query2) {
      var _this = this;
      var queryPath = query2.path;
      var immediateChildrenLength = queryPath.length + 1;
      var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, queryPath);
      var indexStart = IDBKeyRange.lowerBound(indexPrefix);
      var uniqueBatchIDs = new SortedSet(primitiveComparator);
      return documentMutationsStore(transaction).iterate({range: indexStart}, function(indexKey, _, control) {
        var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];
        var path2 = decodeResourcePath(encodedPath);
        if (userID !== _this.userId || !queryPath.isPrefixOf(path2)) {
          control.done();
          return;
        }
        if (path2.length !== immediateChildrenLength) {
          return;
        }
        uniqueBatchIDs = uniqueBatchIDs.add(batchID);
      }).next(function() {
        return _this.lookupMutationBatches(transaction, uniqueBatchIDs);
      });
    };
    IndexedDbMutationQueue2.prototype.lookupMutationBatches = function(transaction, batchIDs) {
      var _this = this;
      var results = [];
      var promises = [];
      batchIDs.forEach(function(batchId) {
        promises.push(mutationsStore(transaction).get(batchId).next(function(mutation) {
          if (mutation === null) {
            throw fail();
          }
          hardAssert(mutation.userId === _this.userId);
          results.push(fromDbMutationBatch(_this.serializer, mutation));
        }));
      });
      return PersistencePromise.waitFor(promises).next(function() {
        return results;
      });
    };
    IndexedDbMutationQueue2.prototype.removeMutationBatch = function(transaction, batch) {
      var _this = this;
      return removeMutationBatch(transaction.simpleDbTransaction, this.userId, batch).next(function(removedDocuments) {
        transaction.addOnCommittedListener(function() {
          _this.removeCachedMutationKeys(batch.batchId);
        });
        return PersistencePromise.forEach(removedDocuments, function(key) {
          return _this.referenceDelegate.markPotentiallyOrphaned(transaction, key);
        });
      });
    };
    IndexedDbMutationQueue2.prototype.removeCachedMutationKeys = function(batchId) {
      delete this.documentKeysByBatchId[batchId];
    };
    IndexedDbMutationQueue2.prototype.performConsistencyCheck = function(txn) {
      var _this = this;
      return this.checkEmpty(txn).next(function(empty) {
        if (!empty) {
          return PersistencePromise.resolve();
        }
        var startRange = IDBKeyRange.lowerBound(DbDocumentMutation.prefixForUser(_this.userId));
        var danglingMutationReferences = [];
        return documentMutationsStore(txn).iterate({range: startRange}, function(key, _, control) {
          var userID = key[0];
          if (userID !== _this.userId) {
            control.done();
            return;
          } else {
            var path2 = decodeResourcePath(key[1]);
            danglingMutationReferences.push(path2);
          }
        }).next(function() {
          hardAssert(danglingMutationReferences.length === 0);
        });
      });
    };
    IndexedDbMutationQueue2.prototype.containsKey = function(txn, key) {
      return mutationQueueContainsKey(txn, this.userId, key);
    };
    IndexedDbMutationQueue2.prototype.getMutationQueueMetadata = function(transaction) {
      var _this = this;
      return mutationQueuesStore(transaction).get(this.userId).next(function(metadata) {
        return metadata || new DbMutationQueue(_this.userId, BATCHID_UNKNOWN, "");
      });
    };
    return IndexedDbMutationQueue2;
  }();
  function mutationQueueContainsKey(txn, userId, key) {
    var indexKey = DbDocumentMutation.prefixForPath(userId, key.path);
    var encodedPath = indexKey[1];
    var startRange = IDBKeyRange.lowerBound(indexKey);
    var containsKey = false;
    return documentMutationsStore(txn).iterate({range: startRange, keysOnly: true}, function(key2, value, control) {
      var userID = key2[0], keyPath = key2[1], _ = key2[2];
      if (userID === userId && keyPath === encodedPath) {
        containsKey = true;
      }
      control.done();
    }).next(function() {
      return containsKey;
    });
  }
  function mutationQueuesContainKey(txn, docKey) {
    var found = false;
    return mutationQueuesStore(txn).iterateSerial(function(userId) {
      return mutationQueueContainsKey(txn, userId, docKey).next(function(containsKey) {
        if (containsKey) {
          found = true;
        }
        return PersistencePromise.resolve(!containsKey);
      });
    }).next(function() {
      return found;
    });
  }
  function mutationsStore(txn) {
    return getStore(txn, DbMutationBatch.store);
  }
  function documentMutationsStore(txn) {
    return getStore(txn, DbDocumentMutation.store);
  }
  function mutationQueuesStore(txn) {
    return getStore(txn, DbMutationQueue.store);
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var OFFSET = 2;
  var TargetIdGenerator = function() {
    function TargetIdGenerator2(lastId) {
      this.lastId = lastId;
    }
    TargetIdGenerator2.prototype.next = function() {
      this.lastId += OFFSET;
      return this.lastId;
    };
    TargetIdGenerator2.forTargetCache = function() {
      return new TargetIdGenerator2(2 - OFFSET);
    };
    TargetIdGenerator2.forSyncEngine = function() {
      return new TargetIdGenerator2(1 - OFFSET);
    };
    return TargetIdGenerator2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var IndexedDbTargetCache = function() {
    function IndexedDbTargetCache2(referenceDelegate, serializer) {
      this.referenceDelegate = referenceDelegate;
      this.serializer = serializer;
    }
    IndexedDbTargetCache2.prototype.allocateTargetId = function(transaction) {
      var _this = this;
      return this.retrieveMetadata(transaction).next(function(metadata) {
        var targetIdGenerator = new TargetIdGenerator(metadata.highestTargetId);
        metadata.highestTargetId = targetIdGenerator.next();
        return _this.saveMetadata(transaction, metadata).next(function() {
          return metadata.highestTargetId;
        });
      });
    };
    IndexedDbTargetCache2.prototype.getLastRemoteSnapshotVersion = function(transaction) {
      return this.retrieveMetadata(transaction).next(function(metadata) {
        return SnapshotVersion.fromTimestamp(new Timestamp(metadata.lastRemoteSnapshotVersion.seconds, metadata.lastRemoteSnapshotVersion.nanoseconds));
      });
    };
    IndexedDbTargetCache2.prototype.getHighestSequenceNumber = function(transaction) {
      return this.retrieveMetadata(transaction).next(function(targetGlobal) {
        return targetGlobal.highestListenSequenceNumber;
      });
    };
    IndexedDbTargetCache2.prototype.setTargetsMetadata = function(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {
      var _this = this;
      return this.retrieveMetadata(transaction).next(function(metadata) {
        metadata.highestListenSequenceNumber = highestListenSequenceNumber;
        if (lastRemoteSnapshotVersion) {
          metadata.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion.toTimestamp();
        }
        if (highestListenSequenceNumber > metadata.highestListenSequenceNumber) {
          metadata.highestListenSequenceNumber = highestListenSequenceNumber;
        }
        return _this.saveMetadata(transaction, metadata);
      });
    };
    IndexedDbTargetCache2.prototype.addTargetData = function(transaction, targetData) {
      var _this = this;
      return this.saveTargetData(transaction, targetData).next(function() {
        return _this.retrieveMetadata(transaction).next(function(metadata) {
          metadata.targetCount += 1;
          _this.updateMetadataFromTargetData(targetData, metadata);
          return _this.saveMetadata(transaction, metadata);
        });
      });
    };
    IndexedDbTargetCache2.prototype.updateTargetData = function(transaction, targetData) {
      return this.saveTargetData(transaction, targetData);
    };
    IndexedDbTargetCache2.prototype.removeTargetData = function(transaction, targetData) {
      var _this = this;
      return this.removeMatchingKeysForTargetId(transaction, targetData.targetId).next(function() {
        return targetsStore(transaction).delete(targetData.targetId);
      }).next(function() {
        return _this.retrieveMetadata(transaction);
      }).next(function(metadata) {
        hardAssert(metadata.targetCount > 0);
        metadata.targetCount -= 1;
        return _this.saveMetadata(transaction, metadata);
      });
    };
    IndexedDbTargetCache2.prototype.removeTargets = function(txn, upperBound, activeTargetIds) {
      var _this = this;
      var count = 0;
      var promises = [];
      return targetsStore(txn).iterate(function(key, value) {
        var targetData = fromDbTarget(value);
        if (targetData.sequenceNumber <= upperBound && activeTargetIds.get(targetData.targetId) === null) {
          count++;
          promises.push(_this.removeTargetData(txn, targetData));
        }
      }).next(function() {
        return PersistencePromise.waitFor(promises);
      }).next(function() {
        return count;
      });
    };
    IndexedDbTargetCache2.prototype.forEachTarget = function(txn, f) {
      return targetsStore(txn).iterate(function(key, value) {
        var targetData = fromDbTarget(value);
        f(targetData);
      });
    };
    IndexedDbTargetCache2.prototype.retrieveMetadata = function(transaction) {
      return globalTargetStore(transaction).get(DbTargetGlobal.key).next(function(metadata) {
        hardAssert(metadata !== null);
        return metadata;
      });
    };
    IndexedDbTargetCache2.prototype.saveMetadata = function(transaction, metadata) {
      return globalTargetStore(transaction).put(DbTargetGlobal.key, metadata);
    };
    IndexedDbTargetCache2.prototype.saveTargetData = function(transaction, targetData) {
      return targetsStore(transaction).put(toDbTarget(this.serializer, targetData));
    };
    IndexedDbTargetCache2.prototype.updateMetadataFromTargetData = function(targetData, metadata) {
      var updated = false;
      if (targetData.targetId > metadata.highestTargetId) {
        metadata.highestTargetId = targetData.targetId;
        updated = true;
      }
      if (targetData.sequenceNumber > metadata.highestListenSequenceNumber) {
        metadata.highestListenSequenceNumber = targetData.sequenceNumber;
        updated = true;
      }
      return updated;
    };
    IndexedDbTargetCache2.prototype.getTargetCount = function(transaction) {
      return this.retrieveMetadata(transaction).next(function(metadata) {
        return metadata.targetCount;
      });
    };
    IndexedDbTargetCache2.prototype.getTargetData = function(transaction, target) {
      var canonicalId2 = canonifyTarget(target);
      var range = IDBKeyRange.bound([canonicalId2, Number.NEGATIVE_INFINITY], [canonicalId2, Number.POSITIVE_INFINITY]);
      var result = null;
      return targetsStore(transaction).iterate({range, index: DbTarget.queryTargetsIndexName}, function(key, value, control) {
        var found = fromDbTarget(value);
        if (targetEquals(target, found.target)) {
          result = found;
          control.done();
        }
      }).next(function() {
        return result;
      });
    };
    IndexedDbTargetCache2.prototype.addMatchingKeys = function(txn, keys, targetId) {
      var _this = this;
      var promises = [];
      var store = documentTargetStore(txn);
      keys.forEach(function(key) {
        var path2 = encodeResourcePath(key.path);
        promises.push(store.put(new DbTargetDocument(targetId, path2)));
        promises.push(_this.referenceDelegate.addReference(txn, targetId, key));
      });
      return PersistencePromise.waitFor(promises);
    };
    IndexedDbTargetCache2.prototype.removeMatchingKeys = function(txn, keys, targetId) {
      var _this = this;
      var store = documentTargetStore(txn);
      return PersistencePromise.forEach(keys, function(key) {
        var path2 = encodeResourcePath(key.path);
        return PersistencePromise.waitFor([
          store.delete([targetId, path2]),
          _this.referenceDelegate.removeReference(txn, targetId, key)
        ]);
      });
    };
    IndexedDbTargetCache2.prototype.removeMatchingKeysForTargetId = function(txn, targetId) {
      var store = documentTargetStore(txn);
      var range = IDBKeyRange.bound([targetId], [targetId + 1], false, true);
      return store.delete(range);
    };
    IndexedDbTargetCache2.prototype.getMatchingKeysForTargetId = function(txn, targetId) {
      var range = IDBKeyRange.bound([targetId], [targetId + 1], false, true);
      var store = documentTargetStore(txn);
      var result = documentKeySet();
      return store.iterate({range, keysOnly: true}, function(key, _, control) {
        var path2 = decodeResourcePath(key[1]);
        var docKey = new DocumentKey(path2);
        result = result.add(docKey);
      }).next(function() {
        return result;
      });
    };
    IndexedDbTargetCache2.prototype.containsKey = function(txn, key) {
      var path2 = encodeResourcePath(key.path);
      var range = IDBKeyRange.bound([path2], [immediateSuccessor(path2)], false, true);
      var count = 0;
      return documentTargetStore(txn).iterate({
        index: DbTargetDocument.documentTargetsIndex,
        keysOnly: true,
        range
      }, function(_d, _, control) {
        var targetId = _d[0], path3 = _d[1];
        if (targetId !== 0) {
          count++;
          control.done();
        }
      }).next(function() {
        return count > 0;
      });
    };
    IndexedDbTargetCache2.prototype.getTargetDataForTarget = function(transaction, targetId) {
      return targetsStore(transaction).get(targetId).next(function(found) {
        if (found) {
          return fromDbTarget(found);
        } else {
          return null;
        }
      });
    };
    return IndexedDbTargetCache2;
  }();
  function targetsStore(txn) {
    return getStore(txn, DbTarget.store);
  }
  function globalTargetStore(txn) {
    return getStore(txn, DbTargetGlobal.store);
  }
  function documentTargetStore(txn) {
    return getStore(txn, DbTargetDocument.store);
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function ignoreIfPrimaryLeaseLoss(err) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      return tslib.__generator(this, function(_d) {
        if (err.code === Code.FAILED_PRECONDITION && err.message === PRIMARY_LEASE_LOST_ERROR_MSG) {
          logDebug("LocalStore", "Unexpectedly lost primary lease");
        } else {
          throw err;
        }
        return [2];
      });
    });
  }
  /**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var GC_DID_NOT_RUN = {
    didRun: false,
    sequenceNumbersCollected: 0,
    targetsRemoved: 0,
    documentsRemoved: 0
  };
  var LRU_COLLECTION_DISABLED = -1;
  var LRU_DEFAULT_CACHE_SIZE_BYTES = 40 * 1024 * 1024;
  var LruParams = function() {
    function LruParams2(cacheSizeCollectionThreshold, percentileToCollect, maximumSequenceNumbersToCollect) {
      this.cacheSizeCollectionThreshold = cacheSizeCollectionThreshold;
      this.percentileToCollect = percentileToCollect;
      this.maximumSequenceNumbersToCollect = maximumSequenceNumbersToCollect;
    }
    LruParams2.withCacheSize = function(cacheSize) {
      return new LruParams2(cacheSize, LruParams2.DEFAULT_COLLECTION_PERCENTILE, LruParams2.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
    };
    return LruParams2;
  }();
  LruParams.DEFAULT_COLLECTION_PERCENTILE = 10;
  LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3;
  LruParams.DEFAULT = new LruParams(LRU_DEFAULT_CACHE_SIZE_BYTES, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  LruParams.DISABLED = new LruParams(LRU_COLLECTION_DISABLED, 0, 0);
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LOG_TAG$2 = "LruGarbageCollector";
  var LRU_MINIMUM_CACHE_SIZE_BYTES = 1 * 1024 * 1024;
  var INITIAL_GC_DELAY_MS = 1 * 60 * 1e3;
  var REGULAR_GC_DELAY_MS = 5 * 60 * 1e3;
  function bufferEntryComparator(_d, _e) {
    var aSequence = _d[0], aIndex = _d[1];
    var bSequence = _e[0], bIndex = _e[1];
    var seqCmp = primitiveComparator(aSequence, bSequence);
    if (seqCmp === 0) {
      return primitiveComparator(aIndex, bIndex);
    } else {
      return seqCmp;
    }
  }
  var RollingSequenceNumberBuffer = function() {
    function RollingSequenceNumberBuffer2(maxElements) {
      this.maxElements = maxElements;
      this.buffer = new SortedSet(bufferEntryComparator);
      this.previousIndex = 0;
    }
    RollingSequenceNumberBuffer2.prototype.nextIndex = function() {
      return ++this.previousIndex;
    };
    RollingSequenceNumberBuffer2.prototype.addElement = function(sequenceNumber) {
      var entry = [sequenceNumber, this.nextIndex()];
      if (this.buffer.size < this.maxElements) {
        this.buffer = this.buffer.add(entry);
      } else {
        var highestValue = this.buffer.last();
        if (bufferEntryComparator(entry, highestValue) < 0) {
          this.buffer = this.buffer.delete(highestValue).add(entry);
        }
      }
    };
    Object.defineProperty(RollingSequenceNumberBuffer2.prototype, "maxValue", {
      get: function() {
        return this.buffer.last()[0];
      },
      enumerable: false,
      configurable: true
    });
    return RollingSequenceNumberBuffer2;
  }();
  var LruScheduler = function() {
    function LruScheduler2(garbageCollector, asyncQueue) {
      this.garbageCollector = garbageCollector;
      this.asyncQueue = asyncQueue;
      this.hasRun = false;
      this.gcTask = null;
    }
    LruScheduler2.prototype.start = function(localStore) {
      if (this.garbageCollector.params.cacheSizeCollectionThreshold !== LRU_COLLECTION_DISABLED) {
        this.scheduleGC(localStore);
      }
    };
    LruScheduler2.prototype.stop = function() {
      if (this.gcTask) {
        this.gcTask.cancel();
        this.gcTask = null;
      }
    };
    Object.defineProperty(LruScheduler2.prototype, "started", {
      get: function() {
        return this.gcTask !== null;
      },
      enumerable: false,
      configurable: true
    });
    LruScheduler2.prototype.scheduleGC = function(localStore) {
      var _this = this;
      var delay = this.hasRun ? REGULAR_GC_DELAY_MS : INITIAL_GC_DELAY_MS;
      logDebug("LruGarbageCollector", "Garbage collection scheduled in " + delay + "ms");
      this.gcTask = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", delay, function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var e_1;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                this.gcTask = null;
                this.hasRun = true;
                _d.label = 1;
              case 1:
                _d.trys.push([1, 3, , 7]);
                return [4, localStore.collectGarbage(this.garbageCollector)];
              case 2:
                _d.sent();
                return [3, 7];
              case 3:
                e_1 = _d.sent();
                if (!isIndexedDbTransactionError(e_1))
                  return [3, 4];
                logDebug(LOG_TAG$2, "Ignoring IndexedDB error during garbage collection: ", e_1);
                return [3, 6];
              case 4:
                return [4, ignoreIfPrimaryLeaseLoss(e_1)];
              case 5:
                _d.sent();
                _d.label = 6;
              case 6:
                return [3, 7];
              case 7:
                return [4, this.scheduleGC(localStore)];
              case 8:
                _d.sent();
                return [2];
            }
          });
        });
      });
    };
    return LruScheduler2;
  }();
  var LruGarbageCollectorImpl = function() {
    function LruGarbageCollectorImpl2(delegate, params) {
      this.delegate = delegate;
      this.params = params;
    }
    LruGarbageCollectorImpl2.prototype.calculateTargetCount = function(txn, percentile) {
      return this.delegate.getSequenceNumberCount(txn).next(function(targetCount) {
        return Math.floor(percentile / 100 * targetCount);
      });
    };
    LruGarbageCollectorImpl2.prototype.nthSequenceNumber = function(txn, n) {
      var _this = this;
      if (n === 0) {
        return PersistencePromise.resolve(ListenSequence.INVALID);
      }
      var buffer = new RollingSequenceNumberBuffer(n);
      return this.delegate.forEachTarget(txn, function(target) {
        return buffer.addElement(target.sequenceNumber);
      }).next(function() {
        return _this.delegate.forEachOrphanedDocumentSequenceNumber(txn, function(sequenceNumber) {
          return buffer.addElement(sequenceNumber);
        });
      }).next(function() {
        return buffer.maxValue;
      });
    };
    LruGarbageCollectorImpl2.prototype.removeTargets = function(txn, upperBound, activeTargetIds) {
      return this.delegate.removeTargets(txn, upperBound, activeTargetIds);
    };
    LruGarbageCollectorImpl2.prototype.removeOrphanedDocuments = function(txn, upperBound) {
      return this.delegate.removeOrphanedDocuments(txn, upperBound);
    };
    LruGarbageCollectorImpl2.prototype.collect = function(txn, activeTargetIds) {
      var _this = this;
      if (this.params.cacheSizeCollectionThreshold === LRU_COLLECTION_DISABLED) {
        logDebug("LruGarbageCollector", "Garbage collection skipped; disabled");
        return PersistencePromise.resolve(GC_DID_NOT_RUN);
      }
      return this.getCacheSize(txn).next(function(cacheSize) {
        if (cacheSize < _this.params.cacheSizeCollectionThreshold) {
          logDebug("LruGarbageCollector", "Garbage collection skipped; Cache size " + cacheSize + " " + ("is lower than threshold " + _this.params.cacheSizeCollectionThreshold));
          return GC_DID_NOT_RUN;
        } else {
          return _this.runGarbageCollection(txn, activeTargetIds);
        }
      });
    };
    LruGarbageCollectorImpl2.prototype.getCacheSize = function(txn) {
      return this.delegate.getCacheSize(txn);
    };
    LruGarbageCollectorImpl2.prototype.runGarbageCollection = function(txn, activeTargetIds) {
      var _this = this;
      var upperBoundSequenceNumber;
      var sequenceNumbersToCollect, targetsRemoved;
      var countedTargetsTs, foundUpperBoundTs, removedTargetsTs, removedDocumentsTs;
      var startTs = Date.now();
      return this.calculateTargetCount(txn, this.params.percentileToCollect).next(function(sequenceNumbers) {
        if (sequenceNumbers > _this.params.maximumSequenceNumbersToCollect) {
          logDebug("LruGarbageCollector", "Capping sequence numbers to collect down " + ("to the maximum of " + _this.params.maximumSequenceNumbersToCollect + " ") + ("from " + sequenceNumbers));
          sequenceNumbersToCollect = _this.params.maximumSequenceNumbersToCollect;
        } else {
          sequenceNumbersToCollect = sequenceNumbers;
        }
        countedTargetsTs = Date.now();
        return _this.nthSequenceNumber(txn, sequenceNumbersToCollect);
      }).next(function(upperBound) {
        upperBoundSequenceNumber = upperBound;
        foundUpperBoundTs = Date.now();
        return _this.removeTargets(txn, upperBoundSequenceNumber, activeTargetIds);
      }).next(function(numTargetsRemoved) {
        targetsRemoved = numTargetsRemoved;
        removedTargetsTs = Date.now();
        return _this.removeOrphanedDocuments(txn, upperBoundSequenceNumber);
      }).next(function(documentsRemoved) {
        removedDocumentsTs = Date.now();
        if (getLogLevel() <= logger.LogLevel.DEBUG) {
          var desc = "LRU Garbage Collection\n" + ("	Counted targets in " + (countedTargetsTs - startTs) + "ms\n") + ("	Determined least recently used " + sequenceNumbersToCollect + " in ") + (foundUpperBoundTs - countedTargetsTs + "ms\n") + ("	Removed " + targetsRemoved + " targets in ") + (removedTargetsTs - foundUpperBoundTs + "ms\n") + ("	Removed " + documentsRemoved + " documents in ") + (removedDocumentsTs - removedTargetsTs + "ms\n") + ("Total Duration: " + (removedDocumentsTs - startTs) + "ms");
          logDebug("LruGarbageCollector", desc);
        }
        return PersistencePromise.resolve({
          didRun: true,
          sequenceNumbersCollected: sequenceNumbersToCollect,
          targetsRemoved,
          documentsRemoved
        });
      });
    };
    return LruGarbageCollectorImpl2;
  }();
  function newLruGarbageCollector(delegate, params) {
    return new LruGarbageCollectorImpl(delegate, params);
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var IndexedDbLruDelegateImpl = function() {
    function IndexedDbLruDelegateImpl2(db2, params) {
      this.db = db2;
      this.garbageCollector = newLruGarbageCollector(this, params);
    }
    IndexedDbLruDelegateImpl2.prototype.getSequenceNumberCount = function(txn) {
      var docCountPromise = this.orphanedDocumentCount(txn);
      var targetCountPromise = this.db.getTargetCache().getTargetCount(txn);
      return targetCountPromise.next(function(targetCount) {
        return docCountPromise.next(function(docCount) {
          return targetCount + docCount;
        });
      });
    };
    IndexedDbLruDelegateImpl2.prototype.orphanedDocumentCount = function(txn) {
      var orphanedCount = 0;
      return this.forEachOrphanedDocumentSequenceNumber(txn, function(_) {
        orphanedCount++;
      }).next(function() {
        return orphanedCount;
      });
    };
    IndexedDbLruDelegateImpl2.prototype.forEachTarget = function(txn, f) {
      return this.db.getTargetCache().forEachTarget(txn, f);
    };
    IndexedDbLruDelegateImpl2.prototype.forEachOrphanedDocumentSequenceNumber = function(txn, f) {
      return this.forEachOrphanedDocument(txn, function(docKey, sequenceNumber) {
        return f(sequenceNumber);
      });
    };
    IndexedDbLruDelegateImpl2.prototype.addReference = function(txn, targetId, key) {
      return writeSentinelKey(txn, key);
    };
    IndexedDbLruDelegateImpl2.prototype.removeReference = function(txn, targetId, key) {
      return writeSentinelKey(txn, key);
    };
    IndexedDbLruDelegateImpl2.prototype.removeTargets = function(txn, upperBound, activeTargetIds) {
      return this.db.getTargetCache().removeTargets(txn, upperBound, activeTargetIds);
    };
    IndexedDbLruDelegateImpl2.prototype.markPotentiallyOrphaned = function(txn, key) {
      return writeSentinelKey(txn, key);
    };
    IndexedDbLruDelegateImpl2.prototype.isPinned = function(txn, docKey) {
      return mutationQueuesContainKey(txn, docKey);
    };
    IndexedDbLruDelegateImpl2.prototype.removeOrphanedDocuments = function(txn, upperBound) {
      var _this = this;
      var documentCache = this.db.getRemoteDocumentCache();
      var changeBuffer = documentCache.newChangeBuffer();
      var promises = [];
      var documentCount = 0;
      var iteration = this.forEachOrphanedDocument(txn, function(docKey, sequenceNumber) {
        if (sequenceNumber <= upperBound) {
          var p = _this.isPinned(txn, docKey).next(function(isPinned) {
            if (!isPinned) {
              documentCount++;
              return changeBuffer.getEntry(txn, docKey).next(function() {
                changeBuffer.removeEntry(docKey);
                return documentTargetStore(txn).delete(sentinelKey(docKey));
              });
            }
          });
          promises.push(p);
        }
      });
      return iteration.next(function() {
        return PersistencePromise.waitFor(promises);
      }).next(function() {
        return changeBuffer.apply(txn);
      }).next(function() {
        return documentCount;
      });
    };
    IndexedDbLruDelegateImpl2.prototype.removeTarget = function(txn, targetData) {
      var updated = targetData.withSequenceNumber(txn.currentSequenceNumber);
      return this.db.getTargetCache().updateTargetData(txn, updated);
    };
    IndexedDbLruDelegateImpl2.prototype.updateLimboDocument = function(txn, key) {
      return writeSentinelKey(txn, key);
    };
    IndexedDbLruDelegateImpl2.prototype.forEachOrphanedDocument = function(txn, f) {
      var store = documentTargetStore(txn);
      var nextToReport = ListenSequence.INVALID;
      var nextPath;
      return store.iterate({
        index: DbTargetDocument.documentTargetsIndex
      }, function(_d, _e) {
        var targetId = _d[0], docKey = _d[1];
        var path2 = _e.path, sequenceNumber = _e.sequenceNumber;
        if (targetId === 0) {
          if (nextToReport !== ListenSequence.INVALID) {
            f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);
          }
          nextToReport = sequenceNumber;
          nextPath = path2;
        } else {
          nextToReport = ListenSequence.INVALID;
        }
      }).next(function() {
        if (nextToReport !== ListenSequence.INVALID) {
          f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);
        }
      });
    };
    IndexedDbLruDelegateImpl2.prototype.getCacheSize = function(txn) {
      return this.db.getRemoteDocumentCache().getSize(txn);
    };
    return IndexedDbLruDelegateImpl2;
  }();
  function sentinelKey(key) {
    return [0, encodeResourcePath(key.path)];
  }
  function sentinelRow(key, sequenceNumber) {
    return new DbTargetDocument(0, encodeResourcePath(key.path), sequenceNumber);
  }
  function writeSentinelKey(txn, key) {
    return documentTargetStore(txn).put(sentinelRow(key, txn.currentSequenceNumber));
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var ObjectMap = function() {
    function ObjectMap2(mapKeyFn, equalsFn) {
      this.mapKeyFn = mapKeyFn;
      this.equalsFn = equalsFn;
      this.inner = {};
    }
    ObjectMap2.prototype.get = function(key) {
      var id = this.mapKeyFn(key);
      var matches = this.inner[id];
      if (matches === void 0) {
        return void 0;
      }
      for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {
        var _d = matches_1[_i], otherKey = _d[0], value = _d[1];
        if (this.equalsFn(otherKey, key)) {
          return value;
        }
      }
      return void 0;
    };
    ObjectMap2.prototype.has = function(key) {
      return this.get(key) !== void 0;
    };
    ObjectMap2.prototype.set = function(key, value) {
      var id = this.mapKeyFn(key);
      var matches = this.inner[id];
      if (matches === void 0) {
        this.inner[id] = [[key, value]];
        return;
      }
      for (var i = 0; i < matches.length; i++) {
        if (this.equalsFn(matches[i][0], key)) {
          matches[i] = [key, value];
          return;
        }
      }
      matches.push([key, value]);
    };
    ObjectMap2.prototype.delete = function(key) {
      var id = this.mapKeyFn(key);
      var matches = this.inner[id];
      if (matches === void 0) {
        return false;
      }
      for (var i = 0; i < matches.length; i++) {
        if (this.equalsFn(matches[i][0], key)) {
          if (matches.length === 1) {
            delete this.inner[id];
          } else {
            matches.splice(i, 1);
          }
          return true;
        }
      }
      return false;
    };
    ObjectMap2.prototype.forEach = function(fn) {
      forEach(this.inner, function(_, entries) {
        for (var _i = 0, entries_2 = entries; _i < entries_2.length; _i++) {
          var _d = entries_2[_i], k = _d[0], v = _d[1];
          fn(k, v);
        }
      });
    };
    ObjectMap2.prototype.isEmpty = function() {
      return isEmpty(this.inner);
    };
    return ObjectMap2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var RemoteDocumentChangeBuffer = function() {
    function RemoteDocumentChangeBuffer2() {
      this.changes = new ObjectMap(function(key) {
        return key.toString();
      }, function(l, r) {
        return l.isEqual(r);
      });
      this.changesApplied = false;
    }
    RemoteDocumentChangeBuffer2.prototype.getReadTime = function(key) {
      var change = this.changes.get(key);
      if (change) {
        return change.readTime;
      }
      return SnapshotVersion.min();
    };
    RemoteDocumentChangeBuffer2.prototype.addEntry = function(document2, readTime) {
      this.assertNotApplied();
      this.changes.set(document2.key, {document: document2, readTime});
    };
    RemoteDocumentChangeBuffer2.prototype.removeEntry = function(key, readTime) {
      if (readTime === void 0) {
        readTime = null;
      }
      this.assertNotApplied();
      this.changes.set(key, {
        document: MutableDocument.newInvalidDocument(key),
        readTime
      });
    };
    RemoteDocumentChangeBuffer2.prototype.getEntry = function(transaction, documentKey) {
      this.assertNotApplied();
      var bufferedEntry = this.changes.get(documentKey);
      if (bufferedEntry !== void 0) {
        return PersistencePromise.resolve(bufferedEntry.document);
      } else {
        return this.getFromCache(transaction, documentKey);
      }
    };
    RemoteDocumentChangeBuffer2.prototype.getEntries = function(transaction, documentKeys) {
      return this.getAllFromCache(transaction, documentKeys);
    };
    RemoteDocumentChangeBuffer2.prototype.apply = function(transaction) {
      this.assertNotApplied();
      this.changesApplied = true;
      return this.applyChanges(transaction);
    };
    RemoteDocumentChangeBuffer2.prototype.assertNotApplied = function() {
    };
    return RemoteDocumentChangeBuffer2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var IndexedDbRemoteDocumentCacheImpl = function() {
    function IndexedDbRemoteDocumentCacheImpl2(serializer, indexManager) {
      this.serializer = serializer;
      this.indexManager = indexManager;
    }
    IndexedDbRemoteDocumentCacheImpl2.prototype.addEntry = function(transaction, key, doc2) {
      var documentStore = remoteDocumentsStore(transaction);
      return documentStore.put(dbKey(key), doc2);
    };
    IndexedDbRemoteDocumentCacheImpl2.prototype.removeEntry = function(transaction, documentKey) {
      var store = remoteDocumentsStore(transaction);
      var key = dbKey(documentKey);
      return store.delete(key);
    };
    IndexedDbRemoteDocumentCacheImpl2.prototype.updateMetadata = function(transaction, sizeDelta) {
      var _this = this;
      return this.getMetadata(transaction).next(function(metadata) {
        metadata.byteSize += sizeDelta;
        return _this.setMetadata(transaction, metadata);
      });
    };
    IndexedDbRemoteDocumentCacheImpl2.prototype.getEntry = function(transaction, documentKey) {
      var _this = this;
      return remoteDocumentsStore(transaction).get(dbKey(documentKey)).next(function(dbRemoteDoc) {
        return _this.maybeDecodeDocument(documentKey, dbRemoteDoc);
      });
    };
    IndexedDbRemoteDocumentCacheImpl2.prototype.getSizedEntry = function(transaction, documentKey) {
      var _this = this;
      return remoteDocumentsStore(transaction).get(dbKey(documentKey)).next(function(dbRemoteDoc) {
        var doc2 = _this.maybeDecodeDocument(documentKey, dbRemoteDoc);
        return {
          document: doc2,
          size: dbDocumentSize(dbRemoteDoc)
        };
      });
    };
    IndexedDbRemoteDocumentCacheImpl2.prototype.getEntries = function(transaction, documentKeys) {
      var _this = this;
      var results = mutableDocumentMap();
      return this.forEachDbEntry(transaction, documentKeys, function(key, dbRemoteDoc) {
        var doc2 = _this.maybeDecodeDocument(key, dbRemoteDoc);
        results = results.insert(key, doc2);
      }).next(function() {
        return results;
      });
    };
    IndexedDbRemoteDocumentCacheImpl2.prototype.getSizedEntries = function(transaction, documentKeys) {
      var _this = this;
      var results = mutableDocumentMap();
      var sizeMap = new SortedMap(DocumentKey.comparator);
      return this.forEachDbEntry(transaction, documentKeys, function(key, dbRemoteDoc) {
        var doc2 = _this.maybeDecodeDocument(key, dbRemoteDoc);
        results = results.insert(key, doc2);
        sizeMap = sizeMap.insert(key, dbDocumentSize(dbRemoteDoc));
      }).next(function() {
        return {documents: results, sizeMap};
      });
    };
    IndexedDbRemoteDocumentCacheImpl2.prototype.forEachDbEntry = function(transaction, documentKeys, callback) {
      if (documentKeys.isEmpty()) {
        return PersistencePromise.resolve();
      }
      var range = IDBKeyRange.bound(documentKeys.first().path.toArray(), documentKeys.last().path.toArray());
      var keyIter = documentKeys.getIterator();
      var nextKey = keyIter.getNext();
      return remoteDocumentsStore(transaction).iterate({range}, function(potentialKeyRaw, dbRemoteDoc, control) {
        var potentialKey = DocumentKey.fromSegments(potentialKeyRaw);
        while (nextKey && DocumentKey.comparator(nextKey, potentialKey) < 0) {
          callback(nextKey, null);
          nextKey = keyIter.getNext();
        }
        if (nextKey && nextKey.isEqual(potentialKey)) {
          callback(nextKey, dbRemoteDoc);
          nextKey = keyIter.hasNext() ? keyIter.getNext() : null;
        }
        if (nextKey) {
          control.skip(nextKey.path.toArray());
        } else {
          control.done();
        }
      }).next(function() {
        while (nextKey) {
          callback(nextKey, null);
          nextKey = keyIter.hasNext() ? keyIter.getNext() : null;
        }
      });
    };
    IndexedDbRemoteDocumentCacheImpl2.prototype.getDocumentsMatchingQuery = function(transaction, query2, sinceReadTime) {
      var _this = this;
      var results = mutableDocumentMap();
      var immediateChildrenPathLength = query2.path.length + 1;
      var iterationOptions = {};
      if (sinceReadTime.isEqual(SnapshotVersion.min())) {
        var startKey = query2.path.toArray();
        iterationOptions.range = IDBKeyRange.lowerBound(startKey);
      } else {
        var collectionKey = query2.path.toArray();
        var readTimeKey = toDbTimestampKey(sinceReadTime);
        iterationOptions.range = IDBKeyRange.lowerBound([collectionKey, readTimeKey], true);
        iterationOptions.index = DbRemoteDocument.collectionReadTimeIndex;
      }
      return remoteDocumentsStore(transaction).iterate(iterationOptions, function(key, dbRemoteDoc, control) {
        if (key.length !== immediateChildrenPathLength) {
          return;
        }
        var document2 = fromDbRemoteDocument(_this.serializer, dbRemoteDoc);
        if (!query2.path.isPrefixOf(document2.key.path)) {
          control.done();
        } else if (queryMatches(query2, document2)) {
          results = results.insert(document2.key, document2);
        }
      }).next(function() {
        return results;
      });
    };
    IndexedDbRemoteDocumentCacheImpl2.prototype.newChangeBuffer = function(options) {
      return new IndexedDbRemoteDocumentChangeBuffer(this, !!options && options.trackRemovals);
    };
    IndexedDbRemoteDocumentCacheImpl2.prototype.getSize = function(txn) {
      return this.getMetadata(txn).next(function(metadata) {
        return metadata.byteSize;
      });
    };
    IndexedDbRemoteDocumentCacheImpl2.prototype.getMetadata = function(txn) {
      return documentGlobalStore(txn).get(DbRemoteDocumentGlobal.key).next(function(metadata) {
        hardAssert(!!metadata);
        return metadata;
      });
    };
    IndexedDbRemoteDocumentCacheImpl2.prototype.setMetadata = function(txn, metadata) {
      return documentGlobalStore(txn).put(DbRemoteDocumentGlobal.key, metadata);
    };
    IndexedDbRemoteDocumentCacheImpl2.prototype.maybeDecodeDocument = function(documentKey, dbRemoteDoc) {
      if (dbRemoteDoc) {
        var doc_4 = fromDbRemoteDocument(this.serializer, dbRemoteDoc);
        var isSentinelRemoval = doc_4.isNoDocument() && doc_4.version.isEqual(SnapshotVersion.min());
        if (!isSentinelRemoval) {
          return doc_4;
        }
      }
      return MutableDocument.newInvalidDocument(documentKey);
    };
    return IndexedDbRemoteDocumentCacheImpl2;
  }();
  function newIndexedDbRemoteDocumentCache(serializer, indexManager) {
    return new IndexedDbRemoteDocumentCacheImpl(serializer, indexManager);
  }
  function remoteDocumentCacheGetNewDocumentChanges(remoteDocumentCache, transaction, sinceReadTime) {
    var remoteDocumentCacheImpl = debugCast(remoteDocumentCache);
    var changedDocs = mutableDocumentMap();
    var lastReadTime = toDbTimestampKey(sinceReadTime);
    var documentsStore = remoteDocumentsStore(transaction);
    var range = IDBKeyRange.lowerBound(lastReadTime, true);
    return documentsStore.iterate({index: DbRemoteDocument.readTimeIndex, range}, function(_, dbRemoteDoc) {
      var doc2 = fromDbRemoteDocument(remoteDocumentCacheImpl.serializer, dbRemoteDoc);
      changedDocs = changedDocs.insert(doc2.key, doc2);
      lastReadTime = dbRemoteDoc.readTime;
    }).next(function() {
      return {
        changedDocs,
        readTime: fromDbTimestampKey(lastReadTime)
      };
    });
  }
  function remoteDocumentCacheGetLastReadTime(transaction) {
    var documentsStore = remoteDocumentsStore(transaction);
    var readTime = SnapshotVersion.min();
    return documentsStore.iterate({index: DbRemoteDocument.readTimeIndex, reverse: true}, function(key, dbRemoteDoc, control) {
      if (dbRemoteDoc.readTime) {
        readTime = fromDbTimestampKey(dbRemoteDoc.readTime);
      }
      control.done();
    }).next(function() {
      return readTime;
    });
  }
  var IndexedDbRemoteDocumentChangeBuffer = function(_super) {
    tslib.__extends(IndexedDbRemoteDocumentChangeBuffer2, _super);
    function IndexedDbRemoteDocumentChangeBuffer2(documentCache, trackRemovals) {
      var _this = _super.call(this) || this;
      _this.documentCache = documentCache;
      _this.trackRemovals = trackRemovals;
      _this.documentSizes = new ObjectMap(function(key) {
        return key.toString();
      }, function(l, r) {
        return l.isEqual(r);
      });
      return _this;
    }
    IndexedDbRemoteDocumentChangeBuffer2.prototype.applyChanges = function(transaction) {
      var _this = this;
      var promises = [];
      var sizeDelta = 0;
      var collectionParents = new SortedSet(function(l, r) {
        return primitiveComparator(l.canonicalString(), r.canonicalString());
      });
      this.changes.forEach(function(key, documentChange) {
        var previousSize = _this.documentSizes.get(key);
        if (documentChange.document.isValidDocument()) {
          var doc_5 = toDbRemoteDocument(_this.documentCache.serializer, documentChange.document, _this.getReadTime(key));
          collectionParents = collectionParents.add(key.path.popLast());
          var size = dbDocumentSize(doc_5);
          sizeDelta += size - previousSize;
          promises.push(_this.documentCache.addEntry(transaction, key, doc_5));
        } else {
          sizeDelta -= previousSize;
          if (_this.trackRemovals) {
            var deletedDoc = toDbRemoteDocument(_this.documentCache.serializer, MutableDocument.newNoDocument(key, SnapshotVersion.min()), _this.getReadTime(key));
            promises.push(_this.documentCache.addEntry(transaction, key, deletedDoc));
          } else {
            promises.push(_this.documentCache.removeEntry(transaction, key));
          }
        }
      });
      collectionParents.forEach(function(parent) {
        promises.push(_this.documentCache.indexManager.addToCollectionParentIndex(transaction, parent));
      });
      promises.push(this.documentCache.updateMetadata(transaction, sizeDelta));
      return PersistencePromise.waitFor(promises);
    };
    IndexedDbRemoteDocumentChangeBuffer2.prototype.getFromCache = function(transaction, documentKey) {
      var _this = this;
      return this.documentCache.getSizedEntry(transaction, documentKey).next(function(getResult) {
        _this.documentSizes.set(documentKey, getResult.size);
        return getResult.document;
      });
    };
    IndexedDbRemoteDocumentChangeBuffer2.prototype.getAllFromCache = function(transaction, documentKeys) {
      var _this = this;
      return this.documentCache.getSizedEntries(transaction, documentKeys).next(function(_d) {
        var documents = _d.documents, sizeMap = _d.sizeMap;
        sizeMap.forEach(function(documentKey, size) {
          _this.documentSizes.set(documentKey, size);
        });
        return documents;
      });
    };
    return IndexedDbRemoteDocumentChangeBuffer2;
  }(RemoteDocumentChangeBuffer);
  function documentGlobalStore(txn) {
    return getStore(txn, DbRemoteDocumentGlobal.store);
  }
  function remoteDocumentsStore(txn) {
    return getStore(txn, DbRemoteDocument.store);
  }
  function dbKey(docKey) {
    return docKey.path.toArray();
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var SchemaConverter = function() {
    function SchemaConverter2(serializer) {
      this.serializer = serializer;
    }
    SchemaConverter2.prototype.createOrUpgrade = function(db2, txn, fromVersion2, toVersion2) {
      var _this = this;
      hardAssert(fromVersion2 < toVersion2 && fromVersion2 >= 0 && toVersion2 <= SCHEMA_VERSION);
      var simpleDbTransaction = new SimpleDbTransaction("createOrUpgrade", txn);
      if (fromVersion2 < 1 && toVersion2 >= 1) {
        createPrimaryClientStore(db2);
        createMutationQueue(db2);
        createQueryCache(db2);
        createRemoteDocumentCache(db2);
      }
      var p = PersistencePromise.resolve();
      if (fromVersion2 < 3 && toVersion2 >= 3) {
        if (fromVersion2 !== 0) {
          dropQueryCache(db2);
          createQueryCache(db2);
        }
        p = p.next(function() {
          return writeEmptyTargetGlobalEntry(simpleDbTransaction);
        });
      }
      if (fromVersion2 < 4 && toVersion2 >= 4) {
        if (fromVersion2 !== 0) {
          p = p.next(function() {
            return upgradeMutationBatchSchemaAndMigrateData(db2, simpleDbTransaction);
          });
        }
        p = p.next(function() {
          createClientMetadataStore(db2);
        });
      }
      if (fromVersion2 < 5 && toVersion2 >= 5) {
        p = p.next(function() {
          return _this.removeAcknowledgedMutations(simpleDbTransaction);
        });
      }
      if (fromVersion2 < 6 && toVersion2 >= 6) {
        p = p.next(function() {
          createDocumentGlobalStore(db2);
          return _this.addDocumentGlobal(simpleDbTransaction);
        });
      }
      if (fromVersion2 < 7 && toVersion2 >= 7) {
        p = p.next(function() {
          return _this.ensureSequenceNumbers(simpleDbTransaction);
        });
      }
      if (fromVersion2 < 8 && toVersion2 >= 8) {
        p = p.next(function() {
          return _this.createCollectionParentIndex(db2, simpleDbTransaction);
        });
      }
      if (fromVersion2 < 9 && toVersion2 >= 9) {
        p = p.next(function() {
          dropRemoteDocumentChangesStore(db2);
          createRemoteDocumentReadTimeIndex(txn);
        });
      }
      if (fromVersion2 < 10 && toVersion2 >= 10) {
        p = p.next(function() {
          return _this.rewriteCanonicalIds(simpleDbTransaction);
        });
      }
      if (fromVersion2 < 11 && toVersion2 >= 11) {
        p = p.next(function() {
          createBundlesStore(db2);
          createNamedQueriesStore(db2);
        });
      }
      return p;
    };
    SchemaConverter2.prototype.addDocumentGlobal = function(txn) {
      var byteCount = 0;
      return txn.store(DbRemoteDocument.store).iterate(function(_, doc2) {
        byteCount += dbDocumentSize(doc2);
      }).next(function() {
        var metadata = new DbRemoteDocumentGlobal(byteCount);
        return txn.store(DbRemoteDocumentGlobal.store).put(DbRemoteDocumentGlobal.key, metadata);
      });
    };
    SchemaConverter2.prototype.removeAcknowledgedMutations = function(txn) {
      var _this = this;
      var queuesStore = txn.store(DbMutationQueue.store);
      var mutationsStore2 = txn.store(DbMutationBatch.store);
      return queuesStore.loadAll().next(function(queues) {
        return PersistencePromise.forEach(queues, function(queue) {
          var range = IDBKeyRange.bound([queue.userId, BATCHID_UNKNOWN], [queue.userId, queue.lastAcknowledgedBatchId]);
          return mutationsStore2.loadAll(DbMutationBatch.userMutationsIndex, range).next(function(dbBatches) {
            return PersistencePromise.forEach(dbBatches, function(dbBatch) {
              hardAssert(dbBatch.userId === queue.userId);
              var batch = fromDbMutationBatch(_this.serializer, dbBatch);
              return removeMutationBatch(txn, queue.userId, batch).next(function() {
              });
            });
          });
        });
      });
    };
    SchemaConverter2.prototype.ensureSequenceNumbers = function(txn) {
      var documentTargetStore2 = txn.store(DbTargetDocument.store);
      var documentsStore = txn.store(DbRemoteDocument.store);
      var globalTargetStore2 = txn.store(DbTargetGlobal.store);
      return globalTargetStore2.get(DbTargetGlobal.key).next(function(metadata) {
        var writeSentinelKey2 = function(path2) {
          return documentTargetStore2.put(new DbTargetDocument(0, encodeResourcePath(path2), metadata.highestListenSequenceNumber));
        };
        var promises = [];
        return documentsStore.iterate(function(key, doc2) {
          var path2 = new ResourcePath(key);
          var docSentinelKey = sentinelKey$1(path2);
          promises.push(documentTargetStore2.get(docSentinelKey).next(function(maybeSentinel) {
            if (!maybeSentinel) {
              return writeSentinelKey2(path2);
            } else {
              return PersistencePromise.resolve();
            }
          }));
        }).next(function() {
          return PersistencePromise.waitFor(promises);
        });
      });
    };
    SchemaConverter2.prototype.createCollectionParentIndex = function(db2, txn) {
      db2.createObjectStore(DbCollectionParent.store, {
        keyPath: DbCollectionParent.keyPath
      });
      var collectionParentsStore2 = txn.store(DbCollectionParent.store);
      var cache = new MemoryCollectionParentIndex();
      var addEntry = function(collectionPath) {
        if (cache.add(collectionPath)) {
          var collectionId = collectionPath.lastSegment();
          var parentPath = collectionPath.popLast();
          return collectionParentsStore2.put({
            collectionId,
            parent: encodeResourcePath(parentPath)
          });
        }
      };
      return txn.store(DbRemoteDocument.store).iterate({keysOnly: true}, function(pathSegments, _) {
        var path2 = new ResourcePath(pathSegments);
        return addEntry(path2.popLast());
      }).next(function() {
        return txn.store(DbDocumentMutation.store).iterate({keysOnly: true}, function(_d, _) {
          var userID = _d[0], encodedPath = _d[1], batchId = _d[2];
          var path2 = decodeResourcePath(encodedPath);
          return addEntry(path2.popLast());
        });
      });
    };
    SchemaConverter2.prototype.rewriteCanonicalIds = function(txn) {
      var _this = this;
      var targetStore = txn.store(DbTarget.store);
      return targetStore.iterate(function(key, originalDbTarget) {
        var originalTargetData = fromDbTarget(originalDbTarget);
        var updatedDbTarget = toDbTarget(_this.serializer, originalTargetData);
        return targetStore.put(updatedDbTarget);
      });
    };
    return SchemaConverter2;
  }();
  function sentinelKey$1(path2) {
    return [0, encodeResourcePath(path2)];
  }
  function createPrimaryClientStore(db2) {
    db2.createObjectStore(DbPrimaryClient.store);
  }
  function createMutationQueue(db2) {
    db2.createObjectStore(DbMutationQueue.store, {
      keyPath: DbMutationQueue.keyPath
    });
    var mutationBatchesStore = db2.createObjectStore(DbMutationBatch.store, {
      keyPath: DbMutationBatch.keyPath,
      autoIncrement: true
    });
    mutationBatchesStore.createIndex(DbMutationBatch.userMutationsIndex, DbMutationBatch.userMutationsKeyPath, {unique: true});
    db2.createObjectStore(DbDocumentMutation.store);
  }
  function upgradeMutationBatchSchemaAndMigrateData(db2, txn) {
    var v1MutationsStore = txn.store(DbMutationBatch.store);
    return v1MutationsStore.loadAll().next(function(existingMutations) {
      db2.deleteObjectStore(DbMutationBatch.store);
      var mutationsStore2 = db2.createObjectStore(DbMutationBatch.store, {
        keyPath: DbMutationBatch.keyPath,
        autoIncrement: true
      });
      mutationsStore2.createIndex(DbMutationBatch.userMutationsIndex, DbMutationBatch.userMutationsKeyPath, {unique: true});
      var v3MutationsStore = txn.store(DbMutationBatch.store);
      var writeAll = existingMutations.map(function(mutation) {
        return v3MutationsStore.put(mutation);
      });
      return PersistencePromise.waitFor(writeAll);
    });
  }
  function createRemoteDocumentCache(db2) {
    db2.createObjectStore(DbRemoteDocument.store);
  }
  function createDocumentGlobalStore(db2) {
    db2.createObjectStore(DbRemoteDocumentGlobal.store);
  }
  function createQueryCache(db2) {
    var targetDocumentsStore = db2.createObjectStore(DbTargetDocument.store, {
      keyPath: DbTargetDocument.keyPath
    });
    targetDocumentsStore.createIndex(DbTargetDocument.documentTargetsIndex, DbTargetDocument.documentTargetsKeyPath, {unique: true});
    var targetStore = db2.createObjectStore(DbTarget.store, {
      keyPath: DbTarget.keyPath
    });
    targetStore.createIndex(DbTarget.queryTargetsIndexName, DbTarget.queryTargetsKeyPath, {unique: true});
    db2.createObjectStore(DbTargetGlobal.store);
  }
  function dropQueryCache(db2) {
    db2.deleteObjectStore(DbTargetDocument.store);
    db2.deleteObjectStore(DbTarget.store);
    db2.deleteObjectStore(DbTargetGlobal.store);
  }
  function dropRemoteDocumentChangesStore(db2) {
    if (db2.objectStoreNames.contains("remoteDocumentChanges")) {
      db2.deleteObjectStore("remoteDocumentChanges");
    }
  }
  function writeEmptyTargetGlobalEntry(txn) {
    var globalStore = txn.store(DbTargetGlobal.store);
    var metadata = new DbTargetGlobal(0, 0, SnapshotVersion.min().toTimestamp(), 0);
    return globalStore.put(DbTargetGlobal.key, metadata);
  }
  function createRemoteDocumentReadTimeIndex(txn) {
    var remoteDocumentStore = txn.objectStore(DbRemoteDocument.store);
    remoteDocumentStore.createIndex(DbRemoteDocument.readTimeIndex, DbRemoteDocument.readTimeIndexPath, {unique: false});
    remoteDocumentStore.createIndex(DbRemoteDocument.collectionReadTimeIndex, DbRemoteDocument.collectionReadTimeIndexPath, {unique: false});
  }
  function createClientMetadataStore(db2) {
    db2.createObjectStore(DbClientMetadata.store, {
      keyPath: DbClientMetadata.keyPath
    });
  }
  function createBundlesStore(db2) {
    db2.createObjectStore(DbBundle.store, {
      keyPath: DbBundle.keyPath
    });
  }
  function createNamedQueriesStore(db2) {
    db2.createObjectStore(DbNamedQuery.store, {
      keyPath: DbNamedQuery.keyPath
    });
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LOG_TAG$3 = "IndexedDbPersistence";
  var MAX_CLIENT_AGE_MS = 30 * 60 * 1e3;
  var MAX_PRIMARY_ELIGIBLE_AGE_MS = 5e3;
  var CLIENT_METADATA_REFRESH_INTERVAL_MS = 4e3;
  var PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
  var UNSUPPORTED_PLATFORM_ERROR_MSG = "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.";
  var ZOMBIED_CLIENTS_KEY_PREFIX = "firestore_zombie";
  var MAIN_DATABASE = "main";
  var IndexedDbPersistence = function() {
    function IndexedDbPersistence2(allowTabSynchronization, persistenceKey, clientId, lruParams, queue, window2, document2, serializer, sequenceNumberSyncer, forceOwningTab) {
      this.allowTabSynchronization = allowTabSynchronization;
      this.persistenceKey = persistenceKey;
      this.clientId = clientId;
      this.queue = queue;
      this.window = window2;
      this.document = document2;
      this.sequenceNumberSyncer = sequenceNumberSyncer;
      this.forceOwningTab = forceOwningTab;
      this.listenSequence = null;
      this._started = false;
      this.isPrimary = false;
      this.networkEnabled = true;
      this.windowUnloadHandler = null;
      this.inForeground = false;
      this.documentVisibilityHandler = null;
      this.clientMetadataRefresher = null;
      this.lastGarbageCollectionTime = Number.NEGATIVE_INFINITY;
      this.primaryStateListener = function(_) {
        return Promise.resolve();
      };
      if (!IndexedDbPersistence2.isAvailable()) {
        throw new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);
      }
      this.referenceDelegate = new IndexedDbLruDelegateImpl(this, lruParams);
      this.dbName = persistenceKey + MAIN_DATABASE;
      this.serializer = new LocalSerializer(serializer);
      this.simpleDb = new SimpleDb(this.dbName, SCHEMA_VERSION, new SchemaConverter(this.serializer));
      this.targetCache = new IndexedDbTargetCache(this.referenceDelegate, this.serializer);
      this.indexManager = new IndexedDbIndexManager();
      this.remoteDocumentCache = newIndexedDbRemoteDocumentCache(this.serializer, this.indexManager);
      this.bundleCache = new IndexedDbBundleCache();
      if (this.window && this.window.localStorage) {
        this.webStorage = this.window.localStorage;
      } else {
        this.webStorage = null;
        if (forceOwningTab === false) {
          logError(LOG_TAG$3, "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page.");
        }
      }
    }
    IndexedDbPersistence2.prototype.start = function() {
      var _this = this;
      return this.updateClientMetadataAndTryBecomePrimary().then(function() {
        if (!_this.isPrimary && !_this.allowTabSynchronization) {
          throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);
        }
        _this.attachVisibilityHandler();
        _this.attachWindowUnloadHook();
        _this.scheduleClientMetadataAndPrimaryLeaseRefreshes();
        return _this.runTransaction("getHighestListenSequenceNumber", "readonly", function(txn) {
          return _this.targetCache.getHighestSequenceNumber(txn);
        });
      }).then(function(highestListenSequenceNumber) {
        _this.listenSequence = new ListenSequence(highestListenSequenceNumber, _this.sequenceNumberSyncer);
      }).then(function() {
        _this._started = true;
      }).catch(function(reason) {
        _this.simpleDb && _this.simpleDb.close();
        return Promise.reject(reason);
      });
    };
    IndexedDbPersistence2.prototype.setPrimaryStateListener = function(primaryStateListener) {
      var _this = this;
      this.primaryStateListener = function(primaryState) {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          return tslib.__generator(this, function(_d) {
            if (this.started) {
              return [2, primaryStateListener(primaryState)];
            }
            return [2];
          });
        });
      };
      return primaryStateListener(this.isPrimary);
    };
    IndexedDbPersistence2.prototype.setDatabaseDeletedListener = function(databaseDeletedListener) {
      var _this = this;
      this.simpleDb.setVersionChangeListener(function(event) {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (!(event.newVersion === null))
                  return [3, 2];
                return [4, databaseDeletedListener()];
              case 1:
                _d.sent();
                _d.label = 2;
              case 2:
                return [2];
            }
          });
        });
      });
    };
    IndexedDbPersistence2.prototype.setNetworkEnabled = function(networkEnabled) {
      var _this = this;
      if (this.networkEnabled !== networkEnabled) {
        this.networkEnabled = networkEnabled;
        this.queue.enqueueAndForget(function() {
          return tslib.__awaiter(_this, void 0, void 0, function() {
            return tslib.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  if (!this.started)
                    return [3, 2];
                  return [4, this.updateClientMetadataAndTryBecomePrimary()];
                case 1:
                  _d.sent();
                  _d.label = 2;
                case 2:
                  return [2];
              }
            });
          });
        });
      }
    };
    IndexedDbPersistence2.prototype.updateClientMetadataAndTryBecomePrimary = function() {
      var _this = this;
      return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", function(txn) {
        var metadataStore = clientMetadataStore(txn);
        return metadataStore.put(new DbClientMetadata(_this.clientId, Date.now(), _this.networkEnabled, _this.inForeground)).next(function() {
          if (_this.isPrimary) {
            return _this.verifyPrimaryLease(txn).next(function(success) {
              if (!success) {
                _this.isPrimary = false;
                _this.queue.enqueueRetryable(function() {
                  return _this.primaryStateListener(false);
                });
              }
            });
          }
        }).next(function() {
          return _this.canActAsPrimary(txn);
        }).next(function(canActAsPrimary) {
          if (_this.isPrimary && !canActAsPrimary) {
            return _this.releasePrimaryLeaseIfHeld(txn).next(function() {
              return false;
            });
          } else if (canActAsPrimary) {
            return _this.acquireOrExtendPrimaryLease(txn).next(function() {
              return true;
            });
          } else {
            return false;
          }
        });
      }).catch(function(e) {
        if (isIndexedDbTransactionError(e)) {
          logDebug(LOG_TAG$3, "Failed to extend owner lease: ", e);
          return _this.isPrimary;
        }
        if (!_this.allowTabSynchronization) {
          throw e;
        }
        logDebug(LOG_TAG$3, "Releasing owner lease after error during lease refresh", e);
        return false;
      }).then(function(isPrimary) {
        if (_this.isPrimary !== isPrimary) {
          _this.queue.enqueueRetryable(function() {
            return _this.primaryStateListener(isPrimary);
          });
        }
        _this.isPrimary = isPrimary;
      });
    };
    IndexedDbPersistence2.prototype.verifyPrimaryLease = function(txn) {
      var _this = this;
      var store = primaryClientStore(txn);
      return store.get(DbPrimaryClient.key).next(function(primaryClient) {
        return PersistencePromise.resolve(_this.isLocalClient(primaryClient));
      });
    };
    IndexedDbPersistence2.prototype.removeClientMetadata = function(txn) {
      var metadataStore = clientMetadataStore(txn);
      return metadataStore.delete(this.clientId);
    };
    IndexedDbPersistence2.prototype.maybeGarbageCollectMultiClientState = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var inactiveClients, _i, inactiveClients_1, inactiveClient;
        var _this = this;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (!(this.isPrimary && !this.isWithinAge(this.lastGarbageCollectionTime, MAX_CLIENT_AGE_MS)))
                return [3, 2];
              this.lastGarbageCollectionTime = Date.now();
              return [4, this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", function(txn) {
                var metadataStore = getStore(txn, DbClientMetadata.store);
                return metadataStore.loadAll().next(function(existingClients) {
                  var active = _this.filterActiveClients(existingClients, MAX_CLIENT_AGE_MS);
                  var inactive = existingClients.filter(function(client) {
                    return active.indexOf(client) === -1;
                  });
                  return PersistencePromise.forEach(inactive, function(inactiveClient2) {
                    return metadataStore.delete(inactiveClient2.clientId);
                  }).next(function() {
                    return inactive;
                  });
                });
              }).catch(function() {
                return [];
              })];
            case 1:
              inactiveClients = _d.sent();
              if (this.webStorage) {
                for (_i = 0, inactiveClients_1 = inactiveClients; _i < inactiveClients_1.length; _i++) {
                  inactiveClient = inactiveClients_1[_i];
                  this.webStorage.removeItem(this.zombiedClientLocalStorageKey(inactiveClient.clientId));
                }
              }
              _d.label = 2;
            case 2:
              return [2];
          }
        });
      });
    };
    IndexedDbPersistence2.prototype.scheduleClientMetadataAndPrimaryLeaseRefreshes = function() {
      var _this = this;
      this.clientMetadataRefresher = this.queue.enqueueAfterDelay("client_metadata_refresh", CLIENT_METADATA_REFRESH_INTERVAL_MS, function() {
        return _this.updateClientMetadataAndTryBecomePrimary().then(function() {
          return _this.maybeGarbageCollectMultiClientState();
        }).then(function() {
          return _this.scheduleClientMetadataAndPrimaryLeaseRefreshes();
        });
      });
    };
    IndexedDbPersistence2.prototype.isLocalClient = function(client) {
      return client ? client.ownerId === this.clientId : false;
    };
    IndexedDbPersistence2.prototype.canActAsPrimary = function(txn) {
      var _this = this;
      if (this.forceOwningTab) {
        return PersistencePromise.resolve(true);
      }
      var store = primaryClientStore(txn);
      return store.get(DbPrimaryClient.key).next(function(currentPrimary) {
        var currentLeaseIsValid = currentPrimary !== null && _this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) && !_this.isClientZombied(currentPrimary.ownerId);
        if (currentLeaseIsValid) {
          if (_this.isLocalClient(currentPrimary) && _this.networkEnabled) {
            return true;
          }
          if (!_this.isLocalClient(currentPrimary)) {
            if (!currentPrimary.allowTabSynchronization) {
              throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);
            }
            return false;
          }
        }
        if (_this.networkEnabled && _this.inForeground) {
          return true;
        }
        return clientMetadataStore(txn).loadAll().next(function(existingClients) {
          var preferredCandidate = _this.filterActiveClients(existingClients, MAX_PRIMARY_ELIGIBLE_AGE_MS).find(function(otherClient) {
            if (_this.clientId !== otherClient.clientId) {
              var otherClientHasBetterNetworkState = !_this.networkEnabled && otherClient.networkEnabled;
              var otherClientHasBetterVisibility = !_this.inForeground && otherClient.inForeground;
              var otherClientHasSameNetworkState = _this.networkEnabled === otherClient.networkEnabled;
              if (otherClientHasBetterNetworkState || otherClientHasBetterVisibility && otherClientHasSameNetworkState) {
                return true;
              }
            }
            return false;
          });
          return preferredCandidate === void 0;
        });
      }).next(function(canActAsPrimary) {
        if (_this.isPrimary !== canActAsPrimary) {
          logDebug(LOG_TAG$3, "Client " + (canActAsPrimary ? "is" : "is not") + " eligible for a primary lease.");
        }
        return canActAsPrimary;
      });
    };
    IndexedDbPersistence2.prototype.shutdown = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var _this = this;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              this._started = false;
              this.markClientZombied();
              if (this.clientMetadataRefresher) {
                this.clientMetadataRefresher.cancel();
                this.clientMetadataRefresher = null;
              }
              this.detachVisibilityHandler();
              this.detachWindowUnloadHook();
              return [4, this.simpleDb.runTransaction("shutdown", "readwrite", [DbPrimaryClient.store, DbClientMetadata.store], function(simpleDbTxn) {
                var persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, ListenSequence.INVALID);
                return _this.releasePrimaryLeaseIfHeld(persistenceTransaction).next(function() {
                  return _this.removeClientMetadata(persistenceTransaction);
                });
              })];
            case 1:
              _d.sent();
              this.simpleDb.close();
              this.removeClientZombiedEntry();
              return [2];
          }
        });
      });
    };
    IndexedDbPersistence2.prototype.filterActiveClients = function(clients, activityThresholdMs) {
      var _this = this;
      return clients.filter(function(client) {
        return _this.isWithinAge(client.updateTimeMs, activityThresholdMs) && !_this.isClientZombied(client.clientId);
      });
    };
    IndexedDbPersistence2.prototype.getActiveClients = function() {
      var _this = this;
      return this.runTransaction("getActiveClients", "readonly", function(txn) {
        return clientMetadataStore(txn).loadAll().next(function(clients) {
          return _this.filterActiveClients(clients, MAX_CLIENT_AGE_MS).map(function(clientMetadata) {
            return clientMetadata.clientId;
          });
        });
      });
    };
    Object.defineProperty(IndexedDbPersistence2.prototype, "started", {
      get: function() {
        return this._started;
      },
      enumerable: false,
      configurable: true
    });
    IndexedDbPersistence2.prototype.getMutationQueue = function(user) {
      return IndexedDbMutationQueue.forUser(user, this.serializer, this.indexManager, this.referenceDelegate);
    };
    IndexedDbPersistence2.prototype.getTargetCache = function() {
      return this.targetCache;
    };
    IndexedDbPersistence2.prototype.getRemoteDocumentCache = function() {
      return this.remoteDocumentCache;
    };
    IndexedDbPersistence2.prototype.getIndexManager = function() {
      return this.indexManager;
    };
    IndexedDbPersistence2.prototype.getBundleCache = function() {
      return this.bundleCache;
    };
    IndexedDbPersistence2.prototype.runTransaction = function(action, mode, transactionOperation) {
      var _this = this;
      logDebug(LOG_TAG$3, "Starting transaction:", action);
      var simpleDbMode = mode === "readonly" ? "readonly" : "readwrite";
      var persistenceTransaction;
      return this.simpleDb.runTransaction(action, simpleDbMode, ALL_STORES, function(simpleDbTxn) {
        persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, _this.listenSequence ? _this.listenSequence.next() : ListenSequence.INVALID);
        if (mode === "readwrite-primary") {
          return _this.verifyPrimaryLease(persistenceTransaction).next(function(holdsPrimaryLease) {
            if (holdsPrimaryLease) {
              return true;
            }
            return _this.canActAsPrimary(persistenceTransaction);
          }).next(function(holdsPrimaryLease) {
            if (!holdsPrimaryLease) {
              logError("Failed to obtain primary lease for action '" + action + "'.");
              _this.isPrimary = false;
              _this.queue.enqueueRetryable(function() {
                return _this.primaryStateListener(false);
              });
              throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_LOST_ERROR_MSG);
            }
            return transactionOperation(persistenceTransaction);
          }).next(function(result) {
            return _this.acquireOrExtendPrimaryLease(persistenceTransaction).next(function() {
              return result;
            });
          });
        } else {
          return _this.verifyAllowTabSynchronization(persistenceTransaction).next(function() {
            return transactionOperation(persistenceTransaction);
          });
        }
      }).then(function(result) {
        persistenceTransaction.raiseOnCommittedEvent();
        return result;
      });
    };
    IndexedDbPersistence2.prototype.verifyAllowTabSynchronization = function(txn) {
      var _this = this;
      var store = primaryClientStore(txn);
      return store.get(DbPrimaryClient.key).next(function(currentPrimary) {
        var currentLeaseIsValid = currentPrimary !== null && _this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) && !_this.isClientZombied(currentPrimary.ownerId);
        if (currentLeaseIsValid && !_this.isLocalClient(currentPrimary)) {
          if (!_this.forceOwningTab && (!_this.allowTabSynchronization || !currentPrimary.allowTabSynchronization)) {
            throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);
          }
        }
      });
    };
    IndexedDbPersistence2.prototype.acquireOrExtendPrimaryLease = function(txn) {
      var newPrimary = new DbPrimaryClient(this.clientId, this.allowTabSynchronization, Date.now());
      return primaryClientStore(txn).put(DbPrimaryClient.key, newPrimary);
    };
    IndexedDbPersistence2.isAvailable = function() {
      return SimpleDb.isAvailable();
    };
    IndexedDbPersistence2.prototype.releasePrimaryLeaseIfHeld = function(txn) {
      var _this = this;
      var store = primaryClientStore(txn);
      return store.get(DbPrimaryClient.key).next(function(primaryClient) {
        if (_this.isLocalClient(primaryClient)) {
          logDebug(LOG_TAG$3, "Releasing primary lease.");
          return store.delete(DbPrimaryClient.key);
        } else {
          return PersistencePromise.resolve();
        }
      });
    };
    IndexedDbPersistence2.prototype.isWithinAge = function(updateTimeMs, maxAgeMs) {
      var now = Date.now();
      var minAcceptable = now - maxAgeMs;
      var maxAcceptable = now;
      if (updateTimeMs < minAcceptable) {
        return false;
      } else if (updateTimeMs > maxAcceptable) {
        logError("Detected an update time that is in the future: " + updateTimeMs + " > " + maxAcceptable);
        return false;
      }
      return true;
    };
    IndexedDbPersistence2.prototype.attachVisibilityHandler = function() {
      var _this = this;
      if (this.document !== null && typeof this.document.addEventListener === "function") {
        this.documentVisibilityHandler = function() {
          _this.queue.enqueueAndForget(function() {
            _this.inForeground = _this.document.visibilityState === "visible";
            return _this.updateClientMetadataAndTryBecomePrimary();
          });
        };
        this.document.addEventListener("visibilitychange", this.documentVisibilityHandler);
        this.inForeground = this.document.visibilityState === "visible";
      }
    };
    IndexedDbPersistence2.prototype.detachVisibilityHandler = function() {
      if (this.documentVisibilityHandler) {
        this.document.removeEventListener("visibilitychange", this.documentVisibilityHandler);
        this.documentVisibilityHandler = null;
      }
    };
    IndexedDbPersistence2.prototype.attachWindowUnloadHook = function() {
      var _this = this;
      var _a;
      if (typeof ((_a = this.window) === null || _a === void 0 ? void 0 : _a.addEventListener) === "function") {
        this.windowUnloadHandler = function() {
          _this.markClientZombied();
          _this.queue.enqueueAndForget(function() {
            return _this.shutdown();
          });
        };
        this.window.addEventListener("unload", this.windowUnloadHandler);
      }
    };
    IndexedDbPersistence2.prototype.detachWindowUnloadHook = function() {
      if (this.windowUnloadHandler) {
        this.window.removeEventListener("unload", this.windowUnloadHandler);
        this.windowUnloadHandler = null;
      }
    };
    IndexedDbPersistence2.prototype.isClientZombied = function(clientId) {
      var _a;
      try {
        var isZombied = ((_a = this.webStorage) === null || _a === void 0 ? void 0 : _a.getItem(this.zombiedClientLocalStorageKey(clientId))) !== null;
        logDebug(LOG_TAG$3, "Client '" + clientId + "' " + (isZombied ? "is" : "is not") + " zombied in LocalStorage");
        return isZombied;
      } catch (e) {
        logError(LOG_TAG$3, "Failed to get zombied client id.", e);
        return false;
      }
    };
    IndexedDbPersistence2.prototype.markClientZombied = function() {
      if (!this.webStorage) {
        return;
      }
      try {
        this.webStorage.setItem(this.zombiedClientLocalStorageKey(this.clientId), String(Date.now()));
      } catch (e) {
        logError("Failed to set zombie client id.", e);
      }
    };
    IndexedDbPersistence2.prototype.removeClientZombiedEntry = function() {
      if (!this.webStorage) {
        return;
      }
      try {
        this.webStorage.removeItem(this.zombiedClientLocalStorageKey(this.clientId));
      } catch (e) {
      }
    };
    IndexedDbPersistence2.prototype.zombiedClientLocalStorageKey = function(clientId) {
      return ZOMBIED_CLIENTS_KEY_PREFIX + "_" + this.persistenceKey + "_" + clientId;
    };
    return IndexedDbPersistence2;
  }();
  function primaryClientStore(txn) {
    return getStore(txn, DbPrimaryClient.store);
  }
  function clientMetadataStore(txn) {
    return getStore(txn, DbClientMetadata.store);
  }
  function indexedDbStoragePrefix(databaseId, persistenceKey) {
    var database = databaseId.projectId;
    if (!databaseId.isDefaultDatabase) {
      database += "." + databaseId.database;
    }
    return "firestore/" + persistenceKey + "/" + database + "/";
  }
  function indexedDbClearPersistence(persistenceKey) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var dbName;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            if (!SimpleDb.isAvailable()) {
              return [2, Promise.resolve()];
            }
            dbName = persistenceKey + MAIN_DATABASE;
            return [4, SimpleDb.delete(dbName)];
          case 1:
            _d.sent();
            return [2];
        }
      });
    });
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LocalDocumentsView = function() {
    function LocalDocumentsView2(remoteDocumentCache, mutationQueue, indexManager) {
      this.remoteDocumentCache = remoteDocumentCache;
      this.mutationQueue = mutationQueue;
      this.indexManager = indexManager;
    }
    LocalDocumentsView2.prototype.getDocument = function(transaction, key) {
      var _this = this;
      return this.mutationQueue.getAllMutationBatchesAffectingDocumentKey(transaction, key).next(function(batches) {
        return _this.getDocumentInternal(transaction, key, batches);
      });
    };
    LocalDocumentsView2.prototype.getDocumentInternal = function(transaction, key, inBatches) {
      return this.remoteDocumentCache.getEntry(transaction, key).next(function(doc2) {
        for (var _i = 0, inBatches_1 = inBatches; _i < inBatches_1.length; _i++) {
          var batch = inBatches_1[_i];
          batch.applyToLocalView(doc2);
        }
        return doc2;
      });
    };
    LocalDocumentsView2.prototype.applyLocalMutationsToDocuments = function(docs, batches) {
      docs.forEach(function(key, localView) {
        for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {
          var batch = batches_1[_i];
          batch.applyToLocalView(localView);
        }
      });
    };
    LocalDocumentsView2.prototype.getDocuments = function(transaction, keys) {
      var _this = this;
      return this.remoteDocumentCache.getEntries(transaction, keys).next(function(docs) {
        return _this.applyLocalViewToDocuments(transaction, docs).next(function() {
          return docs;
        });
      });
    };
    LocalDocumentsView2.prototype.applyLocalViewToDocuments = function(transaction, baseDocs) {
      var _this = this;
      return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(transaction, baseDocs).next(function(batches) {
        return _this.applyLocalMutationsToDocuments(baseDocs, batches);
      });
    };
    LocalDocumentsView2.prototype.getDocumentsMatchingQuery = function(transaction, query2, sinceReadTime) {
      if (isDocumentQuery(query2)) {
        return this.getDocumentsMatchingDocumentQuery(transaction, query2.path);
      } else if (isCollectionGroupQuery(query2)) {
        return this.getDocumentsMatchingCollectionGroupQuery(transaction, query2, sinceReadTime);
      } else {
        return this.getDocumentsMatchingCollectionQuery(transaction, query2, sinceReadTime);
      }
    };
    LocalDocumentsView2.prototype.getDocumentsMatchingDocumentQuery = function(transaction, docPath) {
      return this.getDocument(transaction, new DocumentKey(docPath)).next(function(document2) {
        var result = documentMap();
        if (document2.isFoundDocument()) {
          result = result.insert(document2.key, document2);
        }
        return result;
      });
    };
    LocalDocumentsView2.prototype.getDocumentsMatchingCollectionGroupQuery = function(transaction, query2, sinceReadTime) {
      var _this = this;
      var collectionId = query2.collectionGroup;
      var results = documentMap();
      return this.indexManager.getCollectionParents(transaction, collectionId).next(function(parents) {
        return PersistencePromise.forEach(parents, function(parent) {
          var collectionQuery = asCollectionQueryAtPath(query2, parent.child(collectionId));
          return _this.getDocumentsMatchingCollectionQuery(transaction, collectionQuery, sinceReadTime).next(function(r) {
            r.forEach(function(key, doc2) {
              results = results.insert(key, doc2);
            });
          });
        }).next(function() {
          return results;
        });
      });
    };
    LocalDocumentsView2.prototype.getDocumentsMatchingCollectionQuery = function(transaction, query2, sinceReadTime) {
      var _this = this;
      var results;
      var mutationBatches;
      return this.remoteDocumentCache.getDocumentsMatchingQuery(transaction, query2, sinceReadTime).next(function(queryResults) {
        results = queryResults;
        return _this.mutationQueue.getAllMutationBatchesAffectingQuery(transaction, query2);
      }).next(function(matchingMutationBatches) {
        mutationBatches = matchingMutationBatches;
        return _this.addMissingBaseDocuments(transaction, mutationBatches, results).next(function(mergedDocuments) {
          results = mergedDocuments;
          for (var _i = 0, mutationBatches_1 = mutationBatches; _i < mutationBatches_1.length; _i++) {
            var batch = mutationBatches_1[_i];
            for (var _d = 0, _e = batch.mutations; _d < _e.length; _d++) {
              var mutation = _e[_d];
              var key = mutation.key;
              var document_2 = results.get(key);
              if (document_2 == null) {
                document_2 = MutableDocument.newInvalidDocument(key);
                results = results.insert(key, document_2);
              }
              applyMutationToLocalView(mutation, document_2, batch.localWriteTime);
              if (!document_2.isFoundDocument()) {
                results = results.remove(key);
              }
            }
          }
        });
      }).next(function() {
        results.forEach(function(key, doc2) {
          if (!queryMatches(query2, doc2)) {
            results = results.remove(key);
          }
        });
        return results;
      });
    };
    LocalDocumentsView2.prototype.addMissingBaseDocuments = function(transaction, matchingMutationBatches, existingDocuments) {
      var missingBaseDocEntriesForPatching = documentKeySet();
      for (var _i = 0, matchingMutationBatches_1 = matchingMutationBatches; _i < matchingMutationBatches_1.length; _i++) {
        var batch = matchingMutationBatches_1[_i];
        for (var _d = 0, _e = batch.mutations; _d < _e.length; _d++) {
          var mutation = _e[_d];
          if (mutation instanceof PatchMutation && existingDocuments.get(mutation.key) === null) {
            missingBaseDocEntriesForPatching = missingBaseDocEntriesForPatching.add(mutation.key);
          }
        }
      }
      var mergedDocuments = existingDocuments;
      return this.remoteDocumentCache.getEntries(transaction, missingBaseDocEntriesForPatching).next(function(missingBaseDocs) {
        missingBaseDocs.forEach(function(key, doc2) {
          if (doc2.isFoundDocument()) {
            mergedDocuments = mergedDocuments.insert(key, doc2);
          }
        });
        return mergedDocuments;
      });
    };
    return LocalDocumentsView2;
  }();
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LOG_TAG$4 = "LocalStore";
  var RESUME_TOKEN_MAX_AGE_MICROS = 5 * 60 * 1e6;
  var LocalStoreImpl = function() {
    function LocalStoreImpl2(persistence, queryEngine, initialUser, serializer) {
      this.persistence = persistence;
      this.queryEngine = queryEngine;
      this.serializer = serializer;
      this.targetDataByTarget = new SortedMap(primitiveComparator);
      this.targetIdByTarget = new ObjectMap(function(t) {
        return canonifyTarget(t);
      }, targetEquals);
      this.lastDocumentChangeReadTime = SnapshotVersion.min();
      this.mutationQueue = persistence.getMutationQueue(initialUser);
      this.remoteDocuments = persistence.getRemoteDocumentCache();
      this.targetCache = persistence.getTargetCache();
      this.localDocuments = new LocalDocumentsView(this.remoteDocuments, this.mutationQueue, this.persistence.getIndexManager());
      this.bundleCache = persistence.getBundleCache();
      this.queryEngine.setLocalDocumentsView(this.localDocuments);
    }
    LocalStoreImpl2.prototype.collectGarbage = function(garbageCollector) {
      var _this = this;
      return this.persistence.runTransaction("Collect garbage", "readwrite-primary", function(txn) {
        return garbageCollector.collect(txn, _this.targetDataByTarget);
      });
    };
    return LocalStoreImpl2;
  }();
  function newLocalStore(persistence, queryEngine, initialUser, serializer) {
    return new LocalStoreImpl(persistence, queryEngine, initialUser, serializer);
  }
  function localStoreHandleUserChange(localStore, user) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var localStoreImpl, newMutationQueue, newLocalDocuments, result;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            localStoreImpl = debugCast(localStore);
            newMutationQueue = localStoreImpl.mutationQueue;
            newLocalDocuments = localStoreImpl.localDocuments;
            return [4, localStoreImpl.persistence.runTransaction("Handle user change", "readonly", function(txn) {
              var oldBatches;
              return localStoreImpl.mutationQueue.getAllMutationBatches(txn).next(function(promisedOldBatches) {
                oldBatches = promisedOldBatches;
                newMutationQueue = localStoreImpl.persistence.getMutationQueue(user);
                newLocalDocuments = new LocalDocumentsView(localStoreImpl.remoteDocuments, newMutationQueue, localStoreImpl.persistence.getIndexManager());
                return newMutationQueue.getAllMutationBatches(txn);
              }).next(function(newBatches) {
                var removedBatchIds = [];
                var addedBatchIds = [];
                var changedKeys = documentKeySet();
                for (var _i = 0, oldBatches_1 = oldBatches; _i < oldBatches_1.length; _i++) {
                  var batch = oldBatches_1[_i];
                  removedBatchIds.push(batch.batchId);
                  for (var _d2 = 0, _e = batch.mutations; _d2 < _e.length; _d2++) {
                    var mutation = _e[_d2];
                    changedKeys = changedKeys.add(mutation.key);
                  }
                }
                for (var _f = 0, newBatches_1 = newBatches; _f < newBatches_1.length; _f++) {
                  var batch = newBatches_1[_f];
                  addedBatchIds.push(batch.batchId);
                  for (var _g = 0, _h = batch.mutations; _g < _h.length; _g++) {
                    var mutation = _h[_g];
                    changedKeys = changedKeys.add(mutation.key);
                  }
                }
                return newLocalDocuments.getDocuments(txn, changedKeys).next(function(affectedDocuments) {
                  return {
                    affectedDocuments,
                    removedBatchIds,
                    addedBatchIds
                  };
                });
              });
            })];
          case 1:
            result = _d.sent();
            localStoreImpl.mutationQueue = newMutationQueue;
            localStoreImpl.localDocuments = newLocalDocuments;
            localStoreImpl.queryEngine.setLocalDocumentsView(localStoreImpl.localDocuments);
            return [2, result];
        }
      });
    });
  }
  function localStoreWriteLocally(localStore, mutations) {
    var localStoreImpl = debugCast(localStore);
    var localWriteTime = Timestamp.now();
    var keys = mutations.reduce(function(keys2, m) {
      return keys2.add(m.key);
    }, documentKeySet());
    var existingDocs;
    return localStoreImpl.persistence.runTransaction("Locally write mutations", "readwrite", function(txn) {
      return localStoreImpl.localDocuments.getDocuments(txn, keys).next(function(docs) {
        existingDocs = docs;
        var baseMutations = [];
        for (var _i = 0, mutations_2 = mutations; _i < mutations_2.length; _i++) {
          var mutation = mutations_2[_i];
          var baseValue = extractMutationBaseValue(mutation, existingDocs.get(mutation.key));
          if (baseValue != null) {
            baseMutations.push(new PatchMutation(mutation.key, baseValue, extractFieldMask(baseValue.toProto().mapValue), Precondition.exists(true)));
          }
        }
        return localStoreImpl.mutationQueue.addMutationBatch(txn, localWriteTime, baseMutations, mutations);
      });
    }).then(function(batch) {
      batch.applyToLocalDocumentSet(existingDocs);
      return {batchId: batch.batchId, changes: existingDocs};
    });
  }
  function localStoreAcknowledgeBatch(localStore, batchResult) {
    var localStoreImpl = debugCast(localStore);
    return localStoreImpl.persistence.runTransaction("Acknowledge batch", "readwrite-primary", function(txn) {
      var affected = batchResult.batch.keys();
      var documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({
        trackRemovals: true
      });
      return applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer).next(function() {
        return documentBuffer.apply(txn);
      }).next(function() {
        return localStoreImpl.mutationQueue.performConsistencyCheck(txn);
      }).next(function() {
        return localStoreImpl.localDocuments.getDocuments(txn, affected);
      });
    });
  }
  function localStoreRejectBatch(localStore, batchId) {
    var localStoreImpl = debugCast(localStore);
    return localStoreImpl.persistence.runTransaction("Reject batch", "readwrite-primary", function(txn) {
      var affectedKeys;
      return localStoreImpl.mutationQueue.lookupMutationBatch(txn, batchId).next(function(batch) {
        hardAssert(batch !== null);
        affectedKeys = batch.keys();
        return localStoreImpl.mutationQueue.removeMutationBatch(txn, batch);
      }).next(function() {
        return localStoreImpl.mutationQueue.performConsistencyCheck(txn);
      }).next(function() {
        return localStoreImpl.localDocuments.getDocuments(txn, affectedKeys);
      });
    });
  }
  function localStoreGetHighestUnacknowledgedBatchId(localStore) {
    var localStoreImpl = debugCast(localStore);
    return localStoreImpl.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", function(txn) {
      return localStoreImpl.mutationQueue.getHighestUnacknowledgedBatchId(txn);
    });
  }
  function localStoreGetLastRemoteSnapshotVersion(localStore) {
    var localStoreImpl = debugCast(localStore);
    return localStoreImpl.persistence.runTransaction("Get last remote snapshot version", "readonly", function(txn) {
      return localStoreImpl.targetCache.getLastRemoteSnapshotVersion(txn);
    });
  }
  function localStoreApplyRemoteEventToLocalCache(localStore, remoteEvent) {
    var localStoreImpl = debugCast(localStore);
    var remoteVersion = remoteEvent.snapshotVersion;
    var newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;
    return localStoreImpl.persistence.runTransaction("Apply remote event", "readwrite-primary", function(txn) {
      var documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({
        trackRemovals: true
      });
      newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;
      var promises = [];
      remoteEvent.targetChanges.forEach(function(change, targetId) {
        var oldTargetData = newTargetDataByTargetMap.get(targetId);
        if (!oldTargetData) {
          return;
        }
        promises.push(localStoreImpl.targetCache.removeMatchingKeys(txn, change.removedDocuments, targetId).next(function() {
          return localStoreImpl.targetCache.addMatchingKeys(txn, change.addedDocuments, targetId);
        }));
        var resumeToken = change.resumeToken;
        if (resumeToken.approximateByteSize() > 0) {
          var newTargetData = oldTargetData.withResumeToken(resumeToken, remoteVersion).withSequenceNumber(txn.currentSequenceNumber);
          newTargetDataByTargetMap = newTargetDataByTargetMap.insert(targetId, newTargetData);
          if (shouldPersistTargetData(oldTargetData, newTargetData, change)) {
            promises.push(localStoreImpl.targetCache.updateTargetData(txn, newTargetData));
          }
        }
      });
      var changedDocs = mutableDocumentMap();
      remoteEvent.documentUpdates.forEach(function(key, doc2) {
        if (remoteEvent.resolvedLimboDocuments.has(key)) {
          promises.push(localStoreImpl.persistence.referenceDelegate.updateLimboDocument(txn, key));
        }
      });
      promises.push(populateDocumentChangeBuffer(txn, documentBuffer, remoteEvent.documentUpdates, remoteVersion, void 0).next(function(result) {
        changedDocs = result;
      }));
      if (!remoteVersion.isEqual(SnapshotVersion.min())) {
        var updateRemoteVersion = localStoreImpl.targetCache.getLastRemoteSnapshotVersion(txn).next(function(lastRemoteSnapshotVersion) {
          return localStoreImpl.targetCache.setTargetsMetadata(txn, txn.currentSequenceNumber, remoteVersion);
        });
        promises.push(updateRemoteVersion);
      }
      return PersistencePromise.waitFor(promises).next(function() {
        return documentBuffer.apply(txn);
      }).next(function() {
        return localStoreImpl.localDocuments.applyLocalViewToDocuments(txn, changedDocs);
      }).next(function() {
        return changedDocs;
      });
    }).then(function(changedDocs) {
      localStoreImpl.targetDataByTarget = newTargetDataByTargetMap;
      return changedDocs;
    });
  }
  function populateDocumentChangeBuffer(txn, documentBuffer, documents, globalVersion, documentVersions) {
    var updatedKeys = documentKeySet();
    documents.forEach(function(k) {
      return updatedKeys = updatedKeys.add(k);
    });
    return documentBuffer.getEntries(txn, updatedKeys).next(function(existingDocs) {
      var changedDocs = mutableDocumentMap();
      documents.forEach(function(key, doc2) {
        var existingDoc = existingDocs.get(key);
        var docReadTime = (documentVersions === null || documentVersions === void 0 ? void 0 : documentVersions.get(key)) || globalVersion;
        if (doc2.isNoDocument() && doc2.version.isEqual(SnapshotVersion.min())) {
          documentBuffer.removeEntry(key, docReadTime);
          changedDocs = changedDocs.insert(key, doc2);
        } else if (!existingDoc.isValidDocument() || doc2.version.compareTo(existingDoc.version) > 0 || doc2.version.compareTo(existingDoc.version) === 0 && existingDoc.hasPendingWrites) {
          documentBuffer.addEntry(doc2, docReadTime);
          changedDocs = changedDocs.insert(key, doc2);
        } else {
          logDebug(LOG_TAG$4, "Ignoring outdated watch update for ", key, ". Current version:", existingDoc.version, " Watch version:", doc2.version);
        }
      });
      return changedDocs;
    });
  }
  function shouldPersistTargetData(oldTargetData, newTargetData, change) {
    hardAssert(newTargetData.resumeToken.approximateByteSize() > 0);
    if (oldTargetData.resumeToken.approximateByteSize() === 0) {
      return true;
    }
    var timeDelta = newTargetData.snapshotVersion.toMicroseconds() - oldTargetData.snapshotVersion.toMicroseconds();
    if (timeDelta >= RESUME_TOKEN_MAX_AGE_MICROS) {
      return true;
    }
    var changes = change.addedDocuments.size + change.modifiedDocuments.size + change.removedDocuments.size;
    return changes > 0;
  }
  function localStoreNotifyLocalViewChanges(localStore, viewChanges) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var localStoreImpl, e_2, _i, viewChanges_1, viewChange, targetId, targetData, lastLimboFreeSnapshotVersion, updatedTargetData;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            localStoreImpl = debugCast(localStore);
            _d.label = 1;
          case 1:
            _d.trys.push([1, 3, , 4]);
            return [4, localStoreImpl.persistence.runTransaction("notifyLocalViewChanges", "readwrite", function(txn) {
              return PersistencePromise.forEach(viewChanges, function(viewChange2) {
                return PersistencePromise.forEach(viewChange2.addedKeys, function(key) {
                  return localStoreImpl.persistence.referenceDelegate.addReference(txn, viewChange2.targetId, key);
                }).next(function() {
                  return PersistencePromise.forEach(viewChange2.removedKeys, function(key) {
                    return localStoreImpl.persistence.referenceDelegate.removeReference(txn, viewChange2.targetId, key);
                  });
                });
              });
            })];
          case 2:
            _d.sent();
            return [3, 4];
          case 3:
            e_2 = _d.sent();
            if (isIndexedDbTransactionError(e_2)) {
              logDebug(LOG_TAG$4, "Failed to update sequence numbers: " + e_2);
            } else {
              throw e_2;
            }
            return [3, 4];
          case 4:
            for (_i = 0, viewChanges_1 = viewChanges; _i < viewChanges_1.length; _i++) {
              viewChange = viewChanges_1[_i];
              targetId = viewChange.targetId;
              if (!viewChange.fromCache) {
                targetData = localStoreImpl.targetDataByTarget.get(targetId);
                lastLimboFreeSnapshotVersion = targetData.snapshotVersion;
                updatedTargetData = targetData.withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion);
                localStoreImpl.targetDataByTarget = localStoreImpl.targetDataByTarget.insert(targetId, updatedTargetData);
              }
            }
            return [2];
        }
      });
    });
  }
  function localStoreGetNextMutationBatch(localStore, afterBatchId) {
    var localStoreImpl = debugCast(localStore);
    return localStoreImpl.persistence.runTransaction("Get next mutation batch", "readonly", function(txn) {
      if (afterBatchId === void 0) {
        afterBatchId = BATCHID_UNKNOWN;
      }
      return localStoreImpl.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);
    });
  }
  function localStoreReadDocument(localStore, key) {
    var localStoreImpl = debugCast(localStore);
    return localStoreImpl.persistence.runTransaction("read document", "readonly", function(txn) {
      return localStoreImpl.localDocuments.getDocument(txn, key);
    });
  }
  function localStoreAllocateTarget(localStore, target) {
    var localStoreImpl = debugCast(localStore);
    return localStoreImpl.persistence.runTransaction("Allocate target", "readwrite", function(txn) {
      var targetData;
      return localStoreImpl.targetCache.getTargetData(txn, target).next(function(cached) {
        if (cached) {
          targetData = cached;
          return PersistencePromise.resolve(targetData);
        } else {
          return localStoreImpl.targetCache.allocateTargetId(txn).next(function(targetId) {
            targetData = new TargetData(target, targetId, 0, txn.currentSequenceNumber);
            return localStoreImpl.targetCache.addTargetData(txn, targetData).next(function() {
              return targetData;
            });
          });
        }
      });
    }).then(function(targetData) {
      var cachedTargetData = localStoreImpl.targetDataByTarget.get(targetData.targetId);
      if (cachedTargetData === null || targetData.snapshotVersion.compareTo(cachedTargetData.snapshotVersion) > 0) {
        localStoreImpl.targetDataByTarget = localStoreImpl.targetDataByTarget.insert(targetData.targetId, targetData);
        localStoreImpl.targetIdByTarget.set(target, targetData.targetId);
      }
      return targetData;
    });
  }
  function localStoreGetTargetData(localStore, transaction, target) {
    var localStoreImpl = debugCast(localStore);
    var targetId = localStoreImpl.targetIdByTarget.get(target);
    if (targetId !== void 0) {
      return PersistencePromise.resolve(localStoreImpl.targetDataByTarget.get(targetId));
    } else {
      return localStoreImpl.targetCache.getTargetData(transaction, target);
    }
  }
  function localStoreReleaseTarget(localStore, targetId, keepPersistedTargetData) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var localStoreImpl, targetData, mode, e_3;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            localStoreImpl = debugCast(localStore);
            targetData = localStoreImpl.targetDataByTarget.get(targetId);
            mode = keepPersistedTargetData ? "readwrite" : "readwrite-primary";
            _d.label = 1;
          case 1:
            _d.trys.push([1, 4, , 5]);
            if (!!keepPersistedTargetData)
              return [3, 3];
            return [4, localStoreImpl.persistence.runTransaction("Release target", mode, function(txn) {
              return localStoreImpl.persistence.referenceDelegate.removeTarget(txn, targetData);
            })];
          case 2:
            _d.sent();
            _d.label = 3;
          case 3:
            return [3, 5];
          case 4:
            e_3 = _d.sent();
            if (isIndexedDbTransactionError(e_3)) {
              logDebug(LOG_TAG$4, "Failed to update sequence numbers for target " + targetId + ": " + e_3);
            } else {
              throw e_3;
            }
            return [3, 5];
          case 5:
            localStoreImpl.targetDataByTarget = localStoreImpl.targetDataByTarget.remove(targetId);
            localStoreImpl.targetIdByTarget.delete(targetData.target);
            return [2];
        }
      });
    });
  }
  function localStoreExecuteQuery(localStore, query2, usePreviousResults) {
    var localStoreImpl = debugCast(localStore);
    var lastLimboFreeSnapshotVersion = SnapshotVersion.min();
    var remoteKeys = documentKeySet();
    return localStoreImpl.persistence.runTransaction("Execute query", "readonly", function(txn) {
      return localStoreGetTargetData(localStoreImpl, txn, queryToTarget(query2)).next(function(targetData) {
        if (targetData) {
          lastLimboFreeSnapshotVersion = targetData.lastLimboFreeSnapshotVersion;
          return localStoreImpl.targetCache.getMatchingKeysForTargetId(txn, targetData.targetId).next(function(result) {
            remoteKeys = result;
          });
        }
      }).next(function() {
        return localStoreImpl.queryEngine.getDocumentsMatchingQuery(txn, query2, usePreviousResults ? lastLimboFreeSnapshotVersion : SnapshotVersion.min(), usePreviousResults ? remoteKeys : documentKeySet());
      }).next(function(documents) {
        return {documents, remoteKeys};
      });
    });
  }
  function applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer) {
    var batch = batchResult.batch;
    var docKeys = batch.keys();
    var promiseChain = PersistencePromise.resolve();
    docKeys.forEach(function(docKey) {
      promiseChain = promiseChain.next(function() {
        return documentBuffer.getEntry(txn, docKey);
      }).next(function(doc2) {
        var ackVersion = batchResult.docVersions.get(docKey);
        hardAssert(ackVersion !== null);
        if (doc2.version.compareTo(ackVersion) < 0) {
          batch.applyToRemoteDocument(doc2, batchResult);
          if (doc2.isValidDocument()) {
            documentBuffer.addEntry(doc2, batchResult.commitVersion);
          }
        }
      });
    });
    return promiseChain.next(function() {
      return localStoreImpl.mutationQueue.removeMutationBatch(txn, batch);
    });
  }
  function localStoreLookupMutationDocuments(localStore, batchId) {
    var localStoreImpl = debugCast(localStore);
    var mutationQueueImpl = debugCast(localStoreImpl.mutationQueue);
    return localStoreImpl.persistence.runTransaction("Lookup mutation documents", "readonly", function(txn) {
      return mutationQueueImpl.lookupMutationKeys(txn, batchId).next(function(keys) {
        if (keys) {
          return localStoreImpl.localDocuments.getDocuments(txn, keys);
        } else {
          return PersistencePromise.resolve(null);
        }
      });
    });
  }
  function localStoreRemoveCachedMutationBatchMetadata(localStore, batchId) {
    var mutationQueueImpl = debugCast(debugCast(localStore, LocalStoreImpl).mutationQueue);
    mutationQueueImpl.removeCachedMutationKeys(batchId);
  }
  function localStoreGetActiveClients(localStore) {
    var persistenceImpl = debugCast(debugCast(localStore, LocalStoreImpl).persistence);
    return persistenceImpl.getActiveClients();
  }
  function localStoreGetCachedTarget(localStore, targetId) {
    var localStoreImpl = debugCast(localStore);
    var targetCacheImpl = debugCast(localStoreImpl.targetCache);
    var cachedTargetData = localStoreImpl.targetDataByTarget.get(targetId);
    if (cachedTargetData) {
      return Promise.resolve(cachedTargetData.target);
    } else {
      return localStoreImpl.persistence.runTransaction("Get target data", "readonly", function(txn) {
        return targetCacheImpl.getTargetDataForTarget(txn, targetId).next(function(targetData) {
          return targetData ? targetData.target : null;
        });
      });
    }
  }
  function localStoreGetNewDocumentChanges(localStore) {
    var localStoreImpl = debugCast(localStore);
    return localStoreImpl.persistence.runTransaction("Get new document changes", "readonly", function(txn) {
      return remoteDocumentCacheGetNewDocumentChanges(localStoreImpl.remoteDocuments, txn, localStoreImpl.lastDocumentChangeReadTime);
    }).then(function(_d) {
      var changedDocs = _d.changedDocs, readTime = _d.readTime;
      localStoreImpl.lastDocumentChangeReadTime = readTime;
      return changedDocs;
    });
  }
  function localStoreSynchronizeLastDocumentChangeReadTime(localStore) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var localStoreImpl;
      return tslib.__generator(this, function(_d) {
        localStoreImpl = debugCast(localStore);
        return [2, localStoreImpl.persistence.runTransaction("Synchronize last document change read time", "readonly", function(txn) {
          return remoteDocumentCacheGetLastReadTime(txn);
        }).then(function(readTime) {
          localStoreImpl.lastDocumentChangeReadTime = readTime;
        })];
      });
    });
  }
  function umbrellaTarget(bundleName) {
    return queryToTarget(newQueryForPath(ResourcePath.fromString("__bundle__/docs/" + bundleName)));
  }
  function localStoreApplyBundledDocuments(localStore, bundleConverter, documents, bundleName) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var localStoreImpl, documentKeys, documentMap2, versionMap, _i, documents_1, bundleDoc, documentKey, documentBuffer, umbrellaTargetData;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            localStoreImpl = debugCast(localStore);
            documentKeys = documentKeySet();
            documentMap2 = mutableDocumentMap();
            versionMap = documentVersionMap();
            for (_i = 0, documents_1 = documents; _i < documents_1.length; _i++) {
              bundleDoc = documents_1[_i];
              documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);
              if (bundleDoc.document) {
                documentKeys = documentKeys.add(documentKey);
              }
              documentMap2 = documentMap2.insert(documentKey, bundleConverter.toMutableDocument(bundleDoc));
              versionMap = versionMap.insert(documentKey, bundleConverter.toSnapshotVersion(bundleDoc.metadata.readTime));
            }
            documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({
              trackRemovals: true
            });
            return [4, localStoreAllocateTarget(localStoreImpl, umbrellaTarget(bundleName))];
          case 1:
            umbrellaTargetData = _d.sent();
            return [2, localStoreImpl.persistence.runTransaction("Apply bundle documents", "readwrite", function(txn) {
              return populateDocumentChangeBuffer(txn, documentBuffer, documentMap2, SnapshotVersion.min(), versionMap).next(function(changedDocs) {
                documentBuffer.apply(txn);
                return changedDocs;
              }).next(function(changedDocs) {
                return localStoreImpl.targetCache.removeMatchingKeysForTargetId(txn, umbrellaTargetData.targetId).next(function() {
                  return localStoreImpl.targetCache.addMatchingKeys(txn, documentKeys, umbrellaTargetData.targetId);
                }).next(function() {
                  return localStoreImpl.localDocuments.applyLocalViewToDocuments(txn, changedDocs);
                }).next(function() {
                  return changedDocs;
                });
              });
            })];
        }
      });
    });
  }
  function localStoreHasNewerBundle(localStore, bundleMetadata) {
    var localStoreImpl = debugCast(localStore);
    var currentReadTime = fromVersion(bundleMetadata.createTime);
    return localStoreImpl.persistence.runTransaction("hasNewerBundle", "readonly", function(transaction) {
      return localStoreImpl.bundleCache.getBundleMetadata(transaction, bundleMetadata.id);
    }).then(function(cached) {
      return !!cached && cached.createTime.compareTo(currentReadTime) >= 0;
    });
  }
  function localStoreSaveBundle(localStore, bundleMetadata) {
    var localStoreImpl = debugCast(localStore);
    return localStoreImpl.persistence.runTransaction("Save bundle", "readwrite", function(transaction) {
      return localStoreImpl.bundleCache.saveBundleMetadata(transaction, bundleMetadata);
    });
  }
  function localStoreGetNamedQuery(localStore, queryName) {
    var localStoreImpl = debugCast(localStore);
    return localStoreImpl.persistence.runTransaction("Get named query", "readonly", function(transaction) {
      return localStoreImpl.bundleCache.getNamedQuery(transaction, queryName);
    });
  }
  function localStoreSaveNamedQuery(localStore, query2, documents) {
    if (documents === void 0) {
      documents = documentKeySet();
    }
    return tslib.__awaiter(this, void 0, void 0, function() {
      var allocated, localStoreImpl;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            return [4, localStoreAllocateTarget(localStore, queryToTarget(fromBundledQuery(query2.bundledQuery)))];
          case 1:
            allocated = _d.sent();
            localStoreImpl = debugCast(localStore);
            return [2, localStoreImpl.persistence.runTransaction("Save named query", "readwrite", function(transaction) {
              var readTime = fromVersion(query2.readTime);
              if (allocated.snapshotVersion.compareTo(readTime) >= 0) {
                return localStoreImpl.bundleCache.saveNamedQuery(transaction, query2);
              }
              var newTargetData = allocated.withResumeToken(ByteString.EMPTY_BYTE_STRING, readTime);
              localStoreImpl.targetDataByTarget = localStoreImpl.targetDataByTarget.insert(newTargetData.targetId, newTargetData);
              return localStoreImpl.targetCache.updateTargetData(transaction, newTargetData).next(function() {
                return localStoreImpl.targetCache.removeMatchingKeysForTargetId(transaction, allocated.targetId);
              }).next(function() {
                return localStoreImpl.targetCache.addMatchingKeys(transaction, documents, allocated.targetId);
              }).next(function() {
                return localStoreImpl.bundleCache.saveNamedQuery(transaction, query2);
              });
            })];
        }
      });
    });
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var MemoryBundleCache = function() {
    function MemoryBundleCache2(serializer) {
      this.serializer = serializer;
      this.bundles = new Map();
      this.namedQueries = new Map();
    }
    MemoryBundleCache2.prototype.getBundleMetadata = function(transaction, bundleId) {
      return PersistencePromise.resolve(this.bundles.get(bundleId));
    };
    MemoryBundleCache2.prototype.saveBundleMetadata = function(transaction, bundleMetadata) {
      this.bundles.set(bundleMetadata.id, fromBundleMetadata(bundleMetadata));
      return PersistencePromise.resolve();
    };
    MemoryBundleCache2.prototype.getNamedQuery = function(transaction, queryName) {
      return PersistencePromise.resolve(this.namedQueries.get(queryName));
    };
    MemoryBundleCache2.prototype.saveNamedQuery = function(transaction, query2) {
      this.namedQueries.set(query2.name, fromProtoNamedQuery(query2));
      return PersistencePromise.resolve();
    };
    return MemoryBundleCache2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var ReferenceSet = function() {
    function ReferenceSet2() {
      this.refsByKey = new SortedSet(DocReference.compareByKey);
      this.refsByTarget = new SortedSet(DocReference.compareByTargetId);
    }
    ReferenceSet2.prototype.isEmpty = function() {
      return this.refsByKey.isEmpty();
    };
    ReferenceSet2.prototype.addReference = function(key, id) {
      var ref = new DocReference(key, id);
      this.refsByKey = this.refsByKey.add(ref);
      this.refsByTarget = this.refsByTarget.add(ref);
    };
    ReferenceSet2.prototype.addReferences = function(keys, id) {
      var _this = this;
      keys.forEach(function(key) {
        return _this.addReference(key, id);
      });
    };
    ReferenceSet2.prototype.removeReference = function(key, id) {
      this.removeRef(new DocReference(key, id));
    };
    ReferenceSet2.prototype.removeReferences = function(keys, id) {
      var _this = this;
      keys.forEach(function(key) {
        return _this.removeReference(key, id);
      });
    };
    ReferenceSet2.prototype.removeReferencesForId = function(id) {
      var _this = this;
      var emptyKey = new DocumentKey(new ResourcePath([]));
      var startRef = new DocReference(emptyKey, id);
      var endRef = new DocReference(emptyKey, id + 1);
      var keys = [];
      this.refsByTarget.forEachInRange([startRef, endRef], function(ref) {
        _this.removeRef(ref);
        keys.push(ref.key);
      });
      return keys;
    };
    ReferenceSet2.prototype.removeAllReferences = function() {
      var _this = this;
      this.refsByKey.forEach(function(ref) {
        return _this.removeRef(ref);
      });
    };
    ReferenceSet2.prototype.removeRef = function(ref) {
      this.refsByKey = this.refsByKey.delete(ref);
      this.refsByTarget = this.refsByTarget.delete(ref);
    };
    ReferenceSet2.prototype.referencesForId = function(id) {
      var emptyKey = new DocumentKey(new ResourcePath([]));
      var startRef = new DocReference(emptyKey, id);
      var endRef = new DocReference(emptyKey, id + 1);
      var keys = documentKeySet();
      this.refsByTarget.forEachInRange([startRef, endRef], function(ref) {
        keys = keys.add(ref.key);
      });
      return keys;
    };
    ReferenceSet2.prototype.containsKey = function(key) {
      var ref = new DocReference(key, 0);
      var firstRef = this.refsByKey.firstAfterOrEqual(ref);
      return firstRef !== null && key.isEqual(firstRef.key);
    };
    return ReferenceSet2;
  }();
  var DocReference = function() {
    function DocReference2(key, targetOrBatchId) {
      this.key = key;
      this.targetOrBatchId = targetOrBatchId;
    }
    DocReference2.compareByKey = function(left, right) {
      return DocumentKey.comparator(left.key, right.key) || primitiveComparator(left.targetOrBatchId, right.targetOrBatchId);
    };
    DocReference2.compareByTargetId = function(left, right) {
      return primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) || DocumentKey.comparator(left.key, right.key);
    };
    return DocReference2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var MemoryMutationQueue = function() {
    function MemoryMutationQueue2(indexManager, referenceDelegate) {
      this.indexManager = indexManager;
      this.referenceDelegate = referenceDelegate;
      this.mutationQueue = [];
      this.nextBatchId = 1;
      this.batchesByDocumentKey = new SortedSet(DocReference.compareByKey);
    }
    MemoryMutationQueue2.prototype.checkEmpty = function(transaction) {
      return PersistencePromise.resolve(this.mutationQueue.length === 0);
    };
    MemoryMutationQueue2.prototype.addMutationBatch = function(transaction, localWriteTime, baseMutations, mutations) {
      var batchId = this.nextBatchId;
      this.nextBatchId++;
      if (this.mutationQueue.length > 0) {
        var prior = this.mutationQueue[this.mutationQueue.length - 1];
      }
      var batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);
      this.mutationQueue.push(batch);
      for (var _i = 0, mutations_3 = mutations; _i < mutations_3.length; _i++) {
        var mutation = mutations_3[_i];
        this.batchesByDocumentKey = this.batchesByDocumentKey.add(new DocReference(mutation.key, batchId));
        this.indexManager.addToCollectionParentIndex(transaction, mutation.key.path.popLast());
      }
      return PersistencePromise.resolve(batch);
    };
    MemoryMutationQueue2.prototype.lookupMutationBatch = function(transaction, batchId) {
      return PersistencePromise.resolve(this.findMutationBatch(batchId));
    };
    MemoryMutationQueue2.prototype.getNextMutationBatchAfterBatchId = function(transaction, batchId) {
      var nextBatchId = batchId + 1;
      var rawIndex = this.indexOfBatchId(nextBatchId);
      var index = rawIndex < 0 ? 0 : rawIndex;
      return PersistencePromise.resolve(this.mutationQueue.length > index ? this.mutationQueue[index] : null);
    };
    MemoryMutationQueue2.prototype.getHighestUnacknowledgedBatchId = function() {
      return PersistencePromise.resolve(this.mutationQueue.length === 0 ? BATCHID_UNKNOWN : this.nextBatchId - 1);
    };
    MemoryMutationQueue2.prototype.getAllMutationBatches = function(transaction) {
      return PersistencePromise.resolve(this.mutationQueue.slice());
    };
    MemoryMutationQueue2.prototype.getAllMutationBatchesAffectingDocumentKey = function(transaction, documentKey) {
      var _this = this;
      var start = new DocReference(documentKey, 0);
      var end = new DocReference(documentKey, Number.POSITIVE_INFINITY);
      var result = [];
      this.batchesByDocumentKey.forEachInRange([start, end], function(ref) {
        var batch = _this.findMutationBatch(ref.targetOrBatchId);
        result.push(batch);
      });
      return PersistencePromise.resolve(result);
    };
    MemoryMutationQueue2.prototype.getAllMutationBatchesAffectingDocumentKeys = function(transaction, documentKeys) {
      var _this = this;
      var uniqueBatchIDs = new SortedSet(primitiveComparator);
      documentKeys.forEach(function(documentKey) {
        var start = new DocReference(documentKey, 0);
        var end = new DocReference(documentKey, Number.POSITIVE_INFINITY);
        _this.batchesByDocumentKey.forEachInRange([start, end], function(ref) {
          uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);
        });
      });
      return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));
    };
    MemoryMutationQueue2.prototype.getAllMutationBatchesAffectingQuery = function(transaction, query2) {
      var prefix = query2.path;
      var immediateChildrenPathLength = prefix.length + 1;
      var startPath = prefix;
      if (!DocumentKey.isDocumentKey(startPath)) {
        startPath = startPath.child("");
      }
      var start = new DocReference(new DocumentKey(startPath), 0);
      var uniqueBatchIDs = new SortedSet(primitiveComparator);
      this.batchesByDocumentKey.forEachWhile(function(ref) {
        var rowKeyPath = ref.key.path;
        if (!prefix.isPrefixOf(rowKeyPath)) {
          return false;
        } else {
          if (rowKeyPath.length === immediateChildrenPathLength) {
            uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);
          }
          return true;
        }
      }, start);
      return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));
    };
    MemoryMutationQueue2.prototype.findMutationBatches = function(batchIDs) {
      var _this = this;
      var result = [];
      batchIDs.forEach(function(batchId) {
        var batch = _this.findMutationBatch(batchId);
        if (batch !== null) {
          result.push(batch);
        }
      });
      return result;
    };
    MemoryMutationQueue2.prototype.removeMutationBatch = function(transaction, batch) {
      var _this = this;
      var batchIndex = this.indexOfExistingBatchId(batch.batchId, "removed");
      hardAssert(batchIndex === 0);
      this.mutationQueue.shift();
      var references = this.batchesByDocumentKey;
      return PersistencePromise.forEach(batch.mutations, function(mutation) {
        var ref = new DocReference(mutation.key, batch.batchId);
        references = references.delete(ref);
        return _this.referenceDelegate.markPotentiallyOrphaned(transaction, mutation.key);
      }).next(function() {
        _this.batchesByDocumentKey = references;
      });
    };
    MemoryMutationQueue2.prototype.removeCachedMutationKeys = function(batchId) {
    };
    MemoryMutationQueue2.prototype.containsKey = function(txn, key) {
      var ref = new DocReference(key, 0);
      var firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);
      return PersistencePromise.resolve(key.isEqual(firstRef && firstRef.key));
    };
    MemoryMutationQueue2.prototype.performConsistencyCheck = function(txn) {
      if (this.mutationQueue.length === 0)
        ;
      return PersistencePromise.resolve();
    };
    MemoryMutationQueue2.prototype.indexOfExistingBatchId = function(batchId, action) {
      var index = this.indexOfBatchId(batchId);
      return index;
    };
    MemoryMutationQueue2.prototype.indexOfBatchId = function(batchId) {
      if (this.mutationQueue.length === 0) {
        return 0;
      }
      var firstBatchId = this.mutationQueue[0].batchId;
      return batchId - firstBatchId;
    };
    MemoryMutationQueue2.prototype.findMutationBatch = function(batchId) {
      var index = this.indexOfBatchId(batchId);
      if (index < 0 || index >= this.mutationQueue.length) {
        return null;
      }
      var batch = this.mutationQueue[index];
      return batch;
    };
    return MemoryMutationQueue2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function documentEntryMap() {
    return new SortedMap(DocumentKey.comparator);
  }
  var MemoryRemoteDocumentCacheImpl = function() {
    function MemoryRemoteDocumentCacheImpl2(indexManager, sizer) {
      this.indexManager = indexManager;
      this.sizer = sizer;
      this.docs = documentEntryMap();
      this.size = 0;
    }
    MemoryRemoteDocumentCacheImpl2.prototype.addEntry = function(transaction, doc2, readTime) {
      var key = doc2.key;
      var entry = this.docs.get(key);
      var previousSize = entry ? entry.size : 0;
      var currentSize = this.sizer(doc2);
      this.docs = this.docs.insert(key, {
        document: doc2.clone(),
        size: currentSize,
        readTime
      });
      this.size += currentSize - previousSize;
      return this.indexManager.addToCollectionParentIndex(transaction, key.path.popLast());
    };
    MemoryRemoteDocumentCacheImpl2.prototype.removeEntry = function(documentKey) {
      var entry = this.docs.get(documentKey);
      if (entry) {
        this.docs = this.docs.remove(documentKey);
        this.size -= entry.size;
      }
    };
    MemoryRemoteDocumentCacheImpl2.prototype.getEntry = function(transaction, documentKey) {
      var entry = this.docs.get(documentKey);
      return PersistencePromise.resolve(entry ? entry.document.clone() : MutableDocument.newInvalidDocument(documentKey));
    };
    MemoryRemoteDocumentCacheImpl2.prototype.getEntries = function(transaction, documentKeys) {
      var _this = this;
      var results = mutableDocumentMap();
      documentKeys.forEach(function(documentKey) {
        var entry = _this.docs.get(documentKey);
        results = results.insert(documentKey, entry ? entry.document.clone() : MutableDocument.newInvalidDocument(documentKey));
      });
      return PersistencePromise.resolve(results);
    };
    MemoryRemoteDocumentCacheImpl2.prototype.getDocumentsMatchingQuery = function(transaction, query2, sinceReadTime) {
      var results = mutableDocumentMap();
      var prefix = new DocumentKey(query2.path.child(""));
      var iterator = this.docs.getIteratorFrom(prefix);
      while (iterator.hasNext()) {
        var _d = iterator.getNext(), key = _d.key, _e = _d.value, document_3 = _e.document, readTime = _e.readTime;
        if (!query2.path.isPrefixOf(key.path)) {
          break;
        }
        if (readTime.compareTo(sinceReadTime) <= 0) {
          continue;
        }
        if (!queryMatches(query2, document_3)) {
          continue;
        }
        results = results.insert(document_3.key, document_3.clone());
      }
      return PersistencePromise.resolve(results);
    };
    MemoryRemoteDocumentCacheImpl2.prototype.forEachDocumentKey = function(transaction, f) {
      return PersistencePromise.forEach(this.docs, function(key) {
        return f(key);
      });
    };
    MemoryRemoteDocumentCacheImpl2.prototype.newChangeBuffer = function(options) {
      return new MemoryRemoteDocumentChangeBuffer(this);
    };
    MemoryRemoteDocumentCacheImpl2.prototype.getSize = function(txn) {
      return PersistencePromise.resolve(this.size);
    };
    return MemoryRemoteDocumentCacheImpl2;
  }();
  function newMemoryRemoteDocumentCache(indexManager, sizer) {
    return new MemoryRemoteDocumentCacheImpl(indexManager, sizer);
  }
  var MemoryRemoteDocumentChangeBuffer = function(_super) {
    tslib.__extends(MemoryRemoteDocumentChangeBuffer2, _super);
    function MemoryRemoteDocumentChangeBuffer2(documentCache) {
      var _this = _super.call(this) || this;
      _this.documentCache = documentCache;
      return _this;
    }
    MemoryRemoteDocumentChangeBuffer2.prototype.applyChanges = function(transaction) {
      var _this = this;
      var promises = [];
      this.changes.forEach(function(key, doc2) {
        if (doc2.document.isValidDocument()) {
          promises.push(_this.documentCache.addEntry(transaction, doc2.document, _this.getReadTime(key)));
        } else {
          _this.documentCache.removeEntry(key);
        }
      });
      return PersistencePromise.waitFor(promises);
    };
    MemoryRemoteDocumentChangeBuffer2.prototype.getFromCache = function(transaction, documentKey) {
      return this.documentCache.getEntry(transaction, documentKey);
    };
    MemoryRemoteDocumentChangeBuffer2.prototype.getAllFromCache = function(transaction, documentKeys) {
      return this.documentCache.getEntries(transaction, documentKeys);
    };
    return MemoryRemoteDocumentChangeBuffer2;
  }(RemoteDocumentChangeBuffer);
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var MemoryTargetCache = function() {
    function MemoryTargetCache2(persistence) {
      this.persistence = persistence;
      this.targets = new ObjectMap(function(t) {
        return canonifyTarget(t);
      }, targetEquals);
      this.lastRemoteSnapshotVersion = SnapshotVersion.min();
      this.highestTargetId = 0;
      this.highestSequenceNumber = 0;
      this.references = new ReferenceSet();
      this.targetCount = 0;
      this.targetIdGenerator = TargetIdGenerator.forTargetCache();
    }
    MemoryTargetCache2.prototype.forEachTarget = function(txn, f) {
      this.targets.forEach(function(_, targetData) {
        return f(targetData);
      });
      return PersistencePromise.resolve();
    };
    MemoryTargetCache2.prototype.getLastRemoteSnapshotVersion = function(transaction) {
      return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);
    };
    MemoryTargetCache2.prototype.getHighestSequenceNumber = function(transaction) {
      return PersistencePromise.resolve(this.highestSequenceNumber);
    };
    MemoryTargetCache2.prototype.allocateTargetId = function(transaction) {
      this.highestTargetId = this.targetIdGenerator.next();
      return PersistencePromise.resolve(this.highestTargetId);
    };
    MemoryTargetCache2.prototype.setTargetsMetadata = function(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {
      if (lastRemoteSnapshotVersion) {
        this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;
      }
      if (highestListenSequenceNumber > this.highestSequenceNumber) {
        this.highestSequenceNumber = highestListenSequenceNumber;
      }
      return PersistencePromise.resolve();
    };
    MemoryTargetCache2.prototype.saveTargetData = function(targetData) {
      this.targets.set(targetData.target, targetData);
      var targetId = targetData.targetId;
      if (targetId > this.highestTargetId) {
        this.targetIdGenerator = new TargetIdGenerator(targetId);
        this.highestTargetId = targetId;
      }
      if (targetData.sequenceNumber > this.highestSequenceNumber) {
        this.highestSequenceNumber = targetData.sequenceNumber;
      }
    };
    MemoryTargetCache2.prototype.addTargetData = function(transaction, targetData) {
      this.saveTargetData(targetData);
      this.targetCount += 1;
      return PersistencePromise.resolve();
    };
    MemoryTargetCache2.prototype.updateTargetData = function(transaction, targetData) {
      this.saveTargetData(targetData);
      return PersistencePromise.resolve();
    };
    MemoryTargetCache2.prototype.removeTargetData = function(transaction, targetData) {
      this.targets.delete(targetData.target);
      this.references.removeReferencesForId(targetData.targetId);
      this.targetCount -= 1;
      return PersistencePromise.resolve();
    };
    MemoryTargetCache2.prototype.removeTargets = function(transaction, upperBound, activeTargetIds) {
      var _this = this;
      var count = 0;
      var removals = [];
      this.targets.forEach(function(key, targetData) {
        if (targetData.sequenceNumber <= upperBound && activeTargetIds.get(targetData.targetId) === null) {
          _this.targets.delete(key);
          removals.push(_this.removeMatchingKeysForTargetId(transaction, targetData.targetId));
          count++;
        }
      });
      return PersistencePromise.waitFor(removals).next(function() {
        return count;
      });
    };
    MemoryTargetCache2.prototype.getTargetCount = function(transaction) {
      return PersistencePromise.resolve(this.targetCount);
    };
    MemoryTargetCache2.prototype.getTargetData = function(transaction, target) {
      var targetData = this.targets.get(target) || null;
      return PersistencePromise.resolve(targetData);
    };
    MemoryTargetCache2.prototype.addMatchingKeys = function(txn, keys, targetId) {
      this.references.addReferences(keys, targetId);
      return PersistencePromise.resolve();
    };
    MemoryTargetCache2.prototype.removeMatchingKeys = function(txn, keys, targetId) {
      this.references.removeReferences(keys, targetId);
      var referenceDelegate = this.persistence.referenceDelegate;
      var promises = [];
      if (referenceDelegate) {
        keys.forEach(function(key) {
          promises.push(referenceDelegate.markPotentiallyOrphaned(txn, key));
        });
      }
      return PersistencePromise.waitFor(promises);
    };
    MemoryTargetCache2.prototype.removeMatchingKeysForTargetId = function(txn, targetId) {
      this.references.removeReferencesForId(targetId);
      return PersistencePromise.resolve();
    };
    MemoryTargetCache2.prototype.getMatchingKeysForTargetId = function(txn, targetId) {
      var matchingKeys = this.references.referencesForId(targetId);
      return PersistencePromise.resolve(matchingKeys);
    };
    MemoryTargetCache2.prototype.containsKey = function(txn, key) {
      return PersistencePromise.resolve(this.references.containsKey(key));
    };
    return MemoryTargetCache2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LOG_TAG$5 = "MemoryPersistence";
  var MemoryPersistence = function() {
    function MemoryPersistence2(referenceDelegateFactory, serializer) {
      var _this = this;
      this.mutationQueues = {};
      this.listenSequence = new ListenSequence(0);
      this._started = false;
      this._started = true;
      this.referenceDelegate = referenceDelegateFactory(this);
      this.targetCache = new MemoryTargetCache(this);
      var sizer = function(doc2) {
        return _this.referenceDelegate.documentSize(doc2);
      };
      this.indexManager = new MemoryIndexManager();
      this.remoteDocumentCache = newMemoryRemoteDocumentCache(this.indexManager, sizer);
      this.serializer = new LocalSerializer(serializer);
      this.bundleCache = new MemoryBundleCache(this.serializer);
    }
    MemoryPersistence2.prototype.start = function() {
      return Promise.resolve();
    };
    MemoryPersistence2.prototype.shutdown = function() {
      this._started = false;
      return Promise.resolve();
    };
    Object.defineProperty(MemoryPersistence2.prototype, "started", {
      get: function() {
        return this._started;
      },
      enumerable: false,
      configurable: true
    });
    MemoryPersistence2.prototype.setDatabaseDeletedListener = function() {
    };
    MemoryPersistence2.prototype.setNetworkEnabled = function() {
    };
    MemoryPersistence2.prototype.getIndexManager = function() {
      return this.indexManager;
    };
    MemoryPersistence2.prototype.getMutationQueue = function(user) {
      var queue = this.mutationQueues[user.toKey()];
      if (!queue) {
        queue = new MemoryMutationQueue(this.indexManager, this.referenceDelegate);
        this.mutationQueues[user.toKey()] = queue;
      }
      return queue;
    };
    MemoryPersistence2.prototype.getTargetCache = function() {
      return this.targetCache;
    };
    MemoryPersistence2.prototype.getRemoteDocumentCache = function() {
      return this.remoteDocumentCache;
    };
    MemoryPersistence2.prototype.getBundleCache = function() {
      return this.bundleCache;
    };
    MemoryPersistence2.prototype.runTransaction = function(action, mode, transactionOperation) {
      var _this = this;
      logDebug(LOG_TAG$5, "Starting transaction:", action);
      var txn = new MemoryTransaction(this.listenSequence.next());
      this.referenceDelegate.onTransactionStarted();
      return transactionOperation(txn).next(function(result) {
        return _this.referenceDelegate.onTransactionCommitted(txn).next(function() {
          return result;
        });
      }).toPromise().then(function(result) {
        txn.raiseOnCommittedEvent();
        return result;
      });
    };
    MemoryPersistence2.prototype.mutationQueuesContainKey = function(transaction, key) {
      return PersistencePromise.or(Object.values(this.mutationQueues).map(function(queue) {
        return function() {
          return queue.containsKey(transaction, key);
        };
      }));
    };
    return MemoryPersistence2;
  }();
  var MemoryTransaction = function(_super) {
    tslib.__extends(MemoryTransaction2, _super);
    function MemoryTransaction2(currentSequenceNumber) {
      var _this = _super.call(this) || this;
      _this.currentSequenceNumber = currentSequenceNumber;
      return _this;
    }
    return MemoryTransaction2;
  }(PersistenceTransaction);
  var MemoryEagerDelegate = function() {
    function MemoryEagerDelegate2(persistence) {
      this.persistence = persistence;
      this.localViewReferences = new ReferenceSet();
      this._orphanedDocuments = null;
    }
    MemoryEagerDelegate2.factory = function(persistence) {
      return new MemoryEagerDelegate2(persistence);
    };
    Object.defineProperty(MemoryEagerDelegate2.prototype, "orphanedDocuments", {
      get: function() {
        if (!this._orphanedDocuments) {
          throw fail();
        } else {
          return this._orphanedDocuments;
        }
      },
      enumerable: false,
      configurable: true
    });
    MemoryEagerDelegate2.prototype.addReference = function(txn, targetId, key) {
      this.localViewReferences.addReference(key, targetId);
      this.orphanedDocuments.delete(key.toString());
      return PersistencePromise.resolve();
    };
    MemoryEagerDelegate2.prototype.removeReference = function(txn, targetId, key) {
      this.localViewReferences.removeReference(key, targetId);
      this.orphanedDocuments.add(key.toString());
      return PersistencePromise.resolve();
    };
    MemoryEagerDelegate2.prototype.markPotentiallyOrphaned = function(txn, key) {
      this.orphanedDocuments.add(key.toString());
      return PersistencePromise.resolve();
    };
    MemoryEagerDelegate2.prototype.removeTarget = function(txn, targetData) {
      var _this = this;
      var orphaned = this.localViewReferences.removeReferencesForId(targetData.targetId);
      orphaned.forEach(function(key) {
        return _this.orphanedDocuments.add(key.toString());
      });
      var cache = this.persistence.getTargetCache();
      return cache.getMatchingKeysForTargetId(txn, targetData.targetId).next(function(keys) {
        keys.forEach(function(key) {
          return _this.orphanedDocuments.add(key.toString());
        });
      }).next(function() {
        return cache.removeTargetData(txn, targetData);
      });
    };
    MemoryEagerDelegate2.prototype.onTransactionStarted = function() {
      this._orphanedDocuments = new Set();
    };
    MemoryEagerDelegate2.prototype.onTransactionCommitted = function(txn) {
      var _this = this;
      var cache = this.persistence.getRemoteDocumentCache();
      var changeBuffer = cache.newChangeBuffer();
      return PersistencePromise.forEach(this.orphanedDocuments, function(path2) {
        var key = DocumentKey.fromPath(path2);
        return _this.isReferenced(txn, key).next(function(isReferenced) {
          if (!isReferenced) {
            changeBuffer.removeEntry(key);
          }
        });
      }).next(function() {
        _this._orphanedDocuments = null;
        return changeBuffer.apply(txn);
      });
    };
    MemoryEagerDelegate2.prototype.updateLimboDocument = function(txn, key) {
      var _this = this;
      return this.isReferenced(txn, key).next(function(isReferenced) {
        if (isReferenced) {
          _this.orphanedDocuments.delete(key.toString());
        } else {
          _this.orphanedDocuments.add(key.toString());
        }
      });
    };
    MemoryEagerDelegate2.prototype.documentSize = function(doc2) {
      return 0;
    };
    MemoryEagerDelegate2.prototype.isReferenced = function(txn, key) {
      var _this = this;
      return PersistencePromise.or([
        function() {
          return PersistencePromise.resolve(_this.localViewReferences.containsKey(key));
        },
        function() {
          return _this.persistence.getTargetCache().containsKey(txn, key);
        },
        function() {
          return _this.persistence.mutationQueuesContainKey(txn, key);
        }
      ]);
    };
    return MemoryEagerDelegate2;
  }();
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var QueryEngine = function() {
    function QueryEngine2() {
    }
    QueryEngine2.prototype.setLocalDocumentsView = function(localDocuments) {
      this.localDocumentsView = localDocuments;
    };
    QueryEngine2.prototype.getDocumentsMatchingQuery = function(transaction, query2, lastLimboFreeSnapshotVersion, remoteKeys) {
      var _this = this;
      if (matchesAllDocuments(query2)) {
        return this.executeFullCollectionScan(transaction, query2);
      }
      if (lastLimboFreeSnapshotVersion.isEqual(SnapshotVersion.min())) {
        return this.executeFullCollectionScan(transaction, query2);
      }
      return this.localDocumentsView.getDocuments(transaction, remoteKeys).next(function(documents) {
        var previousResults = _this.applyQuery(query2, documents);
        if ((hasLimitToFirst(query2) || hasLimitToLast(query2)) && _this.needsRefill(query2.limitType, previousResults, remoteKeys, lastLimboFreeSnapshotVersion)) {
          return _this.executeFullCollectionScan(transaction, query2);
        }
        if (getLogLevel() <= logger.LogLevel.DEBUG) {
          logDebug("QueryEngine", "Re-using previous result from %s to execute query: %s", lastLimboFreeSnapshotVersion.toString(), stringifyQuery(query2));
        }
        return _this.localDocumentsView.getDocumentsMatchingQuery(transaction, query2, lastLimboFreeSnapshotVersion).next(function(updatedResults) {
          previousResults.forEach(function(doc2) {
            updatedResults = updatedResults.insert(doc2.key, doc2);
          });
          return updatedResults;
        });
      });
    };
    QueryEngine2.prototype.applyQuery = function(query2, documents) {
      var queryResults = new SortedSet(newQueryComparator(query2));
      documents.forEach(function(_, maybeDoc) {
        if (queryMatches(query2, maybeDoc)) {
          queryResults = queryResults.add(maybeDoc);
        }
      });
      return queryResults;
    };
    QueryEngine2.prototype.needsRefill = function(limitType, sortedPreviousResults, remoteKeys, limboFreeSnapshotVersion) {
      if (remoteKeys.size !== sortedPreviousResults.size) {
        return true;
      }
      var docAtLimitEdge = limitType === "F" ? sortedPreviousResults.last() : sortedPreviousResults.first();
      if (!docAtLimitEdge) {
        return false;
      }
      return docAtLimitEdge.hasPendingWrites || docAtLimitEdge.version.compareTo(limboFreeSnapshotVersion) > 0;
    };
    QueryEngine2.prototype.executeFullCollectionScan = function(transaction, query2) {
      if (getLogLevel() <= logger.LogLevel.DEBUG) {
        logDebug("QueryEngine", "Using full collection scan to execute query:", stringifyQuery(query2));
      }
      return this.localDocumentsView.getDocumentsMatchingQuery(transaction, query2, SnapshotVersion.min());
    };
    return QueryEngine2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var User = function() {
    function User2(uid) {
      this.uid = uid;
    }
    User2.prototype.isAuthenticated = function() {
      return this.uid != null;
    };
    User2.prototype.toKey = function() {
      if (this.isAuthenticated()) {
        return "uid:" + this.uid;
      } else {
        return "anonymous-user";
      }
    };
    User2.prototype.isEqual = function(otherUser) {
      return otherUser.uid === this.uid;
    };
    return User2;
  }();
  User.UNAUTHENTICATED = new User(null);
  User.GOOGLE_CREDENTIALS = new User("google-credentials-uid");
  User.FIRST_PARTY = new User("first-party-uid");
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var CLIENT_STATE_KEY_PREFIX = "firestore_clients";
  function createWebStorageClientStateKey(persistenceKey, clientId) {
    return CLIENT_STATE_KEY_PREFIX + "_" + persistenceKey + "_" + clientId;
  }
  var MUTATION_BATCH_KEY_PREFIX = "firestore_mutations";
  function createWebStorageMutationBatchKey(persistenceKey, user, batchId) {
    var mutationKey = MUTATION_BATCH_KEY_PREFIX + "_" + persistenceKey + "_" + batchId;
    if (user.isAuthenticated()) {
      mutationKey += "_" + user.uid;
    }
    return mutationKey;
  }
  var QUERY_TARGET_KEY_PREFIX = "firestore_targets";
  function createWebStorageQueryTargetMetadataKey(persistenceKey, targetId) {
    return QUERY_TARGET_KEY_PREFIX + "_" + persistenceKey + "_" + targetId;
  }
  var ONLINE_STATE_KEY_PREFIX = "firestore_online_state";
  function createWebStorageOnlineStateKey(persistenceKey) {
    return ONLINE_STATE_KEY_PREFIX + "_" + persistenceKey;
  }
  var BUNDLE_LOADED_KEY_PREFIX = "firestore_bundle_loaded";
  function createBundleLoadedKey(persistenceKey) {
    return BUNDLE_LOADED_KEY_PREFIX + "_" + persistenceKey;
  }
  var SEQUENCE_NUMBER_KEY_PREFIX = "firestore_sequence_number";
  function createWebStorageSequenceNumberKey(persistenceKey) {
    return SEQUENCE_NUMBER_KEY_PREFIX + "_" + persistenceKey;
  }
  /**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LOG_TAG$6 = "SharedClientState";
  var MutationMetadata = function() {
    function MutationMetadata2(user, batchId, state, error) {
      this.user = user;
      this.batchId = batchId;
      this.state = state;
      this.error = error;
    }
    MutationMetadata2.fromWebStorageEntry = function(user, batchId, value) {
      var mutationBatch = JSON.parse(value);
      var validData = typeof mutationBatch === "object" && ["pending", "acknowledged", "rejected"].indexOf(mutationBatch.state) !== -1 && (mutationBatch.error === void 0 || typeof mutationBatch.error === "object");
      var firestoreError = void 0;
      if (validData && mutationBatch.error) {
        validData = typeof mutationBatch.error.message === "string" && typeof mutationBatch.error.code === "string";
        if (validData) {
          firestoreError = new FirestoreError(mutationBatch.error.code, mutationBatch.error.message);
        }
      }
      if (validData) {
        return new MutationMetadata2(user, batchId, mutationBatch.state, firestoreError);
      } else {
        logError(LOG_TAG$6, "Failed to parse mutation state for ID '" + batchId + "': " + value);
        return null;
      }
    };
    MutationMetadata2.prototype.toWebStorageJSON = function() {
      var batchMetadata = {
        state: this.state,
        updateTimeMs: Date.now()
      };
      if (this.error) {
        batchMetadata.error = {
          code: this.error.code,
          message: this.error.message
        };
      }
      return JSON.stringify(batchMetadata);
    };
    return MutationMetadata2;
  }();
  var QueryTargetMetadata = function() {
    function QueryTargetMetadata2(targetId, state, error) {
      this.targetId = targetId;
      this.state = state;
      this.error = error;
    }
    QueryTargetMetadata2.fromWebStorageEntry = function(targetId, value) {
      var targetState = JSON.parse(value);
      var validData = typeof targetState === "object" && ["not-current", "current", "rejected"].indexOf(targetState.state) !== -1 && (targetState.error === void 0 || typeof targetState.error === "object");
      var firestoreError = void 0;
      if (validData && targetState.error) {
        validData = typeof targetState.error.message === "string" && typeof targetState.error.code === "string";
        if (validData) {
          firestoreError = new FirestoreError(targetState.error.code, targetState.error.message);
        }
      }
      if (validData) {
        return new QueryTargetMetadata2(targetId, targetState.state, firestoreError);
      } else {
        logError(LOG_TAG$6, "Failed to parse target state for ID '" + targetId + "': " + value);
        return null;
      }
    };
    QueryTargetMetadata2.prototype.toWebStorageJSON = function() {
      var targetState = {
        state: this.state,
        updateTimeMs: Date.now()
      };
      if (this.error) {
        targetState.error = {
          code: this.error.code,
          message: this.error.message
        };
      }
      return JSON.stringify(targetState);
    };
    return QueryTargetMetadata2;
  }();
  var RemoteClientState = function() {
    function RemoteClientState2(clientId, activeTargetIds) {
      this.clientId = clientId;
      this.activeTargetIds = activeTargetIds;
    }
    RemoteClientState2.fromWebStorageEntry = function(clientId, value) {
      var clientState = JSON.parse(value);
      var validData = typeof clientState === "object" && clientState.activeTargetIds instanceof Array;
      var activeTargetIdsSet = targetIdSet();
      for (var i = 0; validData && i < clientState.activeTargetIds.length; ++i) {
        validData = isSafeInteger(clientState.activeTargetIds[i]);
        activeTargetIdsSet = activeTargetIdsSet.add(clientState.activeTargetIds[i]);
      }
      if (validData) {
        return new RemoteClientState2(clientId, activeTargetIdsSet);
      } else {
        logError(LOG_TAG$6, "Failed to parse client data for instance '" + clientId + "': " + value);
        return null;
      }
    };
    return RemoteClientState2;
  }();
  var SharedOnlineState = function() {
    function SharedOnlineState2(clientId, onlineState) {
      this.clientId = clientId;
      this.onlineState = onlineState;
    }
    SharedOnlineState2.fromWebStorageEntry = function(value) {
      var onlineState = JSON.parse(value);
      var validData = typeof onlineState === "object" && ["Unknown", "Online", "Offline"].indexOf(onlineState.onlineState) !== -1 && typeof onlineState.clientId === "string";
      if (validData) {
        return new SharedOnlineState2(onlineState.clientId, onlineState.onlineState);
      } else {
        logError(LOG_TAG$6, "Failed to parse online state: " + value);
        return null;
      }
    };
    return SharedOnlineState2;
  }();
  var LocalClientState = function() {
    function LocalClientState2() {
      this.activeTargetIds = targetIdSet();
    }
    LocalClientState2.prototype.addQueryTarget = function(targetId) {
      this.activeTargetIds = this.activeTargetIds.add(targetId);
    };
    LocalClientState2.prototype.removeQueryTarget = function(targetId) {
      this.activeTargetIds = this.activeTargetIds.delete(targetId);
    };
    LocalClientState2.prototype.toWebStorageJSON = function() {
      var data = {
        activeTargetIds: this.activeTargetIds.toArray(),
        updateTimeMs: Date.now()
      };
      return JSON.stringify(data);
    };
    return LocalClientState2;
  }();
  var WebStorageSharedClientState = function() {
    function WebStorageSharedClientState2(window2, queue, persistenceKey, localClientId, initialUser) {
      this.window = window2;
      this.queue = queue;
      this.persistenceKey = persistenceKey;
      this.localClientId = localClientId;
      this.syncEngine = null;
      this.onlineStateHandler = null;
      this.sequenceNumberHandler = null;
      this.storageListener = this.handleWebStorageEvent.bind(this);
      this.activeClients = new SortedMap(primitiveComparator);
      this.started = false;
      this.earlyEvents = [];
      var escapedPersistenceKey = persistenceKey.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      this.storage = this.window.localStorage;
      this.currentUser = initialUser;
      this.localClientStorageKey = createWebStorageClientStateKey(this.persistenceKey, this.localClientId);
      this.sequenceNumberKey = createWebStorageSequenceNumberKey(this.persistenceKey);
      this.activeClients = this.activeClients.insert(this.localClientId, new LocalClientState());
      this.clientStateKeyRe = new RegExp("^" + CLIENT_STATE_KEY_PREFIX + "_" + escapedPersistenceKey + "_([^_]*)$");
      this.mutationBatchKeyRe = new RegExp("^" + MUTATION_BATCH_KEY_PREFIX + "_" + escapedPersistenceKey + "_(\\d+)(?:_(.*))?$");
      this.queryTargetKeyRe = new RegExp("^" + QUERY_TARGET_KEY_PREFIX + "_" + escapedPersistenceKey + "_(\\d+)$");
      this.onlineStateKey = createWebStorageOnlineStateKey(this.persistenceKey);
      this.bundleLoadedKey = createBundleLoadedKey(this.persistenceKey);
      this.window.addEventListener("storage", this.storageListener);
    }
    WebStorageSharedClientState2.isAvailable = function(window2) {
      return !!(window2 && window2.localStorage);
    };
    WebStorageSharedClientState2.prototype.start = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var existingClients, _i, existingClients_1, clientId, storageItem, clientState, onlineStateJSON, onlineState, _d, _e, event_1;
        var _this = this;
        return tslib.__generator(this, function(_f) {
          switch (_f.label) {
            case 0:
              return [4, this.syncEngine.getActiveClients()];
            case 1:
              existingClients = _f.sent();
              for (_i = 0, existingClients_1 = existingClients; _i < existingClients_1.length; _i++) {
                clientId = existingClients_1[_i];
                if (clientId === this.localClientId) {
                  continue;
                }
                storageItem = this.getItem(createWebStorageClientStateKey(this.persistenceKey, clientId));
                if (storageItem) {
                  clientState = RemoteClientState.fromWebStorageEntry(clientId, storageItem);
                  if (clientState) {
                    this.activeClients = this.activeClients.insert(clientState.clientId, clientState);
                  }
                }
              }
              this.persistClientState();
              onlineStateJSON = this.storage.getItem(this.onlineStateKey);
              if (onlineStateJSON) {
                onlineState = this.fromWebStorageOnlineState(onlineStateJSON);
                if (onlineState) {
                  this.handleOnlineStateEvent(onlineState);
                }
              }
              for (_d = 0, _e = this.earlyEvents; _d < _e.length; _d++) {
                event_1 = _e[_d];
                this.handleWebStorageEvent(event_1);
              }
              this.earlyEvents = [];
              this.window.addEventListener("unload", function() {
                return _this.shutdown();
              });
              this.started = true;
              return [2];
          }
        });
      });
    };
    WebStorageSharedClientState2.prototype.writeSequenceNumber = function(sequenceNumber) {
      this.setItem(this.sequenceNumberKey, JSON.stringify(sequenceNumber));
    };
    WebStorageSharedClientState2.prototype.getAllActiveQueryTargets = function() {
      return this.extractActiveQueryTargets(this.activeClients);
    };
    WebStorageSharedClientState2.prototype.isActiveQueryTarget = function(targetId) {
      var found = false;
      this.activeClients.forEach(function(key, value) {
        if (value.activeTargetIds.has(targetId)) {
          found = true;
        }
      });
      return found;
    };
    WebStorageSharedClientState2.prototype.addPendingMutation = function(batchId) {
      this.persistMutationState(batchId, "pending");
    };
    WebStorageSharedClientState2.prototype.updateMutationState = function(batchId, state, error) {
      this.persistMutationState(batchId, state, error);
      this.removeMutationState(batchId);
    };
    WebStorageSharedClientState2.prototype.addLocalQueryTarget = function(targetId) {
      var queryState = "not-current";
      if (this.isActiveQueryTarget(targetId)) {
        var storageItem = this.storage.getItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));
        if (storageItem) {
          var metadata = QueryTargetMetadata.fromWebStorageEntry(targetId, storageItem);
          if (metadata) {
            queryState = metadata.state;
          }
        }
      }
      this.localClientState.addQueryTarget(targetId);
      this.persistClientState();
      return queryState;
    };
    WebStorageSharedClientState2.prototype.removeLocalQueryTarget = function(targetId) {
      this.localClientState.removeQueryTarget(targetId);
      this.persistClientState();
    };
    WebStorageSharedClientState2.prototype.isLocalQueryTarget = function(targetId) {
      return this.localClientState.activeTargetIds.has(targetId);
    };
    WebStorageSharedClientState2.prototype.clearQueryState = function(targetId) {
      this.removeItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));
    };
    WebStorageSharedClientState2.prototype.updateQueryState = function(targetId, state, error) {
      this.persistQueryTargetState(targetId, state, error);
    };
    WebStorageSharedClientState2.prototype.handleUserChange = function(user, removedBatchIds, addedBatchIds) {
      var _this = this;
      removedBatchIds.forEach(function(batchId) {
        _this.removeMutationState(batchId);
      });
      this.currentUser = user;
      addedBatchIds.forEach(function(batchId) {
        _this.addPendingMutation(batchId);
      });
    };
    WebStorageSharedClientState2.prototype.setOnlineState = function(onlineState) {
      this.persistOnlineState(onlineState);
    };
    WebStorageSharedClientState2.prototype.notifyBundleLoaded = function() {
      this.persistBundleLoadedState();
    };
    WebStorageSharedClientState2.prototype.shutdown = function() {
      if (this.started) {
        this.window.removeEventListener("storage", this.storageListener);
        this.removeItem(this.localClientStorageKey);
        this.started = false;
      }
    };
    WebStorageSharedClientState2.prototype.getItem = function(key) {
      var value = this.storage.getItem(key);
      logDebug(LOG_TAG$6, "READ", key, value);
      return value;
    };
    WebStorageSharedClientState2.prototype.setItem = function(key, value) {
      logDebug(LOG_TAG$6, "SET", key, value);
      this.storage.setItem(key, value);
    };
    WebStorageSharedClientState2.prototype.removeItem = function(key) {
      logDebug(LOG_TAG$6, "REMOVE", key);
      this.storage.removeItem(key);
    };
    WebStorageSharedClientState2.prototype.handleWebStorageEvent = function(event) {
      var _this = this;
      var storageEvent = event;
      if (storageEvent.storageArea === this.storage) {
        logDebug(LOG_TAG$6, "EVENT", storageEvent.key, storageEvent.newValue);
        if (storageEvent.key === this.localClientStorageKey) {
          logError("Received WebStorage notification for local change. Another client might have garbage-collected our state");
          return;
        }
        this.queue.enqueueRetryable(function() {
          return tslib.__awaiter(_this, void 0, void 0, function() {
            var clientState, clientId, mutationMetadata, queryTargetMetadata, onlineState, sequenceNumber;
            return tslib.__generator(this, function(_d) {
              if (!this.started) {
                this.earlyEvents.push(storageEvent);
                return [2];
              }
              if (storageEvent.key === null) {
                return [2];
              }
              if (this.clientStateKeyRe.test(storageEvent.key)) {
                if (storageEvent.newValue != null) {
                  clientState = this.fromWebStorageClientState(storageEvent.key, storageEvent.newValue);
                  if (clientState) {
                    return [2, this.handleClientStateEvent(clientState.clientId, clientState)];
                  }
                } else {
                  clientId = this.fromWebStorageClientStateKey(storageEvent.key);
                  return [2, this.handleClientStateEvent(clientId, null)];
                }
              } else if (this.mutationBatchKeyRe.test(storageEvent.key)) {
                if (storageEvent.newValue !== null) {
                  mutationMetadata = this.fromWebStorageMutationMetadata(storageEvent.key, storageEvent.newValue);
                  if (mutationMetadata) {
                    return [2, this.handleMutationBatchEvent(mutationMetadata)];
                  }
                }
              } else if (this.queryTargetKeyRe.test(storageEvent.key)) {
                if (storageEvent.newValue !== null) {
                  queryTargetMetadata = this.fromWebStorageQueryTargetMetadata(storageEvent.key, storageEvent.newValue);
                  if (queryTargetMetadata) {
                    return [2, this.handleQueryTargetEvent(queryTargetMetadata)];
                  }
                }
              } else if (storageEvent.key === this.onlineStateKey) {
                if (storageEvent.newValue !== null) {
                  onlineState = this.fromWebStorageOnlineState(storageEvent.newValue);
                  if (onlineState) {
                    return [2, this.handleOnlineStateEvent(onlineState)];
                  }
                }
              } else if (storageEvent.key === this.sequenceNumberKey) {
                sequenceNumber = fromWebStorageSequenceNumber(storageEvent.newValue);
                if (sequenceNumber !== ListenSequence.INVALID) {
                  this.sequenceNumberHandler(sequenceNumber);
                }
              } else if (storageEvent.key === this.bundleLoadedKey) {
                return [2, this.syncEngine.synchronizeWithChangedDocuments()];
              }
              return [2];
            });
          });
        });
      }
    };
    Object.defineProperty(WebStorageSharedClientState2.prototype, "localClientState", {
      get: function() {
        return this.activeClients.get(this.localClientId);
      },
      enumerable: false,
      configurable: true
    });
    WebStorageSharedClientState2.prototype.persistClientState = function() {
      this.setItem(this.localClientStorageKey, this.localClientState.toWebStorageJSON());
    };
    WebStorageSharedClientState2.prototype.persistMutationState = function(batchId, state, error) {
      var mutationState = new MutationMetadata(this.currentUser, batchId, state, error);
      var mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);
      this.setItem(mutationKey, mutationState.toWebStorageJSON());
    };
    WebStorageSharedClientState2.prototype.removeMutationState = function(batchId) {
      var mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);
      this.removeItem(mutationKey);
    };
    WebStorageSharedClientState2.prototype.persistOnlineState = function(onlineState) {
      var entry = {
        clientId: this.localClientId,
        onlineState
      };
      this.storage.setItem(this.onlineStateKey, JSON.stringify(entry));
    };
    WebStorageSharedClientState2.prototype.persistQueryTargetState = function(targetId, state, error) {
      var targetKey = createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId);
      var targetMetadata = new QueryTargetMetadata(targetId, state, error);
      this.setItem(targetKey, targetMetadata.toWebStorageJSON());
    };
    WebStorageSharedClientState2.prototype.persistBundleLoadedState = function() {
      this.setItem(this.bundleLoadedKey, "value-not-used");
    };
    WebStorageSharedClientState2.prototype.fromWebStorageClientStateKey = function(key) {
      var match = this.clientStateKeyRe.exec(key);
      return match ? match[1] : null;
    };
    WebStorageSharedClientState2.prototype.fromWebStorageClientState = function(key, value) {
      var clientId = this.fromWebStorageClientStateKey(key);
      return RemoteClientState.fromWebStorageEntry(clientId, value);
    };
    WebStorageSharedClientState2.prototype.fromWebStorageMutationMetadata = function(key, value) {
      var match = this.mutationBatchKeyRe.exec(key);
      var batchId = Number(match[1]);
      var userId = match[2] !== void 0 ? match[2] : null;
      return MutationMetadata.fromWebStorageEntry(new User(userId), batchId, value);
    };
    WebStorageSharedClientState2.prototype.fromWebStorageQueryTargetMetadata = function(key, value) {
      var match = this.queryTargetKeyRe.exec(key);
      var targetId = Number(match[1]);
      return QueryTargetMetadata.fromWebStorageEntry(targetId, value);
    };
    WebStorageSharedClientState2.prototype.fromWebStorageOnlineState = function(value) {
      return SharedOnlineState.fromWebStorageEntry(value);
    };
    WebStorageSharedClientState2.prototype.handleMutationBatchEvent = function(mutationBatch) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          if (mutationBatch.user.uid !== this.currentUser.uid) {
            logDebug(LOG_TAG$6, "Ignoring mutation for non-active user " + mutationBatch.user.uid);
            return [2];
          }
          return [2, this.syncEngine.applyBatchState(mutationBatch.batchId, mutationBatch.state, mutationBatch.error)];
        });
      });
    };
    WebStorageSharedClientState2.prototype.handleQueryTargetEvent = function(targetMetadata) {
      return this.syncEngine.applyTargetState(targetMetadata.targetId, targetMetadata.state, targetMetadata.error);
    };
    WebStorageSharedClientState2.prototype.handleClientStateEvent = function(clientId, clientState) {
      var _this = this;
      var updatedClients = clientState ? this.activeClients.insert(clientId, clientState) : this.activeClients.remove(clientId);
      var existingTargets = this.extractActiveQueryTargets(this.activeClients);
      var newTargets = this.extractActiveQueryTargets(updatedClients);
      var addedTargets = [];
      var removedTargets = [];
      newTargets.forEach(function(targetId) {
        if (!existingTargets.has(targetId)) {
          addedTargets.push(targetId);
        }
      });
      existingTargets.forEach(function(targetId) {
        if (!newTargets.has(targetId)) {
          removedTargets.push(targetId);
        }
      });
      return this.syncEngine.applyActiveTargetsChange(addedTargets, removedTargets).then(function() {
        _this.activeClients = updatedClients;
      });
    };
    WebStorageSharedClientState2.prototype.handleOnlineStateEvent = function(onlineState) {
      if (this.activeClients.get(onlineState.clientId)) {
        this.onlineStateHandler(onlineState.onlineState);
      }
    };
    WebStorageSharedClientState2.prototype.extractActiveQueryTargets = function(clients) {
      var activeTargets = targetIdSet();
      clients.forEach(function(kev, value) {
        activeTargets = activeTargets.unionWith(value.activeTargetIds);
      });
      return activeTargets;
    };
    return WebStorageSharedClientState2;
  }();
  function fromWebStorageSequenceNumber(seqString) {
    var sequenceNumber = ListenSequence.INVALID;
    if (seqString != null) {
      try {
        var parsed = JSON.parse(seqString);
        hardAssert(typeof parsed === "number");
        sequenceNumber = parsed;
      } catch (e) {
        logError(LOG_TAG$6, "Failed to read sequence number from WebStorage", e);
      }
    }
    return sequenceNumber;
  }
  var MemorySharedClientState = function() {
    function MemorySharedClientState2() {
      this.localState = new LocalClientState();
      this.queryState = {};
      this.onlineStateHandler = null;
      this.sequenceNumberHandler = null;
    }
    MemorySharedClientState2.prototype.addPendingMutation = function(batchId) {
    };
    MemorySharedClientState2.prototype.updateMutationState = function(batchId, state, error) {
    };
    MemorySharedClientState2.prototype.addLocalQueryTarget = function(targetId) {
      this.localState.addQueryTarget(targetId);
      return this.queryState[targetId] || "not-current";
    };
    MemorySharedClientState2.prototype.updateQueryState = function(targetId, state, error) {
      this.queryState[targetId] = state;
    };
    MemorySharedClientState2.prototype.removeLocalQueryTarget = function(targetId) {
      this.localState.removeQueryTarget(targetId);
    };
    MemorySharedClientState2.prototype.isLocalQueryTarget = function(targetId) {
      return this.localState.activeTargetIds.has(targetId);
    };
    MemorySharedClientState2.prototype.clearQueryState = function(targetId) {
      delete this.queryState[targetId];
    };
    MemorySharedClientState2.prototype.getAllActiveQueryTargets = function() {
      return this.localState.activeTargetIds;
    };
    MemorySharedClientState2.prototype.isActiveQueryTarget = function(targetId) {
      return this.localState.activeTargetIds.has(targetId);
    };
    MemorySharedClientState2.prototype.start = function() {
      this.localState = new LocalClientState();
      return Promise.resolve();
    };
    MemorySharedClientState2.prototype.handleUserChange = function(user, removedBatchIds, addedBatchIds) {
    };
    MemorySharedClientState2.prototype.setOnlineState = function(onlineState) {
    };
    MemorySharedClientState2.prototype.shutdown = function() {
    };
    MemorySharedClientState2.prototype.writeSequenceNumber = function(sequenceNumber) {
    };
    MemorySharedClientState2.prototype.notifyBundleLoaded = function() {
    };
    return MemorySharedClientState2;
  }();
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var NoopConnectivityMonitor = function() {
    function NoopConnectivityMonitor2() {
    }
    NoopConnectivityMonitor2.prototype.addCallback = function(callback) {
    };
    NoopConnectivityMonitor2.prototype.shutdown = function() {
    };
    return NoopConnectivityMonitor2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var StreamBridge = function() {
    function StreamBridge2(args) {
      this.sendFn = args.sendFn;
      this.closeFn = args.closeFn;
    }
    StreamBridge2.prototype.onOpen = function(callback) {
      this.wrappedOnOpen = callback;
    };
    StreamBridge2.prototype.onClose = function(callback) {
      this.wrappedOnClose = callback;
    };
    StreamBridge2.prototype.onMessage = function(callback) {
      this.wrappedOnMessage = callback;
    };
    StreamBridge2.prototype.close = function() {
      this.closeFn();
    };
    StreamBridge2.prototype.send = function(msg) {
      this.sendFn(msg);
    };
    StreamBridge2.prototype.callOnOpen = function() {
      this.wrappedOnOpen();
    };
    StreamBridge2.prototype.callOnClose = function(err) {
      this.wrappedOnClose(err);
    };
    StreamBridge2.prototype.callOnMessage = function(msg) {
      this.wrappedOnMessage(msg);
    };
    return StreamBridge2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function nodePromise(action) {
    return new Promise(function(resolve, reject) {
      action(function(error, value) {
        if (error) {
          reject(error);
        } else {
          resolve(value);
        }
      });
    });
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LOG_TAG$7 = "Connection";
  var X_GOOG_API_CLIENT_VALUE = "gl-node/" + process.versions.node + " fire/" + version + " grpc/" + package_json.version;
  function createMetadata(databasePath, token, appId) {
    hardAssert(token === null || token.type === "OAuth");
    var metadata = new grpcJs.Metadata();
    if (token) {
      for (var header in token.authHeaders) {
        if (token.authHeaders.hasOwnProperty(header)) {
          metadata.set(header, token.authHeaders[header]);
        }
      }
    }
    metadata.set("X-Firebase-GMPID", appId);
    metadata.set("X-Goog-Api-Client", X_GOOG_API_CLIENT_VALUE);
    metadata.set("Google-Cloud-Resource-Prefix", databasePath);
    return metadata;
  }
  var GrpcConnection = function() {
    function GrpcConnection2(protos, databaseInfo) {
      this.databaseInfo = databaseInfo;
      this.cachedStub = null;
      this.firestore = protos["google"]["firestore"]["v1"];
      this.databasePath = "projects/" + databaseInfo.databaseId.projectId + "/databases/" + databaseInfo.databaseId.database;
    }
    GrpcConnection2.prototype.ensureActiveStub = function() {
      if (!this.cachedStub) {
        logDebug(LOG_TAG$7, "Creating Firestore stub.");
        var credentials$1 = this.databaseInfo.ssl ? grpcJs.credentials.createSsl() : grpcJs.credentials.createInsecure();
        this.cachedStub = new this.firestore.Firestore(this.databaseInfo.host, credentials$1);
      }
      return this.cachedStub;
    };
    GrpcConnection2.prototype.invokeRPC = function(rpcName, path2, request, token) {
      var stub = this.ensureActiveStub();
      var metadata = createMetadata(this.databasePath, token, this.databaseInfo.appId);
      var jsonRequest = Object.assign({database: this.databasePath}, request);
      return nodePromise(function(callback) {
        logDebug(LOG_TAG$7, "RPC '" + rpcName + "' invoked with request:", request);
        return stub[rpcName](jsonRequest, metadata, function(grpcError, value) {
          if (grpcError) {
            logDebug(LOG_TAG$7, "RPC '" + rpcName + "' failed with error:", grpcError);
            callback(new FirestoreError(mapCodeFromRpcCode(grpcError.code), grpcError.message));
          } else {
            logDebug(LOG_TAG$7, "RPC '" + rpcName + "' completed with response:", value);
            callback(void 0, value);
          }
        });
      });
    };
    GrpcConnection2.prototype.invokeStreamingRPC = function(rpcName, path2, request, token) {
      var results = [];
      var responseDeferred = new Deferred();
      logDebug(LOG_TAG$7, "RPC '" + rpcName + "' invoked (streaming) with request:", request);
      var stub = this.ensureActiveStub();
      var metadata = createMetadata(this.databasePath, token, this.databaseInfo.appId);
      var jsonRequest = Object.assign(Object.assign({}, request), {database: this.databasePath});
      var stream = stub[rpcName](jsonRequest, metadata);
      stream.on("data", function(response) {
        logDebug(LOG_TAG$7, "RPC " + rpcName + " received result:", response);
        results.push(response);
      });
      stream.on("end", function() {
        logDebug(LOG_TAG$7, "RPC '" + rpcName + "' completed.");
        responseDeferred.resolve(results);
      });
      stream.on("error", function(grpcError) {
        logDebug(LOG_TAG$7, "RPC '" + rpcName + "' failed with error:", grpcError);
        var code = mapCodeFromRpcCode(grpcError.code);
        responseDeferred.reject(new FirestoreError(code, grpcError.message));
      });
      return responseDeferred.promise;
    };
    GrpcConnection2.prototype.openStream = function(rpcName, token) {
      var stub = this.ensureActiveStub();
      var metadata = createMetadata(this.databasePath, token, this.databaseInfo.appId);
      var grpcStream = stub[rpcName](metadata);
      var closed = false;
      var close = function(err) {
        if (!closed) {
          closed = true;
          stream.callOnClose(err);
          grpcStream.end();
        }
      };
      var stream = new StreamBridge({
        sendFn: function(msg) {
          if (!closed) {
            logDebug(LOG_TAG$7, "GRPC stream sending:", msg);
            try {
              grpcStream.write(msg);
            } catch (e) {
              logError("Failure sending:", msg);
              logError("Error:", e);
              throw e;
            }
          } else {
            logDebug(LOG_TAG$7, "Not sending because gRPC stream is closed:", msg);
          }
        },
        closeFn: function() {
          logDebug(LOG_TAG$7, "GRPC stream closed locally via close().");
          close();
        }
      });
      grpcStream.on("data", function(msg) {
        if (!closed) {
          logDebug(LOG_TAG$7, "GRPC stream received:", msg);
          stream.callOnMessage(msg);
        }
      });
      grpcStream.on("end", function() {
        logDebug(LOG_TAG$7, "GRPC stream ended.");
        close();
      });
      grpcStream.on("error", function(grpcError) {
        if (!closed) {
          logWarn(LOG_TAG$7, "GRPC stream error. Code:", grpcError.code, "Message:", grpcError.message);
          var code = mapCodeFromRpcCode(grpcError.code);
          close(new FirestoreError(code, grpcError.message));
        }
      });
      logDebug(LOG_TAG$7, "Opening GRPC stream");
      setTimeout(function() {
        stream.callOnOpen();
      }, 0);
      return stream;
    };
    return GrpcConnection2;
  }();
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var protoLoaderOptions = {
    longs: String,
    enums: String,
    defaults: true,
    oneofs: false
  };
  function loadProtos() {
    var root = path.resolve(__dirname, "../protos");
    var firestoreProtoFile = path.join(root, "google/firestore/v1/firestore.proto");
    var packageDefinition = protoLoader.loadSync(firestoreProtoFile, Object.assign(Object.assign({}, protoLoaderOptions), {includeDirs: [root]}));
    return grpcJs.loadPackageDefinition(packageDefinition);
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function newConnection(databaseInfo) {
    var protos = loadProtos();
    return new GrpcConnection(protos, databaseInfo);
  }
  function newConnectivityMonitor() {
    return new NoopConnectivityMonitor();
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function getWindow() {
    if (process.env.USE_MOCK_PERSISTENCE === "YES") {
      return window;
    }
    return null;
  }
  function getDocument() {
    return null;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function newSerializer(databaseId) {
    return new JsonProtoSerializer(databaseId, false);
  }
  function newTextEncoder() {
    return new util$1.TextEncoder();
  }
  function newTextDecoder() {
    return new util$1.TextDecoder("utf-8");
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LOG_TAG$8 = "ExponentialBackoff";
  var DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1e3;
  var DEFAULT_BACKOFF_FACTOR = 1.5;
  var DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1e3;
  var ExponentialBackoff = function() {
    function ExponentialBackoff2(queue, timerId, initialDelayMs, backoffFactor, maxDelayMs) {
      if (initialDelayMs === void 0) {
        initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS;
      }
      if (backoffFactor === void 0) {
        backoffFactor = DEFAULT_BACKOFF_FACTOR;
      }
      if (maxDelayMs === void 0) {
        maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS;
      }
      this.queue = queue;
      this.timerId = timerId;
      this.initialDelayMs = initialDelayMs;
      this.backoffFactor = backoffFactor;
      this.maxDelayMs = maxDelayMs;
      this.currentBaseMs = 0;
      this.timerPromise = null;
      this.lastAttemptTime = Date.now();
      this.reset();
    }
    ExponentialBackoff2.prototype.reset = function() {
      this.currentBaseMs = 0;
    };
    ExponentialBackoff2.prototype.resetToMax = function() {
      this.currentBaseMs = this.maxDelayMs;
    };
    ExponentialBackoff2.prototype.backoffAndRun = function(op) {
      var _this = this;
      this.cancel();
      var desiredDelayWithJitterMs = Math.floor(this.currentBaseMs + this.jitterDelayMs());
      var delaySoFarMs = Math.max(0, Date.now() - this.lastAttemptTime);
      var remainingDelayMs = Math.max(0, desiredDelayWithJitterMs - delaySoFarMs);
      if (remainingDelayMs > 0) {
        logDebug(LOG_TAG$8, "Backing off for " + remainingDelayMs + " ms " + ("(base delay: " + this.currentBaseMs + " ms, ") + ("delay with jitter: " + desiredDelayWithJitterMs + " ms, ") + ("last attempt: " + delaySoFarMs + " ms ago)"));
      }
      this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, remainingDelayMs, function() {
        _this.lastAttemptTime = Date.now();
        return op();
      });
      this.currentBaseMs *= this.backoffFactor;
      if (this.currentBaseMs < this.initialDelayMs) {
        this.currentBaseMs = this.initialDelayMs;
      }
      if (this.currentBaseMs > this.maxDelayMs) {
        this.currentBaseMs = this.maxDelayMs;
      }
    };
    ExponentialBackoff2.prototype.skipBackoff = function() {
      if (this.timerPromise !== null) {
        this.timerPromise.skipDelay();
        this.timerPromise = null;
      }
    };
    ExponentialBackoff2.prototype.cancel = function() {
      if (this.timerPromise !== null) {
        this.timerPromise.cancel();
        this.timerPromise = null;
      }
    };
    ExponentialBackoff2.prototype.jitterDelayMs = function() {
      return (Math.random() - 0.5) * this.currentBaseMs;
    };
    return ExponentialBackoff2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LOG_TAG$9 = "PersistentStream";
  var IDLE_TIMEOUT_MS = 60 * 1e3;
  var PersistentStream = function() {
    function PersistentStream2(queue, connectionTimerId, idleTimerId, connection, credentialsProvider, listener) {
      this.queue = queue;
      this.idleTimerId = idleTimerId;
      this.connection = connection;
      this.credentialsProvider = credentialsProvider;
      this.listener = listener;
      this.state = 0;
      this.closeCount = 0;
      this.idleTimer = null;
      this.stream = null;
      this.backoff = new ExponentialBackoff(queue, connectionTimerId);
    }
    PersistentStream2.prototype.isStarted = function() {
      return this.state === 1 || this.state === 2 || this.state === 4;
    };
    PersistentStream2.prototype.isOpen = function() {
      return this.state === 2;
    };
    PersistentStream2.prototype.start = function() {
      if (this.state === 3) {
        this.performBackoff();
        return;
      }
      this.auth();
    };
    PersistentStream2.prototype.stop = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (!this.isStarted())
                return [3, 2];
              return [4, this.close(0)];
            case 1:
              _d.sent();
              _d.label = 2;
            case 2:
              return [2];
          }
        });
      });
    };
    PersistentStream2.prototype.inhibitBackoff = function() {
      this.state = 0;
      this.backoff.reset();
    };
    PersistentStream2.prototype.markIdle = function() {
      var _this = this;
      if (this.isOpen() && this.idleTimer === null) {
        this.idleTimer = this.queue.enqueueAfterDelay(this.idleTimerId, IDLE_TIMEOUT_MS, function() {
          return _this.handleIdleCloseTimer();
        });
      }
    };
    PersistentStream2.prototype.sendRequest = function(msg) {
      this.cancelIdleCheck();
      this.stream.send(msg);
    };
    PersistentStream2.prototype.handleIdleCloseTimer = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          if (this.isOpen()) {
            return [2, this.close(0)];
          }
          return [2];
        });
      });
    };
    PersistentStream2.prototype.cancelIdleCheck = function() {
      if (this.idleTimer) {
        this.idleTimer.cancel();
        this.idleTimer = null;
      }
    };
    PersistentStream2.prototype.close = function(finalState, error) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              this.cancelIdleCheck();
              this.backoff.cancel();
              this.closeCount++;
              if (finalState !== 3) {
                this.backoff.reset();
              } else if (error && error.code === Code.RESOURCE_EXHAUSTED) {
                logError(error.toString());
                logError("Using maximum backoff delay to prevent overloading the backend.");
                this.backoff.resetToMax();
              } else if (error && error.code === Code.UNAUTHENTICATED) {
                this.credentialsProvider.invalidateToken();
              }
              if (this.stream !== null) {
                this.tearDown();
                this.stream.close();
                this.stream = null;
              }
              this.state = finalState;
              return [4, this.listener.onClose(error)];
            case 1:
              _d.sent();
              return [2];
          }
        });
      });
    };
    PersistentStream2.prototype.tearDown = function() {
    };
    PersistentStream2.prototype.auth = function() {
      var _this = this;
      this.state = 1;
      var dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);
      var closeCount = this.closeCount;
      this.credentialsProvider.getToken().then(function(token) {
        if (_this.closeCount === closeCount) {
          _this.startStream(token);
        }
      }, function(error) {
        dispatchIfNotClosed(function() {
          var rpcError = new FirestoreError(Code.UNKNOWN, "Fetching auth token failed: " + error.message);
          return _this.handleStreamClose(rpcError);
        });
      });
    };
    PersistentStream2.prototype.startStream = function(token) {
      var _this = this;
      var dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);
      this.stream = this.startRpc(token);
      this.stream.onOpen(function() {
        dispatchIfNotClosed(function() {
          _this.state = 2;
          return _this.listener.onOpen();
        });
      });
      this.stream.onClose(function(error) {
        dispatchIfNotClosed(function() {
          return _this.handleStreamClose(error);
        });
      });
      this.stream.onMessage(function(msg) {
        dispatchIfNotClosed(function() {
          return _this.onMessage(msg);
        });
      });
    };
    PersistentStream2.prototype.performBackoff = function() {
      var _this = this;
      this.state = 4;
      this.backoff.backoffAndRun(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          return tslib.__generator(this, function(_d) {
            this.state = 0;
            this.start();
            return [2];
          });
        });
      });
    };
    PersistentStream2.prototype.handleStreamClose = function(error) {
      logDebug(LOG_TAG$9, "close with error: " + error);
      this.stream = null;
      return this.close(3, error);
    };
    PersistentStream2.prototype.getCloseGuardedDispatcher = function(startCloseCount) {
      var _this = this;
      return function(fn) {
        _this.queue.enqueueAndForget(function() {
          if (_this.closeCount === startCloseCount) {
            return fn();
          } else {
            logDebug(LOG_TAG$9, "stream callback skipped by getCloseGuardedDispatcher.");
            return Promise.resolve();
          }
        });
      };
    };
    return PersistentStream2;
  }();
  var PersistentListenStream = function(_super) {
    tslib.__extends(PersistentListenStream2, _super);
    function PersistentListenStream2(queue, connection, credentials, serializer, listener) {
      var _this = _super.call(this, queue, "listen_stream_connection_backoff", "listen_stream_idle", connection, credentials, listener) || this;
      _this.serializer = serializer;
      return _this;
    }
    PersistentListenStream2.prototype.startRpc = function(token) {
      return this.connection.openStream("Listen", token);
    };
    PersistentListenStream2.prototype.onMessage = function(watchChangeProto) {
      this.backoff.reset();
      var watchChange = fromWatchChange(this.serializer, watchChangeProto);
      var snapshot = versionFromListenResponse(watchChangeProto);
      return this.listener.onWatchChange(watchChange, snapshot);
    };
    PersistentListenStream2.prototype.watch = function(targetData) {
      var request = {};
      request.database = getEncodedDatabaseId(this.serializer);
      request.addTarget = toTarget(this.serializer, targetData);
      var labels = toListenRequestLabels(this.serializer, targetData);
      if (labels) {
        request.labels = labels;
      }
      this.sendRequest(request);
    };
    PersistentListenStream2.prototype.unwatch = function(targetId) {
      var request = {};
      request.database = getEncodedDatabaseId(this.serializer);
      request.removeTarget = targetId;
      this.sendRequest(request);
    };
    return PersistentListenStream2;
  }(PersistentStream);
  var PersistentWriteStream = function(_super) {
    tslib.__extends(PersistentWriteStream2, _super);
    function PersistentWriteStream2(queue, connection, credentials, serializer, listener) {
      var _this = _super.call(this, queue, "write_stream_connection_backoff", "write_stream_idle", connection, credentials, listener) || this;
      _this.serializer = serializer;
      _this.handshakeComplete_ = false;
      return _this;
    }
    Object.defineProperty(PersistentWriteStream2.prototype, "handshakeComplete", {
      get: function() {
        return this.handshakeComplete_;
      },
      enumerable: false,
      configurable: true
    });
    PersistentWriteStream2.prototype.start = function() {
      this.handshakeComplete_ = false;
      this.lastStreamToken = void 0;
      _super.prototype.start.call(this);
    };
    PersistentWriteStream2.prototype.tearDown = function() {
      if (this.handshakeComplete_) {
        this.writeMutations([]);
      }
    };
    PersistentWriteStream2.prototype.startRpc = function(token) {
      return this.connection.openStream("Write", token);
    };
    PersistentWriteStream2.prototype.onMessage = function(responseProto) {
      hardAssert(!!responseProto.streamToken);
      this.lastStreamToken = responseProto.streamToken;
      if (!this.handshakeComplete_) {
        hardAssert(!responseProto.writeResults || responseProto.writeResults.length === 0);
        this.handshakeComplete_ = true;
        return this.listener.onHandshakeComplete();
      } else {
        this.backoff.reset();
        var results = fromWriteResults(responseProto.writeResults, responseProto.commitTime);
        var commitVersion = fromVersion(responseProto.commitTime);
        return this.listener.onMutationResult(commitVersion, results);
      }
    };
    PersistentWriteStream2.prototype.writeHandshake = function() {
      var request = {};
      request.database = getEncodedDatabaseId(this.serializer);
      this.sendRequest(request);
    };
    PersistentWriteStream2.prototype.writeMutations = function(mutations) {
      var _this = this;
      var request = {
        streamToken: this.lastStreamToken,
        writes: mutations.map(function(mutation) {
          return toMutation(_this.serializer, mutation);
        })
      };
      this.sendRequest(request);
    };
    return PersistentWriteStream2;
  }(PersistentStream);
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var Datastore = function() {
    function Datastore2() {
    }
    return Datastore2;
  }();
  var DatastoreImpl = function(_super) {
    tslib.__extends(DatastoreImpl2, _super);
    function DatastoreImpl2(credentials, connection, serializer) {
      var _this = _super.call(this) || this;
      _this.credentials = credentials;
      _this.connection = connection;
      _this.serializer = serializer;
      _this.terminated = false;
      return _this;
    }
    DatastoreImpl2.prototype.verifyInitialized = function() {
      if (this.terminated) {
        throw new FirestoreError(Code.FAILED_PRECONDITION, "The client has already been terminated.");
      }
    };
    DatastoreImpl2.prototype.invokeRPC = function(rpcName, path2, request) {
      var _this = this;
      this.verifyInitialized();
      return this.credentials.getToken().then(function(token) {
        return _this.connection.invokeRPC(rpcName, path2, request, token);
      }).catch(function(error) {
        if (error.code === Code.UNAUTHENTICATED) {
          _this.credentials.invalidateToken();
        }
        throw error;
      });
    };
    DatastoreImpl2.prototype.invokeStreamingRPC = function(rpcName, path2, request) {
      var _this = this;
      this.verifyInitialized();
      return this.credentials.getToken().then(function(token) {
        return _this.connection.invokeStreamingRPC(rpcName, path2, request, token);
      }).catch(function(error) {
        if (error.code === Code.UNAUTHENTICATED) {
          _this.credentials.invalidateToken();
        }
        throw error;
      });
    };
    DatastoreImpl2.prototype.terminate = function() {
      this.terminated = false;
    };
    return DatastoreImpl2;
  }(Datastore);
  function newDatastore(credentials, connection, serializer) {
    return new DatastoreImpl(credentials, connection, serializer);
  }
  function invokeCommitRpc(datastore, mutations) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var datastoreImpl, path2, request;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            datastoreImpl = debugCast(datastore);
            path2 = getEncodedDatabaseId(datastoreImpl.serializer) + "/documents";
            request = {
              writes: mutations.map(function(m) {
                return toMutation(datastoreImpl.serializer, m);
              })
            };
            return [4, datastoreImpl.invokeRPC("Commit", path2, request)];
          case 1:
            _d.sent();
            return [2];
        }
      });
    });
  }
  function invokeBatchGetDocumentsRpc(datastore, keys) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var datastoreImpl, path2, request, response, docs, result;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            datastoreImpl = debugCast(datastore);
            path2 = getEncodedDatabaseId(datastoreImpl.serializer) + "/documents";
            request = {
              documents: keys.map(function(k) {
                return toName(datastoreImpl.serializer, k);
              })
            };
            return [4, datastoreImpl.invokeStreamingRPC("BatchGetDocuments", path2, request)];
          case 1:
            response = _d.sent();
            docs = new Map();
            response.forEach(function(proto) {
              var doc2 = fromBatchGetDocumentsResponse(datastoreImpl.serializer, proto);
              docs.set(doc2.key.toString(), doc2);
            });
            result = [];
            keys.forEach(function(key) {
              var doc2 = docs.get(key.toString());
              hardAssert(!!doc2);
              result.push(doc2);
            });
            return [2, result];
        }
      });
    });
  }
  function newPersistentWriteStream(datastore, queue, listener) {
    var datastoreImpl = debugCast(datastore);
    datastoreImpl.verifyInitialized();
    return new PersistentWriteStream(queue, datastoreImpl.connection, datastoreImpl.credentials, datastoreImpl.serializer, listener);
  }
  function newPersistentWatchStream(datastore, queue, listener) {
    var datastoreImpl = debugCast(datastore);
    datastoreImpl.verifyInitialized();
    return new PersistentListenStream(queue, datastoreImpl.connection, datastoreImpl.credentials, datastoreImpl.serializer, listener);
  }
  /**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LOG_TAG$a = "OnlineStateTracker";
  var MAX_WATCH_STREAM_FAILURES = 1;
  var ONLINE_STATE_TIMEOUT_MS = 10 * 1e3;
  var OnlineStateTracker = function() {
    function OnlineStateTracker2(asyncQueue, onlineStateHandler) {
      this.asyncQueue = asyncQueue;
      this.onlineStateHandler = onlineStateHandler;
      this.state = "Unknown";
      this.watchStreamFailures = 0;
      this.onlineStateTimer = null;
      this.shouldWarnClientIsOffline = true;
    }
    OnlineStateTracker2.prototype.handleWatchStreamStart = function() {
      var _this = this;
      if (this.watchStreamFailures === 0) {
        this.setAndBroadcast("Unknown");
        this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay("online_state_timeout", ONLINE_STATE_TIMEOUT_MS, function() {
          _this.onlineStateTimer = null;
          _this.logClientOfflineWarningIfNecessary("Backend didn't respond within " + ONLINE_STATE_TIMEOUT_MS / 1e3 + " seconds.");
          _this.setAndBroadcast("Offline");
          return Promise.resolve();
        });
      }
    };
    OnlineStateTracker2.prototype.handleWatchStreamFailure = function(error) {
      if (this.state === "Online") {
        this.setAndBroadcast("Unknown");
      } else {
        this.watchStreamFailures++;
        if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {
          this.clearOnlineStateTimer();
          this.logClientOfflineWarningIfNecessary("Connection failed " + MAX_WATCH_STREAM_FAILURES + " " + ("times. Most recent error: " + error.toString()));
          this.setAndBroadcast("Offline");
        }
      }
    };
    OnlineStateTracker2.prototype.set = function(newState) {
      this.clearOnlineStateTimer();
      this.watchStreamFailures = 0;
      if (newState === "Online") {
        this.shouldWarnClientIsOffline = false;
      }
      this.setAndBroadcast(newState);
    };
    OnlineStateTracker2.prototype.setAndBroadcast = function(newState) {
      if (newState !== this.state) {
        this.state = newState;
        this.onlineStateHandler(newState);
      }
    };
    OnlineStateTracker2.prototype.logClientOfflineWarningIfNecessary = function(details) {
      var message = "Could not reach Cloud Firestore backend. " + details + "\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.";
      if (this.shouldWarnClientIsOffline) {
        logError(message);
        this.shouldWarnClientIsOffline = false;
      } else {
        logDebug(LOG_TAG$a, message);
      }
    };
    OnlineStateTracker2.prototype.clearOnlineStateTimer = function() {
      if (this.onlineStateTimer !== null) {
        this.onlineStateTimer.cancel();
        this.onlineStateTimer = null;
      }
    };
    return OnlineStateTracker2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LOG_TAG$b = "RemoteStore";
  var MAX_PENDING_WRITES = 10;
  var RemoteStoreImpl = function() {
    function RemoteStoreImpl2(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {
      var _this = this;
      this.localStore = localStore;
      this.datastore = datastore;
      this.asyncQueue = asyncQueue;
      this.remoteSyncer = {};
      this.writePipeline = [];
      this.listenTargets = new Map();
      this.offlineCauses = new Set();
      this.onNetworkStatusChange = [];
      this.connectivityMonitor = connectivityMonitor;
      this.connectivityMonitor.addCallback(function(_) {
        asyncQueue.enqueueAndForget(function() {
          return tslib.__awaiter(_this, void 0, void 0, function() {
            return tslib.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  if (!canUseNetwork(this))
                    return [3, 2];
                  logDebug(LOG_TAG$b, "Restarting streams for network reachability change.");
                  return [4, restartNetwork(this)];
                case 1:
                  _d.sent();
                  _d.label = 2;
                case 2:
                  return [2];
              }
            });
          });
        });
      });
      this.onlineStateTracker = new OnlineStateTracker(asyncQueue, onlineStateHandler);
    }
    return RemoteStoreImpl2;
  }();
  function newRemoteStore(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {
    return new RemoteStoreImpl(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor);
  }
  function remoteStoreEnableNetwork(remoteStore) {
    var remoteStoreImpl = debugCast(remoteStore);
    remoteStoreImpl.offlineCauses.delete(0);
    return enableNetworkInternal(remoteStoreImpl);
  }
  function enableNetworkInternal(remoteStoreImpl) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var _i, _d, networkStatusHandler;
      return tslib.__generator(this, function(_e) {
        switch (_e.label) {
          case 0:
            if (!canUseNetwork(remoteStoreImpl))
              return [3, 4];
            _i = 0, _d = remoteStoreImpl.onNetworkStatusChange;
            _e.label = 1;
          case 1:
            if (!(_i < _d.length))
              return [3, 4];
            networkStatusHandler = _d[_i];
            return [4, networkStatusHandler(true)];
          case 2:
            _e.sent();
            _e.label = 3;
          case 3:
            _i++;
            return [3, 1];
          case 4:
            return [2];
        }
      });
    });
  }
  function remoteStoreDisableNetwork(remoteStore) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var remoteStoreImpl;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            remoteStoreImpl = debugCast(remoteStore);
            remoteStoreImpl.offlineCauses.add(0);
            return [4, disableNetworkInternal(remoteStoreImpl)];
          case 1:
            _d.sent();
            remoteStoreImpl.onlineStateTracker.set("Offline");
            return [2];
        }
      });
    });
  }
  function disableNetworkInternal(remoteStoreImpl) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var _i, _d, networkStatusHandler;
      return tslib.__generator(this, function(_e) {
        switch (_e.label) {
          case 0:
            _i = 0, _d = remoteStoreImpl.onNetworkStatusChange;
            _e.label = 1;
          case 1:
            if (!(_i < _d.length))
              return [3, 4];
            networkStatusHandler = _d[_i];
            return [4, networkStatusHandler(false)];
          case 2:
            _e.sent();
            _e.label = 3;
          case 3:
            _i++;
            return [3, 1];
          case 4:
            return [2];
        }
      });
    });
  }
  function remoteStoreShutdown(remoteStore) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var remoteStoreImpl;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            remoteStoreImpl = debugCast(remoteStore);
            logDebug(LOG_TAG$b, "RemoteStore shutting down.");
            remoteStoreImpl.offlineCauses.add(5);
            return [4, disableNetworkInternal(remoteStoreImpl)];
          case 1:
            _d.sent();
            remoteStoreImpl.connectivityMonitor.shutdown();
            remoteStoreImpl.onlineStateTracker.set("Unknown");
            return [2];
        }
      });
    });
  }
  function remoteStoreListen(remoteStore, targetData) {
    var remoteStoreImpl = debugCast(remoteStore);
    if (remoteStoreImpl.listenTargets.has(targetData.targetId)) {
      return;
    }
    remoteStoreImpl.listenTargets.set(targetData.targetId, targetData);
    if (shouldStartWatchStream(remoteStoreImpl)) {
      startWatchStream(remoteStoreImpl);
    } else if (ensureWatchStream(remoteStoreImpl).isOpen()) {
      sendWatchRequest(remoteStoreImpl, targetData);
    }
  }
  function remoteStoreUnlisten(remoteStore, targetId) {
    var remoteStoreImpl = debugCast(remoteStore);
    var watchStream = ensureWatchStream(remoteStoreImpl);
    remoteStoreImpl.listenTargets.delete(targetId);
    if (watchStream.isOpen()) {
      sendUnwatchRequest(remoteStoreImpl, targetId);
    }
    if (remoteStoreImpl.listenTargets.size === 0) {
      if (watchStream.isOpen()) {
        watchStream.markIdle();
      } else if (canUseNetwork(remoteStoreImpl)) {
        remoteStoreImpl.onlineStateTracker.set("Unknown");
      }
    }
  }
  function sendWatchRequest(remoteStoreImpl, targetData) {
    remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetData.targetId);
    ensureWatchStream(remoteStoreImpl).watch(targetData);
  }
  function sendUnwatchRequest(remoteStoreImpl, targetId) {
    remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetId);
    ensureWatchStream(remoteStoreImpl).unwatch(targetId);
  }
  function startWatchStream(remoteStoreImpl) {
    remoteStoreImpl.watchChangeAggregator = new WatchChangeAggregator({
      getRemoteKeysForTarget: function(targetId) {
        return remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetId);
      },
      getTargetDataForTarget: function(targetId) {
        return remoteStoreImpl.listenTargets.get(targetId) || null;
      }
    });
    ensureWatchStream(remoteStoreImpl).start();
    remoteStoreImpl.onlineStateTracker.handleWatchStreamStart();
  }
  function shouldStartWatchStream(remoteStoreImpl) {
    return canUseNetwork(remoteStoreImpl) && !ensureWatchStream(remoteStoreImpl).isStarted() && remoteStoreImpl.listenTargets.size > 0;
  }
  function canUseNetwork(remoteStore) {
    var remoteStoreImpl = debugCast(remoteStore);
    return remoteStoreImpl.offlineCauses.size === 0;
  }
  function cleanUpWatchStreamState(remoteStoreImpl) {
    remoteStoreImpl.watchChangeAggregator = void 0;
  }
  function onWatchStreamOpen(remoteStoreImpl) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      return tslib.__generator(this, function(_d) {
        remoteStoreImpl.listenTargets.forEach(function(targetData, targetId) {
          sendWatchRequest(remoteStoreImpl, targetData);
        });
        return [2];
      });
    });
  }
  function onWatchStreamClose(remoteStoreImpl, error) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      return tslib.__generator(this, function(_d) {
        cleanUpWatchStreamState(remoteStoreImpl);
        if (shouldStartWatchStream(remoteStoreImpl)) {
          remoteStoreImpl.onlineStateTracker.handleWatchStreamFailure(error);
          startWatchStream(remoteStoreImpl);
        } else {
          remoteStoreImpl.onlineStateTracker.set("Unknown");
        }
        return [2];
      });
    });
  }
  function onWatchStreamChange(remoteStoreImpl, watchChange, snapshotVersion) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var e_4, lastRemoteSnapshotVersion, e_5;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            remoteStoreImpl.onlineStateTracker.set("Online");
            if (!(watchChange instanceof WatchTargetChange && watchChange.state === 2 && watchChange.cause))
              return [3, 6];
            _d.label = 1;
          case 1:
            _d.trys.push([1, 3, , 5]);
            return [4, handleTargetError(remoteStoreImpl, watchChange)];
          case 2:
            _d.sent();
            return [3, 5];
          case 3:
            e_4 = _d.sent();
            logDebug(LOG_TAG$b, "Failed to remove targets %s: %s ", watchChange.targetIds.join(","), e_4);
            return [4, disableNetworkUntilRecovery(remoteStoreImpl, e_4)];
          case 4:
            _d.sent();
            return [3, 5];
          case 5:
            return [2];
          case 6:
            if (watchChange instanceof DocumentWatchChange) {
              remoteStoreImpl.watchChangeAggregator.handleDocumentChange(watchChange);
            } else if (watchChange instanceof ExistenceFilterChange) {
              remoteStoreImpl.watchChangeAggregator.handleExistenceFilter(watchChange);
            } else {
              remoteStoreImpl.watchChangeAggregator.handleTargetChange(watchChange);
            }
            if (!!snapshotVersion.isEqual(SnapshotVersion.min()))
              return [3, 13];
            _d.label = 7;
          case 7:
            _d.trys.push([7, 11, , 13]);
            return [4, localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore)];
          case 8:
            lastRemoteSnapshotVersion = _d.sent();
            if (!(snapshotVersion.compareTo(lastRemoteSnapshotVersion) >= 0))
              return [3, 10];
            return [4, raiseWatchSnapshot(remoteStoreImpl, snapshotVersion)];
          case 9:
            _d.sent();
            _d.label = 10;
          case 10:
            return [3, 13];
          case 11:
            e_5 = _d.sent();
            logDebug(LOG_TAG$b, "Failed to raise snapshot:", e_5);
            return [4, disableNetworkUntilRecovery(remoteStoreImpl, e_5)];
          case 12:
            _d.sent();
            return [3, 13];
          case 13:
            return [2];
        }
      });
    });
  }
  function disableNetworkUntilRecovery(remoteStoreImpl, e, op) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var _this = this;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            if (!isIndexedDbTransactionError(e))
              return [3, 2];
            remoteStoreImpl.offlineCauses.add(1);
            return [4, disableNetworkInternal(remoteStoreImpl)];
          case 1:
            _d.sent();
            remoteStoreImpl.onlineStateTracker.set("Offline");
            if (!op) {
              op = function() {
                return localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);
              };
            }
            remoteStoreImpl.asyncQueue.enqueueRetryable(function() {
              return tslib.__awaiter(_this, void 0, void 0, function() {
                return tslib.__generator(this, function(_d2) {
                  switch (_d2.label) {
                    case 0:
                      logDebug(LOG_TAG$b, "Retrying IndexedDB access");
                      return [4, op()];
                    case 1:
                      _d2.sent();
                      remoteStoreImpl.offlineCauses.delete(1);
                      return [4, enableNetworkInternal(remoteStoreImpl)];
                    case 2:
                      _d2.sent();
                      return [2];
                  }
                });
              });
            });
            return [3, 3];
          case 2:
            throw e;
          case 3:
            return [2];
        }
      });
    });
  }
  function executeWithRecovery(remoteStoreImpl, op) {
    return op().catch(function(e) {
      return disableNetworkUntilRecovery(remoteStoreImpl, e, op);
    });
  }
  function raiseWatchSnapshot(remoteStoreImpl, snapshotVersion) {
    var remoteEvent = remoteStoreImpl.watchChangeAggregator.createRemoteEvent(snapshotVersion);
    remoteEvent.targetChanges.forEach(function(change, targetId) {
      if (change.resumeToken.approximateByteSize() > 0) {
        var targetData = remoteStoreImpl.listenTargets.get(targetId);
        if (targetData) {
          remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(change.resumeToken, snapshotVersion));
        }
      }
    });
    remoteEvent.targetMismatches.forEach(function(targetId) {
      var targetData = remoteStoreImpl.listenTargets.get(targetId);
      if (!targetData) {
        return;
      }
      remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(ByteString.EMPTY_BYTE_STRING, targetData.snapshotVersion));
      sendUnwatchRequest(remoteStoreImpl, targetId);
      var requestTargetData = new TargetData(targetData.target, targetId, 1, targetData.sequenceNumber);
      sendWatchRequest(remoteStoreImpl, requestTargetData);
    });
    return remoteStoreImpl.remoteSyncer.applyRemoteEvent(remoteEvent);
  }
  function handleTargetError(remoteStoreImpl, watchChange) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var error, _i, _d, targetId;
      return tslib.__generator(this, function(_e) {
        switch (_e.label) {
          case 0:
            error = watchChange.cause;
            _i = 0, _d = watchChange.targetIds;
            _e.label = 1;
          case 1:
            if (!(_i < _d.length))
              return [3, 4];
            targetId = _d[_i];
            if (!remoteStoreImpl.listenTargets.has(targetId))
              return [3, 3];
            return [4, remoteStoreImpl.remoteSyncer.rejectListen(targetId, error)];
          case 2:
            _e.sent();
            remoteStoreImpl.listenTargets.delete(targetId);
            remoteStoreImpl.watchChangeAggregator.removeTarget(targetId);
            _e.label = 3;
          case 3:
            _i++;
            return [3, 1];
          case 4:
            return [2];
        }
      });
    });
  }
  function fillWritePipeline(remoteStore) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var remoteStoreImpl, writeStream, lastBatchIdRetrieved, batch, e_6;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            remoteStoreImpl = debugCast(remoteStore);
            writeStream = ensureWriteStream(remoteStoreImpl);
            lastBatchIdRetrieved = remoteStoreImpl.writePipeline.length > 0 ? remoteStoreImpl.writePipeline[remoteStoreImpl.writePipeline.length - 1].batchId : BATCHID_UNKNOWN;
            _d.label = 1;
          case 1:
            if (!canAddToWritePipeline(remoteStoreImpl))
              return [3, 7];
            _d.label = 2;
          case 2:
            _d.trys.push([2, 4, , 6]);
            return [4, localStoreGetNextMutationBatch(remoteStoreImpl.localStore, lastBatchIdRetrieved)];
          case 3:
            batch = _d.sent();
            if (batch === null) {
              if (remoteStoreImpl.writePipeline.length === 0) {
                writeStream.markIdle();
              }
              return [3, 7];
            } else {
              lastBatchIdRetrieved = batch.batchId;
              addToWritePipeline(remoteStoreImpl, batch);
            }
            return [3, 6];
          case 4:
            e_6 = _d.sent();
            return [4, disableNetworkUntilRecovery(remoteStoreImpl, e_6)];
          case 5:
            _d.sent();
            return [3, 6];
          case 6:
            return [3, 1];
          case 7:
            if (shouldStartWriteStream(remoteStoreImpl)) {
              startWriteStream(remoteStoreImpl);
            }
            return [2];
        }
      });
    });
  }
  function canAddToWritePipeline(remoteStoreImpl) {
    return canUseNetwork(remoteStoreImpl) && remoteStoreImpl.writePipeline.length < MAX_PENDING_WRITES;
  }
  function addToWritePipeline(remoteStoreImpl, batch) {
    remoteStoreImpl.writePipeline.push(batch);
    var writeStream = ensureWriteStream(remoteStoreImpl);
    if (writeStream.isOpen() && writeStream.handshakeComplete) {
      writeStream.writeMutations(batch.mutations);
    }
  }
  function shouldStartWriteStream(remoteStoreImpl) {
    return canUseNetwork(remoteStoreImpl) && !ensureWriteStream(remoteStoreImpl).isStarted() && remoteStoreImpl.writePipeline.length > 0;
  }
  function startWriteStream(remoteStoreImpl) {
    ensureWriteStream(remoteStoreImpl).start();
  }
  function onWriteStreamOpen(remoteStoreImpl) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      return tslib.__generator(this, function(_d) {
        ensureWriteStream(remoteStoreImpl).writeHandshake();
        return [2];
      });
    });
  }
  function onWriteHandshakeComplete(remoteStoreImpl) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var writeStream, _i, _d, batch;
      return tslib.__generator(this, function(_e) {
        writeStream = ensureWriteStream(remoteStoreImpl);
        for (_i = 0, _d = remoteStoreImpl.writePipeline; _i < _d.length; _i++) {
          batch = _d[_i];
          writeStream.writeMutations(batch.mutations);
        }
        return [2];
      });
    });
  }
  function onMutationResult(remoteStoreImpl, commitVersion, results) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var batch, success;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            batch = remoteStoreImpl.writePipeline.shift();
            success = MutationBatchResult.from(batch, commitVersion, results);
            return [4, executeWithRecovery(remoteStoreImpl, function() {
              return remoteStoreImpl.remoteSyncer.applySuccessfulWrite(success);
            })];
          case 1:
            _d.sent();
            return [4, fillWritePipeline(remoteStoreImpl)];
          case 2:
            _d.sent();
            return [2];
        }
      });
    });
  }
  function onWriteStreamClose(remoteStoreImpl, error) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            if (!(error && ensureWriteStream(remoteStoreImpl).handshakeComplete))
              return [3, 2];
            return [4, handleWriteError(remoteStoreImpl, error)];
          case 1:
            _d.sent();
            _d.label = 2;
          case 2:
            if (shouldStartWriteStream(remoteStoreImpl)) {
              startWriteStream(remoteStoreImpl);
            }
            return [2];
        }
      });
    });
  }
  function handleWriteError(remoteStoreImpl, error) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var batch_1;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            if (!isPermanentWriteError(error.code))
              return [3, 3];
            batch_1 = remoteStoreImpl.writePipeline.shift();
            ensureWriteStream(remoteStoreImpl).inhibitBackoff();
            return [4, executeWithRecovery(remoteStoreImpl, function() {
              return remoteStoreImpl.remoteSyncer.rejectFailedWrite(batch_1.batchId, error);
            })];
          case 1:
            _d.sent();
            return [4, fillWritePipeline(remoteStoreImpl)];
          case 2:
            _d.sent();
            _d.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }
  function restartNetwork(remoteStore) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var remoteStoreImpl;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            remoteStoreImpl = debugCast(remoteStore);
            remoteStoreImpl.offlineCauses.add(4);
            return [4, disableNetworkInternal(remoteStoreImpl)];
          case 1:
            _d.sent();
            remoteStoreImpl.onlineStateTracker.set("Unknown");
            remoteStoreImpl.offlineCauses.delete(4);
            return [4, enableNetworkInternal(remoteStoreImpl)];
          case 2:
            _d.sent();
            return [2];
        }
      });
    });
  }
  function remoteStoreHandleCredentialChange(remoteStore, user) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var remoteStoreImpl, usesNetwork;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            remoteStoreImpl = debugCast(remoteStore);
            remoteStoreImpl.asyncQueue.verifyOperationInProgress();
            logDebug(LOG_TAG$b, "RemoteStore received new credentials");
            usesNetwork = canUseNetwork(remoteStoreImpl);
            remoteStoreImpl.offlineCauses.add(3);
            return [4, disableNetworkInternal(remoteStoreImpl)];
          case 1:
            _d.sent();
            if (usesNetwork) {
              remoteStoreImpl.onlineStateTracker.set("Unknown");
            }
            return [4, remoteStoreImpl.remoteSyncer.handleCredentialChange(user)];
          case 2:
            _d.sent();
            remoteStoreImpl.offlineCauses.delete(3);
            return [4, enableNetworkInternal(remoteStoreImpl)];
          case 3:
            _d.sent();
            return [2];
        }
      });
    });
  }
  function remoteStoreApplyPrimaryState(remoteStore, isPrimary) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var remoteStoreImpl;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            remoteStoreImpl = debugCast(remoteStore);
            if (!isPrimary)
              return [3, 2];
            remoteStoreImpl.offlineCauses.delete(2);
            return [4, enableNetworkInternal(remoteStoreImpl)];
          case 1:
            _d.sent();
            return [3, 4];
          case 2:
            if (!!isPrimary)
              return [3, 4];
            remoteStoreImpl.offlineCauses.add(2);
            return [4, disableNetworkInternal(remoteStoreImpl)];
          case 3:
            _d.sent();
            remoteStoreImpl.onlineStateTracker.set("Unknown");
            _d.label = 4;
          case 4:
            return [2];
        }
      });
    });
  }
  function ensureWatchStream(remoteStoreImpl) {
    var _this = this;
    if (!remoteStoreImpl.watchStream) {
      remoteStoreImpl.watchStream = newPersistentWatchStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {
        onOpen: onWatchStreamOpen.bind(null, remoteStoreImpl),
        onClose: onWatchStreamClose.bind(null, remoteStoreImpl),
        onWatchChange: onWatchStreamChange.bind(null, remoteStoreImpl)
      });
      remoteStoreImpl.onNetworkStatusChange.push(function(enabled) {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (!enabled)
                  return [3, 1];
                remoteStoreImpl.watchStream.inhibitBackoff();
                if (shouldStartWatchStream(remoteStoreImpl)) {
                  startWatchStream(remoteStoreImpl);
                } else {
                  remoteStoreImpl.onlineStateTracker.set("Unknown");
                }
                return [3, 3];
              case 1:
                return [4, remoteStoreImpl.watchStream.stop()];
              case 2:
                _d.sent();
                cleanUpWatchStreamState(remoteStoreImpl);
                _d.label = 3;
              case 3:
                return [2];
            }
          });
        });
      });
    }
    return remoteStoreImpl.watchStream;
  }
  function ensureWriteStream(remoteStoreImpl) {
    var _this = this;
    if (!remoteStoreImpl.writeStream) {
      remoteStoreImpl.writeStream = newPersistentWriteStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {
        onOpen: onWriteStreamOpen.bind(null, remoteStoreImpl),
        onClose: onWriteStreamClose.bind(null, remoteStoreImpl),
        onHandshakeComplete: onWriteHandshakeComplete.bind(null, remoteStoreImpl),
        onMutationResult: onMutationResult.bind(null, remoteStoreImpl)
      });
      remoteStoreImpl.onNetworkStatusChange.push(function(enabled) {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (!enabled)
                  return [3, 2];
                remoteStoreImpl.writeStream.inhibitBackoff();
                return [4, fillWritePipeline(remoteStoreImpl)];
              case 1:
                _d.sent();
                return [3, 4];
              case 2:
                return [4, remoteStoreImpl.writeStream.stop()];
              case 3:
                _d.sent();
                if (remoteStoreImpl.writePipeline.length > 0) {
                  logDebug(LOG_TAG$b, "Stopping write stream with " + remoteStoreImpl.writePipeline.length + " pending writes");
                  remoteStoreImpl.writePipeline = [];
                }
                _d.label = 4;
              case 4:
                return [2];
            }
          });
        });
      });
    }
    return remoteStoreImpl.writeStream;
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LOG_TAG$c = "AsyncQueue";
  var DelayedOperation = function() {
    function DelayedOperation2(asyncQueue, timerId, targetTimeMs, op, removalCallback) {
      this.asyncQueue = asyncQueue;
      this.timerId = timerId;
      this.targetTimeMs = targetTimeMs;
      this.op = op;
      this.removalCallback = removalCallback;
      this.deferred = new Deferred();
      this.then = this.deferred.promise.then.bind(this.deferred.promise);
      this.deferred.promise.catch(function(err) {
      });
    }
    DelayedOperation2.createAndSchedule = function(asyncQueue, timerId, delayMs, op, removalCallback) {
      var targetTime = Date.now() + delayMs;
      var delayedOp = new DelayedOperation2(asyncQueue, timerId, targetTime, op, removalCallback);
      delayedOp.start(delayMs);
      return delayedOp;
    };
    DelayedOperation2.prototype.start = function(delayMs) {
      var _this = this;
      this.timerHandle = setTimeout(function() {
        return _this.handleDelayElapsed();
      }, delayMs);
    };
    DelayedOperation2.prototype.skipDelay = function() {
      return this.handleDelayElapsed();
    };
    DelayedOperation2.prototype.cancel = function(reason) {
      if (this.timerHandle !== null) {
        this.clearTimeout();
        this.deferred.reject(new FirestoreError(Code.CANCELLED, "Operation cancelled" + (reason ? ": " + reason : "")));
      }
    };
    DelayedOperation2.prototype.handleDelayElapsed = function() {
      var _this = this;
      this.asyncQueue.enqueueAndForget(function() {
        if (_this.timerHandle !== null) {
          _this.clearTimeout();
          return _this.op().then(function(result) {
            return _this.deferred.resolve(result);
          });
        } else {
          return Promise.resolve();
        }
      });
    };
    DelayedOperation2.prototype.clearTimeout = function() {
      if (this.timerHandle !== null) {
        this.removalCallback(this);
        clearTimeout(this.timerHandle);
        this.timerHandle = null;
      }
    };
    return DelayedOperation2;
  }();
  function wrapInUserErrorIfRecoverable(e, msg) {
    logError(LOG_TAG$c, msg + ": " + e);
    if (isIndexedDbTransactionError(e)) {
      return new FirestoreError(Code.UNAVAILABLE, msg + ": " + e);
    } else {
      throw e;
    }
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var DocumentSet = function() {
    function DocumentSet2(comp) {
      if (comp) {
        this.comparator = function(d1, d2) {
          return comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);
        };
      } else {
        this.comparator = function(d1, d2) {
          return DocumentKey.comparator(d1.key, d2.key);
        };
      }
      this.keyedMap = documentMap();
      this.sortedSet = new SortedMap(this.comparator);
    }
    DocumentSet2.emptySet = function(oldSet) {
      return new DocumentSet2(oldSet.comparator);
    };
    DocumentSet2.prototype.has = function(key) {
      return this.keyedMap.get(key) != null;
    };
    DocumentSet2.prototype.get = function(key) {
      return this.keyedMap.get(key);
    };
    DocumentSet2.prototype.first = function() {
      return this.sortedSet.minKey();
    };
    DocumentSet2.prototype.last = function() {
      return this.sortedSet.maxKey();
    };
    DocumentSet2.prototype.isEmpty = function() {
      return this.sortedSet.isEmpty();
    };
    DocumentSet2.prototype.indexOf = function(key) {
      var doc2 = this.keyedMap.get(key);
      return doc2 ? this.sortedSet.indexOf(doc2) : -1;
    };
    Object.defineProperty(DocumentSet2.prototype, "size", {
      get: function() {
        return this.sortedSet.size;
      },
      enumerable: false,
      configurable: true
    });
    DocumentSet2.prototype.forEach = function(cb) {
      this.sortedSet.inorderTraversal(function(k, v) {
        cb(k);
        return false;
      });
    };
    DocumentSet2.prototype.add = function(doc2) {
      var set = this.delete(doc2.key);
      return set.copy(set.keyedMap.insert(doc2.key, doc2), set.sortedSet.insert(doc2, null));
    };
    DocumentSet2.prototype.delete = function(key) {
      var doc2 = this.get(key);
      if (!doc2) {
        return this;
      }
      return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc2));
    };
    DocumentSet2.prototype.isEqual = function(other) {
      if (!(other instanceof DocumentSet2)) {
        return false;
      }
      if (this.size !== other.size) {
        return false;
      }
      var thisIt = this.sortedSet.getIterator();
      var otherIt = other.sortedSet.getIterator();
      while (thisIt.hasNext()) {
        var thisDoc = thisIt.getNext().key;
        var otherDoc = otherIt.getNext().key;
        if (!thisDoc.isEqual(otherDoc)) {
          return false;
        }
      }
      return true;
    };
    DocumentSet2.prototype.toString = function() {
      var docStrings = [];
      this.forEach(function(doc2) {
        docStrings.push(doc2.toString());
      });
      if (docStrings.length === 0) {
        return "DocumentSet ()";
      } else {
        return "DocumentSet (\n  " + docStrings.join("  \n") + "\n)";
      }
    };
    DocumentSet2.prototype.copy = function(keyedMap, sortedSet) {
      var newSet = new DocumentSet2();
      newSet.comparator = this.comparator;
      newSet.keyedMap = keyedMap;
      newSet.sortedSet = sortedSet;
      return newSet;
    };
    return DocumentSet2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var DocumentChangeSet = function() {
    function DocumentChangeSet2() {
      this.changeMap = new SortedMap(DocumentKey.comparator);
    }
    DocumentChangeSet2.prototype.track = function(change) {
      var key = change.doc.key;
      var oldChange = this.changeMap.get(key);
      if (!oldChange) {
        this.changeMap = this.changeMap.insert(key, change);
        return;
      }
      if (change.type !== 0 && oldChange.type === 3) {
        this.changeMap = this.changeMap.insert(key, change);
      } else if (change.type === 3 && oldChange.type !== 1) {
        this.changeMap = this.changeMap.insert(key, {
          type: oldChange.type,
          doc: change.doc
        });
      } else if (change.type === 2 && oldChange.type === 2) {
        this.changeMap = this.changeMap.insert(key, {
          type: 2,
          doc: change.doc
        });
      } else if (change.type === 2 && oldChange.type === 0) {
        this.changeMap = this.changeMap.insert(key, {
          type: 0,
          doc: change.doc
        });
      } else if (change.type === 1 && oldChange.type === 0) {
        this.changeMap = this.changeMap.remove(key);
      } else if (change.type === 1 && oldChange.type === 2) {
        this.changeMap = this.changeMap.insert(key, {
          type: 1,
          doc: oldChange.doc
        });
      } else if (change.type === 0 && oldChange.type === 1) {
        this.changeMap = this.changeMap.insert(key, {
          type: 2,
          doc: change.doc
        });
      } else {
        fail();
      }
    };
    DocumentChangeSet2.prototype.getChanges = function() {
      var changes = [];
      this.changeMap.inorderTraversal(function(key, change) {
        changes.push(change);
      });
      return changes;
    };
    return DocumentChangeSet2;
  }();
  var ViewSnapshot = function() {
    function ViewSnapshot2(query2, docs, oldDocs, docChanges, mutatedKeys, fromCache, syncStateChanged, excludesMetadataChanges) {
      this.query = query2;
      this.docs = docs;
      this.oldDocs = oldDocs;
      this.docChanges = docChanges;
      this.mutatedKeys = mutatedKeys;
      this.fromCache = fromCache;
      this.syncStateChanged = syncStateChanged;
      this.excludesMetadataChanges = excludesMetadataChanges;
    }
    ViewSnapshot2.fromInitialDocuments = function(query2, documents, mutatedKeys, fromCache) {
      var changes = [];
      documents.forEach(function(doc2) {
        changes.push({type: 0, doc: doc2});
      });
      return new ViewSnapshot2(query2, documents, DocumentSet.emptySet(documents), changes, mutatedKeys, fromCache, true, false);
    };
    Object.defineProperty(ViewSnapshot2.prototype, "hasPendingWrites", {
      get: function() {
        return !this.mutatedKeys.isEmpty();
      },
      enumerable: false,
      configurable: true
    });
    ViewSnapshot2.prototype.isEqual = function(other) {
      if (this.fromCache !== other.fromCache || this.syncStateChanged !== other.syncStateChanged || !this.mutatedKeys.isEqual(other.mutatedKeys) || !queryEquals(this.query, other.query) || !this.docs.isEqual(other.docs) || !this.oldDocs.isEqual(other.oldDocs)) {
        return false;
      }
      var changes = this.docChanges;
      var otherChanges = other.docChanges;
      if (changes.length !== otherChanges.length) {
        return false;
      }
      for (var i = 0; i < changes.length; i++) {
        if (changes[i].type !== otherChanges[i].type || !changes[i].doc.isEqual(otherChanges[i].doc)) {
          return false;
        }
      }
      return true;
    };
    return ViewSnapshot2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var QueryListenersInfo = function() {
    function QueryListenersInfo2() {
      this.viewSnap = void 0;
      this.listeners = [];
    }
    return QueryListenersInfo2;
  }();
  function newEventManager() {
    return new EventManagerImpl();
  }
  var EventManagerImpl = function() {
    function EventManagerImpl2() {
      this.queries = new ObjectMap(function(q) {
        return canonifyQuery(q);
      }, queryEquals);
      this.onlineState = "Unknown";
      this.snapshotsInSyncListeners = new Set();
    }
    return EventManagerImpl2;
  }();
  function eventManagerListen(eventManager, listener) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var eventManagerImpl, query2, firstListen, queryInfo, _d, e_7, firestoreError, raisedEvent, raisedEvent_1;
      return tslib.__generator(this, function(_e) {
        switch (_e.label) {
          case 0:
            eventManagerImpl = debugCast(eventManager);
            query2 = listener.query;
            firstListen = false;
            queryInfo = eventManagerImpl.queries.get(query2);
            if (!queryInfo) {
              firstListen = true;
              queryInfo = new QueryListenersInfo();
            }
            if (!firstListen)
              return [3, 4];
            _e.label = 1;
          case 1:
            _e.trys.push([1, 3, , 4]);
            _d = queryInfo;
            return [4, eventManagerImpl.onListen(query2)];
          case 2:
            _d.viewSnap = _e.sent();
            return [3, 4];
          case 3:
            e_7 = _e.sent();
            firestoreError = wrapInUserErrorIfRecoverable(e_7, "Initialization of query '" + stringifyQuery(listener.query) + "' failed");
            listener.onError(firestoreError);
            return [2];
          case 4:
            eventManagerImpl.queries.set(query2, queryInfo);
            queryInfo.listeners.push(listener);
            raisedEvent = listener.applyOnlineStateChange(eventManagerImpl.onlineState);
            if (queryInfo.viewSnap) {
              raisedEvent_1 = listener.onViewSnapshot(queryInfo.viewSnap);
              if (raisedEvent_1) {
                raiseSnapshotsInSyncEvent(eventManagerImpl);
              }
            }
            return [2];
        }
      });
    });
  }
  function eventManagerUnlisten(eventManager, listener) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var eventManagerImpl, query2, lastListen, queryInfo, i;
      return tslib.__generator(this, function(_d) {
        eventManagerImpl = debugCast(eventManager);
        query2 = listener.query;
        lastListen = false;
        queryInfo = eventManagerImpl.queries.get(query2);
        if (queryInfo) {
          i = queryInfo.listeners.indexOf(listener);
          if (i >= 0) {
            queryInfo.listeners.splice(i, 1);
            lastListen = queryInfo.listeners.length === 0;
          }
        }
        if (lastListen) {
          eventManagerImpl.queries.delete(query2);
          return [2, eventManagerImpl.onUnlisten(query2)];
        }
        return [2];
      });
    });
  }
  function eventManagerOnWatchChange(eventManager, viewSnaps) {
    var eventManagerImpl = debugCast(eventManager);
    var raisedEvent = false;
    for (var _i = 0, viewSnaps_1 = viewSnaps; _i < viewSnaps_1.length; _i++) {
      var viewSnap = viewSnaps_1[_i];
      var query_1 = viewSnap.query;
      var queryInfo = eventManagerImpl.queries.get(query_1);
      if (queryInfo) {
        for (var _d = 0, _e = queryInfo.listeners; _d < _e.length; _d++) {
          var listener = _e[_d];
          if (listener.onViewSnapshot(viewSnap)) {
            raisedEvent = true;
          }
        }
        queryInfo.viewSnap = viewSnap;
      }
    }
    if (raisedEvent) {
      raiseSnapshotsInSyncEvent(eventManagerImpl);
    }
  }
  function eventManagerOnWatchError(eventManager, query2, error) {
    var eventManagerImpl = debugCast(eventManager);
    var queryInfo = eventManagerImpl.queries.get(query2);
    if (queryInfo) {
      for (var _i = 0, _d = queryInfo.listeners; _i < _d.length; _i++) {
        var listener = _d[_i];
        listener.onError(error);
      }
    }
    eventManagerImpl.queries.delete(query2);
  }
  function eventManagerOnOnlineStateChange(eventManager, onlineState) {
    var eventManagerImpl = debugCast(eventManager);
    eventManagerImpl.onlineState = onlineState;
    var raisedEvent = false;
    eventManagerImpl.queries.forEach(function(_, queryInfo) {
      for (var _i = 0, _d = queryInfo.listeners; _i < _d.length; _i++) {
        var listener = _d[_i];
        if (listener.applyOnlineStateChange(onlineState)) {
          raisedEvent = true;
        }
      }
    });
    if (raisedEvent) {
      raiseSnapshotsInSyncEvent(eventManagerImpl);
    }
  }
  function addSnapshotsInSyncListener(eventManager, observer) {
    var eventManagerImpl = debugCast(eventManager);
    eventManagerImpl.snapshotsInSyncListeners.add(observer);
    observer.next();
  }
  function removeSnapshotsInSyncListener(eventManager, observer) {
    var eventManagerImpl = debugCast(eventManager);
    eventManagerImpl.snapshotsInSyncListeners.delete(observer);
  }
  function raiseSnapshotsInSyncEvent(eventManagerImpl) {
    eventManagerImpl.snapshotsInSyncListeners.forEach(function(observer) {
      observer.next();
    });
  }
  var QueryListener = function() {
    function QueryListener2(query2, queryObserver, options) {
      this.query = query2;
      this.queryObserver = queryObserver;
      this.raisedInitialEvent = false;
      this.snap = null;
      this.onlineState = "Unknown";
      this.options = options || {};
    }
    QueryListener2.prototype.onViewSnapshot = function(snap) {
      if (!this.options.includeMetadataChanges) {
        var docChanges = [];
        for (var _i = 0, _d = snap.docChanges; _i < _d.length; _i++) {
          var docChange = _d[_i];
          if (docChange.type !== 3) {
            docChanges.push(docChange);
          }
        }
        snap = new ViewSnapshot(snap.query, snap.docs, snap.oldDocs, docChanges, snap.mutatedKeys, snap.fromCache, snap.syncStateChanged, true);
      }
      var raisedEvent = false;
      if (!this.raisedInitialEvent) {
        if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {
          this.raiseInitialEvent(snap);
          raisedEvent = true;
        }
      } else if (this.shouldRaiseEvent(snap)) {
        this.queryObserver.next(snap);
        raisedEvent = true;
      }
      this.snap = snap;
      return raisedEvent;
    };
    QueryListener2.prototype.onError = function(error) {
      this.queryObserver.error(error);
    };
    QueryListener2.prototype.applyOnlineStateChange = function(onlineState) {
      this.onlineState = onlineState;
      var raisedEvent = false;
      if (this.snap && !this.raisedInitialEvent && this.shouldRaiseInitialEvent(this.snap, onlineState)) {
        this.raiseInitialEvent(this.snap);
        raisedEvent = true;
      }
      return raisedEvent;
    };
    QueryListener2.prototype.shouldRaiseInitialEvent = function(snap, onlineState) {
      if (!snap.fromCache) {
        return true;
      }
      var maybeOnline = onlineState !== "Offline";
      if (this.options.waitForSyncWhenOnline && maybeOnline) {
        return false;
      }
      return !snap.docs.isEmpty() || onlineState === "Offline";
    };
    QueryListener2.prototype.shouldRaiseEvent = function(snap) {
      if (snap.docChanges.length > 0) {
        return true;
      }
      var hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;
      if (snap.syncStateChanged || hasPendingWritesChanged) {
        return this.options.includeMetadataChanges === true;
      }
      return false;
    };
    QueryListener2.prototype.raiseInitialEvent = function(snap) {
      snap = ViewSnapshot.fromInitialDocuments(snap.query, snap.docs, snap.mutatedKeys, snap.fromCache);
      this.raisedInitialEvent = true;
      this.queryObserver.next(snap);
    };
    return QueryListener2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LocalViewChanges = function() {
    function LocalViewChanges2(targetId, fromCache, addedKeys, removedKeys) {
      this.targetId = targetId;
      this.fromCache = fromCache;
      this.addedKeys = addedKeys;
      this.removedKeys = removedKeys;
    }
    LocalViewChanges2.fromSnapshot = function(targetId, viewSnapshot) {
      var addedKeys = documentKeySet();
      var removedKeys = documentKeySet();
      for (var _i = 0, _d = viewSnapshot.docChanges; _i < _d.length; _i++) {
        var docChange = _d[_i];
        switch (docChange.type) {
          case 0:
            addedKeys = addedKeys.add(docChange.doc.key);
            break;
          case 1:
            removedKeys = removedKeys.add(docChange.doc.key);
            break;
        }
      }
      return new LocalViewChanges2(targetId, viewSnapshot.fromCache, addedKeys, removedKeys);
    };
    return LocalViewChanges2;
  }();
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var BundleLoadResult = function() {
    function BundleLoadResult2(progress, changedDocs) {
      this.progress = progress;
      this.changedDocs = changedDocs;
    }
    return BundleLoadResult2;
  }();
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var BundleConverterImpl = function() {
    function BundleConverterImpl2(serializer) {
      this.serializer = serializer;
    }
    BundleConverterImpl2.prototype.toDocumentKey = function(name) {
      return fromName(this.serializer, name);
    };
    BundleConverterImpl2.prototype.toMutableDocument = function(bundledDoc) {
      if (bundledDoc.metadata.exists) {
        return fromDocument(this.serializer, bundledDoc.document, false);
      } else {
        return MutableDocument.newNoDocument(this.toDocumentKey(bundledDoc.metadata.name), this.toSnapshotVersion(bundledDoc.metadata.readTime));
      }
    };
    BundleConverterImpl2.prototype.toSnapshotVersion = function(time) {
      return fromVersion(time);
    };
    return BundleConverterImpl2;
  }();
  var BundleLoader = function() {
    function BundleLoader2(bundleMetadata, localStore, serializer) {
      this.bundleMetadata = bundleMetadata;
      this.localStore = localStore;
      this.serializer = serializer;
      this.queries = [];
      this.documents = [];
      this.progress = bundleInitialProgress(bundleMetadata);
    }
    BundleLoader2.prototype.addSizedElement = function(element) {
      this.progress.bytesLoaded += element.byteLength;
      var documentsLoaded = this.progress.documentsLoaded;
      if (element.payload.namedQuery) {
        this.queries.push(element.payload.namedQuery);
      } else if (element.payload.documentMetadata) {
        this.documents.push({metadata: element.payload.documentMetadata});
        if (!element.payload.documentMetadata.exists) {
          ++documentsLoaded;
        }
      } else if (element.payload.document) {
        this.documents[this.documents.length - 1].document = element.payload.document;
        ++documentsLoaded;
      }
      if (documentsLoaded !== this.progress.documentsLoaded) {
        this.progress.documentsLoaded = documentsLoaded;
        return Object.assign({}, this.progress);
      }
      return null;
    };
    BundleLoader2.prototype.getQueryDocumentMapping = function(documents) {
      var queryDocumentMap = new Map();
      var bundleConverter = new BundleConverterImpl(this.serializer);
      for (var _i = 0, documents_2 = documents; _i < documents_2.length; _i++) {
        var bundleDoc = documents_2[_i];
        if (bundleDoc.metadata.queries) {
          var documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);
          for (var _d = 0, _e = bundleDoc.metadata.queries; _d < _e.length; _d++) {
            var queryName = _e[_d];
            var documentKeys = (queryDocumentMap.get(queryName) || documentKeySet()).add(documentKey);
            queryDocumentMap.set(queryName, documentKeys);
          }
        }
      }
      return queryDocumentMap;
    };
    BundleLoader2.prototype.complete = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var changedDocuments, queryDocumentMap, _i, _d, q;
        return tslib.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              return [4, localStoreApplyBundledDocuments(this.localStore, new BundleConverterImpl(this.serializer), this.documents, this.bundleMetadata.id)];
            case 1:
              changedDocuments = _e.sent();
              queryDocumentMap = this.getQueryDocumentMapping(this.documents);
              _i = 0, _d = this.queries;
              _e.label = 2;
            case 2:
              if (!(_i < _d.length))
                return [3, 5];
              q = _d[_i];
              return [4, localStoreSaveNamedQuery(this.localStore, q, queryDocumentMap.get(q.name))];
            case 3:
              _e.sent();
              _e.label = 4;
            case 4:
              _i++;
              return [3, 2];
            case 5:
              this.progress.taskState = "Success";
              return [2, new BundleLoadResult(Object.assign({}, this.progress), changedDocuments)];
          }
        });
      });
    };
    return BundleLoader2;
  }();
  function bundleInitialProgress(metadata) {
    return {
      taskState: "Running",
      documentsLoaded: 0,
      bytesLoaded: 0,
      totalDocuments: metadata.totalDocuments,
      totalBytes: metadata.totalBytes
    };
  }
  function bundleSuccessProgress(metadata) {
    return {
      taskState: "Success",
      documentsLoaded: metadata.totalDocuments,
      bytesLoaded: metadata.totalBytes,
      totalDocuments: metadata.totalDocuments,
      totalBytes: metadata.totalBytes
    };
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var AddedLimboDocument = function() {
    function AddedLimboDocument2(key) {
      this.key = key;
    }
    return AddedLimboDocument2;
  }();
  var RemovedLimboDocument = function() {
    function RemovedLimboDocument2(key) {
      this.key = key;
    }
    return RemovedLimboDocument2;
  }();
  var View = function() {
    function View2(query2, _syncedDocuments) {
      this.query = query2;
      this._syncedDocuments = _syncedDocuments;
      this.syncState = null;
      this.current = false;
      this.limboDocuments = documentKeySet();
      this.mutatedKeys = documentKeySet();
      this.docComparator = newQueryComparator(query2);
      this.documentSet = new DocumentSet(this.docComparator);
    }
    Object.defineProperty(View2.prototype, "syncedDocuments", {
      get: function() {
        return this._syncedDocuments;
      },
      enumerable: false,
      configurable: true
    });
    View2.prototype.computeDocChanges = function(docChanges, previousChanges) {
      var _this = this;
      var changeSet = previousChanges ? previousChanges.changeSet : new DocumentChangeSet();
      var oldDocumentSet = previousChanges ? previousChanges.documentSet : this.documentSet;
      var newMutatedKeys = previousChanges ? previousChanges.mutatedKeys : this.mutatedKeys;
      var newDocumentSet = oldDocumentSet;
      var needsRefill = false;
      var lastDocInLimit = hasLimitToFirst(this.query) && oldDocumentSet.size === this.query.limit ? oldDocumentSet.last() : null;
      var firstDocInLimit = hasLimitToLast(this.query) && oldDocumentSet.size === this.query.limit ? oldDocumentSet.first() : null;
      docChanges.inorderTraversal(function(key, entry) {
        var oldDoc2 = oldDocumentSet.get(key);
        var newDoc = queryMatches(_this.query, entry) ? entry : null;
        var oldDocHadPendingMutations = oldDoc2 ? _this.mutatedKeys.has(oldDoc2.key) : false;
        var newDocHasPendingMutations = newDoc ? newDoc.hasLocalMutations || _this.mutatedKeys.has(newDoc.key) && newDoc.hasCommittedMutations : false;
        var changeApplied = false;
        if (oldDoc2 && newDoc) {
          var docsEqual = oldDoc2.data.isEqual(newDoc.data);
          if (!docsEqual) {
            if (!_this.shouldWaitForSyncedDocument(oldDoc2, newDoc)) {
              changeSet.track({
                type: 2,
                doc: newDoc
              });
              changeApplied = true;
              if (lastDocInLimit && _this.docComparator(newDoc, lastDocInLimit) > 0 || firstDocInLimit && _this.docComparator(newDoc, firstDocInLimit) < 0) {
                needsRefill = true;
              }
            }
          } else if (oldDocHadPendingMutations !== newDocHasPendingMutations) {
            changeSet.track({type: 3, doc: newDoc});
            changeApplied = true;
          }
        } else if (!oldDoc2 && newDoc) {
          changeSet.track({type: 0, doc: newDoc});
          changeApplied = true;
        } else if (oldDoc2 && !newDoc) {
          changeSet.track({type: 1, doc: oldDoc2});
          changeApplied = true;
          if (lastDocInLimit || firstDocInLimit) {
            needsRefill = true;
          }
        }
        if (changeApplied) {
          if (newDoc) {
            newDocumentSet = newDocumentSet.add(newDoc);
            if (newDocHasPendingMutations) {
              newMutatedKeys = newMutatedKeys.add(key);
            } else {
              newMutatedKeys = newMutatedKeys.delete(key);
            }
          } else {
            newDocumentSet = newDocumentSet.delete(key);
            newMutatedKeys = newMutatedKeys.delete(key);
          }
        }
      });
      if (hasLimitToFirst(this.query) || hasLimitToLast(this.query)) {
        while (newDocumentSet.size > this.query.limit) {
          var oldDoc = hasLimitToFirst(this.query) ? newDocumentSet.last() : newDocumentSet.first();
          newDocumentSet = newDocumentSet.delete(oldDoc.key);
          newMutatedKeys = newMutatedKeys.delete(oldDoc.key);
          changeSet.track({type: 1, doc: oldDoc});
        }
      }
      return {
        documentSet: newDocumentSet,
        changeSet,
        needsRefill,
        mutatedKeys: newMutatedKeys
      };
    };
    View2.prototype.shouldWaitForSyncedDocument = function(oldDoc, newDoc) {
      return oldDoc.hasLocalMutations && newDoc.hasCommittedMutations && !newDoc.hasLocalMutations;
    };
    View2.prototype.applyChanges = function(docChanges, updateLimboDocuments, targetChange) {
      var _this = this;
      var oldDocs = this.documentSet;
      this.documentSet = docChanges.documentSet;
      this.mutatedKeys = docChanges.mutatedKeys;
      var changes = docChanges.changeSet.getChanges();
      changes.sort(function(c1, c2) {
        return compareChangeType(c1.type, c2.type) || _this.docComparator(c1.doc, c2.doc);
      });
      this.applyTargetChange(targetChange);
      var limboChanges = updateLimboDocuments ? this.updateLimboDocuments() : [];
      var synced = this.limboDocuments.size === 0 && this.current;
      var newSyncState = synced ? 1 : 0;
      var syncStateChanged = newSyncState !== this.syncState;
      this.syncState = newSyncState;
      if (changes.length === 0 && !syncStateChanged) {
        return {limboChanges};
      } else {
        var snap = new ViewSnapshot(this.query, docChanges.documentSet, oldDocs, changes, docChanges.mutatedKeys, newSyncState === 0, syncStateChanged, false);
        return {
          snapshot: snap,
          limboChanges
        };
      }
    };
    View2.prototype.applyOnlineStateChange = function(onlineState) {
      if (this.current && onlineState === "Offline") {
        this.current = false;
        return this.applyChanges({
          documentSet: this.documentSet,
          changeSet: new DocumentChangeSet(),
          mutatedKeys: this.mutatedKeys,
          needsRefill: false
        }, false);
      } else {
        return {limboChanges: []};
      }
    };
    View2.prototype.shouldBeInLimbo = function(key) {
      if (this._syncedDocuments.has(key)) {
        return false;
      }
      if (!this.documentSet.has(key)) {
        return false;
      }
      if (this.documentSet.get(key).hasLocalMutations) {
        return false;
      }
      return true;
    };
    View2.prototype.applyTargetChange = function(targetChange) {
      var _this = this;
      if (targetChange) {
        targetChange.addedDocuments.forEach(function(key) {
          return _this._syncedDocuments = _this._syncedDocuments.add(key);
        });
        targetChange.modifiedDocuments.forEach(function(key) {
        });
        targetChange.removedDocuments.forEach(function(key) {
          return _this._syncedDocuments = _this._syncedDocuments.delete(key);
        });
        this.current = targetChange.current;
      }
    };
    View2.prototype.updateLimboDocuments = function() {
      var _this = this;
      if (!this.current) {
        return [];
      }
      var oldLimboDocuments = this.limboDocuments;
      this.limboDocuments = documentKeySet();
      this.documentSet.forEach(function(doc2) {
        if (_this.shouldBeInLimbo(doc2.key)) {
          _this.limboDocuments = _this.limboDocuments.add(doc2.key);
        }
      });
      var changes = [];
      oldLimboDocuments.forEach(function(key) {
        if (!_this.limboDocuments.has(key)) {
          changes.push(new RemovedLimboDocument(key));
        }
      });
      this.limboDocuments.forEach(function(key) {
        if (!oldLimboDocuments.has(key)) {
          changes.push(new AddedLimboDocument(key));
        }
      });
      return changes;
    };
    View2.prototype.synchronizeWithPersistedState = function(queryResult) {
      this._syncedDocuments = queryResult.remoteKeys;
      this.limboDocuments = documentKeySet();
      var docChanges = this.computeDocChanges(queryResult.documents);
      return this.applyChanges(docChanges, true);
    };
    View2.prototype.computeInitialSnapshot = function() {
      return ViewSnapshot.fromInitialDocuments(this.query, this.documentSet, this.mutatedKeys, this.syncState === 0);
    };
    return View2;
  }();
  function compareChangeType(c1, c2) {
    var order = function(change) {
      switch (change) {
        case 0:
          return 1;
        case 2:
          return 2;
        case 3:
          return 2;
        case 1:
          return 0;
        default:
          return fail();
      }
    };
    return order(c1) - order(c2);
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LOG_TAG$d = "SyncEngine";
  var QueryView = function() {
    function QueryView2(query2, targetId, view) {
      this.query = query2;
      this.targetId = targetId;
      this.view = view;
    }
    return QueryView2;
  }();
  var LimboResolution = function() {
    function LimboResolution2(key) {
      this.key = key;
      this.receivedDocument = false;
    }
    return LimboResolution2;
  }();
  var SyncEngineImpl = function() {
    function SyncEngineImpl2(localStore, remoteStore, eventManager, sharedClientState, currentUser, maxConcurrentLimboResolutions) {
      this.localStore = localStore;
      this.remoteStore = remoteStore;
      this.eventManager = eventManager;
      this.sharedClientState = sharedClientState;
      this.currentUser = currentUser;
      this.maxConcurrentLimboResolutions = maxConcurrentLimboResolutions;
      this.syncEngineListener = {};
      this.queryViewsByQuery = new ObjectMap(function(q) {
        return canonifyQuery(q);
      }, queryEquals);
      this.queriesByTarget = new Map();
      this.enqueuedLimboResolutions = new Set();
      this.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);
      this.activeLimboResolutionsByTarget = new Map();
      this.limboDocumentRefs = new ReferenceSet();
      this.mutationUserCallbacks = {};
      this.pendingWritesCallbacks = new Map();
      this.limboTargetIdGenerator = TargetIdGenerator.forSyncEngine();
      this.onlineState = "Unknown";
      this._isPrimaryClient = void 0;
    }
    Object.defineProperty(SyncEngineImpl2.prototype, "isPrimaryClient", {
      get: function() {
        return this._isPrimaryClient === true;
      },
      enumerable: false,
      configurable: true
    });
    return SyncEngineImpl2;
  }();
  function newSyncEngine(localStore, remoteStore, eventManager, sharedClientState, currentUser, maxConcurrentLimboResolutions, isPrimary) {
    var syncEngine = new SyncEngineImpl(localStore, remoteStore, eventManager, sharedClientState, currentUser, maxConcurrentLimboResolutions);
    if (isPrimary) {
      syncEngine._isPrimaryClient = true;
    }
    return syncEngine;
  }
  function syncEngineListen(syncEngine, query2) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl, targetId, viewSnapshot, queryView, targetData, status_1;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            syncEngineImpl = ensureWatchCallbacks(syncEngine);
            queryView = syncEngineImpl.queryViewsByQuery.get(query2);
            if (!queryView)
              return [3, 1];
            targetId = queryView.targetId;
            syncEngineImpl.sharedClientState.addLocalQueryTarget(targetId);
            viewSnapshot = queryView.view.computeInitialSnapshot();
            return [3, 4];
          case 1:
            return [4, localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(query2))];
          case 2:
            targetData = _d.sent();
            status_1 = syncEngineImpl.sharedClientState.addLocalQueryTarget(targetData.targetId);
            targetId = targetData.targetId;
            return [4, initializeViewAndComputeSnapshot(syncEngineImpl, query2, targetId, status_1 === "current")];
          case 3:
            viewSnapshot = _d.sent();
            if (syncEngineImpl.isPrimaryClient) {
              remoteStoreListen(syncEngineImpl.remoteStore, targetData);
            }
            _d.label = 4;
          case 4:
            return [2, viewSnapshot];
        }
      });
    });
  }
  function initializeViewAndComputeSnapshot(syncEngineImpl, query2, targetId, current) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var queryResult, view, viewDocChanges, synthesizedTargetChange, viewChange, data;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            syncEngineImpl.applyDocChanges = function(queryView, changes, remoteEvent) {
              return applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent);
            };
            return [4, localStoreExecuteQuery(syncEngineImpl.localStore, query2, true)];
          case 1:
            queryResult = _d.sent();
            view = new View(query2, queryResult.remoteKeys);
            viewDocChanges = view.computeDocChanges(queryResult.documents);
            synthesizedTargetChange = TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current && syncEngineImpl.onlineState !== "Offline");
            viewChange = view.applyChanges(viewDocChanges, syncEngineImpl.isPrimaryClient, synthesizedTargetChange);
            updateTrackedLimbos(syncEngineImpl, targetId, viewChange.limboChanges);
            data = new QueryView(query2, targetId, view);
            syncEngineImpl.queryViewsByQuery.set(query2, data);
            if (syncEngineImpl.queriesByTarget.has(targetId)) {
              syncEngineImpl.queriesByTarget.get(targetId).push(query2);
            } else {
              syncEngineImpl.queriesByTarget.set(targetId, [query2]);
            }
            return [2, viewChange.snapshot];
        }
      });
    });
  }
  function syncEngineUnlisten(syncEngine, query2) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl, queryView, queries, targetRemainsActive;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            syncEngineImpl = debugCast(syncEngine);
            queryView = syncEngineImpl.queryViewsByQuery.get(query2);
            queries = syncEngineImpl.queriesByTarget.get(queryView.targetId);
            if (queries.length > 1) {
              syncEngineImpl.queriesByTarget.set(queryView.targetId, queries.filter(function(q) {
                return !queryEquals(q, query2);
              }));
              syncEngineImpl.queryViewsByQuery.delete(query2);
              return [2];
            }
            if (!syncEngineImpl.isPrimaryClient)
              return [3, 3];
            syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);
            targetRemainsActive = syncEngineImpl.sharedClientState.isActiveQueryTarget(queryView.targetId);
            if (!!targetRemainsActive)
              return [3, 2];
            return [4, localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, false).then(function() {
              syncEngineImpl.sharedClientState.clearQueryState(queryView.targetId);
              remoteStoreUnlisten(syncEngineImpl.remoteStore, queryView.targetId);
              removeAndCleanupTarget(syncEngineImpl, queryView.targetId);
            }).catch(ignoreIfPrimaryLeaseLoss)];
          case 1:
            _d.sent();
            _d.label = 2;
          case 2:
            return [3, 5];
          case 3:
            removeAndCleanupTarget(syncEngineImpl, queryView.targetId);
            return [4, localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, true)];
          case 4:
            _d.sent();
            _d.label = 5;
          case 5:
            return [2];
        }
      });
    });
  }
  function syncEngineWrite(syncEngine, batch, userCallback) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl, result, e_8, error;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            syncEngineImpl = syncEngineEnsureWriteCallbacks(syncEngine);
            _d.label = 1;
          case 1:
            _d.trys.push([1, 5, , 6]);
            return [4, localStoreWriteLocally(syncEngineImpl.localStore, batch)];
          case 2:
            result = _d.sent();
            syncEngineImpl.sharedClientState.addPendingMutation(result.batchId);
            addMutationCallback(syncEngineImpl, result.batchId, userCallback);
            return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.changes)];
          case 3:
            _d.sent();
            return [4, fillWritePipeline(syncEngineImpl.remoteStore)];
          case 4:
            _d.sent();
            return [3, 6];
          case 5:
            e_8 = _d.sent();
            error = wrapInUserErrorIfRecoverable(e_8, "Failed to persist write");
            userCallback.reject(error);
            return [3, 6];
          case 6:
            return [2];
        }
      });
    });
  }
  function syncEngineApplyRemoteEvent(syncEngine, remoteEvent) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl, changes, error_2;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            syncEngineImpl = debugCast(syncEngine);
            _d.label = 1;
          case 1:
            _d.trys.push([1, 4, , 6]);
            return [4, localStoreApplyRemoteEventToLocalCache(syncEngineImpl.localStore, remoteEvent)];
          case 2:
            changes = _d.sent();
            remoteEvent.targetChanges.forEach(function(targetChange, targetId) {
              var limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);
              if (limboResolution) {
                hardAssert(targetChange.addedDocuments.size + targetChange.modifiedDocuments.size + targetChange.removedDocuments.size <= 1);
                if (targetChange.addedDocuments.size > 0) {
                  limboResolution.receivedDocument = true;
                } else if (targetChange.modifiedDocuments.size > 0) {
                  hardAssert(limboResolution.receivedDocument);
                } else if (targetChange.removedDocuments.size > 0) {
                  hardAssert(limboResolution.receivedDocument);
                  limboResolution.receivedDocument = false;
                } else
                  ;
              }
            });
            return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, remoteEvent)];
          case 3:
            _d.sent();
            return [3, 6];
          case 4:
            error_2 = _d.sent();
            return [4, ignoreIfPrimaryLeaseLoss(error_2)];
          case 5:
            _d.sent();
            return [3, 6];
          case 6:
            return [2];
        }
      });
    });
  }
  function syncEngineApplyOnlineStateChange(syncEngine, onlineState, source) {
    var syncEngineImpl = debugCast(syncEngine);
    if (syncEngineImpl.isPrimaryClient && source === 0 || !syncEngineImpl.isPrimaryClient && source === 1) {
      var newViewSnapshots_1 = [];
      syncEngineImpl.queryViewsByQuery.forEach(function(query2, queryView) {
        var viewChange = queryView.view.applyOnlineStateChange(onlineState);
        if (viewChange.snapshot) {
          newViewSnapshots_1.push(viewChange.snapshot);
        }
      });
      eventManagerOnOnlineStateChange(syncEngineImpl.eventManager, onlineState);
      if (newViewSnapshots_1.length) {
        syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots_1);
      }
      syncEngineImpl.onlineState = onlineState;
      if (syncEngineImpl.isPrimaryClient) {
        syncEngineImpl.sharedClientState.setOnlineState(onlineState);
      }
    }
  }
  function syncEngineRejectListen(syncEngine, targetId, err) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl, limboResolution, limboKey, documentUpdates, resolvedLimboDocuments, event_2;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            syncEngineImpl = debugCast(syncEngine);
            syncEngineImpl.sharedClientState.updateQueryState(targetId, "rejected", err);
            limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);
            limboKey = limboResolution && limboResolution.key;
            if (!limboKey)
              return [3, 2];
            documentUpdates = new SortedMap(DocumentKey.comparator);
            documentUpdates = documentUpdates.insert(limboKey, MutableDocument.newNoDocument(limboKey, SnapshotVersion.min()));
            resolvedLimboDocuments = documentKeySet().add(limboKey);
            event_2 = new RemoteEvent(SnapshotVersion.min(), new Map(), new SortedSet(primitiveComparator), documentUpdates, resolvedLimboDocuments);
            return [4, syncEngineApplyRemoteEvent(syncEngineImpl, event_2)];
          case 1:
            _d.sent();
            syncEngineImpl.activeLimboTargetsByKey = syncEngineImpl.activeLimboTargetsByKey.remove(limboKey);
            syncEngineImpl.activeLimboResolutionsByTarget.delete(targetId);
            pumpEnqueuedLimboResolutions(syncEngineImpl);
            return [3, 4];
          case 2:
            return [4, localStoreReleaseTarget(syncEngineImpl.localStore, targetId, false).then(function() {
              return removeAndCleanupTarget(syncEngineImpl, targetId, err);
            }).catch(ignoreIfPrimaryLeaseLoss)];
          case 3:
            _d.sent();
            _d.label = 4;
          case 4:
            return [2];
        }
      });
    });
  }
  function syncEngineApplySuccessfulWrite(syncEngine, mutationBatchResult) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl, batchId, changes, error_3;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            syncEngineImpl = debugCast(syncEngine);
            batchId = mutationBatchResult.batch.batchId;
            _d.label = 1;
          case 1:
            _d.trys.push([1, 4, , 6]);
            return [4, localStoreAcknowledgeBatch(syncEngineImpl.localStore, mutationBatchResult)];
          case 2:
            changes = _d.sent();
            processUserCallback(syncEngineImpl, batchId, null);
            triggerPendingWritesCallbacks(syncEngineImpl, batchId);
            syncEngineImpl.sharedClientState.updateMutationState(batchId, "acknowledged");
            return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes)];
          case 3:
            _d.sent();
            return [3, 6];
          case 4:
            error_3 = _d.sent();
            return [4, ignoreIfPrimaryLeaseLoss(error_3)];
          case 5:
            _d.sent();
            return [3, 6];
          case 6:
            return [2];
        }
      });
    });
  }
  function syncEngineRejectFailedWrite(syncEngine, batchId, error) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl, changes, error_4;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            syncEngineImpl = debugCast(syncEngine);
            _d.label = 1;
          case 1:
            _d.trys.push([1, 4, , 6]);
            return [4, localStoreRejectBatch(syncEngineImpl.localStore, batchId)];
          case 2:
            changes = _d.sent();
            processUserCallback(syncEngineImpl, batchId, error);
            triggerPendingWritesCallbacks(syncEngineImpl, batchId);
            syncEngineImpl.sharedClientState.updateMutationState(batchId, "rejected", error);
            return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes)];
          case 3:
            _d.sent();
            return [3, 6];
          case 4:
            error_4 = _d.sent();
            return [4, ignoreIfPrimaryLeaseLoss(error_4)];
          case 5:
            _d.sent();
            return [3, 6];
          case 6:
            return [2];
        }
      });
    });
  }
  function syncEngineRegisterPendingWritesCallback(syncEngine, callback) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl, highestBatchId, callbacks, e_9, firestoreError;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            syncEngineImpl = debugCast(syncEngine);
            if (!canUseNetwork(syncEngineImpl.remoteStore)) {
              logDebug(LOG_TAG$d, "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
            }
            _d.label = 1;
          case 1:
            _d.trys.push([1, 3, , 4]);
            return [4, localStoreGetHighestUnacknowledgedBatchId(syncEngineImpl.localStore)];
          case 2:
            highestBatchId = _d.sent();
            if (highestBatchId === BATCHID_UNKNOWN) {
              callback.resolve();
              return [2];
            }
            callbacks = syncEngineImpl.pendingWritesCallbacks.get(highestBatchId) || [];
            callbacks.push(callback);
            syncEngineImpl.pendingWritesCallbacks.set(highestBatchId, callbacks);
            return [3, 4];
          case 3:
            e_9 = _d.sent();
            firestoreError = wrapInUserErrorIfRecoverable(e_9, "Initialization of waitForPendingWrites() operation failed");
            callback.reject(firestoreError);
            return [3, 4];
          case 4:
            return [2];
        }
      });
    });
  }
  function triggerPendingWritesCallbacks(syncEngineImpl, batchId) {
    (syncEngineImpl.pendingWritesCallbacks.get(batchId) || []).forEach(function(callback) {
      callback.resolve();
    });
    syncEngineImpl.pendingWritesCallbacks.delete(batchId);
  }
  function rejectOutstandingPendingWritesCallbacks(syncEngineImpl, errorMessage) {
    syncEngineImpl.pendingWritesCallbacks.forEach(function(callbacks) {
      callbacks.forEach(function(callback) {
        callback.reject(new FirestoreError(Code.CANCELLED, errorMessage));
      });
    });
    syncEngineImpl.pendingWritesCallbacks.clear();
  }
  function addMutationCallback(syncEngineImpl, batchId, callback) {
    var newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];
    if (!newCallbacks) {
      newCallbacks = new SortedMap(primitiveComparator);
    }
    newCallbacks = newCallbacks.insert(batchId, callback);
    syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] = newCallbacks;
  }
  function processUserCallback(syncEngine, batchId, error) {
    var syncEngineImpl = debugCast(syncEngine);
    var newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];
    if (newCallbacks) {
      var callback = newCallbacks.get(batchId);
      if (callback) {
        if (error) {
          callback.reject(error);
        } else {
          callback.resolve();
        }
        newCallbacks = newCallbacks.remove(batchId);
      }
      syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] = newCallbacks;
    }
  }
  function removeAndCleanupTarget(syncEngineImpl, targetId, error) {
    if (error === void 0) {
      error = null;
    }
    syncEngineImpl.sharedClientState.removeLocalQueryTarget(targetId);
    for (var _i = 0, _d = syncEngineImpl.queriesByTarget.get(targetId); _i < _d.length; _i++) {
      var query_2 = _d[_i];
      syncEngineImpl.queryViewsByQuery.delete(query_2);
      if (error) {
        syncEngineImpl.syncEngineListener.onWatchError(query_2, error);
      }
    }
    syncEngineImpl.queriesByTarget.delete(targetId);
    if (syncEngineImpl.isPrimaryClient) {
      var limboKeys = syncEngineImpl.limboDocumentRefs.removeReferencesForId(targetId);
      limboKeys.forEach(function(limboKey) {
        var isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboKey);
        if (!isReferenced) {
          removeLimboTarget(syncEngineImpl, limboKey);
        }
      });
    }
  }
  function removeLimboTarget(syncEngineImpl, key) {
    syncEngineImpl.enqueuedLimboResolutions.delete(key.path.canonicalString());
    var limboTargetId = syncEngineImpl.activeLimboTargetsByKey.get(key);
    if (limboTargetId === null) {
      return;
    }
    remoteStoreUnlisten(syncEngineImpl.remoteStore, limboTargetId);
    syncEngineImpl.activeLimboTargetsByKey = syncEngineImpl.activeLimboTargetsByKey.remove(key);
    syncEngineImpl.activeLimboResolutionsByTarget.delete(limboTargetId);
    pumpEnqueuedLimboResolutions(syncEngineImpl);
  }
  function updateTrackedLimbos(syncEngineImpl, targetId, limboChanges) {
    for (var _i = 0, limboChanges_1 = limboChanges; _i < limboChanges_1.length; _i++) {
      var limboChange = limboChanges_1[_i];
      if (limboChange instanceof AddedLimboDocument) {
        syncEngineImpl.limboDocumentRefs.addReference(limboChange.key, targetId);
        trackLimboChange(syncEngineImpl, limboChange);
      } else if (limboChange instanceof RemovedLimboDocument) {
        logDebug(LOG_TAG$d, "Document no longer in limbo: " + limboChange.key);
        syncEngineImpl.limboDocumentRefs.removeReference(limboChange.key, targetId);
        var isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboChange.key);
        if (!isReferenced) {
          removeLimboTarget(syncEngineImpl, limboChange.key);
        }
      } else {
        fail();
      }
    }
  }
  function trackLimboChange(syncEngineImpl, limboChange) {
    var key = limboChange.key;
    var keyString = key.path.canonicalString();
    if (!syncEngineImpl.activeLimboTargetsByKey.get(key) && !syncEngineImpl.enqueuedLimboResolutions.has(keyString)) {
      logDebug(LOG_TAG$d, "New document in limbo: " + key);
      syncEngineImpl.enqueuedLimboResolutions.add(keyString);
      pumpEnqueuedLimboResolutions(syncEngineImpl);
    }
  }
  function pumpEnqueuedLimboResolutions(syncEngineImpl) {
    while (syncEngineImpl.enqueuedLimboResolutions.size > 0 && syncEngineImpl.activeLimboTargetsByKey.size < syncEngineImpl.maxConcurrentLimboResolutions) {
      var keyString = syncEngineImpl.enqueuedLimboResolutions.values().next().value;
      syncEngineImpl.enqueuedLimboResolutions.delete(keyString);
      var key = new DocumentKey(ResourcePath.fromString(keyString));
      var limboTargetId = syncEngineImpl.limboTargetIdGenerator.next();
      syncEngineImpl.activeLimboResolutionsByTarget.set(limboTargetId, new LimboResolution(key));
      syncEngineImpl.activeLimboTargetsByKey = syncEngineImpl.activeLimboTargetsByKey.insert(key, limboTargetId);
      remoteStoreListen(syncEngineImpl.remoteStore, new TargetData(queryToTarget(newQueryForPath(key.path)), limboTargetId, 2, ListenSequence.INVALID));
    }
  }
  function syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, changes, remoteEvent) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl, newSnaps, docChangesInAllViews, queriesProcessed;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            syncEngineImpl = debugCast(syncEngine);
            newSnaps = [];
            docChangesInAllViews = [];
            queriesProcessed = [];
            if (syncEngineImpl.queryViewsByQuery.isEmpty()) {
              return [2];
            }
            syncEngineImpl.queryViewsByQuery.forEach(function(_, queryView) {
              queriesProcessed.push(syncEngineImpl.applyDocChanges(queryView, changes, remoteEvent).then(function(viewSnapshot) {
                if (viewSnapshot) {
                  if (syncEngineImpl.isPrimaryClient) {
                    syncEngineImpl.sharedClientState.updateQueryState(queryView.targetId, viewSnapshot.fromCache ? "not-current" : "current");
                  }
                  newSnaps.push(viewSnapshot);
                  var docChanges = LocalViewChanges.fromSnapshot(queryView.targetId, viewSnapshot);
                  docChangesInAllViews.push(docChanges);
                }
              }));
            });
            return [4, Promise.all(queriesProcessed)];
          case 1:
            _d.sent();
            syncEngineImpl.syncEngineListener.onWatchChange(newSnaps);
            return [4, localStoreNotifyLocalViewChanges(syncEngineImpl.localStore, docChangesInAllViews)];
          case 2:
            _d.sent();
            return [2];
        }
      });
    });
  }
  function applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var viewDocChanges, targetChange, viewChange;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            viewDocChanges = queryView.view.computeDocChanges(changes);
            if (!viewDocChanges.needsRefill)
              return [3, 2];
            return [4, localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, false).then(function(_d2) {
              var documents = _d2.documents;
              return queryView.view.computeDocChanges(documents, viewDocChanges);
            })];
          case 1:
            viewDocChanges = _d.sent();
            _d.label = 2;
          case 2:
            targetChange = remoteEvent && remoteEvent.targetChanges.get(queryView.targetId);
            viewChange = queryView.view.applyChanges(viewDocChanges, syncEngineImpl.isPrimaryClient, targetChange);
            updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewChange.limboChanges);
            return [2, viewChange.snapshot];
        }
      });
    });
  }
  function syncEngineHandleCredentialChange(syncEngine, user) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl, userChanged, result;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            syncEngineImpl = debugCast(syncEngine);
            userChanged = !syncEngineImpl.currentUser.isEqual(user);
            if (!userChanged)
              return [3, 3];
            logDebug(LOG_TAG$d, "User change. New user:", user.toKey());
            return [4, localStoreHandleUserChange(syncEngineImpl.localStore, user)];
          case 1:
            result = _d.sent();
            syncEngineImpl.currentUser = user;
            rejectOutstandingPendingWritesCallbacks(syncEngineImpl, "'waitForPendingWrites' promise is rejected due to a user change.");
            syncEngineImpl.sharedClientState.handleUserChange(user, result.removedBatchIds, result.addedBatchIds);
            return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.affectedDocuments)];
          case 2:
            _d.sent();
            _d.label = 3;
          case 3:
            return [2];
        }
      });
    });
  }
  function syncEngineGetRemoteKeysForTarget(syncEngine, targetId) {
    var syncEngineImpl = debugCast(syncEngine);
    var limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);
    if (limboResolution && limboResolution.receivedDocument) {
      return documentKeySet().add(limboResolution.key);
    } else {
      var keySet = documentKeySet();
      var queries = syncEngineImpl.queriesByTarget.get(targetId);
      if (!queries) {
        return keySet;
      }
      for (var _i = 0, queries_1 = queries; _i < queries_1.length; _i++) {
        var query_3 = queries_1[_i];
        var queryView = syncEngineImpl.queryViewsByQuery.get(query_3);
        keySet = keySet.unionWith(queryView.view.syncedDocuments);
      }
      return keySet;
    }
  }
  function synchronizeViewAndComputeSnapshot(syncEngine, queryView) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl, queryResult, viewSnapshot;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            syncEngineImpl = debugCast(syncEngine);
            return [4, localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, true)];
          case 1:
            queryResult = _d.sent();
            viewSnapshot = queryView.view.synchronizeWithPersistedState(queryResult);
            if (syncEngineImpl.isPrimaryClient) {
              updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewSnapshot.limboChanges);
            }
            return [2, viewSnapshot];
        }
      });
    });
  }
  function syncEngineSynchronizeWithChangedDocuments(syncEngine) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl;
      return tslib.__generator(this, function(_d) {
        syncEngineImpl = debugCast(syncEngine);
        return [2, localStoreGetNewDocumentChanges(syncEngineImpl.localStore).then(function(changes) {
          return syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);
        })];
      });
    });
  }
  function syncEngineApplyBatchState(syncEngine, batchId, batchState, error) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl, documents;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            syncEngineImpl = debugCast(syncEngine);
            return [4, localStoreLookupMutationDocuments(syncEngineImpl.localStore, batchId)];
          case 1:
            documents = _d.sent();
            if (documents === null) {
              logDebug(LOG_TAG$d, "Cannot apply mutation batch with id: " + batchId);
              return [2];
            }
            if (!(batchState === "pending"))
              return [3, 3];
            return [4, fillWritePipeline(syncEngineImpl.remoteStore)];
          case 2:
            _d.sent();
            return [3, 4];
          case 3:
            if (batchState === "acknowledged" || batchState === "rejected") {
              processUserCallback(syncEngineImpl, batchId, error ? error : null);
              triggerPendingWritesCallbacks(syncEngineImpl, batchId);
              localStoreRemoveCachedMutationBatchMetadata(syncEngineImpl.localStore, batchId);
            } else {
              fail();
            }
            _d.label = 4;
          case 4:
            return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, documents)];
          case 5:
            _d.sent();
            return [2];
        }
      });
    });
  }
  function syncEngineApplyPrimaryState(syncEngine, isPrimary) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl, activeTargets, activeQueries, _i, activeQueries_1, targetData, activeTargets_1, p_1;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            syncEngineImpl = debugCast(syncEngine);
            ensureWatchCallbacks(syncEngineImpl);
            syncEngineEnsureWriteCallbacks(syncEngineImpl);
            if (!(isPrimary === true && syncEngineImpl._isPrimaryClient !== true))
              return [3, 3];
            activeTargets = syncEngineImpl.sharedClientState.getAllActiveQueryTargets();
            return [4, synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets.toArray())];
          case 1:
            activeQueries = _d.sent();
            syncEngineImpl._isPrimaryClient = true;
            return [4, remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, true)];
          case 2:
            _d.sent();
            for (_i = 0, activeQueries_1 = activeQueries; _i < activeQueries_1.length; _i++) {
              targetData = activeQueries_1[_i];
              remoteStoreListen(syncEngineImpl.remoteStore, targetData);
            }
            return [3, 7];
          case 3:
            if (!(isPrimary === false && syncEngineImpl._isPrimaryClient !== false))
              return [3, 7];
            activeTargets_1 = [];
            p_1 = Promise.resolve();
            syncEngineImpl.queriesByTarget.forEach(function(_, targetId) {
              if (syncEngineImpl.sharedClientState.isLocalQueryTarget(targetId)) {
                activeTargets_1.push(targetId);
              } else {
                p_1 = p_1.then(function() {
                  removeAndCleanupTarget(syncEngineImpl, targetId);
                  return localStoreReleaseTarget(syncEngineImpl.localStore, targetId, true);
                });
              }
              remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);
            });
            return [4, p_1];
          case 4:
            _d.sent();
            return [4, synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets_1)];
          case 5:
            _d.sent();
            resetLimboDocuments(syncEngineImpl);
            syncEngineImpl._isPrimaryClient = false;
            return [4, remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, false)];
          case 6:
            _d.sent();
            _d.label = 7;
          case 7:
            return [2];
        }
      });
    });
  }
  function resetLimboDocuments(syncEngine) {
    var syncEngineImpl = debugCast(syncEngine);
    syncEngineImpl.activeLimboResolutionsByTarget.forEach(function(_, targetId) {
      remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);
    });
    syncEngineImpl.limboDocumentRefs.removeAllReferences();
    syncEngineImpl.activeLimboResolutionsByTarget = new Map();
    syncEngineImpl.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);
  }
  function synchronizeQueryViewsAndRaiseSnapshots(syncEngine, targets, transitionToPrimary) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl, activeQueries, newViewSnapshots, _i, targets_1, targetId, targetData, queries, _d, queries_2, query_4, queryView, viewChange, target;
      return tslib.__generator(this, function(_e) {
        switch (_e.label) {
          case 0:
            syncEngineImpl = debugCast(syncEngine);
            activeQueries = [];
            newViewSnapshots = [];
            _i = 0, targets_1 = targets;
            _e.label = 1;
          case 1:
            if (!(_i < targets_1.length))
              return [3, 13];
            targetId = targets_1[_i];
            targetData = void 0;
            queries = syncEngineImpl.queriesByTarget.get(targetId);
            if (!(queries && queries.length !== 0))
              return [3, 7];
            return [4, localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(queries[0]))];
          case 2:
            targetData = _e.sent();
            _d = 0, queries_2 = queries;
            _e.label = 3;
          case 3:
            if (!(_d < queries_2.length))
              return [3, 6];
            query_4 = queries_2[_d];
            queryView = syncEngineImpl.queryViewsByQuery.get(query_4);
            return [4, synchronizeViewAndComputeSnapshot(syncEngineImpl, queryView)];
          case 4:
            viewChange = _e.sent();
            if (viewChange.snapshot) {
              newViewSnapshots.push(viewChange.snapshot);
            }
            _e.label = 5;
          case 5:
            _d++;
            return [3, 3];
          case 6:
            return [3, 11];
          case 7:
            return [4, localStoreGetCachedTarget(syncEngineImpl.localStore, targetId)];
          case 8:
            target = _e.sent();
            return [4, localStoreAllocateTarget(syncEngineImpl.localStore, target)];
          case 9:
            targetData = _e.sent();
            return [4, initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetId, false)];
          case 10:
            _e.sent();
            _e.label = 11;
          case 11:
            activeQueries.push(targetData);
            _e.label = 12;
          case 12:
            _i++;
            return [3, 1];
          case 13:
            syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);
            return [2, activeQueries];
        }
      });
    });
  }
  function synthesizeTargetToQuery(target) {
    return newQuery(target.path, target.collectionGroup, target.orderBy, target.filters, target.limit, "F", target.startAt, target.endAt);
  }
  function syncEngineGetActiveClients(syncEngine) {
    var syncEngineImpl = debugCast(syncEngine);
    return localStoreGetActiveClients(syncEngineImpl.localStore);
  }
  function syncEngineApplyTargetState(syncEngine, targetId, state, error) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl, _d, changes, synthesizedRemoteEvent;
      return tslib.__generator(this, function(_e) {
        switch (_e.label) {
          case 0:
            syncEngineImpl = debugCast(syncEngine);
            if (syncEngineImpl._isPrimaryClient) {
              logDebug(LOG_TAG$d, "Ignoring unexpected query state notification.");
              return [2];
            }
            if (!syncEngineImpl.queriesByTarget.has(targetId))
              return [3, 7];
            _d = state;
            switch (_d) {
              case "current":
                return [3, 1];
              case "not-current":
                return [3, 1];
              case "rejected":
                return [3, 4];
            }
            return [3, 6];
          case 1:
            return [4, localStoreGetNewDocumentChanges(syncEngineImpl.localStore)];
          case 2:
            changes = _e.sent();
            synthesizedRemoteEvent = RemoteEvent.createSynthesizedRemoteEventForCurrentChange(targetId, state === "current");
            return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, synthesizedRemoteEvent)];
          case 3:
            _e.sent();
            return [3, 7];
          case 4:
            return [4, localStoreReleaseTarget(syncEngineImpl.localStore, targetId, true)];
          case 5:
            _e.sent();
            removeAndCleanupTarget(syncEngineImpl, targetId, error);
            return [3, 7];
          case 6:
            fail();
            _e.label = 7;
          case 7:
            return [2];
        }
      });
    });
  }
  function syncEngineApplyActiveTargetsChange(syncEngine, added, removed) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var syncEngineImpl, _i, added_1, targetId, target, targetData, _loop_5, _d, removed_1, targetId;
      return tslib.__generator(this, function(_e) {
        switch (_e.label) {
          case 0:
            syncEngineImpl = ensureWatchCallbacks(syncEngine);
            if (!syncEngineImpl._isPrimaryClient) {
              return [2];
            }
            _i = 0, added_1 = added;
            _e.label = 1;
          case 1:
            if (!(_i < added_1.length))
              return [3, 6];
            targetId = added_1[_i];
            if (syncEngineImpl.queriesByTarget.has(targetId)) {
              logDebug(LOG_TAG$d, "Adding an already active target " + targetId);
              return [3, 5];
            }
            return [4, localStoreGetCachedTarget(syncEngineImpl.localStore, targetId)];
          case 2:
            target = _e.sent();
            return [4, localStoreAllocateTarget(syncEngineImpl.localStore, target)];
          case 3:
            targetData = _e.sent();
            return [4, initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetData.targetId, false)];
          case 4:
            _e.sent();
            remoteStoreListen(syncEngineImpl.remoteStore, targetData);
            _e.label = 5;
          case 5:
            _i++;
            return [3, 1];
          case 6:
            _loop_5 = function(targetId2) {
              return tslib.__generator(this, function(_f) {
                switch (_f.label) {
                  case 0:
                    if (!syncEngineImpl.queriesByTarget.has(targetId2)) {
                      return [2, "continue"];
                    }
                    return [4, localStoreReleaseTarget(syncEngineImpl.localStore, targetId2, false).then(function() {
                      remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId2);
                      removeAndCleanupTarget(syncEngineImpl, targetId2);
                    }).catch(ignoreIfPrimaryLeaseLoss)];
                  case 1:
                    _f.sent();
                    return [2];
                }
              });
            };
            _d = 0, removed_1 = removed;
            _e.label = 7;
          case 7:
            if (!(_d < removed_1.length))
              return [3, 10];
            targetId = removed_1[_d];
            return [5, _loop_5(targetId)];
          case 8:
            _e.sent();
            _e.label = 9;
          case 9:
            _d++;
            return [3, 7];
          case 10:
            return [2];
        }
      });
    });
  }
  function ensureWatchCallbacks(syncEngine) {
    var syncEngineImpl = debugCast(syncEngine);
    syncEngineImpl.remoteStore.remoteSyncer.applyRemoteEvent = syncEngineApplyRemoteEvent.bind(null, syncEngineImpl);
    syncEngineImpl.remoteStore.remoteSyncer.getRemoteKeysForTarget = syncEngineGetRemoteKeysForTarget.bind(null, syncEngineImpl);
    syncEngineImpl.remoteStore.remoteSyncer.rejectListen = syncEngineRejectListen.bind(null, syncEngineImpl);
    syncEngineImpl.syncEngineListener.onWatchChange = eventManagerOnWatchChange.bind(null, syncEngineImpl.eventManager);
    syncEngineImpl.syncEngineListener.onWatchError = eventManagerOnWatchError.bind(null, syncEngineImpl.eventManager);
    return syncEngineImpl;
  }
  function syncEngineEnsureWriteCallbacks(syncEngine) {
    var syncEngineImpl = debugCast(syncEngine);
    syncEngineImpl.remoteStore.remoteSyncer.applySuccessfulWrite = syncEngineApplySuccessfulWrite.bind(null, syncEngineImpl);
    syncEngineImpl.remoteStore.remoteSyncer.rejectFailedWrite = syncEngineRejectFailedWrite.bind(null, syncEngineImpl);
    return syncEngineImpl;
  }
  function syncEngineLoadBundle(syncEngine, bundleReader, task) {
    var syncEngineImpl = debugCast(syncEngine);
    loadBundleImpl(syncEngineImpl, bundleReader, task).then(function() {
      syncEngineImpl.sharedClientState.notifyBundleLoaded();
    });
  }
  function loadBundleImpl(syncEngine, reader, task) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var metadata, skip, loader, element, progress, result, e_10;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            _d.trys.push([0, 13, , 14]);
            return [4, reader.getMetadata()];
          case 1:
            metadata = _d.sent();
            return [4, localStoreHasNewerBundle(syncEngine.localStore, metadata)];
          case 2:
            skip = _d.sent();
            if (!skip)
              return [3, 4];
            return [4, reader.close()];
          case 3:
            _d.sent();
            task._completeWith(bundleSuccessProgress(metadata));
            return [2];
          case 4:
            task._updateProgress(bundleInitialProgress(metadata));
            loader = new BundleLoader(metadata, syncEngine.localStore, reader.serializer);
            return [4, reader.nextElement()];
          case 5:
            element = _d.sent();
            _d.label = 6;
          case 6:
            if (!element)
              return [3, 9];
            return [4, loader.addSizedElement(element)];
          case 7:
            progress = _d.sent();
            if (progress) {
              task._updateProgress(progress);
            }
            return [4, reader.nextElement()];
          case 8:
            element = _d.sent();
            return [3, 6];
          case 9:
            return [4, loader.complete()];
          case 10:
            result = _d.sent();
            return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, result.changedDocs, void 0)];
          case 11:
            _d.sent();
            return [4, localStoreSaveBundle(syncEngine.localStore, metadata)];
          case 12:
            _d.sent();
            task._completeWith(result.progress);
            return [3, 14];
          case 13:
            e_10 = _d.sent();
            logWarn(LOG_TAG$d, "Loading bundle failed with " + e_10);
            task._failWith(e_10);
            return [3, 14];
          case 14:
            return [2];
        }
      });
    });
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var MemoryOfflineComponentProvider = function() {
    function MemoryOfflineComponentProvider2() {
      this.synchronizeTabs = false;
    }
    MemoryOfflineComponentProvider2.prototype.initialize = function(cfg) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              this.serializer = newSerializer(cfg.databaseInfo.databaseId);
              this.sharedClientState = this.createSharedClientState(cfg);
              this.persistence = this.createPersistence(cfg);
              return [4, this.persistence.start()];
            case 1:
              _d.sent();
              this.gcScheduler = this.createGarbageCollectionScheduler(cfg);
              this.localStore = this.createLocalStore(cfg);
              return [2];
          }
        });
      });
    };
    MemoryOfflineComponentProvider2.prototype.createGarbageCollectionScheduler = function(cfg) {
      return null;
    };
    MemoryOfflineComponentProvider2.prototype.createLocalStore = function(cfg) {
      return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);
    };
    MemoryOfflineComponentProvider2.prototype.createPersistence = function(cfg) {
      return new MemoryPersistence(MemoryEagerDelegate.factory, this.serializer);
    };
    MemoryOfflineComponentProvider2.prototype.createSharedClientState = function(cfg) {
      return new MemorySharedClientState();
    };
    MemoryOfflineComponentProvider2.prototype.terminate = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (this.gcScheduler) {
                this.gcScheduler.stop();
              }
              return [4, this.sharedClientState.shutdown()];
            case 1:
              _d.sent();
              return [4, this.persistence.shutdown()];
            case 2:
              _d.sent();
              return [2];
          }
        });
      });
    };
    return MemoryOfflineComponentProvider2;
  }();
  var IndexedDbOfflineComponentProvider = function(_super) {
    tslib.__extends(IndexedDbOfflineComponentProvider2, _super);
    function IndexedDbOfflineComponentProvider2(onlineComponentProvider, cacheSizeBytes, forceOwnership) {
      var _this = _super.call(this) || this;
      _this.onlineComponentProvider = onlineComponentProvider;
      _this.cacheSizeBytes = cacheSizeBytes;
      _this.forceOwnership = forceOwnership;
      _this.synchronizeTabs = false;
      return _this;
    }
    IndexedDbOfflineComponentProvider2.prototype.initialize = function(cfg) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, _super.prototype.initialize.call(this, cfg)];
            case 1:
              _d.sent();
              return [4, localStoreSynchronizeLastDocumentChangeReadTime(this.localStore)];
            case 2:
              _d.sent();
              return [4, this.onlineComponentProvider.initialize(this, cfg)];
            case 3:
              _d.sent();
              return [4, syncEngineEnsureWriteCallbacks(this.onlineComponentProvider.syncEngine)];
            case 4:
              _d.sent();
              return [4, fillWritePipeline(this.onlineComponentProvider.remoteStore)];
            case 5:
              _d.sent();
              return [2];
          }
        });
      });
    };
    IndexedDbOfflineComponentProvider2.prototype.createLocalStore = function(cfg) {
      return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);
    };
    IndexedDbOfflineComponentProvider2.prototype.createGarbageCollectionScheduler = function(cfg) {
      var garbageCollector = this.persistence.referenceDelegate.garbageCollector;
      return new LruScheduler(garbageCollector, cfg.asyncQueue);
    };
    IndexedDbOfflineComponentProvider2.prototype.createPersistence = function(cfg) {
      var persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);
      var lruParams = this.cacheSizeBytes !== void 0 ? LruParams.withCacheSize(this.cacheSizeBytes) : LruParams.DEFAULT;
      return new IndexedDbPersistence(this.synchronizeTabs, persistenceKey, cfg.clientId, lruParams, cfg.asyncQueue, getWindow(), getDocument(), this.serializer, this.sharedClientState, !!this.forceOwnership);
    };
    IndexedDbOfflineComponentProvider2.prototype.createSharedClientState = function(cfg) {
      return new MemorySharedClientState();
    };
    return IndexedDbOfflineComponentProvider2;
  }(MemoryOfflineComponentProvider);
  var MultiTabOfflineComponentProvider = function(_super) {
    tslib.__extends(MultiTabOfflineComponentProvider2, _super);
    function MultiTabOfflineComponentProvider2(onlineComponentProvider, cacheSizeBytes) {
      var _this = _super.call(this, onlineComponentProvider, cacheSizeBytes, false) || this;
      _this.onlineComponentProvider = onlineComponentProvider;
      _this.cacheSizeBytes = cacheSizeBytes;
      _this.synchronizeTabs = true;
      return _this;
    }
    MultiTabOfflineComponentProvider2.prototype.initialize = function(cfg) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var syncEngine;
        var _this = this;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, _super.prototype.initialize.call(this, cfg)];
            case 1:
              _d.sent();
              syncEngine = this.onlineComponentProvider.syncEngine;
              if (!(this.sharedClientState instanceof WebStorageSharedClientState))
                return [3, 3];
              this.sharedClientState.syncEngine = {
                applyBatchState: syncEngineApplyBatchState.bind(null, syncEngine),
                applyTargetState: syncEngineApplyTargetState.bind(null, syncEngine),
                applyActiveTargetsChange: syncEngineApplyActiveTargetsChange.bind(null, syncEngine),
                getActiveClients: syncEngineGetActiveClients.bind(null, syncEngine),
                synchronizeWithChangedDocuments: syncEngineSynchronizeWithChangedDocuments.bind(null, syncEngine)
              };
              return [4, this.sharedClientState.start()];
            case 2:
              _d.sent();
              _d.label = 3;
            case 3:
              return [4, this.persistence.setPrimaryStateListener(function(isPrimary) {
                return tslib.__awaiter(_this, void 0, void 0, function() {
                  return tslib.__generator(this, function(_d2) {
                    switch (_d2.label) {
                      case 0:
                        return [4, syncEngineApplyPrimaryState(this.onlineComponentProvider.syncEngine, isPrimary)];
                      case 1:
                        _d2.sent();
                        if (this.gcScheduler) {
                          if (isPrimary && !this.gcScheduler.started) {
                            this.gcScheduler.start(this.localStore);
                          } else if (!isPrimary) {
                            this.gcScheduler.stop();
                          }
                        }
                        return [2];
                    }
                  });
                });
              })];
            case 4:
              _d.sent();
              return [2];
          }
        });
      });
    };
    MultiTabOfflineComponentProvider2.prototype.createSharedClientState = function(cfg) {
      var window2 = getWindow();
      if (!WebStorageSharedClientState.isAvailable(window2)) {
        throw new FirestoreError(Code.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
      }
      var persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);
      return new WebStorageSharedClientState(window2, cfg.asyncQueue, persistenceKey, cfg.clientId, cfg.initialUser);
    };
    return MultiTabOfflineComponentProvider2;
  }(IndexedDbOfflineComponentProvider);
  var OnlineComponentProvider = function() {
    function OnlineComponentProvider2() {
    }
    OnlineComponentProvider2.prototype.initialize = function(offlineComponentProvider, cfg) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var _this = this;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (this.localStore) {
                return [2];
              }
              this.localStore = offlineComponentProvider.localStore;
              this.sharedClientState = offlineComponentProvider.sharedClientState;
              this.datastore = this.createDatastore(cfg);
              this.remoteStore = this.createRemoteStore(cfg);
              this.eventManager = this.createEventManager(cfg);
              this.syncEngine = this.createSyncEngine(cfg, !offlineComponentProvider.synchronizeTabs);
              this.sharedClientState.onlineStateHandler = function(onlineState) {
                return syncEngineApplyOnlineStateChange(_this.syncEngine, onlineState, 1);
              };
              this.remoteStore.remoteSyncer.handleCredentialChange = syncEngineHandleCredentialChange.bind(null, this.syncEngine);
              return [4, remoteStoreApplyPrimaryState(this.remoteStore, this.syncEngine.isPrimaryClient)];
            case 1:
              _d.sent();
              return [2];
          }
        });
      });
    };
    OnlineComponentProvider2.prototype.createEventManager = function(cfg) {
      return newEventManager();
    };
    OnlineComponentProvider2.prototype.createDatastore = function(cfg) {
      var serializer = newSerializer(cfg.databaseInfo.databaseId);
      var connection = newConnection(cfg.databaseInfo);
      return newDatastore(cfg.credentials, connection, serializer);
    };
    OnlineComponentProvider2.prototype.createRemoteStore = function(cfg) {
      var _this = this;
      return newRemoteStore(this.localStore, this.datastore, cfg.asyncQueue, function(onlineState) {
        return syncEngineApplyOnlineStateChange(_this.syncEngine, onlineState, 0);
      }, newConnectivityMonitor());
    };
    OnlineComponentProvider2.prototype.createSyncEngine = function(cfg, startAsPrimary) {
      return newSyncEngine(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, cfg.initialUser, cfg.maxConcurrentLimboResolutions, startAsPrimary);
    };
    OnlineComponentProvider2.prototype.terminate = function() {
      return remoteStoreShutdown(this.remoteStore);
    };
    return OnlineComponentProvider2;
  }();
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var DEFAULT_BYTES_PER_READ = 10240;
  function toByteStreamReaderHelper(source, bytesPerRead) {
    if (bytesPerRead === void 0) {
      bytesPerRead = DEFAULT_BYTES_PER_READ;
    }
    var readFrom = 0;
    var reader = {
      read: function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          var result;
          return tslib.__generator(this, function(_d) {
            if (readFrom < source.byteLength) {
              result = {
                value: source.slice(readFrom, readFrom + bytesPerRead),
                done: false
              };
              readFrom += bytesPerRead;
              return [2, result];
            }
            return [2, {done: true}];
          });
        });
      },
      cancel: function() {
        return tslib.__awaiter(this, void 0, void 0, function() {
          return tslib.__generator(this, function(_d) {
            return [2];
          });
        });
      },
      releaseLock: function() {
      },
      closed: Promise.reject("unimplemented")
    };
    return reader;
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function validateNonEmptyArgument(functionName, argumentName, argument) {
    if (!argument) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() cannot be called with an empty " + argumentName + ".");
    }
  }
  function validateSetOptions(methodName, options) {
    if (options === void 0) {
      return {
        merge: false
      };
    }
    if (options.mergeFields !== void 0 && options.merge !== void 0) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid options passed to function " + methodName + '(): You cannot specify both "merge" and "mergeFields".');
    }
    return options;
  }
  function validateIsNotUsedTogether(optionName1, argument1, optionName2, argument2) {
    if (argument1 === true && argument2 === true) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, optionName1 + " and " + optionName2 + " cannot be used together.");
    }
  }
  function validateDocumentPath(path2) {
    if (!DocumentKey.isDocumentKey(path2)) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid document reference. Document references must have an even number of segments, but " + path2 + " has " + path2.length + ".");
    }
  }
  function validateCollectionPath(path2) {
    if (DocumentKey.isDocumentKey(path2)) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid collection reference. Collection references must have an odd number of segments, but " + path2 + " has " + path2.length + ".");
    }
  }
  function isPlainObject(input) {
    return typeof input === "object" && input !== null && (Object.getPrototypeOf(input) === Object.prototype || Object.getPrototypeOf(input) === null);
  }
  function valueDescription(input) {
    if (input === void 0) {
      return "undefined";
    } else if (input === null) {
      return "null";
    } else if (typeof input === "string") {
      if (input.length > 20) {
        input = input.substring(0, 20) + "...";
      }
      return JSON.stringify(input);
    } else if (typeof input === "number" || typeof input === "boolean") {
      return "" + input;
    } else if (typeof input === "object") {
      if (input instanceof Array) {
        return "an array";
      } else {
        var customObjectName = tryGetCustomObjectType(input);
        if (customObjectName) {
          return "a custom " + customObjectName + " object";
        } else {
          return "an object";
        }
      }
    } else if (typeof input === "function") {
      return "a function";
    } else {
      return fail();
    }
  }
  function tryGetCustomObjectType(input) {
    if (input.constructor) {
      var funcNameRegex = /function\s+([^\s(]+)\s*\(/;
      var results = funcNameRegex.exec(input.constructor.toString());
      if (results && results.length > 1) {
        return results[1];
      }
    }
    return null;
  }
  function cast(obj, constructor) {
    if ("_delegate" in obj) {
      obj = obj._delegate;
    }
    if (!(obj instanceof constructor)) {
      if (constructor.name === obj.constructor.name) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
      } else {
        var description = valueDescription(obj);
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Expected type '" + constructor.name + "', but it was: " + description);
      }
    }
    return obj;
  }
  function validatePositiveNumber(functionName, n) {
    if (n <= 0) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires a positive number, but it was: " + n + ".");
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function toByteStreamReader(source, bytesPerRead) {
    if (!(source instanceof Uint8Array)) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "NodePlatform.toByteStreamReader expects source to be Uint8Array, got " + valueDescription(source));
    }
    return toByteStreamReaderHelper(source, bytesPerRead);
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var AsyncObserver = function() {
    function AsyncObserver2(observer) {
      this.observer = observer;
      this.muted = false;
    }
    AsyncObserver2.prototype.next = function(value) {
      if (this.observer.next) {
        this.scheduleEvent(this.observer.next, value);
      }
    };
    AsyncObserver2.prototype.error = function(error) {
      if (this.observer.error) {
        this.scheduleEvent(this.observer.error, error);
      } else {
        console.error("Uncaught Error in snapshot listener:", error);
      }
    };
    AsyncObserver2.prototype.mute = function() {
      this.muted = true;
    };
    AsyncObserver2.prototype.scheduleEvent = function(eventHandler, event) {
      var _this = this;
      if (!this.muted) {
        setTimeout(function() {
          if (!_this.muted) {
            eventHandler(event);
          }
        }, 0);
      }
    };
    return AsyncObserver2;
  }();
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var SizedBundleElement = function() {
    function SizedBundleElement2(payload, byteLength) {
      this.payload = payload;
      this.byteLength = byteLength;
    }
    SizedBundleElement2.prototype.isBundleMetadata = function() {
      return "metadata" in this.payload;
    };
    return SizedBundleElement2;
  }();
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var BundleReaderImpl = function() {
    function BundleReaderImpl2(reader, serializer) {
      var _this = this;
      this.reader = reader;
      this.serializer = serializer;
      this.metadata = new Deferred();
      this.buffer = new Uint8Array();
      this.textDecoder = newTextDecoder();
      this.nextElementImpl().then(function(element) {
        if (element && element.isBundleMetadata()) {
          _this.metadata.resolve(element.payload.metadata);
        } else {
          _this.metadata.reject(new Error("The first element of the bundle is not a metadata, it is\n             " + JSON.stringify(element === null || element === void 0 ? void 0 : element.payload)));
        }
      }, function(error) {
        return _this.metadata.reject(error);
      });
    }
    BundleReaderImpl2.prototype.close = function() {
      return this.reader.cancel();
    };
    BundleReaderImpl2.prototype.getMetadata = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          return [2, this.metadata.promise];
        });
      });
    };
    BundleReaderImpl2.prototype.nextElement = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, this.getMetadata()];
            case 1:
              _d.sent();
              return [2, this.nextElementImpl()];
          }
        });
      });
    };
    BundleReaderImpl2.prototype.nextElementImpl = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var lengthBuffer, lengthString, length, jsonString;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, this.readLength()];
            case 1:
              lengthBuffer = _d.sent();
              if (lengthBuffer === null) {
                return [2, null];
              }
              lengthString = this.textDecoder.decode(lengthBuffer);
              length = Number(lengthString);
              if (isNaN(length)) {
                this.raiseError("length string (" + lengthString + ") is not valid number");
              }
              return [4, this.readJsonString(length)];
            case 2:
              jsonString = _d.sent();
              return [2, new SizedBundleElement(JSON.parse(jsonString), lengthBuffer.length + length)];
          }
        });
      });
    };
    BundleReaderImpl2.prototype.indexOfOpenBracket = function() {
      return this.buffer.findIndex(function(v) {
        return v === "{".charCodeAt(0);
      });
    };
    BundleReaderImpl2.prototype.readLength = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var done, position, result;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (!(this.indexOfOpenBracket() < 0))
                return [3, 2];
              return [4, this.pullMoreDataToBuffer()];
            case 1:
              done = _d.sent();
              if (done) {
                return [3, 2];
              }
              return [3, 0];
            case 2:
              if (this.buffer.length === 0) {
                return [2, null];
              }
              position = this.indexOfOpenBracket();
              if (position < 0) {
                this.raiseError("Reached the end of bundle when a length string is expected.");
              }
              result = this.buffer.slice(0, position);
              this.buffer = this.buffer.slice(position);
              return [2, result];
          }
        });
      });
    };
    BundleReaderImpl2.prototype.readJsonString = function(length) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var done, result;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (!(this.buffer.length < length))
                return [3, 2];
              return [4, this.pullMoreDataToBuffer()];
            case 1:
              done = _d.sent();
              if (done) {
                this.raiseError("Reached the end of bundle when more is expected.");
              }
              return [3, 0];
            case 2:
              result = this.textDecoder.decode(this.buffer.slice(0, length));
              this.buffer = this.buffer.slice(length);
              return [2, result];
          }
        });
      });
    };
    BundleReaderImpl2.prototype.raiseError = function(message) {
      this.reader.cancel();
      throw new Error("Invalid bundle format: " + message);
    };
    BundleReaderImpl2.prototype.pullMoreDataToBuffer = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var result, newBuffer;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, this.reader.read()];
            case 1:
              result = _d.sent();
              if (!result.done) {
                newBuffer = new Uint8Array(this.buffer.length + result.value.length);
                newBuffer.set(this.buffer);
                newBuffer.set(result.value, this.buffer.length);
                this.buffer = newBuffer;
              }
              return [2, result.done];
          }
        });
      });
    };
    return BundleReaderImpl2;
  }();
  function newBundleReader(reader, serializer) {
    return new BundleReaderImpl(reader, serializer);
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var Transaction = function() {
    function Transaction2(datastore) {
      this.datastore = datastore;
      this.readVersions = new Map();
      this.mutations = [];
      this.committed = false;
      this.lastWriteError = null;
      this.writtenDocs = new Set();
    }
    Transaction2.prototype.lookup = function(keys) {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var docs;
        var _this = this;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              this.ensureCommitNotCalled();
              if (this.mutations.length > 0) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
              }
              return [4, invokeBatchGetDocumentsRpc(this.datastore, keys)];
            case 1:
              docs = _d.sent();
              docs.forEach(function(doc2) {
                return _this.recordVersion(doc2);
              });
              return [2, docs];
          }
        });
      });
    };
    Transaction2.prototype.set = function(key, data) {
      this.write(data.toMutation(key, this.precondition(key)));
      this.writtenDocs.add(key.toString());
    };
    Transaction2.prototype.update = function(key, data) {
      try {
        this.write(data.toMutation(key, this.preconditionForUpdate(key)));
      } catch (e) {
        this.lastWriteError = e;
      }
      this.writtenDocs.add(key.toString());
    };
    Transaction2.prototype.delete = function(key) {
      this.write(new DeleteMutation(key, this.precondition(key)));
      this.writtenDocs.add(key.toString());
    };
    Transaction2.prototype.commit = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var unwritten;
        var _this = this;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              this.ensureCommitNotCalled();
              if (this.lastWriteError) {
                throw this.lastWriteError;
              }
              unwritten = this.readVersions;
              this.mutations.forEach(function(mutation) {
                unwritten.delete(mutation.key.toString());
              });
              unwritten.forEach(function(_, path2) {
                var key = DocumentKey.fromPath(path2);
                _this.mutations.push(new VerifyMutation(key, _this.precondition(key)));
              });
              return [4, invokeCommitRpc(this.datastore, this.mutations)];
            case 1:
              _d.sent();
              this.committed = true;
              return [2];
          }
        });
      });
    };
    Transaction2.prototype.recordVersion = function(doc2) {
      var docVersion;
      if (doc2.isFoundDocument()) {
        docVersion = doc2.version;
      } else if (doc2.isNoDocument()) {
        docVersion = SnapshotVersion.min();
      } else {
        throw fail();
      }
      var existingVersion = this.readVersions.get(doc2.key.toString());
      if (existingVersion) {
        if (!docVersion.isEqual(existingVersion)) {
          throw new FirestoreError(Code.ABORTED, "Document version changed between two reads.");
        }
      } else {
        this.readVersions.set(doc2.key.toString(), docVersion);
      }
    };
    Transaction2.prototype.precondition = function(key) {
      var version2 = this.readVersions.get(key.toString());
      if (!this.writtenDocs.has(key.toString()) && version2) {
        return Precondition.updateTime(version2);
      } else {
        return Precondition.none();
      }
    };
    Transaction2.prototype.preconditionForUpdate = function(key) {
      var version2 = this.readVersions.get(key.toString());
      if (!this.writtenDocs.has(key.toString()) && version2) {
        if (version2.isEqual(SnapshotVersion.min())) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
        }
        return Precondition.updateTime(version2);
      } else {
        return Precondition.exists(true);
      }
    };
    Transaction2.prototype.write = function(mutation) {
      this.ensureCommitNotCalled();
      this.mutations.push(mutation);
    };
    Transaction2.prototype.ensureCommitNotCalled = function() {
    };
    return Transaction2;
  }();
  /**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var RETRY_COUNT = 5;
  var TransactionRunner = function() {
    function TransactionRunner2(asyncQueue, datastore, updateFunction, deferred) {
      this.asyncQueue = asyncQueue;
      this.datastore = datastore;
      this.updateFunction = updateFunction;
      this.deferred = deferred;
      this.retries = RETRY_COUNT;
      this.backoff = new ExponentialBackoff(this.asyncQueue, "transaction_retry");
    }
    TransactionRunner2.prototype.run = function() {
      this.runWithBackOff();
    };
    TransactionRunner2.prototype.runWithBackOff = function() {
      var _this = this;
      this.backoff.backoffAndRun(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var transaction, userPromise;
          var _this2 = this;
          return tslib.__generator(this, function(_d) {
            transaction = new Transaction(this.datastore);
            userPromise = this.tryRunUpdateFunction(transaction);
            if (userPromise) {
              userPromise.then(function(result) {
                _this2.asyncQueue.enqueueAndForget(function() {
                  return transaction.commit().then(function() {
                    _this2.deferred.resolve(result);
                  }).catch(function(commitError) {
                    _this2.handleTransactionError(commitError);
                  });
                });
              }).catch(function(userPromiseError) {
                _this2.handleTransactionError(userPromiseError);
              });
            }
            return [2];
          });
        });
      });
    };
    TransactionRunner2.prototype.tryRunUpdateFunction = function(transaction) {
      try {
        var userPromise = this.updateFunction(transaction);
        if (isNullOrUndefined(userPromise) || !userPromise.catch || !userPromise.then) {
          this.deferred.reject(Error("Transaction callback must return a Promise"));
          return null;
        }
        return userPromise;
      } catch (error) {
        this.deferred.reject(error);
        return null;
      }
    };
    TransactionRunner2.prototype.handleTransactionError = function(error) {
      var _this = this;
      if (this.retries > 0 && this.isRetryableTransactionError(error)) {
        this.retries -= 1;
        this.asyncQueue.enqueueAndForget(function() {
          _this.runWithBackOff();
          return Promise.resolve();
        });
      } else {
        this.deferred.reject(error);
      }
    };
    TransactionRunner2.prototype.isRetryableTransactionError = function(error) {
      if (error.name === "FirebaseError") {
        var code = error.code;
        return code === "aborted" || code === "failed-precondition" || !isPermanentError(code);
      }
      return false;
    };
    return TransactionRunner2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LOG_TAG$e = "FirestoreClient";
  var MAX_CONCURRENT_LIMBO_RESOLUTIONS = 100;
  var FirestoreClient = function() {
    function FirestoreClient2(credentials, asyncQueue, databaseInfo) {
      var _this = this;
      this.credentials = credentials;
      this.asyncQueue = asyncQueue;
      this.databaseInfo = databaseInfo;
      this.user = User.UNAUTHENTICATED;
      this.clientId = AutoId.newId();
      this.credentialListener = function() {
      };
      this.receivedInitialUser = new Deferred();
      this.credentials.setChangeListener(function(user) {
        logDebug(LOG_TAG$e, "Received user=", user.uid);
        _this.user = user;
        _this.credentialListener(user);
        _this.receivedInitialUser.resolve();
      });
    }
    FirestoreClient2.prototype.getConfiguration = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, this.receivedInitialUser.promise];
            case 1:
              _d.sent();
              return [2, {
                asyncQueue: this.asyncQueue,
                databaseInfo: this.databaseInfo,
                clientId: this.clientId,
                credentials: this.credentials,
                initialUser: this.user,
                maxConcurrentLimboResolutions: MAX_CONCURRENT_LIMBO_RESOLUTIONS
              }];
          }
        });
      });
    };
    FirestoreClient2.prototype.setCredentialChangeListener = function(listener) {
      var _this = this;
      this.credentialListener = listener;
      this.receivedInitialUser.promise.then(function() {
        return _this.credentialListener(_this.user);
      });
    };
    FirestoreClient2.prototype.verifyNotTerminated = function() {
      if (this.asyncQueue.isShuttingDown) {
        throw new FirestoreError(Code.FAILED_PRECONDITION, "The client has already been terminated.");
      }
    };
    FirestoreClient2.prototype.terminate = function() {
      var _this = this;
      this.asyncQueue.enterRestrictedMode();
      var deferred = new Deferred();
      this.asyncQueue.enqueueAndForgetEvenWhileRestricted(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var e_11, firestoreError;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                _d.trys.push([0, 5, , 6]);
                if (!this.onlineComponents)
                  return [3, 2];
                return [4, this.onlineComponents.terminate()];
              case 1:
                _d.sent();
                _d.label = 2;
              case 2:
                if (!this.offlineComponents)
                  return [3, 4];
                return [4, this.offlineComponents.terminate()];
              case 3:
                _d.sent();
                _d.label = 4;
              case 4:
                this.credentials.removeChangeListener();
                deferred.resolve();
                return [3, 6];
              case 5:
                e_11 = _d.sent();
                firestoreError = wrapInUserErrorIfRecoverable(e_11, "Failed to shutdown persistence");
                deferred.reject(firestoreError);
                return [3, 6];
              case 6:
                return [2];
            }
          });
        });
      });
      return deferred.promise;
    };
    return FirestoreClient2;
  }();
  function setOfflineComponentProvider(client, offlineComponentProvider) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var configuration, currentUser;
      var _this = this;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            client.asyncQueue.verifyOperationInProgress();
            logDebug(LOG_TAG$e, "Initializing OfflineComponentProvider");
            return [4, client.getConfiguration()];
          case 1:
            configuration = _d.sent();
            return [4, offlineComponentProvider.initialize(configuration)];
          case 2:
            _d.sent();
            currentUser = configuration.initialUser;
            client.setCredentialChangeListener(function(user) {
              if (!currentUser.isEqual(user)) {
                currentUser = user;
                client.asyncQueue.enqueueRetryable(function() {
                  return tslib.__awaiter(_this, void 0, void 0, function() {
                    return tslib.__generator(this, function(_d2) {
                      switch (_d2.label) {
                        case 0:
                          return [4, localStoreHandleUserChange(offlineComponentProvider.localStore, user)];
                        case 1:
                          _d2.sent();
                          return [2];
                      }
                    });
                  });
                });
              }
            });
            offlineComponentProvider.persistence.setDatabaseDeletedListener(function() {
              return client.terminate();
            });
            client.offlineComponents = offlineComponentProvider;
            return [2];
        }
      });
    });
  }
  function setOnlineComponentProvider(client, onlineComponentProvider) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var offlineComponentProvider, configuration;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            client.asyncQueue.verifyOperationInProgress();
            return [4, ensureOfflineComponents(client)];
          case 1:
            offlineComponentProvider = _d.sent();
            logDebug(LOG_TAG$e, "Initializing OnlineComponentProvider");
            return [4, client.getConfiguration()];
          case 2:
            configuration = _d.sent();
            return [4, onlineComponentProvider.initialize(offlineComponentProvider, configuration)];
          case 3:
            _d.sent();
            client.setCredentialChangeListener(function(user) {
              return client.asyncQueue.enqueueRetryable(function() {
                return remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user);
              });
            });
            client.onlineComponents = onlineComponentProvider;
            return [2];
        }
      });
    });
  }
  function ensureOfflineComponents(client) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            if (!!client.offlineComponents)
              return [3, 2];
            logDebug(LOG_TAG$e, "Using default OfflineComponentProvider");
            return [4, setOfflineComponentProvider(client, new MemoryOfflineComponentProvider())];
          case 1:
            _d.sent();
            _d.label = 2;
          case 2:
            return [2, client.offlineComponents];
        }
      });
    });
  }
  function ensureOnlineComponents(client) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            if (!!client.onlineComponents)
              return [3, 2];
            logDebug(LOG_TAG$e, "Using default OnlineComponentProvider");
            return [4, setOnlineComponentProvider(client, new OnlineComponentProvider())];
          case 1:
            _d.sent();
            _d.label = 2;
          case 2:
            return [2, client.onlineComponents];
        }
      });
    });
  }
  function getPersistence(client) {
    return ensureOfflineComponents(client).then(function(c) {
      return c.persistence;
    });
  }
  function getLocalStore(client) {
    return ensureOfflineComponents(client).then(function(c) {
      return c.localStore;
    });
  }
  function getRemoteStore(client) {
    return ensureOnlineComponents(client).then(function(c) {
      return c.remoteStore;
    });
  }
  function getSyncEngine(client) {
    return ensureOnlineComponents(client).then(function(c) {
      return c.syncEngine;
    });
  }
  function getDatastore(client) {
    return ensureOnlineComponents(client).then(function(c) {
      return c.datastore;
    });
  }
  function getEventManager(client) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var onlineComponentProvider, eventManager;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            return [4, ensureOnlineComponents(client)];
          case 1:
            onlineComponentProvider = _d.sent();
            eventManager = onlineComponentProvider.eventManager;
            eventManager.onListen = syncEngineListen.bind(null, onlineComponentProvider.syncEngine);
            eventManager.onUnlisten = syncEngineUnlisten.bind(null, onlineComponentProvider.syncEngine);
            return [2, eventManager];
        }
      });
    });
  }
  function firestoreClientEnableNetwork(client) {
    var _this = this;
    return client.asyncQueue.enqueue(function() {
      return tslib.__awaiter(_this, void 0, void 0, function() {
        var persistence, remoteStore;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, getPersistence(client)];
            case 1:
              persistence = _d.sent();
              return [4, getRemoteStore(client)];
            case 2:
              remoteStore = _d.sent();
              persistence.setNetworkEnabled(true);
              return [2, remoteStoreEnableNetwork(remoteStore)];
          }
        });
      });
    });
  }
  function firestoreClientDisableNetwork(client) {
    var _this = this;
    return client.asyncQueue.enqueue(function() {
      return tslib.__awaiter(_this, void 0, void 0, function() {
        var persistence, remoteStore;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, getPersistence(client)];
            case 1:
              persistence = _d.sent();
              return [4, getRemoteStore(client)];
            case 2:
              remoteStore = _d.sent();
              persistence.setNetworkEnabled(false);
              return [2, remoteStoreDisableNetwork(remoteStore)];
          }
        });
      });
    });
  }
  function firestoreClientWaitForPendingWrites(client) {
    var _this = this;
    var deferred = new Deferred();
    client.asyncQueue.enqueueAndForget(function() {
      return tslib.__awaiter(_this, void 0, void 0, function() {
        var syncEngine;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, getSyncEngine(client)];
            case 1:
              syncEngine = _d.sent();
              return [2, syncEngineRegisterPendingWritesCallback(syncEngine, deferred)];
          }
        });
      });
    });
    return deferred.promise;
  }
  function firestoreClientListen(client, query2, options, observer) {
    var _this = this;
    var wrappedObserver = new AsyncObserver(observer);
    var listener = new QueryListener(query2, wrappedObserver, options);
    client.asyncQueue.enqueueAndForget(function() {
      return tslib.__awaiter(_this, void 0, void 0, function() {
        var eventManager;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, getEventManager(client)];
            case 1:
              eventManager = _d.sent();
              return [2, eventManagerListen(eventManager, listener)];
          }
        });
      });
    });
    return function() {
      wrappedObserver.mute();
      client.asyncQueue.enqueueAndForget(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var eventManager;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getEventManager(client)];
              case 1:
                eventManager = _d.sent();
                return [2, eventManagerUnlisten(eventManager, listener)];
            }
          });
        });
      });
    };
  }
  function firestoreClientGetDocumentFromLocalCache(client, docKey) {
    var _this = this;
    var deferred = new Deferred();
    client.asyncQueue.enqueueAndForget(function() {
      return tslib.__awaiter(_this, void 0, void 0, function() {
        var localStore;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, getLocalStore(client)];
            case 1:
              localStore = _d.sent();
              return [2, readDocumentFromCache(localStore, docKey, deferred)];
          }
        });
      });
    });
    return deferred.promise;
  }
  function firestoreClientGetDocumentViaSnapshotListener(client, key, options) {
    var _this = this;
    if (options === void 0) {
      options = {};
    }
    var deferred = new Deferred();
    client.asyncQueue.enqueueAndForget(function() {
      return tslib.__awaiter(_this, void 0, void 0, function() {
        var eventManager;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, getEventManager(client)];
            case 1:
              eventManager = _d.sent();
              return [2, readDocumentViaSnapshotListener(eventManager, client.asyncQueue, key, options, deferred)];
          }
        });
      });
    });
    return deferred.promise;
  }
  function firestoreClientGetDocumentsFromLocalCache(client, query2) {
    var _this = this;
    var deferred = new Deferred();
    client.asyncQueue.enqueueAndForget(function() {
      return tslib.__awaiter(_this, void 0, void 0, function() {
        var localStore;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, getLocalStore(client)];
            case 1:
              localStore = _d.sent();
              return [2, executeQueryFromCache(localStore, query2, deferred)];
          }
        });
      });
    });
    return deferred.promise;
  }
  function firestoreClientGetDocumentsViaSnapshotListener(client, query2, options) {
    var _this = this;
    if (options === void 0) {
      options = {};
    }
    var deferred = new Deferred();
    client.asyncQueue.enqueueAndForget(function() {
      return tslib.__awaiter(_this, void 0, void 0, function() {
        var eventManager;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, getEventManager(client)];
            case 1:
              eventManager = _d.sent();
              return [2, executeQueryViaSnapshotListener(eventManager, client.asyncQueue, query2, options, deferred)];
          }
        });
      });
    });
    return deferred.promise;
  }
  function firestoreClientWrite(client, mutations) {
    var _this = this;
    var deferred = new Deferred();
    client.asyncQueue.enqueueAndForget(function() {
      return tslib.__awaiter(_this, void 0, void 0, function() {
        var syncEngine;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, getSyncEngine(client)];
            case 1:
              syncEngine = _d.sent();
              return [2, syncEngineWrite(syncEngine, mutations, deferred)];
          }
        });
      });
    });
    return deferred.promise;
  }
  function firestoreClientAddSnapshotsInSyncListener(client, observer) {
    var _this = this;
    var wrappedObserver = new AsyncObserver(observer);
    client.asyncQueue.enqueueAndForget(function() {
      return tslib.__awaiter(_this, void 0, void 0, function() {
        var eventManager;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, getEventManager(client)];
            case 1:
              eventManager = _d.sent();
              return [2, addSnapshotsInSyncListener(eventManager, wrappedObserver)];
          }
        });
      });
    });
    return function() {
      wrappedObserver.mute();
      client.asyncQueue.enqueueAndForget(function() {
        return tslib.__awaiter(_this, void 0, void 0, function() {
          var eventManager;
          return tslib.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getEventManager(client)];
              case 1:
                eventManager = _d.sent();
                return [2, removeSnapshotsInSyncListener(eventManager, wrappedObserver)];
            }
          });
        });
      });
    };
  }
  function firestoreClientTransaction(client, updateFunction) {
    var _this = this;
    var deferred = new Deferred();
    client.asyncQueue.enqueueAndForget(function() {
      return tslib.__awaiter(_this, void 0, void 0, function() {
        var datastore;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, getDatastore(client)];
            case 1:
              datastore = _d.sent();
              new TransactionRunner(client.asyncQueue, datastore, updateFunction, deferred).run();
              return [2];
          }
        });
      });
    });
    return deferred.promise;
  }
  function readDocumentFromCache(localStore, docKey, result) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var document_4, e_12, firestoreError;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            _d.trys.push([0, 2, , 3]);
            return [4, localStoreReadDocument(localStore, docKey)];
          case 1:
            document_4 = _d.sent();
            if (document_4.isFoundDocument()) {
              result.resolve(document_4);
            } else if (document_4.isNoDocument()) {
              result.resolve(null);
            } else {
              result.reject(new FirestoreError(Code.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
            }
            return [3, 3];
          case 2:
            e_12 = _d.sent();
            firestoreError = wrapInUserErrorIfRecoverable(e_12, "Failed to get document '" + docKey + " from cache");
            result.reject(firestoreError);
            return [3, 3];
          case 3:
            return [2];
        }
      });
    });
  }
  function readDocumentViaSnapshotListener(eventManager, asyncQueue, key, options, result) {
    var wrappedObserver = new AsyncObserver({
      next: function(snap) {
        asyncQueue.enqueueAndForget(function() {
          return eventManagerUnlisten(eventManager, listener);
        });
        var exists = snap.docs.has(key);
        if (!exists && snap.fromCache) {
          result.reject(new FirestoreError(Code.UNAVAILABLE, "Failed to get document because the client is offline."));
        } else if (exists && snap.fromCache && options && options.source === "server") {
          result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)'));
        } else {
          result.resolve(snap);
        }
      },
      error: function(e) {
        return result.reject(e);
      }
    });
    var listener = new QueryListener(newQueryForPath(key.path), wrappedObserver, {
      includeMetadataChanges: true,
      waitForSyncWhenOnline: true
    });
    return eventManagerListen(eventManager, listener);
  }
  function executeQueryFromCache(localStore, query2, result) {
    return tslib.__awaiter(this, void 0, void 0, function() {
      var queryResult, view, viewDocChanges, viewChange, e_13, firestoreError;
      return tslib.__generator(this, function(_d) {
        switch (_d.label) {
          case 0:
            _d.trys.push([0, 2, , 3]);
            return [4, localStoreExecuteQuery(localStore, query2, true)];
          case 1:
            queryResult = _d.sent();
            view = new View(query2, queryResult.remoteKeys);
            viewDocChanges = view.computeDocChanges(queryResult.documents);
            viewChange = view.applyChanges(viewDocChanges, false);
            result.resolve(viewChange.snapshot);
            return [3, 3];
          case 2:
            e_13 = _d.sent();
            firestoreError = wrapInUserErrorIfRecoverable(e_13, "Failed to execute query '" + query2 + " against cache");
            result.reject(firestoreError);
            return [3, 3];
          case 3:
            return [2];
        }
      });
    });
  }
  function executeQueryViaSnapshotListener(eventManager, asyncQueue, query2, options, result) {
    var wrappedObserver = new AsyncObserver({
      next: function(snapshot) {
        asyncQueue.enqueueAndForget(function() {
          return eventManagerUnlisten(eventManager, listener);
        });
        if (snapshot.fromCache && options.source === "server") {
          result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)'));
        } else {
          result.resolve(snapshot);
        }
      },
      error: function(e) {
        return result.reject(e);
      }
    });
    var listener = new QueryListener(query2, wrappedObserver, {
      includeMetadataChanges: true,
      waitForSyncWhenOnline: true
    });
    return eventManagerListen(eventManager, listener);
  }
  function firestoreClientLoadBundle(client, databaseId, data, resultTask) {
    var _this = this;
    var reader = createBundleReader(data, newSerializer(databaseId));
    client.asyncQueue.enqueueAndForget(function() {
      return tslib.__awaiter(_this, void 0, void 0, function() {
        var _d;
        return tslib.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              _d = syncEngineLoadBundle;
              return [4, getSyncEngine(client)];
            case 1:
              _d.apply(void 0, [_e.sent(), reader, resultTask]);
              return [2];
          }
        });
      });
    });
  }
  function firestoreClientGetNamedQuery(client, queryName) {
    var _this = this;
    return client.asyncQueue.enqueue(function() {
      return tslib.__awaiter(_this, void 0, void 0, function() {
        var _d;
        return tslib.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              _d = localStoreGetNamedQuery;
              return [4, getLocalStore(client)];
            case 1:
              return [2, _d.apply(void 0, [_e.sent(), queryName])];
          }
        });
      });
    });
  }
  function createBundleReader(data, serializer) {
    var content;
    if (typeof data === "string") {
      content = newTextEncoder().encode(data);
    } else {
      content = data;
    }
    return newBundleReader(toByteStreamReader(content), serializer);
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var DatabaseInfo = function() {
    function DatabaseInfo2(databaseId, appId, persistenceKey, host, ssl, forceLongPolling, autoDetectLongPolling) {
      this.databaseId = databaseId;
      this.appId = appId;
      this.persistenceKey = persistenceKey;
      this.host = host;
      this.ssl = ssl;
      this.forceLongPolling = forceLongPolling;
      this.autoDetectLongPolling = autoDetectLongPolling;
    }
    return DatabaseInfo2;
  }();
  var DEFAULT_DATABASE_NAME = "(default)";
  var DatabaseId = function() {
    function DatabaseId2(projectId, database) {
      this.projectId = projectId;
      this.database = database ? database : DEFAULT_DATABASE_NAME;
    }
    Object.defineProperty(DatabaseId2.prototype, "isDefaultDatabase", {
      get: function() {
        return this.database === DEFAULT_DATABASE_NAME;
      },
      enumerable: false,
      configurable: true
    });
    DatabaseId2.prototype.isEqual = function(other) {
      return other instanceof DatabaseId2 && other.projectId === this.projectId && other.database === this.database;
    };
    return DatabaseId2;
  }();
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LOG_TAG$f = "ComponentProvider";
  var datastoreInstances = new Map();
  function removeComponents(firestore) {
    var datastore = datastoreInstances.get(firestore);
    if (datastore) {
      logDebug(LOG_TAG$f, "Removing Datastore");
      datastoreInstances.delete(firestore);
      datastore.terminate();
    }
  }
  function makeDatabaseInfo(databaseId, appId, persistenceKey, settings) {
    return new DatabaseInfo(databaseId, appId, persistenceKey, settings.host, settings.ssl, settings.experimentalForceLongPolling, settings.experimentalAutoDetectLongPolling);
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var OAuthToken = function() {
    function OAuthToken2(value, user) {
      this.user = user;
      this.type = "OAuth";
      this.authHeaders = {};
      this.authHeaders["Authorization"] = "Bearer " + value;
    }
    return OAuthToken2;
  }();
  var EmptyCredentialsProvider = function() {
    function EmptyCredentialsProvider2() {
      this.changeListener = null;
    }
    EmptyCredentialsProvider2.prototype.getToken = function() {
      return Promise.resolve(null);
    };
    EmptyCredentialsProvider2.prototype.invalidateToken = function() {
    };
    EmptyCredentialsProvider2.prototype.setChangeListener = function(changeListener) {
      this.changeListener = changeListener;
      changeListener(User.UNAUTHENTICATED);
    };
    EmptyCredentialsProvider2.prototype.removeChangeListener = function() {
      this.changeListener = null;
    };
    return EmptyCredentialsProvider2;
  }();
  var FirebaseCredentialsProvider = function() {
    function FirebaseCredentialsProvider2(authProvider) {
      var _this = this;
      this.tokenListener = null;
      this.currentUser = User.UNAUTHENTICATED;
      this.receivedInitialUser = false;
      this.tokenCounter = 0;
      this.changeListener = null;
      this.forceRefresh = false;
      this.tokenListener = function() {
        _this.tokenCounter++;
        _this.currentUser = _this.getUser();
        _this.receivedInitialUser = true;
        if (_this.changeListener) {
          _this.changeListener(_this.currentUser);
        }
      };
      this.tokenCounter = 0;
      this.auth = authProvider.getImmediate({optional: true});
      if (this.auth) {
        this.auth.addAuthTokenListener(this.tokenListener);
      } else {
        this.tokenListener(null);
        authProvider.get().then(function(auth) {
          _this.auth = auth;
          if (_this.tokenListener) {
            _this.auth.addAuthTokenListener(_this.tokenListener);
          }
        }, function() {
        });
      }
    }
    FirebaseCredentialsProvider2.prototype.getToken = function() {
      var _this = this;
      var initialTokenCounter = this.tokenCounter;
      var forceRefresh = this.forceRefresh;
      this.forceRefresh = false;
      if (!this.auth) {
        return Promise.resolve(null);
      }
      return this.auth.getToken(forceRefresh).then(function(tokenData) {
        if (_this.tokenCounter !== initialTokenCounter) {
          logDebug("FirebaseCredentialsProvider", "getToken aborted due to token change.");
          return _this.getToken();
        } else {
          if (tokenData) {
            hardAssert(typeof tokenData.accessToken === "string");
            return new OAuthToken(tokenData.accessToken, _this.currentUser);
          } else {
            return null;
          }
        }
      });
    };
    FirebaseCredentialsProvider2.prototype.invalidateToken = function() {
      this.forceRefresh = true;
    };
    FirebaseCredentialsProvider2.prototype.setChangeListener = function(changeListener) {
      this.changeListener = changeListener;
      if (this.receivedInitialUser) {
        changeListener(this.currentUser);
      }
    };
    FirebaseCredentialsProvider2.prototype.removeChangeListener = function() {
      if (this.auth) {
        this.auth.removeAuthTokenListener(this.tokenListener);
      }
      this.tokenListener = null;
      this.changeListener = null;
    };
    FirebaseCredentialsProvider2.prototype.getUser = function() {
      var currentUid = this.auth && this.auth.getUid();
      hardAssert(currentUid === null || typeof currentUid === "string");
      return new User(currentUid);
    };
    return FirebaseCredentialsProvider2;
  }();
  var FirstPartyToken = function() {
    function FirstPartyToken2(gapi, sessionIndex, iamToken) {
      this.gapi = gapi;
      this.sessionIndex = sessionIndex;
      this.iamToken = iamToken;
      this.type = "FirstParty";
      this.user = User.FIRST_PARTY;
    }
    Object.defineProperty(FirstPartyToken2.prototype, "authHeaders", {
      get: function() {
        var headers = {
          "X-Goog-AuthUser": this.sessionIndex
        };
        var authHeader = this.gapi["auth"]["getAuthHeaderValueForFirstParty"]([]);
        if (authHeader) {
          headers["Authorization"] = authHeader;
        }
        if (this.iamToken) {
          headers["X-Goog-Iam-Authorization-Token"] = this.iamToken;
        }
        return headers;
      },
      enumerable: false,
      configurable: true
    });
    return FirstPartyToken2;
  }();
  var FirstPartyCredentialsProvider = function() {
    function FirstPartyCredentialsProvider2(gapi, sessionIndex, iamToken) {
      this.gapi = gapi;
      this.sessionIndex = sessionIndex;
      this.iamToken = iamToken;
    }
    FirstPartyCredentialsProvider2.prototype.getToken = function() {
      return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex, this.iamToken));
    };
    FirstPartyCredentialsProvider2.prototype.setChangeListener = function(changeListener) {
      changeListener(User.FIRST_PARTY);
    };
    FirstPartyCredentialsProvider2.prototype.removeChangeListener = function() {
    };
    FirstPartyCredentialsProvider2.prototype.invalidateToken = function() {
    };
    return FirstPartyCredentialsProvider2;
  }();
  function makeCredentialsProvider(credentials) {
    if (!credentials) {
      return new EmptyCredentialsProvider();
    }
    switch (credentials["type"]) {
      case "gapi":
        var client = credentials["client"];
        hardAssert(!!(typeof client === "object" && client !== null && client["auth"] && client["auth"]["getAuthHeaderValueForFirstParty"]));
        return new FirstPartyCredentialsProvider(client, credentials["sessionIndex"] || "0", credentials["iamToken"] || null);
      case "provider":
        return credentials["client"];
      default:
        throw new FirestoreError(Code.INVALID_ARGUMENT, "makeCredentialsProvider failed due to invalid credential type");
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var DEFAULT_HOST = "firestore.googleapis.com";
  var DEFAULT_SSL = true;
  var FirestoreSettings = function() {
    function FirestoreSettings2(settings) {
      var _a;
      if (settings.host === void 0) {
        if (settings.ssl !== void 0) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
        }
        this.host = DEFAULT_HOST;
        this.ssl = DEFAULT_SSL;
      } else {
        this.host = settings.host;
        this.ssl = (_a = settings.ssl) !== null && _a !== void 0 ? _a : DEFAULT_SSL;
      }
      this.credentials = settings.credentials;
      this.ignoreUndefinedProperties = !!settings.ignoreUndefinedProperties;
      if (settings.cacheSizeBytes === void 0) {
        this.cacheSizeBytes = LRU_DEFAULT_CACHE_SIZE_BYTES;
      } else {
        if (settings.cacheSizeBytes !== LRU_COLLECTION_DISABLED && settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "cacheSizeBytes must be at least " + LRU_MINIMUM_CACHE_SIZE_BYTES);
        } else {
          this.cacheSizeBytes = settings.cacheSizeBytes;
        }
      }
      this.experimentalForceLongPolling = !!settings.experimentalForceLongPolling;
      this.experimentalAutoDetectLongPolling = !!settings.experimentalAutoDetectLongPolling;
      validateIsNotUsedTogether("experimentalForceLongPolling", settings.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", settings.experimentalAutoDetectLongPolling);
    }
    FirestoreSettings2.prototype.isEqual = function(other) {
      return this.host === other.host && this.ssl === other.ssl && this.credentials === other.credentials && this.cacheSizeBytes === other.cacheSizeBytes && this.experimentalForceLongPolling === other.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === other.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === other.ignoreUndefinedProperties;
    };
    return FirestoreSettings2;
  }();
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var FirebaseFirestore = function() {
    function FirebaseFirestore2(databaseIdOrApp, authProvider) {
      this._persistenceKey = "(lite)";
      this._settings = new FirestoreSettings({});
      this._settingsFrozen = false;
      if (databaseIdOrApp instanceof DatabaseId) {
        this._databaseId = databaseIdOrApp;
        this._credentials = new EmptyCredentialsProvider();
      } else {
        this._app = databaseIdOrApp;
        this._databaseId = databaseIdFromApp(databaseIdOrApp);
        this._credentials = new FirebaseCredentialsProvider(authProvider);
      }
    }
    Object.defineProperty(FirebaseFirestore2.prototype, "app", {
      get: function() {
        if (!this._app) {
          throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
        }
        return this._app;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FirebaseFirestore2.prototype, "_initialized", {
      get: function() {
        return this._settingsFrozen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FirebaseFirestore2.prototype, "_terminated", {
      get: function() {
        return this._terminateTask !== void 0;
      },
      enumerable: false,
      configurable: true
    });
    FirebaseFirestore2.prototype._setSettings = function(settings) {
      if (this._settingsFrozen) {
        throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
      }
      this._settings = new FirestoreSettings(settings);
      if (settings.credentials !== void 0) {
        this._credentials = makeCredentialsProvider(settings.credentials);
      }
    };
    FirebaseFirestore2.prototype._getSettings = function() {
      return this._settings;
    };
    FirebaseFirestore2.prototype._freezeSettings = function() {
      this._settingsFrozen = true;
      return this._settings;
    };
    FirebaseFirestore2.prototype._delete = function() {
      if (!this._terminateTask) {
        this._terminateTask = this._terminate();
      }
      return this._terminateTask;
    };
    FirebaseFirestore2.prototype.toJSON = function() {
      return {
        app: this._app,
        databaseId: this._databaseId,
        settings: this._settings
      };
    };
    FirebaseFirestore2.prototype._terminate = function() {
      removeComponents(this);
      return Promise.resolve();
    };
    return FirebaseFirestore2;
  }();
  function databaseIdFromApp(app2) {
    if (!Object.prototype.hasOwnProperty.apply(app2.options, ["projectId"])) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
    }
    return new DatabaseId(app2.options.projectId);
  }
  function useFirestoreEmulator(firestore, host, port) {
    firestore = cast(firestore, FirebaseFirestore);
    var settings = firestore._getSettings();
    if (settings.host !== DEFAULT_HOST && settings.host !== host) {
      logWarn("Host has been set in both settings() and useEmulator(), emulator host will be used");
    }
    firestore._setSettings(Object.assign(Object.assign({}, settings), {host: host + ":" + port, ssl: false}));
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var DocumentReference = function() {
    function DocumentReference2(firestore, _converter, _key) {
      this._converter = _converter;
      this._key = _key;
      this.type = "document";
      this.firestore = firestore;
    }
    Object.defineProperty(DocumentReference2.prototype, "_path", {
      get: function() {
        return this._key.path;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DocumentReference2.prototype, "id", {
      get: function() {
        return this._key.path.lastSegment();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DocumentReference2.prototype, "path", {
      get: function() {
        return this._key.path.canonicalString();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DocumentReference2.prototype, "parent", {
      get: function() {
        return new CollectionReference(this.firestore, this._converter, this._key.path.popLast());
      },
      enumerable: false,
      configurable: true
    });
    DocumentReference2.prototype.withConverter = function(converter) {
      return new DocumentReference2(this.firestore, converter, this._key);
    };
    return DocumentReference2;
  }();
  var Query = function() {
    function Query2(firestore, _converter, _query) {
      this._converter = _converter;
      this._query = _query;
      this.type = "query";
      this.firestore = firestore;
    }
    Query2.prototype.withConverter = function(converter) {
      return new Query2(this.firestore, converter, this._query);
    };
    return Query2;
  }();
  var CollectionReference = function(_super) {
    tslib.__extends(CollectionReference2, _super);
    function CollectionReference2(firestore, converter, _path) {
      var _this = _super.call(this, firestore, converter, newQueryForPath(_path)) || this;
      _this.firestore = firestore;
      _this._path = _path;
      _this.type = "collection";
      return _this;
    }
    Object.defineProperty(CollectionReference2.prototype, "id", {
      get: function() {
        return this._query.path.lastSegment();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CollectionReference2.prototype, "path", {
      get: function() {
        return this._query.path.canonicalString();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CollectionReference2.prototype, "parent", {
      get: function() {
        var parentPath = this._path.popLast();
        if (parentPath.isEmpty()) {
          return null;
        } else {
          return new DocumentReference(this.firestore, null, new DocumentKey(parentPath));
        }
      },
      enumerable: false,
      configurable: true
    });
    CollectionReference2.prototype.withConverter = function(converter) {
      return new CollectionReference2(this.firestore, converter, this._path);
    };
    return CollectionReference2;
  }(Query);
  function collection(parent, path2) {
    var pathSegments = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      pathSegments[_i - 2] = arguments[_i];
    }
    parent = util.getModularInstance(parent);
    validateNonEmptyArgument("collection", "path", path2);
    if (parent instanceof FirebaseFirestore) {
      var absolutePath = ResourcePath.fromString.apply(ResourcePath, tslib.__spreadArray([path2], pathSegments));
      validateCollectionPath(absolutePath);
      return new CollectionReference(parent, null, absolutePath);
    } else {
      if (!(parent instanceof DocumentReference) && !(parent instanceof CollectionReference)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
      }
      var absolutePath = ResourcePath.fromString.apply(ResourcePath, tslib.__spreadArray([parent.path], pathSegments)).child(ResourcePath.fromString(path2));
      validateCollectionPath(absolutePath);
      return new CollectionReference(parent.firestore, null, absolutePath);
    }
  }
  function collectionGroup(firestore, collectionId) {
    firestore = cast(firestore, FirebaseFirestore);
    validateNonEmptyArgument("collectionGroup", "collection id", collectionId);
    if (collectionId.indexOf("/") >= 0) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid collection ID '" + collectionId + "' passed to function collectionGroup(). Collection IDs must not contain '/'.");
    }
    return new Query(firestore, null, newQueryForCollectionGroup(collectionId));
  }
  function doc(parent, path2) {
    var pathSegments = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      pathSegments[_i - 2] = arguments[_i];
    }
    parent = util.getModularInstance(parent);
    if (arguments.length === 1) {
      path2 = AutoId.newId();
    }
    validateNonEmptyArgument("doc", "path", path2);
    if (parent instanceof FirebaseFirestore) {
      var absolutePath = ResourcePath.fromString.apply(ResourcePath, tslib.__spreadArray([path2], pathSegments));
      validateDocumentPath(absolutePath);
      return new DocumentReference(parent, null, new DocumentKey(absolutePath));
    } else {
      if (!(parent instanceof DocumentReference) && !(parent instanceof CollectionReference)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
      }
      var absolutePath = parent._path.child(ResourcePath.fromString.apply(ResourcePath, tslib.__spreadArray([path2], pathSegments)));
      validateDocumentPath(absolutePath);
      return new DocumentReference(parent.firestore, parent instanceof CollectionReference ? parent._converter : null, new DocumentKey(absolutePath));
    }
  }
  function refEqual(left, right) {
    left = util.getModularInstance(left);
    right = util.getModularInstance(right);
    if ((left instanceof DocumentReference || left instanceof CollectionReference) && (right instanceof DocumentReference || right instanceof CollectionReference)) {
      return left.firestore === right.firestore && left.path === right.path && left._converter === right._converter;
    }
    return false;
  }
  function queryEqual(left, right) {
    left = util.getModularInstance(left);
    right = util.getModularInstance(right);
    if (left instanceof Query && right instanceof Query) {
      return left.firestore === right.firestore && queryEquals(left._query, right._query) && left._converter === right._converter;
    }
    return false;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LOG_TAG$g = "AsyncQueue";
  var AsyncQueueImpl = function() {
    function AsyncQueueImpl2() {
      var _this = this;
      this.tail = Promise.resolve();
      this.retryableOps = [];
      this._isShuttingDown = false;
      this.delayedOperations = [];
      this.failure = null;
      this.operationInProgress = false;
      this.timerIdsToSkip = [];
      this.backoff = new ExponentialBackoff(this, "async_queue_retry");
      this.visibilityHandler = function() {
        _this.backoff.skipBackoff();
      };
    }
    Object.defineProperty(AsyncQueueImpl2.prototype, "isShuttingDown", {
      get: function() {
        return this._isShuttingDown;
      },
      enumerable: false,
      configurable: true
    });
    AsyncQueueImpl2.prototype.enqueueAndForget = function(op) {
      this.enqueue(op);
    };
    AsyncQueueImpl2.prototype.enqueueAndForgetEvenWhileRestricted = function(op) {
      this.verifyNotFailed();
      this.enqueueInternal(op);
    };
    AsyncQueueImpl2.prototype.enterRestrictedMode = function() {
      if (!this._isShuttingDown) {
        this._isShuttingDown = true;
      }
    };
    AsyncQueueImpl2.prototype.enqueue = function(op) {
      this.verifyNotFailed();
      if (this._isShuttingDown) {
        return new Promise(function(resolve) {
        });
      }
      return this.enqueueInternal(op);
    };
    AsyncQueueImpl2.prototype.enqueueRetryable = function(op) {
      var _this = this;
      this.enqueueAndForget(function() {
        _this.retryableOps.push(op);
        return _this.retryNextOp();
      });
    };
    AsyncQueueImpl2.prototype.retryNextOp = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var e_14;
        var _this = this;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (this.retryableOps.length === 0) {
                return [2];
              }
              _d.label = 1;
            case 1:
              _d.trys.push([1, 3, , 4]);
              return [4, this.retryableOps[0]()];
            case 2:
              _d.sent();
              this.retryableOps.shift();
              this.backoff.reset();
              return [3, 4];
            case 3:
              e_14 = _d.sent();
              if (isIndexedDbTransactionError(e_14)) {
                logDebug(LOG_TAG$g, "Operation failed with retryable error: " + e_14);
              } else {
                throw e_14;
              }
              return [3, 4];
            case 4:
              if (this.retryableOps.length > 0) {
                this.backoff.backoffAndRun(function() {
                  return _this.retryNextOp();
                });
              }
              return [2];
          }
        });
      });
    };
    AsyncQueueImpl2.prototype.enqueueInternal = function(op) {
      var _this = this;
      var newTail = this.tail.then(function() {
        _this.operationInProgress = true;
        return op().catch(function(error) {
          _this.failure = error;
          _this.operationInProgress = false;
          var message = getMessageOrStack(error);
          logError("INTERNAL UNHANDLED ERROR: ", message);
          throw error;
        }).then(function(result) {
          _this.operationInProgress = false;
          return result;
        });
      });
      this.tail = newTail;
      return newTail;
    };
    AsyncQueueImpl2.prototype.enqueueAfterDelay = function(timerId, delayMs, op) {
      var _this = this;
      this.verifyNotFailed();
      if (this.timerIdsToSkip.indexOf(timerId) > -1) {
        delayMs = 0;
      }
      var delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, function(removedOp) {
        return _this.removeDelayedOperation(removedOp);
      });
      this.delayedOperations.push(delayedOp);
      return delayedOp;
    };
    AsyncQueueImpl2.prototype.verifyNotFailed = function() {
      if (this.failure) {
        fail();
      }
    };
    AsyncQueueImpl2.prototype.verifyOperationInProgress = function() {
    };
    AsyncQueueImpl2.prototype.drain = function() {
      return tslib.__awaiter(this, void 0, void 0, function() {
        var currentTail;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              currentTail = this.tail;
              return [4, currentTail];
            case 1:
              _d.sent();
              _d.label = 2;
            case 2:
              if (currentTail !== this.tail)
                return [3, 0];
              _d.label = 3;
            case 3:
              return [2];
          }
        });
      });
    };
    AsyncQueueImpl2.prototype.containsDelayedOperation = function(timerId) {
      for (var _i = 0, _d = this.delayedOperations; _i < _d.length; _i++) {
        var op = _d[_i];
        if (op.timerId === timerId) {
          return true;
        }
      }
      return false;
    };
    AsyncQueueImpl2.prototype.runAllDelayedOperationsUntil = function(lastTimerId) {
      var _this = this;
      return this.drain().then(function() {
        _this.delayedOperations.sort(function(a, b) {
          return a.targetTimeMs - b.targetTimeMs;
        });
        for (var _i = 0, _d = _this.delayedOperations; _i < _d.length; _i++) {
          var op = _d[_i];
          op.skipDelay();
          if (lastTimerId !== "all" && op.timerId === lastTimerId) {
            break;
          }
        }
        return _this.drain();
      });
    };
    AsyncQueueImpl2.prototype.skipDelaysForTimerId = function(timerId) {
      this.timerIdsToSkip.push(timerId);
    };
    AsyncQueueImpl2.prototype.removeDelayedOperation = function(op) {
      var index = this.delayedOperations.indexOf(op);
      this.delayedOperations.splice(index, 1);
    };
    return AsyncQueueImpl2;
  }();
  function newAsyncQueue() {
    return new AsyncQueueImpl();
  }
  function getMessageOrStack(error) {
    var message = error.message || "";
    if (error.stack) {
      if (error.stack.includes(error.message)) {
        message = error.stack;
      } else {
        message = error.message + "\n" + error.stack;
      }
    }
    return message;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var LoadBundleTask = function() {
    function LoadBundleTask2() {
      this._progressObserver = {};
      this._taskCompletionResolver = new Deferred();
      this._lastProgress = {
        taskState: "Running",
        totalBytes: 0,
        totalDocuments: 0,
        bytesLoaded: 0,
        documentsLoaded: 0
      };
    }
    LoadBundleTask2.prototype.onProgress = function(next, error, complete) {
      this._progressObserver = {
        next,
        error,
        complete
      };
    };
    LoadBundleTask2.prototype.catch = function(onRejected) {
      return this._taskCompletionResolver.promise.catch(onRejected);
    };
    LoadBundleTask2.prototype.then = function(onFulfilled, onRejected) {
      return this._taskCompletionResolver.promise.then(onFulfilled, onRejected);
    };
    LoadBundleTask2.prototype._completeWith = function(progress) {
      this._updateProgress(progress);
      if (this._progressObserver.complete) {
        this._progressObserver.complete();
      }
      this._taskCompletionResolver.resolve(progress);
    };
    LoadBundleTask2.prototype._failWith = function(error) {
      this._lastProgress.taskState = "Error";
      if (this._progressObserver.next) {
        this._progressObserver.next(this._lastProgress);
      }
      if (this._progressObserver.error) {
        this._progressObserver.error(error);
      }
      this._taskCompletionResolver.reject(error);
    };
    LoadBundleTask2.prototype._updateProgress = function(progress) {
      this._lastProgress = progress;
      if (this._progressObserver.next) {
        this._progressObserver.next(progress);
      }
    };
    return LoadBundleTask2;
  }();
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var DOM_EXCEPTION_INVALID_STATE = 11;
  var DOM_EXCEPTION_ABORTED = 20;
  var DOM_EXCEPTION_QUOTA_EXCEEDED = 22;
  var CACHE_SIZE_UNLIMITED = LRU_COLLECTION_DISABLED;
  var FirebaseFirestore$1 = function(_super) {
    tslib.__extends(FirebaseFirestore$12, _super);
    function FirebaseFirestore$12(databaseIdOrApp, authProvider) {
      var _this = _super.call(this, databaseIdOrApp, authProvider) || this;
      _this._queue = newAsyncQueue();
      _this._persistenceKey = "name" in databaseIdOrApp ? databaseIdOrApp.name : "[DEFAULT]";
      return _this;
    }
    FirebaseFirestore$12.prototype._terminate = function() {
      if (!this._firestoreClient) {
        configureFirestore(this);
      }
      return this._firestoreClient.terminate();
    };
    return FirebaseFirestore$12;
  }(FirebaseFirestore);
  function ensureFirestoreConfigured(firestore) {
    if (!firestore._firestoreClient) {
      configureFirestore(firestore);
    }
    firestore._firestoreClient.verifyNotTerminated();
    return firestore._firestoreClient;
  }
  function configureFirestore(firestore) {
    var _a;
    var settings = firestore._freezeSettings();
    var databaseInfo = makeDatabaseInfo(firestore._databaseId, ((_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.appId) || "", firestore._persistenceKey, settings);
    firestore._firestoreClient = new FirestoreClient(firestore._credentials, firestore._queue, databaseInfo);
  }
  function enableIndexedDbPersistence(firestore, persistenceSettings) {
    firestore = cast(firestore, FirebaseFirestore$1);
    verifyNotInitialized(firestore);
    var client = ensureFirestoreConfigured(firestore);
    var settings = firestore._freezeSettings();
    var onlineComponentProvider = new OnlineComponentProvider();
    var offlineComponentProvider = new IndexedDbOfflineComponentProvider(onlineComponentProvider, settings.cacheSizeBytes, persistenceSettings === null || persistenceSettings === void 0 ? void 0 : persistenceSettings.forceOwnership);
    return setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider);
  }
  function enableMultiTabIndexedDbPersistence(firestore) {
    firestore = cast(firestore, FirebaseFirestore$1);
    verifyNotInitialized(firestore);
    var client = ensureFirestoreConfigured(firestore);
    var settings = firestore._freezeSettings();
    var onlineComponentProvider = new OnlineComponentProvider();
    var offlineComponentProvider = new MultiTabOfflineComponentProvider(onlineComponentProvider, settings.cacheSizeBytes);
    return setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider);
  }
  function setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider) {
    var _this = this;
    var persistenceResult = new Deferred();
    return client.asyncQueue.enqueue(function() {
      return tslib.__awaiter(_this, void 0, void 0, function() {
        var e_15;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              _d.trys.push([0, 3, , 4]);
              return [4, setOfflineComponentProvider(client, offlineComponentProvider)];
            case 1:
              _d.sent();
              return [4, setOnlineComponentProvider(client, onlineComponentProvider)];
            case 2:
              _d.sent();
              persistenceResult.resolve();
              return [3, 4];
            case 3:
              e_15 = _d.sent();
              if (!canFallbackFromIndexedDbError(e_15)) {
                throw e_15;
              }
              console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + e_15);
              persistenceResult.reject(e_15);
              return [3, 4];
            case 4:
              return [2];
          }
        });
      });
    }).then(function() {
      return persistenceResult.promise;
    });
  }
  function canFallbackFromIndexedDbError(error) {
    if (error.name === "FirebaseError") {
      return error.code === Code.FAILED_PRECONDITION || error.code === Code.UNIMPLEMENTED;
    } else if (typeof DOMException !== "undefined" && error instanceof DOMException) {
      return error.code === DOM_EXCEPTION_QUOTA_EXCEEDED || error.code === DOM_EXCEPTION_ABORTED || error.code === DOM_EXCEPTION_INVALID_STATE;
    }
    return true;
  }
  function clearIndexedDbPersistence(firestore) {
    var _this = this;
    if (firestore._initialized && !firestore._terminated) {
      throw new FirestoreError(Code.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
    }
    var deferred = new Deferred();
    firestore._queue.enqueueAndForgetEvenWhileRestricted(function() {
      return tslib.__awaiter(_this, void 0, void 0, function() {
        var e_16;
        return tslib.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              _d.trys.push([0, 2, , 3]);
              return [4, indexedDbClearPersistence(indexedDbStoragePrefix(firestore._databaseId, firestore._persistenceKey))];
            case 1:
              _d.sent();
              deferred.resolve();
              return [3, 3];
            case 2:
              e_16 = _d.sent();
              deferred.reject(e_16);
              return [3, 3];
            case 3:
              return [2];
          }
        });
      });
    });
    return deferred.promise;
  }
  function waitForPendingWrites(firestore) {
    firestore = cast(firestore, FirebaseFirestore$1);
    var client = ensureFirestoreConfigured(firestore);
    return firestoreClientWaitForPendingWrites(client);
  }
  function enableNetwork(firestore) {
    firestore = cast(firestore, FirebaseFirestore$1);
    var client = ensureFirestoreConfigured(firestore);
    return firestoreClientEnableNetwork(client);
  }
  function disableNetwork(firestore) {
    firestore = cast(firestore, FirebaseFirestore$1);
    var client = ensureFirestoreConfigured(firestore);
    return firestoreClientDisableNetwork(client);
  }
  function loadBundle(firestore, bundleData) {
    firestore = cast(firestore, FirebaseFirestore$1);
    var client = ensureFirestoreConfigured(firestore);
    var resultTask = new LoadBundleTask();
    firestoreClientLoadBundle(client, firestore._databaseId, bundleData, resultTask);
    return resultTask;
  }
  function namedQuery(firestore, name) {
    firestore = cast(firestore, FirebaseFirestore$1);
    var client = ensureFirestoreConfigured(firestore);
    return firestoreClientGetNamedQuery(client, name).then(function(namedQuery2) {
      if (!namedQuery2) {
        return null;
      }
      return new Query(firestore, null, namedQuery2.query);
    });
  }
  function verifyNotInitialized(firestore) {
    if (firestore._initialized || firestore._terminated) {
      throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var FieldPath$1 = function() {
    function FieldPath$12() {
      var fieldNames = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fieldNames[_i] = arguments[_i];
      }
      for (var i = 0; i < fieldNames.length; ++i) {
        if (fieldNames[i].length === 0) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
        }
      }
      this._internalPath = new FieldPath(fieldNames);
    }
    FieldPath$12.prototype.isEqual = function(other) {
      return this._internalPath.isEqual(other._internalPath);
    };
    return FieldPath$12;
  }();
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var Bytes = function() {
    function Bytes2(byteString) {
      this._byteString = byteString;
    }
    Bytes2.fromBase64String = function(base64) {
      try {
        return new Bytes2(ByteString.fromBase64String(base64));
      } catch (e) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + e);
      }
    };
    Bytes2.fromUint8Array = function(array) {
      return new Bytes2(ByteString.fromUint8Array(array));
    };
    Bytes2.prototype.toBase64 = function() {
      return this._byteString.toBase64();
    };
    Bytes2.prototype.toUint8Array = function() {
      return this._byteString.toUint8Array();
    };
    Bytes2.prototype.toString = function() {
      return "Bytes(base64: " + this.toBase64() + ")";
    };
    Bytes2.prototype.isEqual = function(other) {
      return this._byteString.isEqual(other._byteString);
    };
    return Bytes2;
  }();
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var FieldValue = function() {
    function FieldValue2(_methodName) {
      this._methodName = _methodName;
    }
    return FieldValue2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var GeoPoint = function() {
    function GeoPoint2(latitude, longitude) {
      if (!isFinite(latitude) || latitude < -90 || latitude > 90) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + latitude);
      }
      if (!isFinite(longitude) || longitude < -180 || longitude > 180) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + longitude);
      }
      this._lat = latitude;
      this._long = longitude;
    }
    Object.defineProperty(GeoPoint2.prototype, "latitude", {
      get: function() {
        return this._lat;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(GeoPoint2.prototype, "longitude", {
      get: function() {
        return this._long;
      },
      enumerable: false,
      configurable: true
    });
    GeoPoint2.prototype.isEqual = function(other) {
      return this._lat === other._lat && this._long === other._long;
    };
    GeoPoint2.prototype.toJSON = function() {
      return {latitude: this._lat, longitude: this._long};
    };
    GeoPoint2.prototype._compareTo = function(other) {
      return primitiveComparator(this._lat, other._lat) || primitiveComparator(this._long, other._long);
    };
    return GeoPoint2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var RESERVED_FIELD_REGEX = /^__.*__$/;
  var ParsedSetData = function() {
    function ParsedSetData2(data, fieldMask, fieldTransforms) {
      this.data = data;
      this.fieldMask = fieldMask;
      this.fieldTransforms = fieldTransforms;
    }
    ParsedSetData2.prototype.toMutation = function(key, precondition) {
      if (this.fieldMask !== null) {
        return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);
      } else {
        return new SetMutation(key, this.data, precondition, this.fieldTransforms);
      }
    };
    return ParsedSetData2;
  }();
  var ParsedUpdateData = function() {
    function ParsedUpdateData2(data, fieldMask, fieldTransforms) {
      this.data = data;
      this.fieldMask = fieldMask;
      this.fieldTransforms = fieldTransforms;
    }
    ParsedUpdateData2.prototype.toMutation = function(key, precondition) {
      return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);
    };
    return ParsedUpdateData2;
  }();
  function isWrite(dataSource) {
    switch (dataSource) {
      case 0:
      case 2:
      case 1:
        return true;
      case 3:
      case 4:
        return false;
      default:
        throw fail();
    }
  }
  var ParseContextImpl = function() {
    function ParseContextImpl2(settings, databaseId, serializer, ignoreUndefinedProperties, fieldTransforms, fieldMask) {
      this.settings = settings;
      this.databaseId = databaseId;
      this.serializer = serializer;
      this.ignoreUndefinedProperties = ignoreUndefinedProperties;
      if (fieldTransforms === void 0) {
        this.validatePath();
      }
      this.fieldTransforms = fieldTransforms || [];
      this.fieldMask = fieldMask || [];
    }
    Object.defineProperty(ParseContextImpl2.prototype, "path", {
      get: function() {
        return this.settings.path;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ParseContextImpl2.prototype, "dataSource", {
      get: function() {
        return this.settings.dataSource;
      },
      enumerable: false,
      configurable: true
    });
    ParseContextImpl2.prototype.contextWith = function(configuration) {
      return new ParseContextImpl2(Object.assign(Object.assign({}, this.settings), configuration), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
    };
    ParseContextImpl2.prototype.childContextForField = function(field) {
      var _a;
      var childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);
      var context = this.contextWith({path: childPath, arrayElement: false});
      context.validatePathSegment(field);
      return context;
    };
    ParseContextImpl2.prototype.childContextForFieldPath = function(field) {
      var _a;
      var childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);
      var context = this.contextWith({path: childPath, arrayElement: false});
      context.validatePath();
      return context;
    };
    ParseContextImpl2.prototype.childContextForArray = function(index) {
      return this.contextWith({path: void 0, arrayElement: true});
    };
    ParseContextImpl2.prototype.createError = function(reason) {
      return createError(reason, this.settings.methodName, this.settings.hasConverter || false, this.path, this.settings.targetDoc);
    };
    ParseContextImpl2.prototype.contains = function(fieldPath) {
      return this.fieldMask.find(function(field) {
        return fieldPath.isPrefixOf(field);
      }) !== void 0 || this.fieldTransforms.find(function(transform) {
        return fieldPath.isPrefixOf(transform.field);
      }) !== void 0;
    };
    ParseContextImpl2.prototype.validatePath = function() {
      if (!this.path) {
        return;
      }
      for (var i = 0; i < this.path.length; i++) {
        this.validatePathSegment(this.path.get(i));
      }
    };
    ParseContextImpl2.prototype.validatePathSegment = function(segment) {
      if (segment.length === 0) {
        throw this.createError("Document fields must not be empty");
      }
      if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {
        throw this.createError('Document fields cannot begin and end with "__"');
      }
    };
    return ParseContextImpl2;
  }();
  var UserDataReader = function() {
    function UserDataReader2(databaseId, ignoreUndefinedProperties, serializer) {
      this.databaseId = databaseId;
      this.ignoreUndefinedProperties = ignoreUndefinedProperties;
      this.serializer = serializer || newSerializer(databaseId);
    }
    UserDataReader2.prototype.createContext = function(dataSource, methodName, targetDoc, hasConverter) {
      if (hasConverter === void 0) {
        hasConverter = false;
      }
      return new ParseContextImpl({
        dataSource,
        methodName,
        targetDoc,
        path: FieldPath.emptyPath(),
        arrayElement: false,
        hasConverter
      }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);
    };
    return UserDataReader2;
  }();
  function newUserDataReader(firestore) {
    var settings = firestore._freezeSettings();
    var serializer = newSerializer(firestore._databaseId);
    return new UserDataReader(firestore._databaseId, !!settings.ignoreUndefinedProperties, serializer);
  }
  function parseSetData(userDataReader, methodName, targetDoc, input, hasConverter, options) {
    if (options === void 0) {
      options = {};
    }
    var context = userDataReader.createContext(options.merge || options.mergeFields ? 2 : 0, methodName, targetDoc, hasConverter);
    validatePlainObject("Data must be an object, but it was:", context, input);
    var updateData = parseObject(input, context);
    var fieldMask;
    var fieldTransforms;
    if (options.merge) {
      fieldMask = new FieldMask(context.fieldMask);
      fieldTransforms = context.fieldTransforms;
    } else if (options.mergeFields) {
      var validatedFieldPaths = [];
      for (var _i = 0, _d = options.mergeFields; _i < _d.length; _i++) {
        var stringOrFieldPath = _d[_i];
        var fieldPath = fieldPathFromArgument(methodName, stringOrFieldPath, targetDoc);
        if (!context.contains(fieldPath)) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Field '" + fieldPath + "' is specified in your field mask but missing from your input data.");
        }
        if (!fieldMaskContains(validatedFieldPaths, fieldPath)) {
          validatedFieldPaths.push(fieldPath);
        }
      }
      fieldMask = new FieldMask(validatedFieldPaths);
      fieldTransforms = context.fieldTransforms.filter(function(transform) {
        return fieldMask.covers(transform.field);
      });
    } else {
      fieldMask = null;
      fieldTransforms = context.fieldTransforms;
    }
    return new ParsedSetData(new ObjectValue(updateData), fieldMask, fieldTransforms);
  }
  var DeleteFieldValueImpl = function(_super) {
    tslib.__extends(DeleteFieldValueImpl2, _super);
    function DeleteFieldValueImpl2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DeleteFieldValueImpl2.prototype._toFieldTransform = function(context) {
      if (context.dataSource === 2) {
        context.fieldMask.push(context.path);
      } else if (context.dataSource === 1) {
        throw context.createError(this._methodName + "() can only appear at the top level of your update data");
      } else {
        throw context.createError(this._methodName + "() cannot be used with set() unless you pass {merge:true}");
      }
      return null;
    };
    DeleteFieldValueImpl2.prototype.isEqual = function(other) {
      return other instanceof DeleteFieldValueImpl2;
    };
    return DeleteFieldValueImpl2;
  }(FieldValue);
  function createSentinelChildContext(fieldValue, context, arrayElement) {
    return new ParseContextImpl({
      dataSource: 3,
      targetDoc: context.settings.targetDoc,
      methodName: fieldValue._methodName,
      arrayElement
    }, context.databaseId, context.serializer, context.ignoreUndefinedProperties);
  }
  var ServerTimestampFieldValueImpl = function(_super) {
    tslib.__extends(ServerTimestampFieldValueImpl2, _super);
    function ServerTimestampFieldValueImpl2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ServerTimestampFieldValueImpl2.prototype._toFieldTransform = function(context) {
      return new FieldTransform(context.path, new ServerTimestampTransform());
    };
    ServerTimestampFieldValueImpl2.prototype.isEqual = function(other) {
      return other instanceof ServerTimestampFieldValueImpl2;
    };
    return ServerTimestampFieldValueImpl2;
  }(FieldValue);
  var ArrayUnionFieldValueImpl = function(_super) {
    tslib.__extends(ArrayUnionFieldValueImpl2, _super);
    function ArrayUnionFieldValueImpl2(methodName, _elements) {
      var _this = _super.call(this, methodName) || this;
      _this._elements = _elements;
      return _this;
    }
    ArrayUnionFieldValueImpl2.prototype._toFieldTransform = function(context) {
      var parseContext = createSentinelChildContext(this, context, true);
      var parsedElements = this._elements.map(function(element) {
        return parseData(element, parseContext);
      });
      var arrayUnion = new ArrayUnionTransformOperation(parsedElements);
      return new FieldTransform(context.path, arrayUnion);
    };
    ArrayUnionFieldValueImpl2.prototype.isEqual = function(other) {
      return this === other;
    };
    return ArrayUnionFieldValueImpl2;
  }(FieldValue);
  var ArrayRemoveFieldValueImpl = function(_super) {
    tslib.__extends(ArrayRemoveFieldValueImpl2, _super);
    function ArrayRemoveFieldValueImpl2(methodName, _elements) {
      var _this = _super.call(this, methodName) || this;
      _this._elements = _elements;
      return _this;
    }
    ArrayRemoveFieldValueImpl2.prototype._toFieldTransform = function(context) {
      var parseContext = createSentinelChildContext(this, context, true);
      var parsedElements = this._elements.map(function(element) {
        return parseData(element, parseContext);
      });
      var arrayUnion = new ArrayRemoveTransformOperation(parsedElements);
      return new FieldTransform(context.path, arrayUnion);
    };
    ArrayRemoveFieldValueImpl2.prototype.isEqual = function(other) {
      return this === other;
    };
    return ArrayRemoveFieldValueImpl2;
  }(FieldValue);
  var NumericIncrementFieldValueImpl = function(_super) {
    tslib.__extends(NumericIncrementFieldValueImpl2, _super);
    function NumericIncrementFieldValueImpl2(methodName, _operand) {
      var _this = _super.call(this, methodName) || this;
      _this._operand = _operand;
      return _this;
    }
    NumericIncrementFieldValueImpl2.prototype._toFieldTransform = function(context) {
      var numericIncrement = new NumericIncrementTransformOperation(context.serializer, toNumber(context.serializer, this._operand));
      return new FieldTransform(context.path, numericIncrement);
    };
    NumericIncrementFieldValueImpl2.prototype.isEqual = function(other) {
      return this === other;
    };
    return NumericIncrementFieldValueImpl2;
  }(FieldValue);
  function parseUpdateData(userDataReader, methodName, targetDoc, input) {
    var context = userDataReader.createContext(1, methodName, targetDoc);
    validatePlainObject("Data must be an object, but it was:", context, input);
    var fieldMaskPaths = [];
    var updateData = ObjectValue.empty();
    forEach(input, function(key, value) {
      var path2 = fieldPathFromDotSeparatedString(methodName, key, targetDoc);
      value = util.getModularInstance(value);
      var childContext = context.childContextForFieldPath(path2);
      if (value instanceof DeleteFieldValueImpl) {
        fieldMaskPaths.push(path2);
      } else {
        var parsedValue = parseData(value, childContext);
        if (parsedValue != null) {
          fieldMaskPaths.push(path2);
          updateData.set(path2, parsedValue);
        }
      }
    });
    var mask = new FieldMask(fieldMaskPaths);
    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);
  }
  function parseUpdateVarargs(userDataReader, methodName, targetDoc, field, value, moreFieldsAndValues) {
    var context = userDataReader.createContext(1, methodName, targetDoc);
    var keys = [fieldPathFromArgument(methodName, field, targetDoc)];
    var values = [value];
    if (moreFieldsAndValues.length % 2 !== 0) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + methodName + "() needs to be called with an even number of arguments that alternate between field names and values.");
    }
    for (var i = 0; i < moreFieldsAndValues.length; i += 2) {
      keys.push(fieldPathFromArgument(methodName, moreFieldsAndValues[i]));
      values.push(moreFieldsAndValues[i + 1]);
    }
    var fieldMaskPaths = [];
    var updateData = ObjectValue.empty();
    for (var i = keys.length - 1; i >= 0; --i) {
      if (!fieldMaskContains(fieldMaskPaths, keys[i])) {
        var path2 = keys[i];
        var value_1 = values[i];
        value_1 = util.getModularInstance(value_1);
        var childContext = context.childContextForFieldPath(path2);
        if (value_1 instanceof DeleteFieldValueImpl) {
          fieldMaskPaths.push(path2);
        } else {
          var parsedValue = parseData(value_1, childContext);
          if (parsedValue != null) {
            fieldMaskPaths.push(path2);
            updateData.set(path2, parsedValue);
          }
        }
      }
    }
    var mask = new FieldMask(fieldMaskPaths);
    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);
  }
  function parseQueryValue(userDataReader, methodName, input, allowArrays) {
    if (allowArrays === void 0) {
      allowArrays = false;
    }
    var context = userDataReader.createContext(allowArrays ? 4 : 3, methodName);
    var parsed = parseData(input, context);
    return parsed;
  }
  function parseData(input, context) {
    input = util.getModularInstance(input);
    if (looksLikeJsonObject(input)) {
      validatePlainObject("Unsupported field value:", context, input);
      return parseObject(input, context);
    } else if (input instanceof FieldValue) {
      parseSentinelFieldValue(input, context);
      return null;
    } else if (input === void 0 && context.ignoreUndefinedProperties) {
      return null;
    } else {
      if (context.path) {
        context.fieldMask.push(context.path);
      }
      if (input instanceof Array) {
        if (context.settings.arrayElement && context.dataSource !== 4) {
          throw context.createError("Nested arrays are not supported");
        }
        return parseArray(input, context);
      } else {
        return parseScalarValue(input, context);
      }
    }
  }
  function parseObject(obj, context) {
    var fields = {};
    if (isEmpty(obj)) {
      if (context.path && context.path.length > 0) {
        context.fieldMask.push(context.path);
      }
    } else {
      forEach(obj, function(key, val) {
        var parsedValue = parseData(val, context.childContextForField(key));
        if (parsedValue != null) {
          fields[key] = parsedValue;
        }
      });
    }
    return {mapValue: {fields}};
  }
  function parseArray(array, context) {
    var values = [];
    var entryIndex = 0;
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
      var entry = array_1[_i];
      var parsedEntry = parseData(entry, context.childContextForArray(entryIndex));
      if (parsedEntry == null) {
        parsedEntry = {nullValue: "NULL_VALUE"};
      }
      values.push(parsedEntry);
      entryIndex++;
    }
    return {arrayValue: {values}};
  }
  function parseSentinelFieldValue(value, context) {
    if (!isWrite(context.dataSource)) {
      throw context.createError(value._methodName + "() can only be used with update() and set()");
    }
    if (!context.path) {
      throw context.createError(value._methodName + "() is not currently supported inside arrays");
    }
    var fieldTransform = value._toFieldTransform(context);
    if (fieldTransform) {
      context.fieldTransforms.push(fieldTransform);
    }
  }
  function parseScalarValue(value, context) {
    value = util.getModularInstance(value);
    if (value === null) {
      return {nullValue: "NULL_VALUE"};
    } else if (typeof value === "number") {
      return toNumber(context.serializer, value);
    } else if (typeof value === "boolean") {
      return {booleanValue: value};
    } else if (typeof value === "string") {
      return {stringValue: value};
    } else if (value instanceof Date) {
      var timestamp = Timestamp.fromDate(value);
      return {
        timestampValue: toTimestamp(context.serializer, timestamp)
      };
    } else if (value instanceof Timestamp) {
      var timestamp = new Timestamp(value.seconds, Math.floor(value.nanoseconds / 1e3) * 1e3);
      return {
        timestampValue: toTimestamp(context.serializer, timestamp)
      };
    } else if (value instanceof GeoPoint) {
      return {
        geoPointValue: {
          latitude: value.latitude,
          longitude: value.longitude
        }
      };
    } else if (value instanceof Bytes) {
      return {bytesValue: toBytes(context.serializer, value._byteString)};
    } else if (value instanceof DocumentReference) {
      var thisDb = context.databaseId;
      var otherDb = value.firestore._databaseId;
      if (!otherDb.isEqual(thisDb)) {
        throw context.createError("Document reference is for database " + (otherDb.projectId + "/" + otherDb.database + " but should be ") + ("for database " + thisDb.projectId + "/" + thisDb.database));
      }
      return {
        referenceValue: toResourceName(value.firestore._databaseId || context.databaseId, value._key.path)
      };
    } else {
      throw context.createError("Unsupported field value: " + valueDescription(value));
    }
  }
  function looksLikeJsonObject(input) {
    return typeof input === "object" && input !== null && !(input instanceof Array) && !(input instanceof Date) && !(input instanceof Timestamp) && !(input instanceof GeoPoint) && !(input instanceof Bytes) && !(input instanceof DocumentReference) && !(input instanceof FieldValue);
  }
  function validatePlainObject(message, context, input) {
    if (!looksLikeJsonObject(input) || !isPlainObject(input)) {
      var description = valueDescription(input);
      if (description === "an object") {
        throw context.createError(message + " a custom object");
      } else {
        throw context.createError(message + " " + description);
      }
    }
  }
  function fieldPathFromArgument(methodName, path2, targetDoc) {
    path2 = util.getModularInstance(path2);
    if (path2 instanceof FieldPath$1) {
      return path2._internalPath;
    } else if (typeof path2 === "string") {
      return fieldPathFromDotSeparatedString(methodName, path2);
    } else {
      var message = "Field path arguments must be of type string or FieldPath.";
      throw createError(message, methodName, false, void 0, targetDoc);
    }
  }
  var FIELD_PATH_RESERVED = new RegExp("[~\\*/\\[\\]]");
  function fieldPathFromDotSeparatedString(methodName, path2, targetDoc) {
    var found = path2.search(FIELD_PATH_RESERVED);
    if (found >= 0) {
      throw createError("Invalid field path (" + path2 + "). Paths must not contain '~', '*', '/', '[', or ']'", methodName, false, void 0, targetDoc);
    }
    try {
      return new (FieldPath$1.bind.apply(FieldPath$1, tslib.__spreadArray([void 0], path2.split("."))))()._internalPath;
    } catch (e) {
      throw createError("Invalid field path (" + path2 + "). Paths must not be empty, begin with '.', end with '.', or contain '..'", methodName, false, void 0, targetDoc);
    }
  }
  function createError(reason, methodName, hasConverter, path2, targetDoc) {
    var hasPath = path2 && !path2.isEmpty();
    var hasDocument = targetDoc !== void 0;
    var message = "Function " + methodName + "() called with invalid data";
    if (hasConverter) {
      message += " (via `toFirestore()`)";
    }
    message += ". ";
    var description = "";
    if (hasPath || hasDocument) {
      description += " (found";
      if (hasPath) {
        description += " in field " + path2;
      }
      if (hasDocument) {
        description += " in document " + targetDoc;
      }
      description += ")";
    }
    return new FirestoreError(Code.INVALID_ARGUMENT, message + reason + description);
  }
  function fieldMaskContains(haystack, needle) {
    return haystack.some(function(v) {
      return v.isEqual(needle);
    });
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var DocumentSnapshot = function() {
    function DocumentSnapshot2(_firestore, _userDataWriter, _key, _document, _converter) {
      this._firestore = _firestore;
      this._userDataWriter = _userDataWriter;
      this._key = _key;
      this._document = _document;
      this._converter = _converter;
    }
    Object.defineProperty(DocumentSnapshot2.prototype, "id", {
      get: function() {
        return this._key.path.lastSegment();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DocumentSnapshot2.prototype, "ref", {
      get: function() {
        return new DocumentReference(this._firestore, this._converter, this._key);
      },
      enumerable: false,
      configurable: true
    });
    DocumentSnapshot2.prototype.exists = function() {
      return this._document !== null;
    };
    DocumentSnapshot2.prototype.data = function() {
      if (!this._document) {
        return void 0;
      } else if (this._converter) {
        var snapshot = new QueryDocumentSnapshot(this._firestore, this._userDataWriter, this._key, this._document, null);
        return this._converter.fromFirestore(snapshot);
      } else {
        return this._userDataWriter.convertValue(this._document.data.toProto());
      }
    };
    DocumentSnapshot2.prototype.get = function(fieldPath) {
      if (this._document) {
        var value = this._document.data.field(fieldPathFromArgument$1("DocumentSnapshot.get", fieldPath));
        if (value !== null) {
          return this._userDataWriter.convertValue(value);
        }
      }
      return void 0;
    };
    return DocumentSnapshot2;
  }();
  var QueryDocumentSnapshot = function(_super) {
    tslib.__extends(QueryDocumentSnapshot2, _super);
    function QueryDocumentSnapshot2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    QueryDocumentSnapshot2.prototype.data = function() {
      return _super.prototype.data.call(this);
    };
    return QueryDocumentSnapshot2;
  }(DocumentSnapshot);
  function fieldPathFromArgument$1(methodName, arg) {
    if (typeof arg === "string") {
      return fieldPathFromDotSeparatedString(methodName, arg);
    } else if (arg instanceof FieldPath$1) {
      return arg._internalPath;
    } else {
      return arg._delegate._internalPath;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var SnapshotMetadata = function() {
    function SnapshotMetadata2(hasPendingWrites, fromCache) {
      this.hasPendingWrites = hasPendingWrites;
      this.fromCache = fromCache;
    }
    SnapshotMetadata2.prototype.isEqual = function(other) {
      return this.hasPendingWrites === other.hasPendingWrites && this.fromCache === other.fromCache;
    };
    return SnapshotMetadata2;
  }();
  var DocumentSnapshot$1 = function(_super) {
    tslib.__extends(DocumentSnapshot$12, _super);
    function DocumentSnapshot$12(_firestore, userDataWriter, key, document2, metadata, converter) {
      var _this = _super.call(this, _firestore, userDataWriter, key, document2, converter) || this;
      _this._firestore = _firestore;
      _this._firestoreImpl = _firestore;
      _this.metadata = metadata;
      return _this;
    }
    DocumentSnapshot$12.prototype.exists = function() {
      return _super.prototype.exists.call(this);
    };
    DocumentSnapshot$12.prototype.data = function(options) {
      if (options === void 0) {
        options = {};
      }
      if (!this._document) {
        return void 0;
      } else if (this._converter) {
        var snapshot = new QueryDocumentSnapshot$1(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
        return this._converter.fromFirestore(snapshot, options);
      } else {
        return this._userDataWriter.convertValue(this._document.data.toProto(), options.serverTimestamps);
      }
    };
    DocumentSnapshot$12.prototype.get = function(fieldPath, options) {
      if (options === void 0) {
        options = {};
      }
      if (this._document) {
        var value = this._document.data.field(fieldPathFromArgument$1("DocumentSnapshot.get", fieldPath));
        if (value !== null) {
          return this._userDataWriter.convertValue(value, options.serverTimestamps);
        }
      }
      return void 0;
    };
    return DocumentSnapshot$12;
  }(DocumentSnapshot);
  var QueryDocumentSnapshot$1 = function(_super) {
    tslib.__extends(QueryDocumentSnapshot$12, _super);
    function QueryDocumentSnapshot$12() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    QueryDocumentSnapshot$12.prototype.data = function(options) {
      if (options === void 0) {
        options = {};
      }
      return _super.prototype.data.call(this, options);
    };
    return QueryDocumentSnapshot$12;
  }(DocumentSnapshot$1);
  var QuerySnapshot = function() {
    function QuerySnapshot2(_firestore, _userDataWriter, query2, _snapshot) {
      this._firestore = _firestore;
      this._userDataWriter = _userDataWriter;
      this._snapshot = _snapshot;
      this.metadata = new SnapshotMetadata(_snapshot.hasPendingWrites, _snapshot.fromCache);
      this.query = query2;
    }
    Object.defineProperty(QuerySnapshot2.prototype, "docs", {
      get: function() {
        var result = [];
        this.forEach(function(doc2) {
          return result.push(doc2);
        });
        return result;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(QuerySnapshot2.prototype, "size", {
      get: function() {
        return this._snapshot.docs.size;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(QuerySnapshot2.prototype, "empty", {
      get: function() {
        return this.size === 0;
      },
      enumerable: false,
      configurable: true
    });
    QuerySnapshot2.prototype.forEach = function(callback, thisArg) {
      var _this = this;
      this._snapshot.docs.forEach(function(doc2) {
        callback.call(thisArg, new QueryDocumentSnapshot$1(_this._firestore, _this._userDataWriter, doc2.key, doc2, new SnapshotMetadata(_this._snapshot.mutatedKeys.has(doc2.key), _this._snapshot.fromCache), _this.query._converter));
      });
    };
    QuerySnapshot2.prototype.docChanges = function(options) {
      if (options === void 0) {
        options = {};
      }
      var includeMetadataChanges = !!options.includeMetadataChanges;
      if (includeMetadataChanges && this._snapshot.excludesMetadataChanges) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
      }
      if (!this._cachedChanges || this._cachedChangesIncludeMetadataChanges !== includeMetadataChanges) {
        this._cachedChanges = changesFromSnapshot(this, includeMetadataChanges);
        this._cachedChangesIncludeMetadataChanges = includeMetadataChanges;
      }
      return this._cachedChanges;
    };
    return QuerySnapshot2;
  }();
  function changesFromSnapshot(querySnapshot, includeMetadataChanges) {
    if (querySnapshot._snapshot.oldDocs.isEmpty()) {
      var lastDoc_1;
      var index_1 = 0;
      return querySnapshot._snapshot.docChanges.map(function(change) {
        var doc2 = new QueryDocumentSnapshot$1(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query._converter);
        lastDoc_1 = change.doc;
        return {
          type: "added",
          doc: doc2,
          oldIndex: -1,
          newIndex: index_1++
        };
      });
    } else {
      var indexTracker_1 = querySnapshot._snapshot.oldDocs;
      return querySnapshot._snapshot.docChanges.filter(function(change) {
        return includeMetadataChanges || change.type !== 3;
      }).map(function(change) {
        var doc2 = new QueryDocumentSnapshot$1(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query._converter);
        var oldIndex = -1;
        var newIndex = -1;
        if (change.type !== 0) {
          oldIndex = indexTracker_1.indexOf(change.doc.key);
          indexTracker_1 = indexTracker_1.delete(change.doc.key);
        }
        if (change.type !== 1) {
          indexTracker_1 = indexTracker_1.add(change.doc);
          newIndex = indexTracker_1.indexOf(change.doc.key);
        }
        return {
          type: resultChangeType(change.type),
          doc: doc2,
          oldIndex,
          newIndex
        };
      });
    }
  }
  function resultChangeType(type) {
    switch (type) {
      case 0:
        return "added";
      case 2:
      case 3:
        return "modified";
      case 1:
        return "removed";
      default:
        return fail();
    }
  }
  function snapshotEqual(left, right) {
    if (left instanceof DocumentSnapshot$1 && right instanceof DocumentSnapshot$1) {
      return left._firestore === right._firestore && left._key.isEqual(right._key) && (left._document === null ? right._document === null : left._document.isEqual(right._document)) && left._converter === right._converter;
    } else if (left instanceof QuerySnapshot && right instanceof QuerySnapshot) {
      return left._firestore === right._firestore && queryEqual(left.query, right.query) && left.metadata.isEqual(right.metadata) && left._snapshot.isEqual(right._snapshot);
    }
    return false;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function validateHasExplicitOrderByForLimitToLast(query2) {
    if (hasLimitToLast(query2) && query2.explicitOrderBy.length === 0) {
      throw new FirestoreError(Code.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
    }
  }
  var QueryConstraint = function() {
    function QueryConstraint2() {
    }
    return QueryConstraint2;
  }();
  function query(query2) {
    var queryConstraints = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      queryConstraints[_i - 1] = arguments[_i];
    }
    for (var _d = 0, queryConstraints_1 = queryConstraints; _d < queryConstraints_1.length; _d++) {
      var constraint = queryConstraints_1[_d];
      query2 = constraint._apply(query2);
    }
    return query2;
  }
  var QueryFilterConstraint = function(_super) {
    tslib.__extends(QueryFilterConstraint2, _super);
    function QueryFilterConstraint2(_field, _op, _value) {
      var _this = _super.call(this) || this;
      _this._field = _field;
      _this._op = _op;
      _this._value = _value;
      _this.type = "where";
      return _this;
    }
    QueryFilterConstraint2.prototype._apply = function(query2) {
      var reader = newUserDataReader(query2.firestore);
      var filter = newQueryFilter(query2._query, "where", reader, query2.firestore._databaseId, this._field, this._op, this._value);
      return new Query(query2.firestore, query2._converter, queryWithAddedFilter(query2._query, filter));
    };
    return QueryFilterConstraint2;
  }(QueryConstraint);
  function where(fieldPath, opStr, value) {
    var op = opStr;
    var field = fieldPathFromArgument$1("where", fieldPath);
    return new QueryFilterConstraint(field, op, value);
  }
  var QueryOrderByConstraint = function(_super) {
    tslib.__extends(QueryOrderByConstraint2, _super);
    function QueryOrderByConstraint2(_field, _direction) {
      var _this = _super.call(this) || this;
      _this._field = _field;
      _this._direction = _direction;
      _this.type = "orderBy";
      return _this;
    }
    QueryOrderByConstraint2.prototype._apply = function(query2) {
      var orderBy2 = newQueryOrderBy(query2._query, this._field, this._direction);
      return new Query(query2.firestore, query2._converter, queryWithAddedOrderBy(query2._query, orderBy2));
    };
    return QueryOrderByConstraint2;
  }(QueryConstraint);
  function orderBy(fieldPath, directionStr) {
    if (directionStr === void 0) {
      directionStr = "asc";
    }
    var direction = directionStr;
    var path2 = fieldPathFromArgument$1("orderBy", fieldPath);
    return new QueryOrderByConstraint(path2, direction);
  }
  var QueryLimitConstraint = function(_super) {
    tslib.__extends(QueryLimitConstraint2, _super);
    function QueryLimitConstraint2(type, _limit, _limitType) {
      var _this = _super.call(this) || this;
      _this.type = type;
      _this._limit = _limit;
      _this._limitType = _limitType;
      return _this;
    }
    QueryLimitConstraint2.prototype._apply = function(query2) {
      return new Query(query2.firestore, query2._converter, queryWithLimit(query2._query, this._limit, this._limitType));
    };
    return QueryLimitConstraint2;
  }(QueryConstraint);
  function limit(limit2) {
    validatePositiveNumber("limit", limit2);
    return new QueryLimitConstraint("limit", limit2, "F");
  }
  function limitToLast(limit2) {
    validatePositiveNumber("limitToLast", limit2);
    return new QueryLimitConstraint("limitToLast", limit2, "L");
  }
  var QueryStartAtConstraint = function(_super) {
    tslib.__extends(QueryStartAtConstraint2, _super);
    function QueryStartAtConstraint2(type, _docOrFields, _before) {
      var _this = _super.call(this) || this;
      _this.type = type;
      _this._docOrFields = _docOrFields;
      _this._before = _before;
      return _this;
    }
    QueryStartAtConstraint2.prototype._apply = function(query2) {
      var bound = newQueryBoundFromDocOrFields(query2, this.type, this._docOrFields, this._before);
      return new Query(query2.firestore, query2._converter, queryWithStartAt(query2._query, bound));
    };
    return QueryStartAtConstraint2;
  }(QueryConstraint);
  function startAt() {
    var docOrFields = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      docOrFields[_i] = arguments[_i];
    }
    return new QueryStartAtConstraint("startAt", docOrFields, true);
  }
  function startAfter() {
    var docOrFields = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      docOrFields[_i] = arguments[_i];
    }
    return new QueryStartAtConstraint("startAfter", docOrFields, false);
  }
  var QueryEndAtConstraint = function(_super) {
    tslib.__extends(QueryEndAtConstraint2, _super);
    function QueryEndAtConstraint2(type, _docOrFields, _before) {
      var _this = _super.call(this) || this;
      _this.type = type;
      _this._docOrFields = _docOrFields;
      _this._before = _before;
      return _this;
    }
    QueryEndAtConstraint2.prototype._apply = function(query2) {
      var bound = newQueryBoundFromDocOrFields(query2, this.type, this._docOrFields, this._before);
      return new Query(query2.firestore, query2._converter, queryWithEndAt(query2._query, bound));
    };
    return QueryEndAtConstraint2;
  }(QueryConstraint);
  function endBefore() {
    var docOrFields = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      docOrFields[_i] = arguments[_i];
    }
    return new QueryEndAtConstraint("endBefore", docOrFields, true);
  }
  function endAt() {
    var docOrFields = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      docOrFields[_i] = arguments[_i];
    }
    return new QueryEndAtConstraint("endAt", docOrFields, false);
  }
  function newQueryBoundFromDocOrFields(query2, methodName, docOrFields, before) {
    docOrFields[0] = util.getModularInstance(docOrFields[0]);
    if (docOrFields[0] instanceof DocumentSnapshot) {
      return newQueryBoundFromDocument(query2._query, query2.firestore._databaseId, methodName, docOrFields[0]._document, before);
    } else {
      var reader = newUserDataReader(query2.firestore);
      return newQueryBoundFromFields(query2._query, query2.firestore._databaseId, reader, methodName, docOrFields, before);
    }
  }
  function newQueryFilter(query2, methodName, dataReader, databaseId, fieldPath, op, value) {
    var fieldValue;
    if (fieldPath.isKeyField()) {
      if (op === "array-contains" || op === "array-contains-any") {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid Query. You can't perform '" + op + "' queries on FieldPath.documentId().");
      } else if (op === "in" || op === "not-in") {
        validateDisjunctiveFilterElements(value, op);
        var referenceList = [];
        for (var _i = 0, value_2 = value; _i < value_2.length; _i++) {
          var arrayValue = value_2[_i];
          referenceList.push(parseDocumentIdValue(databaseId, query2, arrayValue));
        }
        fieldValue = {arrayValue: {values: referenceList}};
      } else {
        fieldValue = parseDocumentIdValue(databaseId, query2, value);
      }
    } else {
      if (op === "in" || op === "not-in" || op === "array-contains-any") {
        validateDisjunctiveFilterElements(value, op);
      }
      fieldValue = parseQueryValue(dataReader, methodName, value, op === "in" || op === "not-in");
    }
    var filter = FieldFilter.create(fieldPath, op, fieldValue);
    validateNewFilter(query2, filter);
    return filter;
  }
  function newQueryOrderBy(query2, fieldPath, direction) {
    if (query2.startAt !== null) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
    }
    if (query2.endAt !== null) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
    }
    var orderBy2 = new OrderBy(fieldPath, direction);
    validateNewOrderBy(query2, orderBy2);
    return orderBy2;
  }
  function newQueryBoundFromDocument(query2, databaseId, methodName, doc2, before) {
    if (!doc2) {
      throw new FirestoreError(Code.NOT_FOUND, "Can't use a DocumentSnapshot that doesn't exist for " + (methodName + "()."));
    }
    var components = [];
    for (var _i = 0, _d = queryOrderBy(query2); _i < _d.length; _i++) {
      var orderBy_5 = _d[_i];
      if (orderBy_5.field.isKeyField()) {
        components.push(refValue(databaseId, doc2.key));
      } else {
        var value = doc2.data.field(orderBy_5.field);
        if (isServerTimestamp(value)) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + orderBy_5.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
        } else if (value !== null) {
          components.push(value);
        } else {
          var field = orderBy_5.field.canonicalString();
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You are trying to start or end a query using a " + ("document for which the field '" + field + "' (used as the ") + "orderBy) does not exist.");
        }
      }
    }
    return new Bound(components, before);
  }
  function newQueryBoundFromFields(query2, databaseId, dataReader, methodName, values, before) {
    var orderBy2 = query2.explicitOrderBy;
    if (values.length > orderBy2.length) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Too many arguments provided to " + methodName + "(). The number of arguments must be less than or equal to the number of orderBy() clauses");
    }
    var components = [];
    for (var i = 0; i < values.length; i++) {
      var rawValue = values[i];
      var orderByComponent = orderBy2[i];
      if (orderByComponent.field.isKeyField()) {
        if (typeof rawValue !== "string") {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. Expected a string for document ID in " + (methodName + "(), but got a " + typeof rawValue));
        }
        if (!isCollectionGroupQuery(query2) && rawValue.indexOf("/") !== -1) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying a collection and ordering by FieldPath.documentId(), " + ("the value passed to " + methodName + "() must be a plain document ID, but ") + ("'" + rawValue + "' contains a slash."));
        }
        var path2 = query2.path.child(ResourcePath.fromString(rawValue));
        if (!DocumentKey.isDocumentKey(path2)) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying a collection group and ordering by " + ("FieldPath.documentId(), the value passed to " + methodName + "() must result in a ") + ("valid document path, but '" + path2 + "' is not because it contains an odd number ") + "of segments.");
        }
        var key = new DocumentKey(path2);
        components.push(refValue(databaseId, key));
      } else {
        var wrapped = parseQueryValue(dataReader, methodName, rawValue);
        components.push(wrapped);
      }
    }
    return new Bound(components, before);
  }
  function parseDocumentIdValue(databaseId, query2, documentIdValue) {
    documentIdValue = util.getModularInstance(documentIdValue);
    if (typeof documentIdValue === "string") {
      if (documentIdValue === "") {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid document ID, but it was an empty string.");
      }
      if (!isCollectionGroupQuery(query2) && documentIdValue.indexOf("/") !== -1) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying a collection by FieldPath.documentId(), you must provide a plain document ID, but " + ("'" + documentIdValue + "' contains a '/' character."));
      }
      var path2 = query2.path.child(ResourcePath.fromString(documentIdValue));
      if (!DocumentKey.isDocumentKey(path2)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying a collection group by FieldPath.documentId(), the value provided must result in a valid document path, " + ("but '" + path2 + "' is not because it has an odd number of segments (" + path2.length + ")."));
      }
      return refValue(databaseId, new DocumentKey(path2));
    } else if (documentIdValue instanceof DocumentReference) {
      return refValue(databaseId, documentIdValue._key);
    } else {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid string or a DocumentReference, but it was: " + (valueDescription(documentIdValue) + "."));
    }
  }
  function validateDisjunctiveFilterElements(value, operator) {
    if (!Array.isArray(value) || value.length === 0) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid Query. A non-empty array is required for " + ("'" + operator.toString() + "' filters."));
    }
    if (value.length > 10) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid Query. '" + operator.toString() + "' filters support a maximum of 10 elements in the value array.");
    }
  }
  function conflictingOps(op) {
    switch (op) {
      case "!=":
        return ["!=", "not-in"];
      case "array-contains":
        return [
          "array-contains",
          "array-contains-any",
          "not-in"
        ];
      case "in":
        return ["array-contains-any", "in", "not-in"];
      case "array-contains-any":
        return [
          "array-contains",
          "array-contains-any",
          "in",
          "not-in"
        ];
      case "not-in":
        return [
          "array-contains",
          "array-contains-any",
          "in",
          "not-in",
          "!="
        ];
      default:
        return [];
    }
  }
  function validateNewFilter(query2, filter) {
    if (filter.isInequality()) {
      var existingField = getInequalityFilterField(query2);
      if (existingField !== null && !existingField.isEqual(filter.field)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have" + (" inequality filters on '" + existingField.toString() + "'") + (" and '" + filter.field.toString() + "'"));
      }
      var firstOrderByField = getFirstOrderByField(query2);
      if (firstOrderByField !== null) {
        validateOrderByAndInequalityMatch(query2, filter.field, firstOrderByField);
      }
    }
    var conflictingOp = findFilterOperator(query2, conflictingOps(filter.op));
    if (conflictingOp !== null) {
      if (conflictingOp === filter.op) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You cannot use more than one " + ("'" + filter.op.toString() + "' filter."));
      } else {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You cannot use '" + filter.op.toString() + "' filters " + ("with '" + conflictingOp.toString() + "' filters."));
      }
    }
  }
  function validateNewOrderBy(query2, orderBy2) {
    if (getFirstOrderByField(query2) === null) {
      var inequalityField = getInequalityFilterField(query2);
      if (inequalityField !== null) {
        validateOrderByAndInequalityMatch(query2, inequalityField, orderBy2.field);
      }
    }
  }
  function validateOrderByAndInequalityMatch(baseQuery, inequality, orderBy2) {
    if (!orderBy2.isEqual(inequality)) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You have a where filter with an inequality " + ("(<, <=, !=, not-in, >, or >=) on field '" + inequality.toString() + "' ") + ("and so you must also use '" + inequality.toString() + "' ") + "as your first argument to orderBy(), but your first orderBy() " + ("is on field '" + orderBy2.toString() + "' instead."));
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var AbstractUserDataWriter = function() {
    function AbstractUserDataWriter2() {
    }
    AbstractUserDataWriter2.prototype.convertValue = function(value, serverTimestampBehavior) {
      if (serverTimestampBehavior === void 0) {
        serverTimestampBehavior = "none";
      }
      switch (typeOrder(value)) {
        case 0:
          return null;
        case 1:
          return value.booleanValue;
        case 2:
          return normalizeNumber(value.integerValue || value.doubleValue);
        case 3:
          return this.convertTimestamp(value.timestampValue);
        case 4:
          return this.convertServerTimestamp(value, serverTimestampBehavior);
        case 5:
          return value.stringValue;
        case 6:
          return this.convertBytes(normalizeByteString(value.bytesValue));
        case 7:
          return this.convertReference(value.referenceValue);
        case 8:
          return this.convertGeoPoint(value.geoPointValue);
        case 9:
          return this.convertArray(value.arrayValue, serverTimestampBehavior);
        case 10:
          return this.convertObject(value.mapValue, serverTimestampBehavior);
        default:
          throw fail();
      }
    };
    AbstractUserDataWriter2.prototype.convertObject = function(mapValue, serverTimestampBehavior) {
      var _this = this;
      var result = {};
      forEach(mapValue.fields || {}, function(key, value) {
        result[key] = _this.convertValue(value, serverTimestampBehavior);
      });
      return result;
    };
    AbstractUserDataWriter2.prototype.convertGeoPoint = function(value) {
      return new GeoPoint(normalizeNumber(value.latitude), normalizeNumber(value.longitude));
    };
    AbstractUserDataWriter2.prototype.convertArray = function(arrayValue, serverTimestampBehavior) {
      var _this = this;
      return (arrayValue.values || []).map(function(value) {
        return _this.convertValue(value, serverTimestampBehavior);
      });
    };
    AbstractUserDataWriter2.prototype.convertServerTimestamp = function(value, serverTimestampBehavior) {
      switch (serverTimestampBehavior) {
        case "previous":
          var previousValue = getPreviousValue(value);
          if (previousValue == null) {
            return null;
          }
          return this.convertValue(previousValue, serverTimestampBehavior);
        case "estimate":
          return this.convertTimestamp(getLocalWriteTime(value));
        default:
          return null;
      }
    };
    AbstractUserDataWriter2.prototype.convertTimestamp = function(value) {
      var normalizedValue = normalizeTimestamp(value);
      return new Timestamp(normalizedValue.seconds, normalizedValue.nanos);
    };
    AbstractUserDataWriter2.prototype.convertDocumentKey = function(name, expectedDatabaseId) {
      var resourcePath = ResourcePath.fromString(name);
      hardAssert(isValidResourceName(resourcePath));
      var databaseId = new DatabaseId(resourcePath.get(1), resourcePath.get(3));
      var key = new DocumentKey(resourcePath.popFirst(5));
      if (!databaseId.isEqual(expectedDatabaseId)) {
        logError("Document " + key + " contains a document reference within a different database (" + (databaseId.projectId + "/" + databaseId.database + ") which is not ") + "supported. It will be treated as a reference in the current " + ("database (" + expectedDatabaseId.projectId + "/" + expectedDatabaseId.database + ") ") + "instead.");
      }
      return key;
    };
    return AbstractUserDataWriter2;
  }();
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function applyFirestoreDataConverter(converter, value, options) {
    var convertedValue;
    if (converter) {
      if (options && (options.merge || options.mergeFields)) {
        convertedValue = converter.toFirestore(value, options);
      } else {
        convertedValue = converter.toFirestore(value);
      }
    } else {
      convertedValue = value;
    }
    return convertedValue;
  }
  var LiteUserDataWriter = function(_super) {
    tslib.__extends(LiteUserDataWriter2, _super);
    function LiteUserDataWriter2(firestore) {
      var _this = _super.call(this) || this;
      _this.firestore = firestore;
      return _this;
    }
    LiteUserDataWriter2.prototype.convertBytes = function(bytes) {
      return new Bytes(bytes);
    };
    LiteUserDataWriter2.prototype.convertReference = function(name) {
      var key = this.convertDocumentKey(name, this.firestore._databaseId);
      return new DocumentReference(this.firestore, null, key);
    };
    return LiteUserDataWriter2;
  }(AbstractUserDataWriter);
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var WriteBatch = function() {
    function WriteBatch2(_firestore, _commitHandler) {
      this._firestore = _firestore;
      this._commitHandler = _commitHandler;
      this._mutations = [];
      this._committed = false;
      this._dataReader = newUserDataReader(_firestore);
    }
    WriteBatch2.prototype.set = function(documentRef, data, options) {
      this._verifyNotCommitted();
      var ref = validateReference(documentRef, this._firestore);
      var convertedValue = applyFirestoreDataConverter(ref._converter, data, options);
      var parsed = parseSetData(this._dataReader, "WriteBatch.set", ref._key, convertedValue, ref._converter !== null, options);
      this._mutations.push(parsed.toMutation(ref._key, Precondition.none()));
      return this;
    };
    WriteBatch2.prototype.update = function(documentRef, fieldOrUpdateData, value) {
      var moreFieldsAndValues = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        moreFieldsAndValues[_i - 3] = arguments[_i];
      }
      this._verifyNotCommitted();
      var ref = validateReference(documentRef, this._firestore);
      fieldOrUpdateData = util.getModularInstance(fieldOrUpdateData);
      var parsed;
      if (typeof fieldOrUpdateData === "string" || fieldOrUpdateData instanceof FieldPath$1) {
        parsed = parseUpdateVarargs(this._dataReader, "WriteBatch.update", ref._key, fieldOrUpdateData, value, moreFieldsAndValues);
      } else {
        parsed = parseUpdateData(this._dataReader, "WriteBatch.update", ref._key, fieldOrUpdateData);
      }
      this._mutations.push(parsed.toMutation(ref._key, Precondition.exists(true)));
      return this;
    };
    WriteBatch2.prototype.delete = function(documentRef) {
      this._verifyNotCommitted();
      var ref = validateReference(documentRef, this._firestore);
      this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.none()));
      return this;
    };
    WriteBatch2.prototype.commit = function() {
      this._verifyNotCommitted();
      this._committed = true;
      if (this._mutations.length > 0) {
        return this._commitHandler(this._mutations);
      }
      return Promise.resolve();
    };
    WriteBatch2.prototype._verifyNotCommitted = function() {
      if (this._committed) {
        throw new FirestoreError(Code.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
      }
    };
    return WriteBatch2;
  }();
  function validateReference(documentRef, firestore) {
    documentRef = util.getModularInstance(documentRef);
    if (documentRef.firestore !== firestore) {
      throw new FirestoreError(Code.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
    } else {
      return documentRef;
    }
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var Transaction$1 = function() {
    function Transaction$12(_firestore, _transaction) {
      this._firestore = _firestore;
      this._transaction = _transaction;
      this._dataReader = newUserDataReader(_firestore);
    }
    Transaction$12.prototype.get = function(documentRef) {
      var _this = this;
      var ref = validateReference(documentRef, this._firestore);
      var userDataWriter = new LiteUserDataWriter(this._firestore);
      return this._transaction.lookup([ref._key]).then(function(docs) {
        if (!docs || docs.length !== 1) {
          return fail();
        }
        var doc2 = docs[0];
        if (doc2.isFoundDocument()) {
          return new DocumentSnapshot(_this._firestore, userDataWriter, doc2.key, doc2, ref._converter);
        } else if (doc2.isNoDocument()) {
          return new DocumentSnapshot(_this._firestore, userDataWriter, ref._key, null, ref._converter);
        } else {
          throw fail();
        }
      });
    };
    Transaction$12.prototype.set = function(documentRef, value, options) {
      var ref = validateReference(documentRef, this._firestore);
      var convertedValue = applyFirestoreDataConverter(ref._converter, value, options);
      var parsed = parseSetData(this._dataReader, "Transaction.set", ref._key, convertedValue, ref._converter !== null, options);
      this._transaction.set(ref._key, parsed);
      return this;
    };
    Transaction$12.prototype.update = function(documentRef, fieldOrUpdateData, value) {
      var moreFieldsAndValues = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        moreFieldsAndValues[_i - 3] = arguments[_i];
      }
      var ref = validateReference(documentRef, this._firestore);
      fieldOrUpdateData = util.getModularInstance(fieldOrUpdateData);
      var parsed;
      if (typeof fieldOrUpdateData === "string" || fieldOrUpdateData instanceof FieldPath$1) {
        parsed = parseUpdateVarargs(this._dataReader, "Transaction.update", ref._key, fieldOrUpdateData, value, moreFieldsAndValues);
      } else {
        parsed = parseUpdateData(this._dataReader, "Transaction.update", ref._key, fieldOrUpdateData);
      }
      this._transaction.update(ref._key, parsed);
      return this;
    };
    Transaction$12.prototype.delete = function(documentRef) {
      var ref = validateReference(documentRef, this._firestore);
      this._transaction.delete(ref._key);
      return this;
    };
    return Transaction$12;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function isPartialObserver(obj) {
    return implementsAnyMethods(obj, ["next", "error", "complete"]);
  }
  function implementsAnyMethods(obj, methods) {
    if (typeof obj !== "object" || obj === null) {
      return false;
    }
    var object = obj;
    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
      var method = methods_1[_i];
      if (method in object && typeof object[method] === "function") {
        return true;
      }
    }
    return false;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function getDoc(reference) {
    reference = cast(reference, DocumentReference);
    var firestore = cast(reference.firestore, FirebaseFirestore$1);
    var client = ensureFirestoreConfigured(firestore);
    return firestoreClientGetDocumentViaSnapshotListener(client, reference._key).then(function(snapshot) {
      return convertToDocSnapshot(firestore, reference, snapshot);
    });
  }
  var ExpUserDataWriter = function(_super) {
    tslib.__extends(ExpUserDataWriter2, _super);
    function ExpUserDataWriter2(firestore) {
      var _this = _super.call(this) || this;
      _this.firestore = firestore;
      return _this;
    }
    ExpUserDataWriter2.prototype.convertBytes = function(bytes) {
      return new Bytes(bytes);
    };
    ExpUserDataWriter2.prototype.convertReference = function(name) {
      var key = this.convertDocumentKey(name, this.firestore._databaseId);
      return new DocumentReference(this.firestore, null, key);
    };
    return ExpUserDataWriter2;
  }(AbstractUserDataWriter);
  function getDocFromCache(reference) {
    reference = cast(reference, DocumentReference);
    var firestore = cast(reference.firestore, FirebaseFirestore$1);
    var client = ensureFirestoreConfigured(firestore);
    var userDataWriter = new ExpUserDataWriter(firestore);
    return firestoreClientGetDocumentFromLocalCache(client, reference._key).then(function(doc2) {
      return new DocumentSnapshot$1(firestore, userDataWriter, reference._key, doc2, new SnapshotMetadata(doc2 !== null && doc2.hasLocalMutations, true), reference._converter);
    });
  }
  function getDocFromServer(reference) {
    reference = cast(reference, DocumentReference);
    var firestore = cast(reference.firestore, FirebaseFirestore$1);
    var client = ensureFirestoreConfigured(firestore);
    return firestoreClientGetDocumentViaSnapshotListener(client, reference._key, {
      source: "server"
    }).then(function(snapshot) {
      return convertToDocSnapshot(firestore, reference, snapshot);
    });
  }
  function getDocs(query2) {
    query2 = cast(query2, Query);
    var firestore = cast(query2.firestore, FirebaseFirestore$1);
    var client = ensureFirestoreConfigured(firestore);
    var userDataWriter = new ExpUserDataWriter(firestore);
    validateHasExplicitOrderByForLimitToLast(query2._query);
    return firestoreClientGetDocumentsViaSnapshotListener(client, query2._query).then(function(snapshot) {
      return new QuerySnapshot(firestore, userDataWriter, query2, snapshot);
    });
  }
  function getDocsFromCache(query2) {
    query2 = cast(query2, Query);
    var firestore = cast(query2.firestore, FirebaseFirestore$1);
    var client = ensureFirestoreConfigured(firestore);
    var userDataWriter = new ExpUserDataWriter(firestore);
    return firestoreClientGetDocumentsFromLocalCache(client, query2._query).then(function(snapshot) {
      return new QuerySnapshot(firestore, userDataWriter, query2, snapshot);
    });
  }
  function getDocsFromServer(query2) {
    query2 = cast(query2, Query);
    var firestore = cast(query2.firestore, FirebaseFirestore$1);
    var client = ensureFirestoreConfigured(firestore);
    var userDataWriter = new ExpUserDataWriter(firestore);
    return firestoreClientGetDocumentsViaSnapshotListener(client, query2._query, {
      source: "server"
    }).then(function(snapshot) {
      return new QuerySnapshot(firestore, userDataWriter, query2, snapshot);
    });
  }
  function setDoc(reference, data, options) {
    reference = cast(reference, DocumentReference);
    var firestore = cast(reference.firestore, FirebaseFirestore$1);
    var convertedValue = applyFirestoreDataConverter(reference._converter, data, options);
    var dataReader = newUserDataReader(firestore);
    var parsed = parseSetData(dataReader, "setDoc", reference._key, convertedValue, reference._converter !== null, options);
    var mutation = parsed.toMutation(reference._key, Precondition.none());
    return executeWrite(firestore, [mutation]);
  }
  function updateDoc(reference, fieldOrUpdateData, value) {
    var moreFieldsAndValues = [];
    for (var _i = 3; _i < arguments.length; _i++) {
      moreFieldsAndValues[_i - 3] = arguments[_i];
    }
    reference = cast(reference, DocumentReference);
    var firestore = cast(reference.firestore, FirebaseFirestore$1);
    var dataReader = newUserDataReader(firestore);
    fieldOrUpdateData = util.getModularInstance(fieldOrUpdateData);
    var parsed;
    if (typeof fieldOrUpdateData === "string" || fieldOrUpdateData instanceof FieldPath$1) {
      parsed = parseUpdateVarargs(dataReader, "updateDoc", reference._key, fieldOrUpdateData, value, moreFieldsAndValues);
    } else {
      parsed = parseUpdateData(dataReader, "updateDoc", reference._key, fieldOrUpdateData);
    }
    var mutation = parsed.toMutation(reference._key, Precondition.exists(true));
    return executeWrite(firestore, [mutation]);
  }
  function deleteDoc(reference) {
    var firestore = cast(reference.firestore, FirebaseFirestore$1);
    var mutations = [new DeleteMutation(reference._key, Precondition.none())];
    return executeWrite(firestore, mutations);
  }
  function addDoc(reference, data) {
    var firestore = cast(reference.firestore, FirebaseFirestore$1);
    var docRef = doc(reference);
    var convertedValue = applyFirestoreDataConverter(reference._converter, data);
    var dataReader = newUserDataReader(reference.firestore);
    var parsed = parseSetData(dataReader, "addDoc", docRef._key, convertedValue, reference._converter !== null, {});
    var mutation = parsed.toMutation(docRef._key, Precondition.exists(false));
    return executeWrite(firestore, [mutation]).then(function() {
      return docRef;
    });
  }
  function onSnapshot(reference) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var _a, _b, _c;
    reference = util.getModularInstance(reference);
    var options = {
      includeMetadataChanges: false
    };
    var currArg = 0;
    if (typeof args[currArg] === "object" && !isPartialObserver(args[currArg])) {
      options = args[currArg];
      currArg++;
    }
    var internalOptions = {
      includeMetadataChanges: options.includeMetadataChanges
    };
    if (isPartialObserver(args[currArg])) {
      var userObserver = args[currArg];
      args[currArg] = (_a = userObserver.next) === null || _a === void 0 ? void 0 : _a.bind(userObserver);
      args[currArg + 1] = (_b = userObserver.error) === null || _b === void 0 ? void 0 : _b.bind(userObserver);
      args[currArg + 2] = (_c = userObserver.complete) === null || _c === void 0 ? void 0 : _c.bind(userObserver);
    }
    var observer;
    var firestore;
    var internalQuery;
    if (reference instanceof DocumentReference) {
      firestore = cast(reference.firestore, FirebaseFirestore$1);
      internalQuery = newQueryForPath(reference._key.path);
      observer = {
        next: function(snapshot) {
          if (args[currArg]) {
            args[currArg](convertToDocSnapshot(firestore, reference, snapshot));
          }
        },
        error: args[currArg + 1],
        complete: args[currArg + 2]
      };
    } else {
      var query_5 = cast(reference, Query);
      firestore = cast(query_5.firestore, FirebaseFirestore$1);
      internalQuery = query_5._query;
      var userDataWriter_1 = new ExpUserDataWriter(firestore);
      observer = {
        next: function(snapshot) {
          if (args[currArg]) {
            args[currArg](new QuerySnapshot(firestore, userDataWriter_1, query_5, snapshot));
          }
        },
        error: args[currArg + 1],
        complete: args[currArg + 2]
      };
      validateHasExplicitOrderByForLimitToLast(reference._query);
    }
    var client = ensureFirestoreConfigured(firestore);
    return firestoreClientListen(client, internalQuery, internalOptions, observer);
  }
  function onSnapshotsInSync(firestore, arg) {
    firestore = cast(firestore, FirebaseFirestore$1);
    var client = ensureFirestoreConfigured(firestore);
    var observer = isPartialObserver(arg) ? arg : {
      next: arg
    };
    return firestoreClientAddSnapshotsInSyncListener(client, observer);
  }
  function executeWrite(firestore, mutations) {
    var client = ensureFirestoreConfigured(firestore);
    return firestoreClientWrite(client, mutations);
  }
  function convertToDocSnapshot(firestore, ref, snapshot) {
    var doc2 = snapshot.docs.get(ref._key);
    var userDataWriter = new ExpUserDataWriter(firestore);
    return new DocumentSnapshot$1(firestore, userDataWriter, ref._key, doc2, new SnapshotMetadata(snapshot.hasPendingWrites, snapshot.fromCache), ref._converter);
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var Transaction$2 = function(_super) {
    tslib.__extends(Transaction$22, _super);
    function Transaction$22(_firestore, _transaction) {
      var _this = _super.call(this, _firestore, _transaction) || this;
      _this._firestore = _firestore;
      return _this;
    }
    Transaction$22.prototype.get = function(documentRef) {
      var _this = this;
      var ref = validateReference(documentRef, this._firestore);
      var userDataWriter = new ExpUserDataWriter(this._firestore);
      return _super.prototype.get.call(this, documentRef).then(function(liteDocumentSnapshot) {
        return new DocumentSnapshot$1(_this._firestore, userDataWriter, ref._key, liteDocumentSnapshot._document, new SnapshotMetadata(false, false), ref._converter);
      });
    };
    return Transaction$22;
  }(Transaction$1);
  function runTransaction(firestore, updateFunction) {
    var client = ensureFirestoreConfigured(firestore);
    return firestoreClientTransaction(client, function(internalTransaction) {
      return updateFunction(new Transaction$2(firestore, internalTransaction));
    });
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function assertUint8ArrayAvailable() {
    if (typeof Uint8Array === "undefined") {
      throw new FirestoreError(Code.UNIMPLEMENTED, "Uint8Arrays are not available in this environment.");
    }
  }
  var Blob2 = function() {
    function Blob3(_delegate) {
      this._delegate = _delegate;
    }
    Blob3.fromBase64String = function(base64) {
      return new Blob3(Bytes.fromBase64String(base64));
    };
    Blob3.fromUint8Array = function(array) {
      assertUint8ArrayAvailable();
      return new Blob3(Bytes.fromUint8Array(array));
    };
    Blob3.prototype.toBase64 = function() {
      return this._delegate.toBase64();
    };
    Blob3.prototype.toUint8Array = function() {
      assertUint8ArrayAvailable();
      return this._delegate.toUint8Array();
    };
    Blob3.prototype.isEqual = function(other) {
      return this._delegate.isEqual(other._delegate);
    };
    Blob3.prototype.toString = function() {
      return "Blob(base64: " + this.toBase64() + ")";
    };
    return Blob3;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var IndexedDbPersistenceProvider = function() {
    function IndexedDbPersistenceProvider2() {
    }
    IndexedDbPersistenceProvider2.prototype.enableIndexedDbPersistence = function(firestore, forceOwnership) {
      return enableIndexedDbPersistence(firestore._delegate, {forceOwnership});
    };
    IndexedDbPersistenceProvider2.prototype.enableMultiTabIndexedDbPersistence = function(firestore) {
      return enableMultiTabIndexedDbPersistence(firestore._delegate);
    };
    IndexedDbPersistenceProvider2.prototype.clearIndexedDbPersistence = function(firestore) {
      return clearIndexedDbPersistence(firestore._delegate);
    };
    return IndexedDbPersistenceProvider2;
  }();
  var Firestore = function() {
    function Firestore2(databaseIdOrApp, _delegate, _persistenceProvider) {
      var _this = this;
      this._delegate = _delegate;
      this._persistenceProvider = _persistenceProvider;
      this.INTERNAL = {
        delete: function() {
          return _this.terminate();
        }
      };
      if (!(databaseIdOrApp instanceof DatabaseId)) {
        this._appCompat = databaseIdOrApp;
      }
    }
    Object.defineProperty(Firestore2.prototype, "_databaseId", {
      get: function() {
        return this._delegate._databaseId;
      },
      enumerable: false,
      configurable: true
    });
    Firestore2.prototype.settings = function(settingsLiteral) {
      if (settingsLiteral.merge) {
        settingsLiteral = Object.assign(Object.assign({}, this._delegate._getSettings()), settingsLiteral);
        delete settingsLiteral.merge;
      }
      this._delegate._setSettings(settingsLiteral);
    };
    Firestore2.prototype.useEmulator = function(host, port) {
      useFirestoreEmulator(this._delegate, host, port);
    };
    Firestore2.prototype.enableNetwork = function() {
      return enableNetwork(this._delegate);
    };
    Firestore2.prototype.disableNetwork = function() {
      return disableNetwork(this._delegate);
    };
    Firestore2.prototype.enablePersistence = function(settings) {
      var synchronizeTabs = false;
      var experimentalForceOwningTab = false;
      if (settings) {
        synchronizeTabs = !!settings.synchronizeTabs;
        experimentalForceOwningTab = !!settings.experimentalForceOwningTab;
        validateIsNotUsedTogether("synchronizeTabs", synchronizeTabs, "experimentalForceOwningTab", experimentalForceOwningTab);
      }
      return synchronizeTabs ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this) : this._persistenceProvider.enableIndexedDbPersistence(this, experimentalForceOwningTab);
    };
    Firestore2.prototype.clearPersistence = function() {
      return this._persistenceProvider.clearIndexedDbPersistence(this);
    };
    Firestore2.prototype.terminate = function() {
      if (this._appCompat) {
        this._appCompat._removeServiceInstance("firestore");
        this._appCompat._removeServiceInstance("firestore-exp");
      }
      return this._delegate._delete();
    };
    Firestore2.prototype.waitForPendingWrites = function() {
      return waitForPendingWrites(this._delegate);
    };
    Firestore2.prototype.onSnapshotsInSync = function(arg) {
      return onSnapshotsInSync(this._delegate, arg);
    };
    Object.defineProperty(Firestore2.prototype, "app", {
      get: function() {
        if (!this._appCompat) {
          throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
        }
        return this._appCompat;
      },
      enumerable: false,
      configurable: true
    });
    Firestore2.prototype.collection = function(pathString) {
      try {
        return new CollectionReference$1(this, collection(this._delegate, pathString));
      } catch (e) {
        throw replaceFunctionName(e, "collection()", "Firestore.collection()");
      }
    };
    Firestore2.prototype.doc = function(pathString) {
      try {
        return new DocumentReference$1(this, doc(this._delegate, pathString));
      } catch (e) {
        throw replaceFunctionName(e, "doc()", "Firestore.doc()");
      }
    };
    Firestore2.prototype.collectionGroup = function(collectionId) {
      try {
        return new Query$1(this, collectionGroup(this._delegate, collectionId));
      } catch (e) {
        throw replaceFunctionName(e, "collectionGroup()", "Firestore.collectionGroup()");
      }
    };
    Firestore2.prototype.runTransaction = function(updateFunction) {
      var _this = this;
      return runTransaction(this._delegate, function(transaction) {
        return updateFunction(new Transaction$3(_this, transaction));
      });
    };
    Firestore2.prototype.batch = function() {
      var _this = this;
      ensureFirestoreConfigured(this._delegate);
      return new WriteBatch$1(new WriteBatch(this._delegate, function(mutations) {
        return executeWrite(_this._delegate, mutations);
      }));
    };
    Firestore2.prototype.loadBundle = function(bundleData) {
      throw new FirestoreError(Code.FAILED_PRECONDITION, '"loadBundle()" does not exist, have you imported "firebase/firestore/bundle"?');
    };
    Firestore2.prototype.namedQuery = function(name) {
      throw new FirestoreError(Code.FAILED_PRECONDITION, '"namedQuery()" does not exist, have you imported "firebase/firestore/bundle"?');
    };
    return Firestore2;
  }();
  var UserDataWriter = function(_super) {
    tslib.__extends(UserDataWriter2, _super);
    function UserDataWriter2(firestore) {
      var _this = _super.call(this) || this;
      _this.firestore = firestore;
      return _this;
    }
    UserDataWriter2.prototype.convertBytes = function(bytes) {
      return new Blob2(new Bytes(bytes));
    };
    UserDataWriter2.prototype.convertReference = function(name) {
      var key = this.convertDocumentKey(name, this.firestore._databaseId);
      return DocumentReference$1.forKey(key, this.firestore, null);
    };
    return UserDataWriter2;
  }(AbstractUserDataWriter);
  function setLogLevel$1(level) {
    setLogLevel(level);
  }
  var Transaction$3 = function() {
    function Transaction$32(_firestore, _delegate) {
      this._firestore = _firestore;
      this._delegate = _delegate;
      this._userDataWriter = new UserDataWriter(_firestore);
    }
    Transaction$32.prototype.get = function(documentRef) {
      var _this = this;
      var ref = castReference(documentRef);
      return this._delegate.get(ref).then(function(result) {
        return new DocumentSnapshot$2(_this._firestore, new DocumentSnapshot$1(_this._firestore._delegate, _this._userDataWriter, result._key, result._document, result.metadata, ref._converter));
      });
    };
    Transaction$32.prototype.set = function(documentRef, data, options) {
      var ref = castReference(documentRef);
      if (options) {
        validateSetOptions("Transaction.set", options);
        this._delegate.set(ref, data, options);
      } else {
        this._delegate.set(ref, data);
      }
      return this;
    };
    Transaction$32.prototype.update = function(documentRef, dataOrField, value) {
      var _d;
      var moreFieldsAndValues = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        moreFieldsAndValues[_i - 3] = arguments[_i];
      }
      var ref = castReference(documentRef);
      if (arguments.length === 2) {
        this._delegate.update(ref, dataOrField);
      } else {
        (_d = this._delegate).update.apply(_d, tslib.__spreadArray([ref, dataOrField, value], moreFieldsAndValues));
      }
      return this;
    };
    Transaction$32.prototype.delete = function(documentRef) {
      var ref = castReference(documentRef);
      this._delegate.delete(ref);
      return this;
    };
    return Transaction$32;
  }();
  var WriteBatch$1 = function() {
    function WriteBatch$12(_delegate) {
      this._delegate = _delegate;
    }
    WriteBatch$12.prototype.set = function(documentRef, data, options) {
      var ref = castReference(documentRef);
      if (options) {
        validateSetOptions("WriteBatch.set", options);
        this._delegate.set(ref, data, options);
      } else {
        this._delegate.set(ref, data);
      }
      return this;
    };
    WriteBatch$12.prototype.update = function(documentRef, dataOrField, value) {
      var _d;
      var moreFieldsAndValues = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        moreFieldsAndValues[_i - 3] = arguments[_i];
      }
      var ref = castReference(documentRef);
      if (arguments.length === 2) {
        this._delegate.update(ref, dataOrField);
      } else {
        (_d = this._delegate).update.apply(_d, tslib.__spreadArray([ref, dataOrField, value], moreFieldsAndValues));
      }
      return this;
    };
    WriteBatch$12.prototype.delete = function(documentRef) {
      var ref = castReference(documentRef);
      this._delegate.delete(ref);
      return this;
    };
    WriteBatch$12.prototype.commit = function() {
      return this._delegate.commit();
    };
    return WriteBatch$12;
  }();
  var FirestoreDataConverter = function() {
    function FirestoreDataConverter2(_firestore, _userDataWriter, _delegate) {
      this._firestore = _firestore;
      this._userDataWriter = _userDataWriter;
      this._delegate = _delegate;
    }
    FirestoreDataConverter2.prototype.fromFirestore = function(snapshot, options) {
      var expSnapshot = new QueryDocumentSnapshot$1(this._firestore._delegate, this._userDataWriter, snapshot._key, snapshot._document, snapshot.metadata, null);
      return this._delegate.fromFirestore(new QueryDocumentSnapshot$2(this._firestore, expSnapshot), options !== null && options !== void 0 ? options : {});
    };
    FirestoreDataConverter2.prototype.toFirestore = function(modelObject, options) {
      if (!options) {
        return this._delegate.toFirestore(modelObject);
      } else {
        return this._delegate.toFirestore(modelObject, options);
      }
    };
    FirestoreDataConverter2.getInstance = function(firestore, converter) {
      var converterMapByFirestore = FirestoreDataConverter2.INSTANCES;
      var untypedConverterByConverter = converterMapByFirestore.get(firestore);
      if (!untypedConverterByConverter) {
        untypedConverterByConverter = new WeakMap();
        converterMapByFirestore.set(firestore, untypedConverterByConverter);
      }
      var instance = untypedConverterByConverter.get(converter);
      if (!instance) {
        instance = new FirestoreDataConverter2(firestore, new UserDataWriter(firestore), converter);
        untypedConverterByConverter.set(converter, instance);
      }
      return instance;
    };
    return FirestoreDataConverter2;
  }();
  FirestoreDataConverter.INSTANCES = new WeakMap();
  var DocumentReference$1 = function() {
    function DocumentReference$12(firestore, _delegate) {
      this.firestore = firestore;
      this._delegate = _delegate;
      this._userDataWriter = new UserDataWriter(firestore);
    }
    DocumentReference$12.forPath = function(path2, firestore, converter) {
      if (path2.length % 2 !== 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid document reference. Document references must have an even number of segments, but " + (path2.canonicalString() + " has " + path2.length));
      }
      return new DocumentReference$12(firestore, new DocumentReference(firestore._delegate, converter, new DocumentKey(path2)));
    };
    DocumentReference$12.forKey = function(key, firestore, converter) {
      return new DocumentReference$12(firestore, new DocumentReference(firestore._delegate, converter, key));
    };
    Object.defineProperty(DocumentReference$12.prototype, "id", {
      get: function() {
        return this._delegate.id;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DocumentReference$12.prototype, "parent", {
      get: function() {
        return new CollectionReference$1(this.firestore, this._delegate.parent);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DocumentReference$12.prototype, "path", {
      get: function() {
        return this._delegate.path;
      },
      enumerable: false,
      configurable: true
    });
    DocumentReference$12.prototype.collection = function(pathString) {
      try {
        return new CollectionReference$1(this.firestore, collection(this._delegate, pathString));
      } catch (e) {
        throw replaceFunctionName(e, "collection()", "DocumentReference.collection()");
      }
    };
    DocumentReference$12.prototype.isEqual = function(other) {
      other = util.getModularInstance(other);
      if (!(other instanceof DocumentReference)) {
        return false;
      }
      return refEqual(this._delegate, other);
    };
    DocumentReference$12.prototype.set = function(value, options) {
      options = validateSetOptions("DocumentReference.set", options);
      try {
        return setDoc(this._delegate, value, options);
      } catch (e) {
        throw replaceFunctionName(e, "setDoc()", "DocumentReference.set()");
      }
    };
    DocumentReference$12.prototype.update = function(fieldOrUpdateData, value) {
      var moreFieldsAndValues = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        moreFieldsAndValues[_i - 2] = arguments[_i];
      }
      try {
        if (arguments.length === 1) {
          return updateDoc(this._delegate, fieldOrUpdateData);
        } else {
          return updateDoc.apply(void 0, tslib.__spreadArray([this._delegate, fieldOrUpdateData, value], moreFieldsAndValues));
        }
      } catch (e) {
        throw replaceFunctionName(e, "updateDoc()", "DocumentReference.update()");
      }
    };
    DocumentReference$12.prototype.delete = function() {
      return deleteDoc(this._delegate);
    };
    DocumentReference$12.prototype.onSnapshot = function() {
      var _this = this;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var options = extractSnapshotOptions(args);
      var observer = wrapObserver(args, function(result) {
        return new DocumentSnapshot$2(_this.firestore, new DocumentSnapshot$1(_this.firestore._delegate, _this._userDataWriter, result._key, result._document, result.metadata, _this._delegate._converter));
      });
      return onSnapshot(this._delegate, options, observer);
    };
    DocumentReference$12.prototype.get = function(options) {
      var _this = this;
      var snap;
      if ((options === null || options === void 0 ? void 0 : options.source) === "cache") {
        snap = getDocFromCache(this._delegate);
      } else if ((options === null || options === void 0 ? void 0 : options.source) === "server") {
        snap = getDocFromServer(this._delegate);
      } else {
        snap = getDoc(this._delegate);
      }
      return snap.then(function(result) {
        return new DocumentSnapshot$2(_this.firestore, new DocumentSnapshot$1(_this.firestore._delegate, _this._userDataWriter, result._key, result._document, result.metadata, _this._delegate._converter));
      });
    };
    DocumentReference$12.prototype.withConverter = function(converter) {
      return new DocumentReference$12(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
    };
    return DocumentReference$12;
  }();
  function replaceFunctionName(e, original, updated) {
    e.message = e.message.replace(original, updated);
    return e;
  }
  function extractSnapshotOptions(args) {
    for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
      var arg = args_1[_i];
      if (typeof arg === "object" && !isPartialObserver(arg)) {
        return arg;
      }
    }
    return {};
  }
  function wrapObserver(args, wrapper) {
    var _a, _b;
    var userObserver;
    if (isPartialObserver(args[0])) {
      userObserver = args[0];
    } else if (isPartialObserver(args[1])) {
      userObserver = args[1];
    } else if (typeof args[0] === "function") {
      userObserver = {
        next: args[0],
        error: args[1],
        complete: args[2]
      };
    } else {
      userObserver = {
        next: args[1],
        error: args[2],
        complete: args[3]
      };
    }
    return {
      next: function(val) {
        if (userObserver.next) {
          userObserver.next(wrapper(val));
        }
      },
      error: (_a = userObserver.error) === null || _a === void 0 ? void 0 : _a.bind(userObserver),
      complete: (_b = userObserver.complete) === null || _b === void 0 ? void 0 : _b.bind(userObserver)
    };
  }
  var DocumentSnapshot$2 = function() {
    function DocumentSnapshot$22(_firestore, _delegate) {
      this._firestore = _firestore;
      this._delegate = _delegate;
    }
    Object.defineProperty(DocumentSnapshot$22.prototype, "ref", {
      get: function() {
        return new DocumentReference$1(this._firestore, this._delegate.ref);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DocumentSnapshot$22.prototype, "id", {
      get: function() {
        return this._delegate.id;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DocumentSnapshot$22.prototype, "metadata", {
      get: function() {
        return this._delegate.metadata;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DocumentSnapshot$22.prototype, "exists", {
      get: function() {
        return this._delegate.exists();
      },
      enumerable: false,
      configurable: true
    });
    DocumentSnapshot$22.prototype.data = function(options) {
      return this._delegate.data(options);
    };
    DocumentSnapshot$22.prototype.get = function(fieldPath, options) {
      return this._delegate.get(fieldPath, options);
    };
    DocumentSnapshot$22.prototype.isEqual = function(other) {
      return snapshotEqual(this._delegate, other._delegate);
    };
    return DocumentSnapshot$22;
  }();
  var QueryDocumentSnapshot$2 = function(_super) {
    tslib.__extends(QueryDocumentSnapshot$22, _super);
    function QueryDocumentSnapshot$22() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    QueryDocumentSnapshot$22.prototype.data = function(options) {
      var data = this._delegate.data(options);
      return data;
    };
    return QueryDocumentSnapshot$22;
  }(DocumentSnapshot$2);
  var Query$1 = function() {
    function Query$12(firestore, _delegate) {
      this.firestore = firestore;
      this._delegate = _delegate;
      this._userDataWriter = new UserDataWriter(firestore);
    }
    Query$12.prototype.where = function(fieldPath, opStr, value) {
      try {
        return new Query$12(this.firestore, query(this._delegate, where(fieldPath, opStr, value)));
      } catch (e) {
        throw replaceFunctionName(e, /(orderBy|where)\(\)/, "Query.$1()");
      }
    };
    Query$12.prototype.orderBy = function(fieldPath, directionStr) {
      try {
        return new Query$12(this.firestore, query(this._delegate, orderBy(fieldPath, directionStr)));
      } catch (e) {
        throw replaceFunctionName(e, /(orderBy|where)\(\)/, "Query.$1()");
      }
    };
    Query$12.prototype.limit = function(n) {
      try {
        return new Query$12(this.firestore, query(this._delegate, limit(n)));
      } catch (e) {
        throw replaceFunctionName(e, "limit()", "Query.limit()");
      }
    };
    Query$12.prototype.limitToLast = function(n) {
      try {
        return new Query$12(this.firestore, query(this._delegate, limitToLast(n)));
      } catch (e) {
        throw replaceFunctionName(e, "limitToLast()", "Query.limitToLast()");
      }
    };
    Query$12.prototype.startAt = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      try {
        return new Query$12(this.firestore, query(this._delegate, startAt.apply(void 0, args)));
      } catch (e) {
        throw replaceFunctionName(e, "startAt()", "Query.startAt()");
      }
    };
    Query$12.prototype.startAfter = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      try {
        return new Query$12(this.firestore, query(this._delegate, startAfter.apply(void 0, args)));
      } catch (e) {
        throw replaceFunctionName(e, "startAfter()", "Query.startAfter()");
      }
    };
    Query$12.prototype.endBefore = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      try {
        return new Query$12(this.firestore, query(this._delegate, endBefore.apply(void 0, args)));
      } catch (e) {
        throw replaceFunctionName(e, "endBefore()", "Query.endBefore()");
      }
    };
    Query$12.prototype.endAt = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      try {
        return new Query$12(this.firestore, query(this._delegate, endAt.apply(void 0, args)));
      } catch (e) {
        throw replaceFunctionName(e, "endAt()", "Query.endAt()");
      }
    };
    Query$12.prototype.isEqual = function(other) {
      return queryEqual(this._delegate, other._delegate);
    };
    Query$12.prototype.get = function(options) {
      var _this = this;
      var query2;
      if ((options === null || options === void 0 ? void 0 : options.source) === "cache") {
        query2 = getDocsFromCache(this._delegate);
      } else if ((options === null || options === void 0 ? void 0 : options.source) === "server") {
        query2 = getDocsFromServer(this._delegate);
      } else {
        query2 = getDocs(this._delegate);
      }
      return query2.then(function(result) {
        return new QuerySnapshot$1(_this.firestore, new QuerySnapshot(_this.firestore._delegate, _this._userDataWriter, _this._delegate, result._snapshot));
      });
    };
    Query$12.prototype.onSnapshot = function() {
      var _this = this;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var options = extractSnapshotOptions(args);
      var observer = wrapObserver(args, function(snap) {
        return new QuerySnapshot$1(_this.firestore, new QuerySnapshot(_this.firestore._delegate, _this._userDataWriter, _this._delegate, snap._snapshot));
      });
      return onSnapshot(this._delegate, options, observer);
    };
    Query$12.prototype.withConverter = function(converter) {
      return new Query$12(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
    };
    return Query$12;
  }();
  var DocumentChange = function() {
    function DocumentChange2(_firestore, _delegate) {
      this._firestore = _firestore;
      this._delegate = _delegate;
    }
    Object.defineProperty(DocumentChange2.prototype, "type", {
      get: function() {
        return this._delegate.type;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DocumentChange2.prototype, "doc", {
      get: function() {
        return new QueryDocumentSnapshot$2(this._firestore, this._delegate.doc);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DocumentChange2.prototype, "oldIndex", {
      get: function() {
        return this._delegate.oldIndex;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DocumentChange2.prototype, "newIndex", {
      get: function() {
        return this._delegate.newIndex;
      },
      enumerable: false,
      configurable: true
    });
    return DocumentChange2;
  }();
  var QuerySnapshot$1 = function() {
    function QuerySnapshot$12(_firestore, _delegate) {
      this._firestore = _firestore;
      this._delegate = _delegate;
    }
    Object.defineProperty(QuerySnapshot$12.prototype, "query", {
      get: function() {
        return new Query$1(this._firestore, this._delegate.query);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(QuerySnapshot$12.prototype, "metadata", {
      get: function() {
        return this._delegate.metadata;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(QuerySnapshot$12.prototype, "size", {
      get: function() {
        return this._delegate.size;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(QuerySnapshot$12.prototype, "empty", {
      get: function() {
        return this._delegate.empty;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(QuerySnapshot$12.prototype, "docs", {
      get: function() {
        var _this = this;
        return this._delegate.docs.map(function(doc2) {
          return new QueryDocumentSnapshot$2(_this._firestore, doc2);
        });
      },
      enumerable: false,
      configurable: true
    });
    QuerySnapshot$12.prototype.docChanges = function(options) {
      var _this = this;
      return this._delegate.docChanges(options).map(function(docChange) {
        return new DocumentChange(_this._firestore, docChange);
      });
    };
    QuerySnapshot$12.prototype.forEach = function(callback, thisArg) {
      var _this = this;
      this._delegate.forEach(function(snapshot) {
        callback.call(thisArg, new QueryDocumentSnapshot$2(_this._firestore, snapshot));
      });
    };
    QuerySnapshot$12.prototype.isEqual = function(other) {
      return snapshotEqual(this._delegate, other._delegate);
    };
    return QuerySnapshot$12;
  }();
  var CollectionReference$1 = function(_super) {
    tslib.__extends(CollectionReference$12, _super);
    function CollectionReference$12(firestore, _delegate) {
      var _this = _super.call(this, firestore, _delegate) || this;
      _this.firestore = firestore;
      _this._delegate = _delegate;
      return _this;
    }
    Object.defineProperty(CollectionReference$12.prototype, "id", {
      get: function() {
        return this._delegate.id;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CollectionReference$12.prototype, "path", {
      get: function() {
        return this._delegate.path;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CollectionReference$12.prototype, "parent", {
      get: function() {
        var docRef = this._delegate.parent;
        return docRef ? new DocumentReference$1(this.firestore, docRef) : null;
      },
      enumerable: false,
      configurable: true
    });
    CollectionReference$12.prototype.doc = function(documentPath) {
      try {
        if (documentPath === void 0) {
          return new DocumentReference$1(this.firestore, doc(this._delegate));
        } else {
          return new DocumentReference$1(this.firestore, doc(this._delegate, documentPath));
        }
      } catch (e) {
        throw replaceFunctionName(e, "doc()", "CollectionReference.doc()");
      }
    };
    CollectionReference$12.prototype.add = function(data) {
      var _this = this;
      return addDoc(this._delegate, data).then(function(docRef) {
        return new DocumentReference$1(_this.firestore, docRef);
      });
    };
    CollectionReference$12.prototype.isEqual = function(other) {
      return refEqual(this._delegate, other._delegate);
    };
    CollectionReference$12.prototype.withConverter = function(converter) {
      return new CollectionReference$12(this.firestore, converter ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter)) : this._delegate.withConverter(null));
    };
    return CollectionReference$12;
  }(Query$1);
  function castReference(documentRef) {
    return cast(documentRef, DocumentReference);
  }
  exports2.ArrayRemoveFieldValueImpl = ArrayRemoveFieldValueImpl;
  exports2.ArrayUnionFieldValueImpl = ArrayUnionFieldValueImpl;
  exports2.Blob = Blob2;
  exports2.CACHE_SIZE_UNLIMITED = CACHE_SIZE_UNLIMITED;
  exports2.CollectionReference$1 = CollectionReference$1;
  exports2.DeleteFieldValueImpl = DeleteFieldValueImpl;
  exports2.DocumentReference$1 = DocumentReference$1;
  exports2.DocumentSnapshot$2 = DocumentSnapshot$2;
  exports2.FieldPath = FieldPath;
  exports2.FieldPath$1 = FieldPath$1;
  exports2.FirebaseFirestore$1 = FirebaseFirestore$1;
  exports2.Firestore = Firestore;
  exports2.GeoPoint = GeoPoint;
  exports2.IndexedDbPersistenceProvider = IndexedDbPersistenceProvider;
  exports2.NumericIncrementFieldValueImpl = NumericIncrementFieldValueImpl;
  exports2.Query$1 = Query$1;
  exports2.QueryDocumentSnapshot$2 = QueryDocumentSnapshot$2;
  exports2.QuerySnapshot$1 = QuerySnapshot$1;
  exports2.ServerTimestampFieldValueImpl = ServerTimestampFieldValueImpl;
  exports2.Timestamp = Timestamp;
  exports2.Transaction$3 = Transaction$3;
  exports2.WriteBatch$1 = WriteBatch$1;
  exports2.loadBundle = loadBundle;
  exports2.namedQuery = namedQuery;
  exports2.setLogLevel$1 = setLogLevel$1;
});

// node_modules/@firebase/firestore/dist/node-cjs/index.js
var require_node_cjs = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var tslib = require_tslib();
  var firebase2 = require_index_node_cjs2();
  var util = require_index_node_cjs();
  var component = require_index_cjs();
  require_index_cjs2();
  require("util");
  require("crypto");
  require_src8();
  require_package2();
  require("path");
  require_src10();
  var database31f1ed21 = require_database_31f1ed21_f1c2f54e();
  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : {default: e};
  }
  var firebase__default = /* @__PURE__ */ _interopDefaultLegacy(firebase2);
  var name = "@firebase/firestore";
  var version = "2.2.3";
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function deleteField() {
    return new database31f1ed21.DeleteFieldValueImpl("deleteField");
  }
  function serverTimestamp() {
    return new database31f1ed21.ServerTimestampFieldValueImpl("serverTimestamp");
  }
  function arrayUnion() {
    var elements = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      elements[_i] = arguments[_i];
    }
    return new database31f1ed21.ArrayUnionFieldValueImpl("arrayUnion", elements);
  }
  function arrayRemove() {
    var elements = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      elements[_i] = arguments[_i];
    }
    return new database31f1ed21.ArrayRemoveFieldValueImpl("arrayRemove", elements);
  }
  function increment(n) {
    return new database31f1ed21.NumericIncrementFieldValueImpl("increment", n);
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var FieldPath = function() {
    function FieldPath2() {
      var fieldNames = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fieldNames[_i] = arguments[_i];
      }
      this._delegate = new (database31f1ed21.FieldPath$1.bind.apply(database31f1ed21.FieldPath$1, tslib.__spreadArray([void 0], fieldNames)))();
    }
    FieldPath2.documentId = function() {
      return new FieldPath2(database31f1ed21.FieldPath.keyField().canonicalString());
    };
    FieldPath2.prototype.isEqual = function(other) {
      other = util.getModularInstance(other);
      if (!(other instanceof database31f1ed21.FieldPath$1)) {
        return false;
      }
      return this._delegate._internalPath.isEqual(other._internalPath);
    };
    return FieldPath2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var FieldValue = function() {
    function FieldValue2(_delegate) {
      this._delegate = _delegate;
    }
    FieldValue2.serverTimestamp = function() {
      var delegate = serverTimestamp();
      delegate._methodName = "FieldValue.serverTimestamp";
      return new FieldValue2(delegate);
    };
    FieldValue2.delete = function() {
      var delegate = deleteField();
      delegate._methodName = "FieldValue.delete";
      return new FieldValue2(delegate);
    };
    FieldValue2.arrayUnion = function() {
      var elements = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        elements[_i] = arguments[_i];
      }
      var delegate = arrayUnion.apply(void 0, elements);
      delegate._methodName = "FieldValue.arrayUnion";
      return new FieldValue2(delegate);
    };
    FieldValue2.arrayRemove = function() {
      var elements = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        elements[_i] = arguments[_i];
      }
      var delegate = arrayRemove.apply(void 0, elements);
      delegate._methodName = "FieldValue.arrayRemove";
      return new FieldValue2(delegate);
    };
    FieldValue2.increment = function(n) {
      var delegate = increment(n);
      delegate._methodName = "FieldValue.increment";
      return new FieldValue2(delegate);
    };
    FieldValue2.prototype.isEqual = function(other) {
      return this._delegate.isEqual(other._delegate);
    };
    return FieldValue2;
  }();
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var firestoreNamespace = {
    Firestore: database31f1ed21.Firestore,
    GeoPoint: database31f1ed21.GeoPoint,
    Timestamp: database31f1ed21.Timestamp,
    Blob: database31f1ed21.Blob,
    Transaction: database31f1ed21.Transaction$3,
    WriteBatch: database31f1ed21.WriteBatch$1,
    DocumentReference: database31f1ed21.DocumentReference$1,
    DocumentSnapshot: database31f1ed21.DocumentSnapshot$2,
    Query: database31f1ed21.Query$1,
    QueryDocumentSnapshot: database31f1ed21.QueryDocumentSnapshot$2,
    QuerySnapshot: database31f1ed21.QuerySnapshot$1,
    CollectionReference: database31f1ed21.CollectionReference$1,
    FieldPath,
    FieldValue,
    setLogLevel: database31f1ed21.setLogLevel$1,
    CACHE_SIZE_UNLIMITED: database31f1ed21.CACHE_SIZE_UNLIMITED
  };
  function configureForFirebase(firebase3, firestoreFactory) {
    firebase3.INTERNAL.registerComponent(new component.Component("firestore", function(container) {
      var app2 = container.getProvider("app").getImmediate();
      return firestoreFactory(app2, container.getProvider("auth-internal"));
    }, "PUBLIC").setServiceProps(Object.assign({}, firestoreNamespace)));
  }
  /**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  function registerFirestore(instance) {
    configureForFirebase(instance, function(app2, auth) {
      return new database31f1ed21.Firestore(app2, new database31f1ed21.FirebaseFirestore$1(app2, auth), new database31f1ed21.IndexedDbPersistenceProvider());
    });
    instance.registerVersion(name, version, "node");
  }
  registerFirestore(firebase__default["default"]);
  exports2.registerFirestore = registerFirestore;
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports2, module2) => {
  var fs = require("fs");
  var path = require("path");
  function log(message) {
    console.log(`[dotenv][DEBUG] ${message}`);
  }
  var NEWLINE = "\n";
  var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
  var RE_NEWLINES = /\\n/g;
  var NEWLINES_MATCH = /\n|\r|\r\n/;
  function parse(src, options) {
    const debug = Boolean(options && options.debug);
    const obj = {};
    src.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
      const keyValueArr = line.match(RE_INI_KEY_VAL);
      if (keyValueArr != null) {
        const key = keyValueArr[1];
        let val = keyValueArr[2] || "";
        const end = val.length - 1;
        const isDoubleQuoted = val[0] === '"' && val[end] === '"';
        const isSingleQuoted = val[0] === "'" && val[end] === "'";
        if (isSingleQuoted || isDoubleQuoted) {
          val = val.substring(1, end);
          if (isDoubleQuoted) {
            val = val.replace(RE_NEWLINES, NEWLINE);
          }
        } else {
          val = val.trim();
        }
        obj[key] = val;
      } else if (debug) {
        log(`did not match key and value when parsing line ${idx + 1}: ${line}`);
      }
    });
    return obj;
  }
  function config(options) {
    let dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    let debug = false;
    if (options) {
      if (options.path != null) {
        dotenvPath = options.path;
      }
      if (options.encoding != null) {
        encoding = options.encoding;
      }
      if (options.debug != null) {
        debug = true;
      }
    }
    try {
      const parsed = parse(fs.readFileSync(dotenvPath, {encoding}), {debug});
      Object.keys(parsed).forEach(function(key) {
        if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
          process.env[key] = parsed[key];
        } else if (debug) {
          log(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
        }
      });
      return {parsed};
    } catch (e) {
      return {error: e};
    }
  }
  module2.exports.config = config;
  module2.exports.parse = parse;
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };
});

// node_modules/axios/lib/utils.js
var require_utils = __commonJS((exports2, module2) => {
  "use strict";
  var bind = require_bind();
  var toString = Object.prototype.toString;
  function isArray(val) {
    return toString.call(val) === "[object Array]";
  }
  function isUndefined(val) {
    return typeof val === "undefined";
  }
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
  }
  function isArrayBuffer(val) {
    return toString.call(val) === "[object ArrayBuffer]";
  }
  function isFormData(val) {
    return typeof FormData !== "undefined" && val instanceof FormData;
  }
  function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }
    return result;
  }
  function isString(val) {
    return typeof val === "string";
  }
  function isNumber(val) {
    return typeof val === "number";
  }
  function isObject(val) {
    return val !== null && typeof val === "object";
  }
  function isPlainObject(val) {
    if (toString.call(val) !== "[object Object]") {
      return false;
    }
    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
  }
  function isDate(val) {
    return toString.call(val) === "[object Date]";
  }
  function isFile(val) {
    return toString.call(val) === "[object File]";
  }
  function isBlob(val) {
    return toString.call(val) === "[object Blob]";
  }
  function isFunction(val) {
    return toString.call(val) === "[object Function]";
  }
  function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
  }
  function isURLSearchParams(val) {
    return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
  }
  function trim(str) {
    return str.replace(/^\s*/, "").replace(/\s*$/, "");
  }
  function isStandardBrowserEnv() {
    if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function forEach(obj, fn) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  function merge() {
    var result = {};
    function assignValue(val, key) {
      if (isPlainObject(result[key]) && isPlainObject(val)) {
        result[key] = merge(result[key], val);
      } else if (isPlainObject(val)) {
        result[key] = merge({}, val);
      } else if (isArray(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }
    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }
  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === "function") {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }
  function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  }
  module2.exports = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isObject,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isFunction,
    isStream,
    isURLSearchParams,
    isStandardBrowserEnv,
    forEach,
    merge,
    extend,
    trim,
    stripBOM
  };
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  module2.exports = function buildURL(url, params, paramsSerializer) {
    if (!params) {
      return url;
    }
    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === "undefined") {
          return;
        }
        if (utils.isArray(val)) {
          key = key + "[]";
        } else {
          val = [val];
        }
        utils.forEach(val, function parseValue(v) {
          if (utils.isDate(v)) {
            v = v.toISOString();
          } else if (utils.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode(key) + "=" + encode(v));
        });
      });
      serializedParams = parts.join("&");
    }
    if (serializedParams) {
      var hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  };
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  function InterceptorManager() {
    this.handlers = [];
  }
  InterceptorManager.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
      fulfilled,
      rejected
    });
    return this.handlers.length - 1;
  };
  InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  InterceptorManager.prototype.forEach = function forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };
  module2.exports = InterceptorManager;
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  module2.exports = function transformData(data, headers, fns) {
    utils.forEach(fns, function transform(fn) {
      data = fn(data, headers);
    });
    return data;
  };
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  module2.exports = function normalizeHeaderName(headers, normalizedName) {
    utils.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function enhanceError(error, config, code, request, response) {
    error.config = config;
    if (code) {
      error.code = code;
    }
    error.request = request;
    error.response = response;
    error.isAxiosError = true;
    error.toJSON = function toJSON() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: this.config,
        code: this.code
      };
    };
    return error;
  };
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS((exports2, module2) => {
  "use strict";
  var enhanceError = require_enhanceError();
  module2.exports = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
  };
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS((exports2, module2) => {
  "use strict";
  var createError = require_createError();
  module2.exports = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
    }
  };
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name) {
        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove() {
      }
    };
  }();
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function isAbsoluteURL(url) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  };
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS((exports2, module2) => {
  "use strict";
  var isAbsoluteURL = require_isAbsoluteURL();
  var combineURLs = require_combineURLs();
  module2.exports = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  };
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  module2.exports = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;
    if (!headers) {
      return parsed;
    }
    utils.forEach(headers.split("\n"), function parser(line) {
      i = line.indexOf(":");
      key = utils.trim(line.substr(0, i)).toLowerCase();
      val = utils.trim(line.substr(i + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url) {
      var href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }();
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  var settle = require_settle();
  var cookies = require_cookies();
  var buildURL = require_buildURL();
  var buildFullPath = require_buildFullPath();
  var parseHeaders = require_parseHeaders();
  var isURLSameOrigin = require_isURLSameOrigin();
  var createError = require_createError();
  module2.exports = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      if (utils.isFormData(requestData)) {
        delete requestHeaders["Content-Type"];
      }
      var request = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath(config.baseURL, config.url);
      request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
      request.timeout = config.timeout;
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        var responseData = !config.responseType || config.responseType === "text" ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(resolve, reject, response);
        request = null;
      };
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(createError("Request aborted", config, "ECONNABORTED", request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(createError("Network Error", config, null, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(createError(timeoutErrorMessage, config, "ECONNABORTED", request));
        request = null;
      };
      if (utils.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request) {
        utils.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request.setRequestHeader(key, val);
          }
        });
      }
      if (!utils.isUndefined(config.withCredentials)) {
        request.withCredentials = !!config.withCredentials;
      }
      if (config.responseType) {
        try {
          request.responseType = config.responseType;
        } catch (e) {
          if (config.responseType !== "json") {
            throw e;
          }
        }
      }
      if (typeof config.onDownloadProgress === "function") {
        request.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request.upload) {
        request.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken) {
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request) {
            return;
          }
          request.abort();
          reject(cancel);
          request = null;
        });
      }
      if (!requestData) {
        requestData = null;
      }
      request.send(requestData);
    });
  };
});

// node_modules/follow-redirects/debug.js
var require_debug2 = __commonJS((exports2, module2) => {
  var debug;
  module2.exports = function() {
    if (!debug) {
      try {
        debug = require_src()("follow-redirects");
      } catch (error) {
        debug = function() {
        };
      }
    }
    debug.apply(null, arguments);
  };
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS((exports2, module2) => {
  var url = require("url");
  var URL2 = url.URL;
  var http = require("http");
  var https = require("https");
  var Writable = require("stream").Writable;
  var assert = require("assert");
  var debug = require_debug2();
  var eventHandlers = Object.create(null);
  ["abort", "aborted", "connect", "error", "socket", "timeout"].forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
      this._redirectable.emit(event, arg1, arg2, arg3);
    };
  });
  var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "");
  var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded");
  var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
  var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  function RedirectableRequest(options, responseCallback) {
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    if (responseCallback) {
      this.on("response", responseCallback);
    }
    var self2 = this;
    this._onNativeResponse = function(response) {
      self2._processResponse(response);
    };
    this._performRequest();
  }
  RedirectableRequest.prototype = Object.create(Writable.prototype);
  RedirectableRequest.prototype.abort = function() {
    this._currentRequest.removeAllListeners();
    this._currentRequest.on("error", noop);
    this._currentRequest.abort();
    this.emit("abort");
    this.removeAllListeners();
  };
  RedirectableRequest.prototype.write = function(data, encoding, callback) {
    if (this._ending) {
      throw new WriteAfterEndError();
    }
    if (!(typeof data === "string" || typeof data === "object" && "length" in data)) {
      throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (typeof encoding === "function") {
      callback = encoding;
      encoding = null;
    }
    if (data.length === 0) {
      if (callback) {
        callback();
      }
      return;
    }
    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
      this._requestBodyLength += data.length;
      this._requestBodyBuffers.push({data, encoding});
      this._currentRequest.write(data, encoding, callback);
    } else {
      this.emit("error", new MaxBodyLengthExceededError());
      this.abort();
    }
  };
  RedirectableRequest.prototype.end = function(data, encoding, callback) {
    if (typeof data === "function") {
      callback = data;
      data = encoding = null;
    } else if (typeof encoding === "function") {
      callback = encoding;
      encoding = null;
    }
    if (!data) {
      this._ended = this._ending = true;
      this._currentRequest.end(null, null, callback);
    } else {
      var self2 = this;
      var currentRequest = this._currentRequest;
      this.write(data, encoding, function() {
        self2._ended = true;
        currentRequest.end(null, null, callback);
      });
      this._ending = true;
    }
  };
  RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
  };
  RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
  };
  RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self2 = this;
    if (callback) {
      this.on("timeout", callback);
    }
    function startTimer() {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
      }
      self2._timeout = setTimeout(function() {
        self2.emit("timeout");
        clearTimer();
      }, msecs);
    }
    function clearTimer() {
      clearTimeout(this._timeout);
      if (callback) {
        self2.removeListener("timeout", callback);
      }
      if (!this.socket) {
        self2._currentRequest.removeListener("socket", startTimer);
      }
    }
    if (this.socket) {
      startTimer();
    } else {
      this._currentRequest.once("socket", startTimer);
    }
    this.once("response", clearTimer);
    this.once("error", clearTimer);
    return this;
  };
  [
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
  ].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
      return this._currentRequest[method](a, b);
    };
  });
  ["aborted", "connection", "socket"].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
      get: function() {
        return this._currentRequest[property];
      }
    });
  });
  RedirectableRequest.prototype._sanitizeOptions = function(options) {
    if (!options.headers) {
      options.headers = {};
    }
    if (options.host) {
      if (!options.hostname) {
        options.hostname = options.host;
      }
      delete options.host;
    }
    if (!options.pathname && options.path) {
      var searchPos = options.path.indexOf("?");
      if (searchPos < 0) {
        options.pathname = options.path;
      } else {
        options.pathname = options.path.substring(0, searchPos);
        options.search = options.path.substring(searchPos);
      }
    }
  };
  RedirectableRequest.prototype._performRequest = function() {
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
      this.emit("error", new TypeError("Unsupported protocol " + protocol));
      return;
    }
    if (this._options.agents) {
      var scheme = protocol.substr(0, protocol.length - 1);
      this._options.agent = this._options.agents[scheme];
    }
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    this._currentUrl = url.format(this._options);
    request._redirectable = this;
    for (var event in eventHandlers) {
      if (event) {
        request.on(event, eventHandlers[event]);
      }
    }
    if (this._isRedirect) {
      var i = 0;
      var self2 = this;
      var buffers = this._requestBodyBuffers;
      (function writeNext(error) {
        if (request === self2._currentRequest) {
          if (error) {
            self2.emit("error", error);
          } else if (i < buffers.length) {
            var buffer = buffers[i++];
            if (!request.finished) {
              request.write(buffer.data, buffer.encoding, writeNext);
            }
          } else if (self2._ended) {
            request.end();
          }
        }
      })();
    }
  };
  RedirectableRequest.prototype._processResponse = function(response) {
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
      this._redirects.push({
        url: this._currentUrl,
        headers: response.headers,
        statusCode
      });
    }
    var location = response.headers.location;
    if (location && this._options.followRedirects !== false && statusCode >= 300 && statusCode < 400) {
      this._currentRequest.removeAllListeners();
      this._currentRequest.on("error", noop);
      this._currentRequest.abort();
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var previousHostName = removeMatchingHeaders(/^host$/i, this._options.headers) || url.parse(this._currentUrl).hostname;
      var redirectUrl = url.resolve(this._currentUrl, location);
      debug("redirecting to", redirectUrl);
      this._isRedirect = true;
      var redirectUrlParts = url.parse(redirectUrl);
      Object.assign(this._options, redirectUrlParts);
      if (redirectUrlParts.hostname !== previousHostName) {
        removeMatchingHeaders(/^authorization$/i, this._options.headers);
      }
      if (typeof this._options.beforeRedirect === "function") {
        var responseDetails = {headers: response.headers};
        try {
          this._options.beforeRedirect.call(null, this._options, responseDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        var error = new RedirectionError("Redirected request failed: " + cause.message);
        error.cause = cause;
        this.emit("error", error);
      }
    } else {
      response.responseUrl = this._currentUrl;
      response.redirects = this._redirects;
      this.emit("response", response);
      this._requestBodyBuffers = [];
    }
  };
  function wrap(protocols) {
    var exports3 = {
      maxRedirects: 21,
      maxBodyLength: 10 * 1024 * 1024
    };
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
      var protocol = scheme + ":";
      var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
      var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
      function request(input, options, callback) {
        if (typeof input === "string") {
          var urlStr = input;
          try {
            input = urlToOptions(new URL2(urlStr));
          } catch (err) {
            input = url.parse(urlStr);
          }
        } else if (URL2 && input instanceof URL2) {
          input = urlToOptions(input);
        } else {
          callback = options;
          options = input;
          input = {protocol};
        }
        if (typeof options === "function") {
          callback = options;
          options = null;
        }
        options = Object.assign({
          maxRedirects: exports3.maxRedirects,
          maxBodyLength: exports3.maxBodyLength
        }, input, options);
        options.nativeProtocols = nativeProtocols;
        assert.equal(options.protocol, protocol, "protocol mismatch");
        debug("options", options);
        return new RedirectableRequest(options, callback);
      }
      function get(input, options, callback) {
        var wrappedRequest = wrappedProtocol.request(input, options, callback);
        wrappedRequest.end();
        return wrappedRequest;
      }
      Object.defineProperties(wrappedProtocol, {
        request: {value: request, configurable: true, enumerable: true, writable: true},
        get: {value: get, configurable: true, enumerable: true, writable: true}
      });
    });
    return exports3;
  }
  function noop() {
  }
  function urlToOptions(urlObject) {
    var options = {
      protocol: urlObject.protocol,
      hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
      hash: urlObject.hash,
      search: urlObject.search,
      pathname: urlObject.pathname,
      path: urlObject.pathname + urlObject.search,
      href: urlObject.href
    };
    if (urlObject.port !== "") {
      options.port = Number(urlObject.port);
    }
    return options;
  }
  function removeMatchingHeaders(regex, headers) {
    var lastValue;
    for (var header in headers) {
      if (regex.test(header)) {
        lastValue = headers[header];
        delete headers[header];
      }
    }
    return lastValue;
  }
  function createErrorType(code, defaultMessage) {
    function CustomError(message) {
      Error.captureStackTrace(this, this.constructor);
      this.message = message || defaultMessage;
    }
    CustomError.prototype = new Error();
    CustomError.prototype.constructor = CustomError;
    CustomError.prototype.name = "Error [" + code + "]";
    CustomError.prototype.code = code;
    return CustomError;
  }
  module2.exports = wrap({http, https});
  module2.exports.wrap = wrap;
});

// node_modules/axios/package.json
var require_package3 = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "axios",
    version: "0.21.1",
    description: "Promise based HTTP client for the browser and node.js",
    main: "index.js",
    scripts: {
      test: "grunt test && bundlesize",
      start: "node ./sandbox/server.js",
      build: "NODE_ENV=production grunt build",
      preversion: "npm test",
      version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
      postversion: "git push && git push --tags",
      examples: "node ./examples/server.js",
      coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
      fix: "eslint --fix lib/**/*.js"
    },
    repository: {
      type: "git",
      url: "https://github.com/axios/axios.git"
    },
    keywords: [
      "xhr",
      "http",
      "ajax",
      "promise",
      "node"
    ],
    author: "Matt Zabriskie",
    license: "MIT",
    bugs: {
      url: "https://github.com/axios/axios/issues"
    },
    homepage: "https://github.com/axios/axios",
    devDependencies: {
      bundlesize: "^0.17.0",
      coveralls: "^3.0.0",
      "es6-promise": "^4.2.4",
      grunt: "^1.0.2",
      "grunt-banner": "^0.6.0",
      "grunt-cli": "^1.2.0",
      "grunt-contrib-clean": "^1.1.0",
      "grunt-contrib-watch": "^1.0.0",
      "grunt-eslint": "^20.1.0",
      "grunt-karma": "^2.0.0",
      "grunt-mocha-test": "^0.13.3",
      "grunt-ts": "^6.0.0-beta.19",
      "grunt-webpack": "^1.0.18",
      "istanbul-instrumenter-loader": "^1.0.0",
      "jasmine-core": "^2.4.1",
      karma: "^1.3.0",
      "karma-chrome-launcher": "^2.2.0",
      "karma-coverage": "^1.1.1",
      "karma-firefox-launcher": "^1.1.0",
      "karma-jasmine": "^1.1.1",
      "karma-jasmine-ajax": "^0.1.13",
      "karma-opera-launcher": "^1.0.0",
      "karma-safari-launcher": "^1.0.0",
      "karma-sauce-launcher": "^1.2.0",
      "karma-sinon": "^1.0.5",
      "karma-sourcemap-loader": "^0.3.7",
      "karma-webpack": "^1.7.0",
      "load-grunt-tasks": "^3.5.2",
      minimist: "^1.2.0",
      mocha: "^5.2.0",
      sinon: "^4.5.0",
      typescript: "^2.8.1",
      "url-search-params": "^0.10.0",
      webpack: "^1.13.1",
      "webpack-dev-server": "^1.14.1"
    },
    browser: {
      "./lib/adapters/http.js": "./lib/adapters/xhr.js"
    },
    jsdelivr: "dist/axios.min.js",
    unpkg: "dist/axios.min.js",
    typings: "./index.d.ts",
    dependencies: {
      "follow-redirects": "^1.10.0"
    },
    bundlesize: [
      {
        path: "./dist/axios.min.js",
        threshold: "5kB"
      }
    ]
  };
});

// node_modules/axios/lib/adapters/http.js
var require_http = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  var settle = require_settle();
  var buildFullPath = require_buildFullPath();
  var buildURL = require_buildURL();
  var http = require("http");
  var https = require("https");
  var httpFollow = require_follow_redirects().http;
  var httpsFollow = require_follow_redirects().https;
  var url = require("url");
  var zlib = require("zlib");
  var pkg = require_package3();
  var createError = require_createError();
  var enhanceError = require_enhanceError();
  var isHttps = /https:?/;
  function setProxy(options, proxy, location) {
    options.hostname = proxy.host;
    options.host = proxy.host;
    options.port = proxy.port;
    options.path = location;
    if (proxy.auth) {
      var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base64;
    }
    options.beforeRedirect = function beforeRedirect(redirection) {
      redirection.headers.host = redirection.host;
      setProxy(redirection, proxy, redirection.href);
    };
  }
  module2.exports = function httpAdapter(config) {
    return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
      var resolve = function resolve2(value) {
        resolvePromise(value);
      };
      var reject = function reject2(value) {
        rejectPromise(value);
      };
      var data = config.data;
      var headers = config.headers;
      if (!headers["User-Agent"] && !headers["user-agent"]) {
        headers["User-Agent"] = "axios/" + pkg.version;
      }
      if (data && !utils.isStream(data)) {
        if (Buffer.isBuffer(data)) {
        } else if (utils.isArrayBuffer(data)) {
          data = Buffer.from(new Uint8Array(data));
        } else if (utils.isString(data)) {
          data = Buffer.from(data, "utf-8");
        } else {
          return reject(createError("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", config));
        }
        headers["Content-Length"] = data.length;
      }
      var auth = void 0;
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password || "";
        auth = username + ":" + password;
      }
      var fullPath = buildFullPath(config.baseURL, config.url);
      var parsed = url.parse(fullPath);
      var protocol = parsed.protocol || "http:";
      if (!auth && parsed.auth) {
        var urlAuth = parsed.auth.split(":");
        var urlUsername = urlAuth[0] || "";
        var urlPassword = urlAuth[1] || "";
        auth = urlUsername + ":" + urlPassword;
      }
      if (auth) {
        delete headers.Authorization;
      }
      var isHttpsRequest = isHttps.test(protocol);
      var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
      var options = {
        path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
        method: config.method.toUpperCase(),
        headers,
        agent,
        agents: {http: config.httpAgent, https: config.httpsAgent},
        auth
      };
      if (config.socketPath) {
        options.socketPath = config.socketPath;
      } else {
        options.hostname = parsed.hostname;
        options.port = parsed.port;
      }
      var proxy = config.proxy;
      if (!proxy && proxy !== false) {
        var proxyEnv = protocol.slice(0, -1) + "_proxy";
        var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
        if (proxyUrl) {
          var parsedProxyUrl = url.parse(proxyUrl);
          var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
          var shouldProxy = true;
          if (noProxyEnv) {
            var noProxy = noProxyEnv.split(",").map(function trim(s) {
              return s.trim();
            });
            shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
              if (!proxyElement) {
                return false;
              }
              if (proxyElement === "*") {
                return true;
              }
              if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                return true;
              }
              return parsed.hostname === proxyElement;
            });
          }
          if (shouldProxy) {
            proxy = {
              host: parsedProxyUrl.hostname,
              port: parsedProxyUrl.port,
              protocol: parsedProxyUrl.protocol
            };
            if (parsedProxyUrl.auth) {
              var proxyUrlAuth = parsedProxyUrl.auth.split(":");
              proxy.auth = {
                username: proxyUrlAuth[0],
                password: proxyUrlAuth[1]
              };
            }
          }
        }
      }
      if (proxy) {
        options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
        setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
      }
      var transport;
      var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
      if (config.transport) {
        transport = config.transport;
      } else if (config.maxRedirects === 0) {
        transport = isHttpsProxy ? https : http;
      } else {
        if (config.maxRedirects) {
          options.maxRedirects = config.maxRedirects;
        }
        transport = isHttpsProxy ? httpsFollow : httpFollow;
      }
      if (config.maxBodyLength > -1) {
        options.maxBodyLength = config.maxBodyLength;
      }
      var req = transport.request(options, function handleResponse(res) {
        if (req.aborted)
          return;
        var stream = res;
        var lastRequest = res.req || req;
        if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
          switch (res.headers["content-encoding"]) {
            case "gzip":
            case "compress":
            case "deflate":
              stream = stream.pipe(zlib.createUnzip());
              delete res.headers["content-encoding"];
              break;
          }
        }
        var response = {
          status: res.statusCode,
          statusText: res.statusMessage,
          headers: res.headers,
          config,
          request: lastRequest
        };
        if (config.responseType === "stream") {
          response.data = stream;
          settle(resolve, reject, response);
        } else {
          var responseBuffer = [];
          stream.on("data", function handleStreamData(chunk) {
            responseBuffer.push(chunk);
            if (config.maxContentLength > -1 && Buffer.concat(responseBuffer).length > config.maxContentLength) {
              stream.destroy();
              reject(createError("maxContentLength size of " + config.maxContentLength + " exceeded", config, null, lastRequest));
            }
          });
          stream.on("error", function handleStreamError(err) {
            if (req.aborted)
              return;
            reject(enhanceError(err, config, null, lastRequest));
          });
          stream.on("end", function handleStreamEnd() {
            var responseData = Buffer.concat(responseBuffer);
            if (config.responseType !== "arraybuffer") {
              responseData = responseData.toString(config.responseEncoding);
              if (!config.responseEncoding || config.responseEncoding === "utf8") {
                responseData = utils.stripBOM(responseData);
              }
            }
            response.data = responseData;
            settle(resolve, reject, response);
          });
        }
      });
      req.on("error", function handleRequestError(err) {
        if (req.aborted && err.code !== "ERR_FR_TOO_MANY_REDIRECTS")
          return;
        reject(enhanceError(err, config, null, req));
      });
      if (config.timeout) {
        req.setTimeout(config.timeout, function handleRequestTimeout() {
          req.abort();
          reject(createError("timeout of " + config.timeout + "ms exceeded", config, "ECONNABORTED", req));
        });
      }
      if (config.cancelToken) {
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (req.aborted)
            return;
          req.abort();
          reject(cancel);
        });
      }
      if (utils.isStream(data)) {
        data.on("error", function handleStreamError(err) {
          reject(enhanceError(err, config, null, req));
        }).pipe(req);
      } else {
        req.end(data);
      }
    });
  };
});

// node_modules/axios/lib/defaults.js
var require_defaults = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  var normalizeHeaderName = require_normalizeHeaderName();
  var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function setContentTypeIfUnset(headers, value) {
    if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
      headers["Content-Type"] = value;
    }
  }
  function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
      adapter = require_xhr();
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
      adapter = require_http();
    }
    return adapter;
  }
  var defaults = {
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName(headers, "Accept");
      normalizeHeaderName(headers, "Content-Type");
      if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
        return data;
      }
      if (utils.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
        return data.toString();
      }
      if (utils.isObject(data)) {
        setContentTypeIfUnset(headers, "application/json;charset=utf-8");
        return JSON.stringify(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      if (typeof data === "string") {
        try {
          data = JSON.parse(data);
        } catch (e) {
        }
      }
      return data;
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };
  defaults.headers = {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  };
  utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
  });
  utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
  });
  module2.exports = defaults;
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  var transformData = require_transformData();
  var isCancel = require_isCancel();
  var defaults = require_defaults();
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }
  module2.exports = function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = config.headers || {};
    config.data = transformData(config.data, config.headers, config.transformRequest);
    config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
    utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
      delete config.headers[method];
    });
    var adapter = config.adapter || defaults.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData(response.data, response.headers, config.transformResponse);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
        }
      }
      return Promise.reject(reason);
    });
  };
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  module2.exports = function mergeConfig(config1, config2) {
    config2 = config2 || {};
    var config = {};
    var valueFromConfig2Keys = ["url", "method", "data"];
    var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
    var defaultToConfig2Keys = [
      "baseURL",
      "transformRequest",
      "transformResponse",
      "paramsSerializer",
      "timeout",
      "timeoutMessage",
      "withCredentials",
      "adapter",
      "responseType",
      "xsrfCookieName",
      "xsrfHeaderName",
      "onUploadProgress",
      "onDownloadProgress",
      "decompress",
      "maxContentLength",
      "maxBodyLength",
      "maxRedirects",
      "transport",
      "httpAgent",
      "httpsAgent",
      "cancelToken",
      "socketPath",
      "responseEncoding"
    ];
    var directMergeKeys = ["validateStatus"];
    function getMergedValue(target, source) {
      if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
        return utils.merge(target, source);
      } else if (utils.isPlainObject(source)) {
        return utils.merge({}, source);
      } else if (utils.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(prop) {
      if (!utils.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (!utils.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    }
    utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
      if (!utils.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(void 0, config2[prop]);
      }
    });
    utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
    utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
      if (!utils.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(void 0, config2[prop]);
      } else if (!utils.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    utils.forEach(directMergeKeys, function merge(prop) {
      if (prop in config2) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
    var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });
    utils.forEach(otherKeys, mergeDeepProperties);
    return config;
  };
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  var buildURL = require_buildURL();
  var InterceptorManager = require_InterceptorManager();
  var dispatchRequest = require_dispatchRequest();
  var mergeConfig = require_mergeConfig();
  function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  Axios.prototype.request = function request(config) {
    if (typeof config === "string") {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }
    config = mergeConfig(this.defaults, config);
    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = "get";
    }
    var chain = [dispatchRequest, void 0];
    var promise = Promise.resolve(config);
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      chain.push(interceptor.fulfilled, interceptor.rejected);
    });
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  };
  Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
  };
  utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    Axios.prototype[method] = function(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        url,
        data
      }));
    };
  });
  module2.exports = Axios;
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS((exports2, module2) => {
  "use strict";
  function Cancel(message) {
    this.message = message;
  }
  Cancel.prototype.toString = function toString() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  };
  Cancel.prototype.__CANCEL__ = true;
  module2.exports = Cancel;
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS((exports2, module2) => {
  "use strict";
  var Cancel = require_Cancel();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        return;
      }
      token.reason = new Cancel(message);
      resolvePromise(token.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  };
  module2.exports = CancelToken;
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function isAxiosError(payload) {
    return typeof payload === "object" && payload.isAxiosError === true;
  };
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils();
  var bind = require_bind();
  var Axios = require_Axios();
  var mergeConfig = require_mergeConfig();
  var defaults = require_defaults();
  function createInstance(defaultConfig) {
    var context = new Axios(defaultConfig);
    var instance = bind(Axios.prototype.request, context);
    utils.extend(instance, Axios.prototype, context);
    utils.extend(instance, context);
    return instance;
  }
  var axios = createInstance(defaults);
  axios.Axios = Axios;
  axios.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios.defaults, instanceConfig));
  };
  axios.Cancel = require_Cancel();
  axios.CancelToken = require_CancelToken();
  axios.isCancel = require_isCancel();
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = require_spread();
  axios.isAxiosError = require_isAxiosError();
  module2.exports = axios;
  module2.exports.default = axios;
});

// node_modules/axios/index.js
var require_axios2 = __commonJS((exports2, module2) => {
  module2.exports = require_axios();
});

// node_modules/@slack/webhook/dist/errors.js
var require_errors = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.httpErrorWithOriginal = exports2.requestErrorWithOriginal = exports2.ErrorCode = void 0;
  var ErrorCode;
  (function(ErrorCode2) {
    ErrorCode2["RequestError"] = "slack_webhook_request_error";
    ErrorCode2["HTTPError"] = "slack_webhook_http_error";
  })(ErrorCode = exports2.ErrorCode || (exports2.ErrorCode = {}));
  function errorWithCode(error, code) {
    const codedError = error;
    codedError.code = code;
    return codedError;
  }
  function requestErrorWithOriginal(original) {
    const error = errorWithCode(new Error(`A request error occurred: ${original.message}`), ErrorCode.RequestError);
    error.original = original;
    return error;
  }
  exports2.requestErrorWithOriginal = requestErrorWithOriginal;
  function httpErrorWithOriginal(original) {
    const error = errorWithCode(new Error(`An HTTP protocol error occurred: statusCode = ${original.response.status}`), ErrorCode.HTTPError);
    error.original = original;
    return error;
  }
  exports2.httpErrorWithOriginal = httpErrorWithOriginal;
});

// node_modules/@slack/webhook/package.json
var require_package4 = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "@slack/webhook",
    version: "6.0.0",
    description: "Official library for using the Slack Platform's Incoming Webhooks",
    author: "Slack Technologies, Inc.",
    license: "MIT",
    keywords: [
      "slack",
      "request",
      "client",
      "http",
      "api",
      "proxy"
    ],
    main: "dist/index.js",
    types: "./dist/index.d.ts",
    files: [
      "dist/**/*"
    ],
    engines: {
      node: ">= 12.13.0",
      npm: ">= 6.12.0"
    },
    repository: "slackapi/node-slack-sdk",
    homepage: "https://slack.dev/node-slack-sdk/webhook",
    publishConfig: {
      access: "public"
    },
    bugs: {
      url: "https://github.com/slackapi/node-slack-sdk/issues"
    },
    scripts: {
      prepare: "npm run build",
      build: "npm run build:clean && tsc",
      "build:clean": "shx rm -rf ./dist ./coverage ./.nyc_output",
      lint: "tslint --project .",
      test: "npm run build && nyc mocha --config .mocharc.json src/*.spec.js",
      coverage: "codecov -F webhook --root=$PWD",
      "ref-docs:model": "api-extractor run"
    },
    dependencies: {
      "@slack/types": "^1.2.1",
      "@types/node": ">=12.0.0",
      axios: "^0.21.1"
    },
    devDependencies: {
      "@microsoft/api-extractor": "^7.3.4",
      "@types/chai": "^4.1.7",
      "@types/mocha": "^5.2.6",
      chai: "^4.2.0",
      codecov: "^3.2.0",
      mocha: "^6.0.2",
      nock: "^10.0.6",
      nyc: "^14.1.1",
      shx: "^0.3.2",
      sinon: "^7.2.7",
      "source-map-support": "^0.5.10",
      "ts-node": "^8.0.3",
      tslint: "^5.13.1",
      "tslint-config-airbnb": "^5.11.1",
      typescript: "^4.1.0"
    }
  };
});

// node_modules/@slack/webhook/dist/instrument.js
var require_instrument = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {enumerable: true, value: v});
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getUserAgent = exports2.addAppMetadata = void 0;
  var os = __importStar(require("os"));
  var packageJson = require_package4();
  function replaceSlashes(s) {
    return s.replace("/", ":");
  }
  var baseUserAgent = `${replaceSlashes(packageJson.name)}/${packageJson.version} node/${process.version.replace("v", "")} ${os.platform()}/${os.release()}`;
  var appMetadata = {};
  function addAppMetadata({name, version}) {
    appMetadata[replaceSlashes(name)] = version;
  }
  exports2.addAppMetadata = addAppMetadata;
  function getUserAgent() {
    const appIdentifier = Object.entries(appMetadata).map(([name, version]) => `${name}/${version}`).join(" ");
    return (appIdentifier.length > 0 ? `${appIdentifier} ` : "") + baseUserAgent;
  }
  exports2.getUserAgent = getUserAgent;
});

// node_modules/@slack/webhook/dist/IncomingWebhook.js
var require_IncomingWebhook = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.IncomingWebhook = void 0;
  var axios_1 = __importDefault(require_axios2());
  var errors_1 = require_errors();
  var instrument_1 = require_instrument();
  var IncomingWebhook2 = class {
    constructor(url, defaults = {}) {
      if (url === void 0) {
        throw new Error("Incoming webhook URL is required");
      }
      this.url = url;
      this.defaults = defaults;
      this.axios = axios_1.default.create({
        baseURL: url,
        httpAgent: defaults.agent,
        httpsAgent: defaults.agent,
        maxRedirects: 0,
        proxy: false,
        headers: {
          "User-Agent": instrument_1.getUserAgent()
        }
      });
      delete this.defaults.agent;
    }
    async send(message) {
      let payload = Object.assign({}, this.defaults);
      if (typeof message === "string") {
        payload.text = message;
      } else {
        payload = Object.assign(payload, message);
      }
      try {
        const response = await this.axios.post(this.url, payload);
        return this.buildResult(response);
      } catch (error) {
        if (error.response !== void 0) {
          throw errors_1.httpErrorWithOriginal(error);
        } else if (error.request !== void 0) {
          throw errors_1.requestErrorWithOriginal(error);
        } else {
          throw error;
        }
      }
    }
    buildResult(response) {
      return {
        text: response.data
      };
    }
  };
  exports2.IncomingWebhook = IncomingWebhook2;
});

// node_modules/@slack/webhook/dist/index.js
var require_dist2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ErrorCode = exports2.IncomingWebhook = void 0;
  var IncomingWebhook_1 = require_IncomingWebhook();
  Object.defineProperty(exports2, "IncomingWebhook", {enumerable: true, get: function() {
    return IncomingWebhook_1.IncomingWebhook;
  }});
  var errors_1 = require_errors();
  Object.defineProperty(exports2, "ErrorCode", {enumerable: true, get: function() {
    return errors_1.ErrorCode;
  }});
});

// space-pikopikoplanet/lib/firebase.ts
var import_app = __toModule(require_index_cjs3());

// node_modules/firebase/firestore/dist/index.node.cjs.js
"use strict";
require_node_cjs();

// space-pikopikoplanet/lib/firebase.ts
require_main().config();
var firebaseConfig = {
  projectId: process.env.SPACE_PIKOPIKOPLANET_FIREBASE_PROJECT_ID
};
var app = import_app.default.initializeApp(firebaseConfig);
var db = import_app.default.firestore();

// space-pikopikoplanet/lib/slack.ts
var import_webhook = __toModule(require_dist2());
require_main().config();
var slack = new import_webhook.IncomingWebhook(process.env.SPACE_PIKOPIKOPLANET_SLACK_WEBHOOK_URL);

// space-pikopikoplanet/check-for-updates.ts
(async () => {
  const lastExecution = Date.parse(process.argv[2]);
  if (isNaN(lastExecution)) {
    throw new Error(`Invalid argument: ${process.argv[2]}`);
  }
  const queryUrl = (queryId) => `https://space.pikopikopla.net/query/${queryId}`;
  const queries = await db.collection("queries").orderBy("updatedAt", "asc").startAfter(lastExecution).get();
  await Promise.all(queries.docs.map(async (doc) => {
    const url = queryUrl(doc.get("queryId"));
    await slack.send(`Query updated: ${url}`);
  }));
  const comments = await db.collectionGroup("comments").orderBy("updatedAt", "asc").startAfter(lastExecution).get();
  await Promise.all(comments.docs.map(async (doc) => {
    const url = queryUrl(doc.get("queryId"));
    await slack.send(`Comment updated: ${url}`);
  }));
})().catch(async (error) => {
  await slack.send(`${error.name}: ${error.message}`);
}).finally(() => {
  app.delete();
});
